/* Generated by Cython 0.29.7 */

/* BEGIN: Cython Metadata
{
    "distutils": {
        "depends": [
            "/usr/local/lib/python2.7/dist-packages/numpy/core/include/numpy/arrayobject.h", 
            "/usr/local/lib/python2.7/dist-packages/numpy/core/include/numpy/ufuncobject.h"
        ], 
        "include_dirs": [
            "/usr/local/lib/python2.7/dist-packages/numpy/core/include", 
            "/usr/lib/python2.7/dist-packages/mpi4py/include", 
            "/home/aurelio/Downloads/ga-5.7/build/include", 
            "."
        ], 
        "libraries": [
            "ga", 
            "lapack", 
            "f77blas", 
            "atlas", 
            "armci", 
            "f77blas", 
            "atlas", 
            "rt", 
            "m"
        ], 
        "library_dirs": [
            "/home/aurelio/Downloads/ga-5.7/build/lib"
        ], 
        "name": "ga4py.gain.notimplemented", 
        "sources": [
            "ga4py/gain/notimplemented.pyx"
        ]
    }, 
    "module_name": "ga4py.gain.notimplemented"
}
END: Cython Metadata */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
    #error Cython requires Python 2.6+ or Python 3.3+.
#else
#define CYTHON_ABI "0_29_7"
#define CYTHON_HEX_VERSION 0x001D07F0
#define CYTHON_FUTURE_DIVISION 0
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#define __PYX_COMMA ,
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x02070000
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #if PY_VERSION_HEX < 0x03050000
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYTYPE_LOOKUP
    #define CYTHON_USE_PYTYPE_LOOKUP 0
  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
    #define CYTHON_USE_PYTYPE_LOOKUP 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #ifndef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL 1
  #endif
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
  #endif
  #ifndef CYTHON_USE_DICT_VERSIONS
    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
  #endif
  #ifndef CYTHON_USE_EXC_INFO_STACK
    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
  #undef SHIFT
  #undef BASE
  #undef MASK
  #ifdef SIZEOF_VOID_P
    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
  #endif
#endif
#ifndef __has_attribute
  #define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
  #define __has_cpp_attribute(x) 0
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
#ifdef _MSC_VER
    #ifndef _MSC_STDINT_H_
        #if _MSC_VER < 1300
           typedef unsigned char     uint8_t;
           typedef unsigned int      uint32_t;
        #else
           typedef unsigned __int8   uint8_t;
           typedef unsigned __int32  uint32_t;
        #endif
    #endif
#else
   #include <stdint.h>
#endif
#ifndef CYTHON_FALLTHROUGH
  #if defined(__cplusplus) && __cplusplus >= 201103L
    #if __has_cpp_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH [[fallthrough]]
    #elif __has_cpp_attribute(clang::fallthrough)
      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
    #elif __has_cpp_attribute(gnu::fallthrough)
      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
    #endif
  #endif
  #ifndef CYTHON_FALLTHROUGH
    #if __has_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
    #else
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
  #if defined(__clang__ ) && defined(__apple_build_version__)
    #if __apple_build_version__ < 7000000
      #undef  CYTHON_FALLTHROUGH
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
#endif

#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #elif defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#ifndef METH_STACKLESS
  #define METH_STACKLESS 0
#endif
#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
  #ifndef METH_FASTCALL
     #define METH_FASTCALL 0x80
  #endif
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                          Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
  #define PyMem_RawFree(p)             PyMem_Free(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#elif PY_VERSION_HEX >= 0x03060000
  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
#elif PY_VERSION_HEX >= 0x03000000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#else
  #define __Pyx_PyThreadState_Current _PyThreadState_Current
#endif
#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
#include "pythread.h"
#define Py_tss_NEEDS_INIT 0
typedef int Py_tss_t;
static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
  *key = PyThread_create_key();
  return 0;
}
static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
  *key = Py_tss_NEEDS_INIT;
  return key;
}
static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
  PyObject_Free(key);
}
static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
  return *key != Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
  PyThread_delete_key(*key);
  *key = Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
  return PyThread_set_key_value(*key, value);
}
static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
  return PyThread_get_key_value(*key);
}
#endif
#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
#else
#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
#endif
#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
#else
#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
  #define PyObject_Unicode             PyObject_Str
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#if CYTHON_ASSUME_SAFE_MACROS
  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
#else
  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : (Py_INCREF(func), func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef __Pyx_PyAsyncMethodsStruct
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif


#define __PYX_ERR(f_index, lineno, Ln_error) \
{ \
  __pyx_filename = __pyx_f[f_index]; __pyx_lineno = lineno; __pyx_clineno = __LINE__; goto Ln_error; \
}

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__ga4py__gain__notimplemented
#define __PYX_HAVE_API__ga4py__gain__notimplemented
/* Early includes */
#include <string.h>
#include <stdio.h>
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
    return (size_t) i < (size_t) limit;
}
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER)
    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
#define __Pyx_PySequence_Tuple(obj)\
    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }

static PyObject *__pyx_m = NULL;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_cython_runtime = NULL;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;

/* Header.proto */
#if !defined(CYTHON_CCOMPLEX)
  #if defined(__cplusplus)
    #define CYTHON_CCOMPLEX 1
  #elif defined(_Complex_I)
    #define CYTHON_CCOMPLEX 1
  #else
    #define CYTHON_CCOMPLEX 0
  #endif
#endif
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #include <complex>
  #else
    #include <complex.h>
  #endif
#endif
#if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
  #undef _Complex_I
  #define _Complex_I 1.0fj
#endif


static const char *__pyx_f[] = {
  "ga4py/gain/notimplemented.pyx",
  "__init__.pxd",
  "type.pxd",
};

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":776
 * # in Cython to enable them only on the right systems.
 * 
 * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t
 */
typedef npy_int8 __pyx_t_5numpy_int8_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":777
 * 
 * ctypedef npy_int8       int8_t
 * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int32      int32_t
 * ctypedef npy_int64      int64_t
 */
typedef npy_int16 __pyx_t_5numpy_int16_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":778
 * ctypedef npy_int8       int8_t
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int64      int64_t
 * #ctypedef npy_int96      int96_t
 */
typedef npy_int32 __pyx_t_5numpy_int32_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":779
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t
 * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_int96      int96_t
 * #ctypedef npy_int128     int128_t
 */
typedef npy_int64 __pyx_t_5numpy_int64_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":783
 * #ctypedef npy_int128     int128_t
 * 
 * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t
 */
typedef npy_uint8 __pyx_t_5numpy_uint8_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":784
 * 
 * ctypedef npy_uint8      uint8_t
 * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint32     uint32_t
 * ctypedef npy_uint64     uint64_t
 */
typedef npy_uint16 __pyx_t_5numpy_uint16_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":785
 * ctypedef npy_uint8      uint8_t
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint64     uint64_t
 * #ctypedef npy_uint96     uint96_t
 */
typedef npy_uint32 __pyx_t_5numpy_uint32_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":786
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t
 * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_uint96     uint96_t
 * #ctypedef npy_uint128    uint128_t
 */
typedef npy_uint64 __pyx_t_5numpy_uint64_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":790
 * #ctypedef npy_uint128    uint128_t
 * 
 * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_float64    float64_t
 * #ctypedef npy_float80    float80_t
 */
typedef npy_float32 __pyx_t_5numpy_float32_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":791
 * 
 * ctypedef npy_float32    float32_t
 * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_float80    float80_t
 * #ctypedef npy_float128   float128_t
 */
typedef npy_float64 __pyx_t_5numpy_float64_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":800
 * # The int types are mapped a bit surprising --
 * # numpy.int corresponds to 'l' and numpy.long to 'q'
 * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longlong   long_t
 * ctypedef npy_longlong   longlong_t
 */
typedef npy_long __pyx_t_5numpy_int_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":801
 * # numpy.int corresponds to 'l' and numpy.long to 'q'
 * ctypedef npy_long       int_t
 * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longlong   longlong_t
 * 
 */
typedef npy_longlong __pyx_t_5numpy_long_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":802
 * ctypedef npy_long       int_t
 * ctypedef npy_longlong   long_t
 * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_ulong      uint_t
 */
typedef npy_longlong __pyx_t_5numpy_longlong_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":804
 * ctypedef npy_longlong   longlong_t
 * 
 * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
 * ctypedef npy_ulonglong  ulong_t
 * ctypedef npy_ulonglong  ulonglong_t
 */
typedef npy_ulong __pyx_t_5numpy_uint_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":805
 * 
 * ctypedef npy_ulong      uint_t
 * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
 * ctypedef npy_ulonglong  ulonglong_t
 * 
 */
typedef npy_ulonglong __pyx_t_5numpy_ulong_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":806
 * ctypedef npy_ulong      uint_t
 * ctypedef npy_ulonglong  ulong_t
 * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_intp       intp_t
 */
typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":808
 * ctypedef npy_ulonglong  ulonglong_t
 * 
 * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uintp      uintp_t
 * 
 */
typedef npy_intp __pyx_t_5numpy_intp_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":809
 * 
 * ctypedef npy_intp       intp_t
 * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_double     float_t
 */
typedef npy_uintp __pyx_t_5numpy_uintp_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":811
 * ctypedef npy_uintp      uintp_t
 * 
 * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
 * ctypedef npy_double     double_t
 * ctypedef npy_longdouble longdouble_t
 */
typedef npy_double __pyx_t_5numpy_float_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":812
 * 
 * ctypedef npy_double     float_t
 * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longdouble longdouble_t
 * 
 */
typedef npy_double __pyx_t_5numpy_double_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":813
 * ctypedef npy_double     float_t
 * ctypedef npy_double     double_t
 * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_cfloat      cfloat_t
 */
typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
/* Declarations.proto */
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< float > __pyx_t_float_complex;
  #else
    typedef float _Complex __pyx_t_float_complex;
  #endif
#else
    typedef struct { float real, imag; } __pyx_t_float_complex;
#endif
static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float, float);

/* Declarations.proto */
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< double > __pyx_t_double_complex;
  #else
    typedef double _Complex __pyx_t_double_complex;
  #endif
#else
    typedef struct { double real, imag; } __pyx_t_double_complex;
#endif
static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double, double);


/*--- Type declarations ---*/

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":815
 * ctypedef npy_longdouble longdouble_t
 * 
 * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
 * ctypedef npy_cdouble     cdouble_t
 * ctypedef npy_clongdouble clongdouble_t
 */
typedef npy_cfloat __pyx_t_5numpy_cfloat_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":816
 * 
 * ctypedef npy_cfloat      cfloat_t
 * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
 * ctypedef npy_clongdouble clongdouble_t
 * 
 */
typedef npy_cdouble __pyx_t_5numpy_cdouble_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":817
 * ctypedef npy_cfloat      cfloat_t
 * ctypedef npy_cdouble     cdouble_t
 * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_cdouble     complex_t
 */
typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":819
 * ctypedef npy_clongdouble clongdouble_t
 * 
 * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew1(a):
 */
typedef npy_cdouble __pyx_t_5numpy_complex_t;

/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
#else
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#endif
#else
#define __Pyx_PyErr_Clear() PyErr_Clear()
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* KeywordStringCheck.proto */
static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyCFunctionFastCall.proto */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
#else
#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
#endif

/* PyFunctionFastCall.proto */
#if CYTHON_FAST_PYCALL
#define __Pyx_PyFunction_FastCall(func, args, nargs)\
    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs);
#else
#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
#endif
#define __Pyx_BUILD_ASSERT_EXPR(cond)\
    (sizeof(char [1 - 2*!(cond)]) - 1)
#ifndef Py_MEMBER_SIZE
#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
#endif
  static size_t __pyx_pyframe_localsplus_offset = 0;
  #include "frameobject.h"
  #define __Pxy_PyFrame_Initialize_Offsets()\
    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
  #define __Pyx_PyFrame_GetLocalsplus(frame)\
    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
#endif

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* DictGetItem.proto */
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key);
#define __Pyx_PyObject_Dict_GetItem(obj, name)\
    (likely(PyDict_CheckExact(obj)) ?\
     __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
#else
#define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
#define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
#endif

/* RaiseTooManyValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

/* RaiseNeedMoreValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

/* RaiseNoneIterError.proto */
static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);

/* ExtTypeTest.proto */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

/* GetTopmostException.proto */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
#endif

/* SaveResetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
#else
#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
#endif

/* PyErrExceptionMatches.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
#else
#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
#endif

/* GetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* TypeImport.proto */
#ifndef __PYX_HAVE_RT_ImportType_proto
#define __PYX_HAVE_RT_ImportType_proto
enum __Pyx_ImportType_CheckSize {
   __Pyx_ImportType_CheckSize_Error = 0,
   __Pyx_ImportType_CheckSize_Warn = 1,
   __Pyx_ImportType_CheckSize_Ignore = 2
};
static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
#endif

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* PyDictVersioning.proto */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
    (version_var) = __PYX_GET_DICT_VERSION(dict);\
    (cache_var) = (value);
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
        (VAR) = __pyx_dict_cached_value;\
    } else {\
        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
    }\
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
#else
#define __PYX_GET_DICT_VERSION(dict)  (0)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
#endif

/* GetModuleGlobalName.proto */
#if CYTHON_USE_DICT_VERSIONS
#define __Pyx_GetModuleGlobalName(var, name)  {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
    PY_UINT64_T __pyx_dict_version;\
    PyObject *__pyx_dict_cached_value;\
    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
#else
#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
#endif

/* CLineInTraceback.proto */
#ifdef CYTHON_CLINE_IN_TRACEBACK
#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
#else
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
#endif

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* RealImag.proto */
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #define __Pyx_CREAL(z) ((z).real())
    #define __Pyx_CIMAG(z) ((z).imag())
  #else
    #define __Pyx_CREAL(z) (__real__(z))
    #define __Pyx_CIMAG(z) (__imag__(z))
  #endif
#else
    #define __Pyx_CREAL(z) ((z).real)
    #define __Pyx_CIMAG(z) ((z).imag)
#endif
#if defined(__cplusplus) && CYTHON_CCOMPLEX\
        && (defined(_WIN32) || defined(__clang__) || (defined(__GNUC__) && (__GNUC__ >= 5 || __GNUC__ == 4 && __GNUC_MINOR__ >= 4 )) || __cplusplus >= 201103)
    #define __Pyx_SET_CREAL(z,x) ((z).real(x))
    #define __Pyx_SET_CIMAG(z,y) ((z).imag(y))
#else
    #define __Pyx_SET_CREAL(z,x) __Pyx_CREAL(z) = (x)
    #define __Pyx_SET_CIMAG(z,y) __Pyx_CIMAG(z) = (y)
#endif

/* Arithmetic.proto */
#if CYTHON_CCOMPLEX
    #define __Pyx_c_eq_float(a, b)   ((a)==(b))
    #define __Pyx_c_sum_float(a, b)  ((a)+(b))
    #define __Pyx_c_diff_float(a, b) ((a)-(b))
    #define __Pyx_c_prod_float(a, b) ((a)*(b))
    #define __Pyx_c_quot_float(a, b) ((a)/(b))
    #define __Pyx_c_neg_float(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zero_float(z) ((z)==(float)0)
    #define __Pyx_c_conj_float(z)    (::std::conj(z))
    #if 1
        #define __Pyx_c_abs_float(z)     (::std::abs(z))
        #define __Pyx_c_pow_float(a, b)  (::std::pow(a, b))
    #endif
  #else
    #define __Pyx_c_is_zero_float(z) ((z)==0)
    #define __Pyx_c_conj_float(z)    (conjf(z))
    #if 1
        #define __Pyx_c_abs_float(z)     (cabsf(z))
        #define __Pyx_c_pow_float(a, b)  (cpowf(a, b))
    #endif
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eq_float(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sum_float(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_diff_float(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prod_float(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quot_float(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_neg_float(__pyx_t_float_complex);
    static CYTHON_INLINE int __Pyx_c_is_zero_float(__pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conj_float(__pyx_t_float_complex);
    #if 1
        static CYTHON_INLINE float __Pyx_c_abs_float(__pyx_t_float_complex);
        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_pow_float(__pyx_t_float_complex, __pyx_t_float_complex);
    #endif
#endif

/* Arithmetic.proto */
#if CYTHON_CCOMPLEX
    #define __Pyx_c_eq_double(a, b)   ((a)==(b))
    #define __Pyx_c_sum_double(a, b)  ((a)+(b))
    #define __Pyx_c_diff_double(a, b) ((a)-(b))
    #define __Pyx_c_prod_double(a, b) ((a)*(b))
    #define __Pyx_c_quot_double(a, b) ((a)/(b))
    #define __Pyx_c_neg_double(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zero_double(z) ((z)==(double)0)
    #define __Pyx_c_conj_double(z)    (::std::conj(z))
    #if 1
        #define __Pyx_c_abs_double(z)     (::std::abs(z))
        #define __Pyx_c_pow_double(a, b)  (::std::pow(a, b))
    #endif
  #else
    #define __Pyx_c_is_zero_double(z) ((z)==0)
    #define __Pyx_c_conj_double(z)    (conj(z))
    #if 1
        #define __Pyx_c_abs_double(z)     (cabs(z))
        #define __Pyx_c_pow_double(a, b)  (cpow(a, b))
    #endif
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eq_double(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum_double(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff_double(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod_double(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot_double(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg_double(__pyx_t_double_complex);
    static CYTHON_INLINE int __Pyx_c_is_zero_double(__pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj_double(__pyx_t_double_complex);
    #if 1
        static CYTHON_INLINE double __Pyx_c_abs_double(__pyx_t_double_complex);
        static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow_double(__pyx_t_double_complex, __pyx_t_double_complex);
    #endif
#endif

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__NPY_TYPES(enum NPY_TYPES value);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* FastTypeChecks.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
#else
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
#endif
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libc.stdio' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'cpython' */

/* Module declarations from 'cpython.object' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'cpython.mem' */

/* Module declarations from 'numpy' */

/* Module declarations from 'numpy' */
static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
static PyTypeObject *__pyx_ptype_5numpy_flatiter = 0;
static PyTypeObject *__pyx_ptype_5numpy_broadcast = 0;
static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *, char *, char *, int *); /*proto*/

/* Module declarations from 'ga4py.gain.notimplemented' */
#define __Pyx_MODULE_NAME "ga4py.gain.notimplemented"
extern int __pyx_module_is_main_ga4py__gain__notimplemented;
int __pyx_module_is_main_ga4py__gain__notimplemented = 0;

/* Implementation of 'ga4py.gain.notimplemented' */
static PyObject *__pyx_builtin_NotImplementedError;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_RuntimeError;
static PyObject *__pyx_builtin_ImportError;
static const char __pyx_k_[] = " ";
static const char __pyx_k_A[] = "A";
static const char __pyx_k_C[] = "C";
static const char __pyx_k_M[] = "M";
static const char __pyx_k_N[] = "N";
static const char __pyx_k_X[] = "X";
static const char __pyx_k_a[] = "a";
static const char __pyx_k_b[] = "b";
static const char __pyx_k_d[] = "d";
static const char __pyx_k_f[] = "f";
static const char __pyx_k_k[] = "k";
static const char __pyx_k_m[] = "m";
static const char __pyx_k_n[] = "n";
static const char __pyx_k_p[] = "p";
static const char __pyx_k_q[] = "q";
static const char __pyx_k_t[] = "t";
static const char __pyx_k_u[] = "u";
static const char __pyx_k_v[] = "v";
static const char __pyx_k_x[] = "x";
static const char __pyx_k_y[] = "y";
static const char __pyx_k_z[] = "z";
static const char __pyx_k__2[] = "";
static const char __pyx_k__9[] = "#";
static const char __pyx_k_a1[] = "a1";
static const char __pyx_k_a2[] = "a2";
static const char __pyx_k_ar[] = "ar";
static const char __pyx_k_dx[] = "dx";
static const char __pyx_k_fb[] = "fb";
static const char __pyx_k_fp[] = "fp";
static const char __pyx_k_fv[] = "fv";
static const char __pyx_k_i0[] = "i0";
static const char __pyx_k_ix[] = "ix_";
static const char __pyx_k_np[] = "np";
static const char __pyx_k_pv[] = "pv";
static const char __pyx_k_xp[] = "xp";
static const char __pyx_k_18e[] = "%.18e";
static const char __pyx_k__10[] = "_";
static const char __pyx_k__14[] = "\n";
static const char __pyx_k_all[] = "all";
static const char __pyx_k_any[] = "any";
static const char __pyx_k_ar1[] = "ar1";
static const char __pyx_k_ar2[] = "ar2";
static const char __pyx_k_arr[] = "arr";
static const char __pyx_k_ary[] = "ary";
static const char __pyx_k_cov[] = "cov";
static const char __pyx_k_deg[] = "deg";
static const char __pyx_k_doc[] = "doc";
static const char __pyx_k_end[] = "end";
static const char __pyx_k_f_i[] = "f%i";
static const char __pyx_k_fix[] = "fix";
static const char __pyx_k_fmt[] = "fmt";
static const char __pyx_k_ind[] = "ind";
static const char __pyx_k_irr[] = "irr";
static const char __pyx_k_mat[] = "mat";
static const char __pyx_k_max[] = "max";
static const char __pyx_k_min[] = "min";
static const char __pyx_k_msg[] = "msg";
static const char __pyx_k_nin[] = "nin";
static const char __pyx_k_npv[] = "npv";
static const char __pyx_k_num[] = "num";
static const char __pyx_k_obj[] = "obj";
static const char __pyx_k_out[] = "out";
static const char __pyx_k_per[] = "per";
static const char __pyx_k_pmt[] = "pmt";
static const char __pyx_k_ptp[] = "ptp";
static const char __pyx_k_put[] = "put";
static const char __pyx_k_rep[] = "rep";
static const char __pyx_k_sep[] = "sep";
static const char __pyx_k_std[] = "std";
static const char __pyx_k_sum[] = "sum";
static const char __pyx_k_sys[] = "sys";
static const char __pyx_k_tol[] = "tol";
static const char __pyx_k_tri[] = "tri";
static const char __pyx_k_tup[] = "tup";
static const char __pyx_k_val[] = "val";
static const char __pyx_k_var[] = "var";
static const char __pyx_k_who[] = "who";
static const char __pyx_k_amax[] = "amax";
static const char __pyx_k_amin[] = "amin";
static const char __pyx_k_arg1[] = "arg1";
static const char __pyx_k_arg2[] = "arg2";
static const char __pyx_k_atol[] = "atol";
static const char __pyx_k_axes[] = "axes";
static const char __pyx_k_axis[] = "axis";
static const char __pyx_k_base[] = "base";
static const char __pyx_k_beta[] = "beta";
static const char __pyx_k_bias[] = "bias";
static const char __pyx_k_bins[] = "bins";
static const char __pyx_k_bmat[] = "bmat";
static const char __pyx_k_char[] = "char_";
static const char __pyx_k_copy[] = "copy";
static const char __pyx_k_data[] = "data";
static const char __pyx_k_ddof[] = "ddof";
static const char __pyx_k_diff[] = "diff";
static const char __pyx_k_dims[] = "dims";
static const char __pyx_k_disp[] = "disp";
static const char __pyx_k_file[] = "file";
static const char __pyx_k_filt[] = "filt";
static const char __pyx_k_full[] = "full";
static const char __pyx_k_func[] = "func";
static const char __pyx_k_imag[] = "imag";
static const char __pyx_k_in1d[] = "in1d";
static const char __pyx_k_info[] = "info";
static const char __pyx_k_ipmt[] = "ipmt";
static const char __pyx_k_keys[] = "keys";
static const char __pyx_k_kind[] = "kind";
static const char __pyx_k_kron[] = "kron";
static const char __pyx_k_left[] = "left";
static const char __pyx_k_load[] = "load";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_mask[] = "mask";
static const char __pyx_k_mean[] = "mean";
static const char __pyx_k_mesg[] = "mesg";
static const char __pyx_k_mirr[] = "mirr";
static const char __pyx_k_mode[] = "mode";
static const char __pyx_k_name[] = "__name__";
static const char __pyx_k_ndim[] = "ndim";
static const char __pyx_k_nout[] = "nout";
static const char __pyx_k_nper[] = "nper";
static const char __pyx_k_over[] = "over";
static const char __pyx_k_poly[] = "poly";
static const char __pyx_k_ppmt[] = "ppmt";
static const char __pyx_k_prod[] = "prod";
static const char __pyx_k_rank[] = "rank";
static const char __pyx_k_rate[] = "rate";
static const char __pyx_k_real[] = "real";
static const char __pyx_k_repr[] = "repr";
static const char __pyx_k_reps[] = "reps";
static const char __pyx_k_roll[] = "roll";
static const char __pyx_k_rtol[] = "rtol";
static const char __pyx_k_save[] = "save";
static const char __pyx_k_side[] = "side";
static const char __pyx_k_sinc[] = "sinc";
static const char __pyx_k_size[] = "size";
static const char __pyx_k_sort[] = "sort";
static const char __pyx_k_take[] = "take";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_tile[] = "tile";
static const char __pyx_k_tril[] = "tril";
static const char __pyx_k_trim[] = "trim";
static const char __pyx_k_triu[] = "triu";
static const char __pyx_k_type[] = "type";
static const char __pyx_k_vals[] = "vals";
static const char __pyx_k_vdot[] = "vdot";
static const char __pyx_k_what[] = "what";
static const char __pyx_k_when[] = "when";
static const char __pyx_k_angle[] = "angle";
static const char __pyx_k_array[] = "array";
static const char __pyx_k_axis1[] = "axis1";
static const char __pyx_k_axis2[] = "axis2";
static const char __pyx_k_axisa[] = "axisa";
static const char __pyx_k_axisb[] = "axisb";
static const char __pyx_k_axisc[] = "axisc";
static const char __pyx_k_count[] = "count";
static const char __pyx_k_cross[] = "cross";
static const char __pyx_k_dtype[] = "dtype";
static const char __pyx_k_fname[] = "fname";
static const char __pyx_k_gdict[] = "gdict";
static const char __pyx_k_guess[] = "guess";
static const char __pyx_k_inner[] = "inner";
static const char __pyx_k_ldict[] = "ldict";
static const char __pyx_k_loads[] = "loads";
static const char __pyx_k_loose[] = "loose";
static const char __pyx_k_msort[] = "msort";
static const char __pyx_k_names[] = "names";
static const char __pyx_k_ndmin[] = "ndmin";
static const char __pyx_k_numpy[] = "numpy";
static const char __pyx_k_order[] = "order";
static const char __pyx_k_outer[] = "outer";
static const char __pyx_k_place[] = "place";
static const char __pyx_k_raise[] = "raise";
static const char __pyx_k_range[] = "range";
static const char __pyx_k_ravel[] = "ravel";
static const char __pyx_k_rcond[] = "rcond";
static const char __pyx_k_right[] = "right";
static const char __pyx_k_roots[] = "roots";
static const char __pyx_k_rot90[] = "rot90";
static const char __pyx_k_round[] = "round";
static const char __pyx_k_savez[] = "savez";
static const char __pyx_k_shift[] = "shift";
static const char __pyx_k_split[] = "split";
static const char __pyx_k_start[] = "start";
static const char __pyx_k_style[] = "style";
static const char __pyx_k_subok[] = "subok";
static const char __pyx_k_trace[] = "trace";
static const char __pyx_k_trapz[] = "trapz";
static const char __pyx_k_type1[] = "type1";
static const char __pyx_k_type2[] = "type2";
static const char __pyx_k_under[] = "under";
static const char __pyx_k_valid[] = "valid";
static const char __pyx_k_where[] = "where";
static const char __pyx_k_width[] = "width";
static const char __pyx_k_GDFgdf[] = "GDFgdf";
static const char __pyx_k_append[] = "append";
static const char __pyx_k_argmax[] = "argmax";
static const char __pyx_k_argmin[] = "argmin";
static const char __pyx_k_around[] = "around";
static const char __pyx_k_buffer[] = "buffer";
static const char __pyx_k_choose[] = "choose";
static const char __pyx_k_cumsum[] = "cumsum";
static const char __pyx_k_delete[] = "delete";
static const char __pyx_k_device[] = "device";
static const char __pyx_k_divide[] = "divide";
static const char __pyx_k_dsplit[] = "dsplit";
static const char __pyx_k_dstack[] = "dstack";
static const char __pyx_k_einsum[] = "einsum";
static const char __pyx_k_errobj[] = "errobj";
static const char __pyx_k_fliplr[] = "fliplr";
static const char __pyx_k_flipud[] = "flipud";
static const char __pyx_k_func1d[] = "func1d";
static const char __pyx_k_geterr[] = "geterr";
static const char __pyx_k_hsplit[] = "hsplit";
static const char __pyx_k_hstack[] = "hstack";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_infstr[] = "infstr";
static const char __pyx_k_insert[] = "insert";
static const char __pyx_k_interp[] = "interp";
static const char __pyx_k_isreal[] = "isreal";
static const char __pyx_k_kaiser[] = "kaiser";
static const char __pyx_k_median[] = "median";
static const char __pyx_k_module[] = "module";
static const char __pyx_k_nanmax[] = "nanmax";
static const char __pyx_k_nanmin[] = "nanmin";
static const char __pyx_k_nanstr[] = "nanstr";
static const char __pyx_k_nansum[] = "nansum";
static const char __pyx_k_normed[] = "normed";
static const char __pyx_k_number[] = "number";
static const char __pyx_k_object[] = "object";
static const char __pyx_k_offset[] = "offset";
static const char __pyx_k_output[] = "output";
static const char __pyx_k_prefix[] = "prefix";
static const char __pyx_k_regexp[] = "regexp";
static const char __pyx_k_repeat[] = "repeat";
static const char __pyx_k_resize[] = "resize";
static const char __pyx_k_rowvar[] = "rowvar";
static const char __pyx_k_sample[] = "sample";
static const char __pyx_k_sctype[] = "sctype";
static const char __pyx_k_select[] = "select";
static const char __pyx_k_seterr[] = "seterr";
static const char __pyx_k_source[] = "source";
static const char __pyx_k_stdout[] = "stdout";
static const char __pyx_k_string[] = "string";
static const char __pyx_k_to_end[] = "to_end";
static const char __pyx_k_unique[] = "unique";
static const char __pyx_k_unpack[] = "unpack";
static const char __pyx_k_unwrap[] = "unwrap";
static const char __pyx_k_values[] = "values";
static const char __pyx_k_vander[] = "vander";
static const char __pyx_k_vsplit[] = "vsplit";
static const char __pyx_k_vstack[] = "vstack";
static const char __pyx_k_alltrue[] = "alltrue";
static const char __pyx_k_argsort[] = "argsort";
static const char __pyx_k_average[] = "average";
static const char __pyx_k_choices[] = "choices";
static const char __pyx_k_cumprod[] = "cumprod";
static const char __pyx_k_default[] = "default";
static const char __pyx_k_density[] = "density";
static const char __pyx_k_discont[] = "discont";
static const char __pyx_k_ediff1d[] = "ediff1d";
static const char __pyx_k_extract[] = "extract";
static const char __pyx_k_float64[] = "float64";
static const char __pyx_k_hamming[] = "hamming";
static const char __pyx_k_hanning[] = "hanning";
static const char __pyx_k_indices[] = "indices";
static const char __pyx_k_invalid[] = "invalid";
static const char __pyx_k_lexsort[] = "lexsort";
static const char __pyx_k_loadtxt[] = "loadtxt";
static const char __pyx_k_lookfor[] = "lookfor";
static const char __pyx_k_maxiter[] = "maxiter";
static const char __pyx_k_missing[] = "missing";
static const char __pyx_k_myarray[] = "myarray";
static const char __pyx_k_newline[] = "newline";
static const char __pyx_k_nonzero[] = "nonzero";
static const char __pyx_k_padding[] = "padding";
static const char __pyx_k_pkgload[] = "pkgload";
static const char __pyx_k_polyadd[] = "polyadd";
static const char __pyx_k_polyder[] = "polyder";
static const char __pyx_k_polydiv[] = "polydiv";
static const char __pyx_k_polyfit[] = "polyfit";
static const char __pyx_k_polyint[] = "polyint";
static const char __pyx_k_polymul[] = "polymul";
static const char __pyx_k_polysub[] = "polysub";
static const char __pyx_k_polyval[] = "polyval";
static const char __pyx_k_product[] = "product";
static const char __pyx_k_putmask[] = "putmask";
static const char __pyx_k_repeats[] = "repeats";
static const char __pyx_k_require[] = "require";
static const char __pyx_k_reshape[] = "reshape";
static const char __pyx_k_round_2[] = "round_";
static const char __pyx_k_savetxt[] = "savetxt";
static const char __pyx_k_squeeze[] = "squeeze";
static const char __pyx_k_typeset[] = "typeset";
static const char __pyx_k_union1d[] = "union1d";
static const char __pyx_k_usecols[] = "usecols";
static const char __pyx_k_usemask[] = "usemask";
static const char __pyx_k_vardict[] = "vardict";
static const char __pyx_k_weights[] = "weights";
static const char __pyx_k_allclose[] = "allclose";
static const char __pyx_k_alterdot[] = "alterdot";
static const char __pyx_k_argwhere[] = "argwhere";
static const char __pyx_k_asfarray[] = "asfarray";
static const char __pyx_k_asmatrix[] = "asmatrix";
static const char __pyx_k_asscalar[] = "asscalar";
static const char __pyx_k_bartlett[] = "bartlett";
static const char __pyx_k_bincount[] = "bincount";
static const char __pyx_k_blackman[] = "blackman";
static const char __pyx_k_can_cast[] = "can_cast";
static const char __pyx_k_comments[] = "comments";
static const char __pyx_k_compress[] = "compress";
static const char __pyx_k_condlist[] = "condlist";
static const char __pyx_k_convolve[] = "convolve";
static const char __pyx_k_corrcoef[] = "corrcoef";
static const char __pyx_k_decimals[] = "decimals";
static const char __pyx_k_diagflat[] = "diagflat";
static const char __pyx_k_digitize[] = "digitize";
static const char __pyx_k_fromfile[] = "fromfile";
static const char __pyx_k_fromiter[] = "fromiter";
static const char __pyx_k_funclist[] = "funclist";
static const char __pyx_k_gradient[] = "gradient";
static const char __pyx_k_isneginf[] = "isneginf";
static const char __pyx_k_isposinf[] = "isposinf";
static const char __pyx_k_isscalar[] = "isscalar";
static const char __pyx_k_issctype[] = "issctype";
static const char __pyx_k_iterable[] = "iterable";
static const char __pyx_k_linefeed[] = "linefeed";
static const char __pyx_k_maxwidth[] = "maxwidth";
static const char __pyx_k_meshgrid[] = "meshgrid";
static const char __pyx_k_newshape[] = "newshape";
static const char __pyx_k_packbits[] = "packbits";
static const char __pyx_k_returned[] = "returned";
static const char __pyx_k_rollaxis[] = "rollaxis";
static const char __pyx_k_setxor1d[] = "setxor1d";
static const char __pyx_k_skiprows[] = "skiprows";
static const char __pyx_k_sometrue[] = "sometrue";
static const char __pyx_k_suppress[] = "suppress";
static const char __pyx_k_swapaxes[] = "swapaxes";
static const char __pyx_k_to_begin[] = "to_begin";
static const char __pyx_k_toplevel[] = "toplevel";
static const char __pyx_k_typename[] = "typename";
static const char __pyx_k_array_str[] = "array_str";
static const char __pyx_k_autostrip[] = "autostrip";
static const char __pyx_k_base_repr[] = "base_repr";
static const char __pyx_k_condition[] = "condition";
static const char __pyx_k_correlate[] = "correlate";
static const char __pyx_k_delimiter[] = "delimiter";
static const char __pyx_k_deprecate[] = "deprecate";
static const char __pyx_k_docstring[] = "docstring";
static const char __pyx_k_edgeitems[] = "edgeitems";
static const char __pyx_k_fromregex[] = "fromregex";
static const char __pyx_k_getbuffer[] = "getbuffer";
static const char __pyx_k_geterrobj[] = "geterrobj";
static const char __pyx_k_histogram[] = "histogram";
static const char __pyx_k_iscomplex[] = "iscomplex";
static const char __pyx_k_isfortran[] = "isfortran";
static const char __pyx_k_isrealobj[] = "isrealobj";
static const char __pyx_k_linewidth[] = "linewidth";
static const char __pyx_k_mafromtxt[] = "mafromtxt";
static const char __pyx_k_mask_func[] = "mask_func";
static const char __pyx_k_minlength[] = "minlength";
static const char __pyx_k_mmap_mode[] = "mmap_mode";
static const char __pyx_k_nanargmax[] = "nanargmax";
static const char __pyx_k_nanargmin[] = "nanargmin";
static const char __pyx_k_ndfromtxt[] = "ndfromtxt";
static const char __pyx_k_new_shape[] = "new_shape";
static const char __pyx_k_newbuffer[] = "newbuffer";
static const char __pyx_k_piecewise[] = "piecewise";
static const char __pyx_k_precision[] = "precision";
static const char __pyx_k_quicksort[] = "quicksort";
static const char __pyx_k_row_stack[] = "row_stack";
static const char __pyx_k_safe_eval[] = "safe_eval";
static const char __pyx_k_separator[] = "separator";
static const char __pyx_k_setdiff1d[] = "setdiff1d";
static const char __pyx_k_seterrobj[] = "seterrobj";
static const char __pyx_k_tensordot[] = "tensordot";
static const char __pyx_k_threshold[] = "threshold";
static const char __pyx_k_transpose[] = "transpose";
static const char __pyx_k_typechars[] = "typechars";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_add_newdoc[] = "add_newdoc";
static const char __pyx_k_array_repr[] = "array_repr";
static const char __pyx_k_asanyarray[] = "asanyarray";
static const char __pyx_k_atleast_1d[] = "atleast_1d";
static const char __pyx_k_atleast_2d[] = "atleast_2d";
static const char __pyx_k_atleast_3d[] = "atleast_3d";
static const char __pyx_k_choicelist[] = "choicelist";
static const char __pyx_k_converters[] = "converters";
static const char __pyx_k_cumproduct[] = "cumproduct";
static const char __pyx_k_defaultfmt[] = "defaultfmt";
static const char __pyx_k_dimensions[] = "dimensions";
static const char __pyx_k_frombuffer[] = "frombuffer";
static const char __pyx_k_frompyfunc[] = "frompyfunc";
static const char __pyx_k_fromstring[] = "fromstring";
static const char __pyx_k_genfromtxt[] = "genfromtxt";
static const char __pyx_k_getbufsize[] = "getbufsize";
static const char __pyx_k_geterrcall[] = "geterrcall";
static const char __pyx_k_issubclass[] = "issubclass_";
static const char __pyx_k_issubdtype[] = "issubdtype";
static const char __pyx_k_nan_to_num[] = "nan_to_num";
static const char __pyx_k_obj2sctype[] = "obj2sctype";
static const char __pyx_k_percentile[] = "percentile";
static const char __pyx_k_recfromcsv[] = "recfromcsv";
static const char __pyx_k_recfromtxt[] = "recfromtxt";
static const char __pyx_k_regenerate[] = "regenerate";
static const char __pyx_k_restoredot[] = "restoredot";
static const char __pyx_k_setbufsize[] = "setbufsize";
static const char __pyx_k_seterrcall[] = "seterrcall";
static const char __pyx_k_trim_zeros[] = "trim_zeros";
static const char __pyx_k_unpackbits[] = "unpackbits";
static const char __pyx_k_ImportError[] = "ImportError";
static const char __pyx_k_all_line_40[] = "all (line 40)";
static const char __pyx_k_array_equal[] = "array_equal";
static const char __pyx_k_array_equiv[] = "array_equiv";
static const char __pyx_k_array_split[] = "array_split";
static const char __pyx_k_array_types[] = "array_types";
static const char __pyx_k_binary_repr[] = "binary_repr";
static const char __pyx_k_byte_bounds[] = "byte_bounds";
static const char __pyx_k_common_type[] = "common_type";
static const char __pyx_k_concatenate[] = "concatenate";
static const char __pyx_k_deletechars[] = "deletechars";
static const char __pyx_k_excludelist[] = "excludelist";
static const char __pyx_k_expand_dims[] = "expand_dims";
static const char __pyx_k_flatnonzero[] = "flatnonzero";
static const char __pyx_k_get_include[] = "get_include";
static const char __pyx_k_histogram2d[] = "histogram2d";
static const char __pyx_k_histogramdd[] = "histogramdd";
static const char __pyx_k_intersect1d[] = "intersect1d";
static const char __pyx_k_issubsctype[] = "issubsctype";
static const char __pyx_k_mintypecode[] = "mintypecode";
static const char __pyx_k_multi_index[] = "multi_index";
static const char __pyx_k_result_type[] = "result_type";
static const char __pyx_k_sctype2char[] = "sctype2char";
static const char __pyx_k_show_config[] = "show_config";
static const char __pyx_k_skip_footer[] = "skip_footer";
static const char __pyx_k_skip_header[] = "skip_header";
static const char __pyx_k_RuntimeError[] = "RuntimeError";
static const char __pyx_k_any_line_335[] = "any (line 335)";
static const char __pyx_k_array2string[] = "array2string";
static const char __pyx_k_column_stack[] = "column_stack";
static const char __pyx_k_diag_indices[] = "diag_indices";
static const char __pyx_k_finance_rate[] = "finance_rate";
static const char __pyx_k_fv_line_4513[] = "fv (line 4513)";
static const char __pyx_k_i0_line_5572[] = "i0 (line 5572)";
static const char __pyx_k_int_asbuffer[] = "int_asbuffer";
static const char __pyx_k_iscomplexobj[] = "iscomplexobj";
static const char __pyx_k_mask_indices[] = "mask_indices";
static const char __pyx_k_nested_iters[] = "nested_iters";
static const char __pyx_k_old_behavior[] = "old_behavior";
static const char __pyx_k_pv_line_9709[] = "pv (line 9709)";
static const char __pyx_k_requirements[] = "requirements";
static const char __pyx_k_return_index[] = "return_index";
static const char __pyx_k_scalar_types[] = "scalar_types";
static const char __pyx_k_searchsorted[] = "searchsorted";
static const char __pyx_k_seq_of_zeros[] = "seq_of_zeros";
static const char __pyx_k_sort_complex[] = "sort_complex";
static const char __pyx_k_tril_indices[] = "tril_indices";
static const char __pyx_k_triu_indices[] = "triu_indices";
static const char __pyx_k_amax_line_187[] = "amax (line 187)";
static const char __pyx_k_amin_line_244[] = "amin (line 244)";
static const char __pyx_k_assume_unique[] = "assume_unique";
static const char __pyx_k_count_nonzero[] = "count_nonzero";
static const char __pyx_k_cov_line_2790[] = "cov (line 2790)";
static const char __pyx_k_datetime_data[] = "datetime_data";
static const char __pyx_k_fill_diagonal[] = "fill_diagonal";
static const char __pyx_k_fix_line_4035[] = "fix (line 4035)";
static const char __pyx_k_invalid_raise[] = "invalid_raise";
static const char __pyx_k_irr_line_6113[] = "irr (line 6113)";
static const char __pyx_k_ix__line_6652[] = "ix_ (line 6652)";
static const char __pyx_k_mat_line_7259[] = "mat (line 7259)";
static const char __pyx_k_max_line_7291[] = "max (line 7291)";
static const char __pyx_k_min_line_7611[] = "min (line 7611)";
static const char __pyx_k_npv_line_8298[] = "npv (line 8298)";
static const char __pyx_k_pmt_line_8738[] = "pmt (line 8738)";
static const char __pyx_k_promote_types[] = "promote_types";
static const char __pyx_k_ptp_line_9575[] = "ptp (line 9575)";
static const char __pyx_k_put_line_9615[] = "put (line 9615)";
static const char __pyx_k_real_if_close[] = "real_if_close";
static const char __pyx_k_reinvest_rate[] = "reinvest_rate";
static const char __pyx_k_replace_space[] = "replace_space";
static const char __pyx_k_unravel_index[] = "unravel_index";
static const char __pyx_k_angle_line_301[] = "angle (line 301)";
static const char __pyx_k_array_line_812[] = "array (line 812)";
static const char __pyx_k_asfortranarray[] = "asfortranarray";
static const char __pyx_k_bmat_line_1979[] = "bmat (line 1979)";
static const char __pyx_k_case_sensitive[] = "case_sensitive";
static const char __pyx_k_copy_line_2630[] = "copy (line 2630)";
static const char __pyx_k_diff_line_3349[] = "diff (line 3349)";
static const char __pyx_k_disp_line_3453[] = "disp (line 3453)";
static const char __pyx_k_filling_values[] = "filling_values";
static const char __pyx_k_get_array_wrap[] = "get_array_wrap";
static const char __pyx_k_imag_line_5628[] = "imag (line 5628)";
static const char __pyx_k_import_modules[] = "import_modules";
static const char __pyx_k_in1d_line_5659[] = "in1d (line 5659)";
static const char __pyx_k_info_line_5769[] = "info (line 5769)";
static const char __pyx_k_kron_line_6825[] = "kron (line 6825)";
static const char __pyx_k_load_line_6975[] = "load (line 6975)";
static const char __pyx_k_max_line_width[] = "max_line_width";
static const char __pyx_k_maximum_sctype[] = "maximum_sctype";
static const char __pyx_k_mean_line_7414[] = "mean (line 7414)";
static const char __pyx_k_missing_values[] = "missing_values";
static const char __pyx_k_ndim_line_8121[] = "ndim (line 8121)";
static const char __pyx_k_nper_line_8247[] = "nper (line 8247)";
static const char __pyx_k_poly_line_8823[] = "poly (line 8823)";
static const char __pyx_k_prod_line_9438[] = "prod (line 9438)";
static const char __pyx_k_rank_line_9797[] = "rank (line 9797)";
static const char __pyx_k_return_inverse[] = "return_inverse";
static const char __pyx_k_std_line_11961[] = "std (line 11961)";
static const char __pyx_k_sum_line_12049[] = "sum (line 12049)";
static const char __pyx_k_suppress_small[] = "suppress_small";
static const char __pyx_k_tri_line_12549[] = "tri (line 12549)";
static const char __pyx_k_var_line_13219[] = "var (line 13219)";
static const char __pyx_k_who_line_13526[] = "who (line 13526)";
static const char __pyx_k_append_line_401[] = "append (line 401)";
static const char __pyx_k_apply_over_axes[] = "apply_over_axes";
static const char __pyx_k_argmax_line_560[] = "argmax (line 560)";
static const char __pyx_k_around_line_744[] = "around (line 744)";
static const char __pyx_k_cross_line_2871[] = "cross (line 2871)";
static const char __pyx_k_inner_line_5819[] = "inner (line 5819)";
static const char __pyx_k_min_scalar_type[] = "min_scalar_type";
static const char __pyx_k_outer_line_8383[] = "outer (line 8383)";
static const char __pyx_k_overwrite_input[] = "overwrite_input";
static const char __pyx_k_place_line_8702[] = "place (line 8702)";
static const char __pyx_k_ravel_line_9884[] = "ravel (line 9884)";
static const char __pyx_k_real_line_10028[] = "real (line 10028)";
static const char __pyx_k_roll_line_10437[] = "roll (line 10437)";
static const char __pyx_k_save_line_10739[] = "save (line 10739)";
static const char __pyx_k_set_numeric_ops[] = "set_numeric_ops";
static const char __pyx_k_sinc_line_11576[] = "sinc (line 11576)";
static const char __pyx_k_size_line_11653[] = "size (line 11653)";
static const char __pyx_k_sort_line_11702[] = "sort (line 11702)";
static const char __pyx_k_take_line_12160[] = "take (line 12160)";
static const char __pyx_k_tile_line_12332[] = "tile (line 12332)";
static const char __pyx_k_tril_line_12588[] = "tril (line 12588)";
static const char __pyx_k_triu_line_12754[] = "triu (line 12754)";
static const char __pyx_k_vdot_line_13309[] = "vdot (line 13309)";
static const char __pyx_k_allclose_line_99[] = "allclose (line 99)";
static const char __pyx_k_apply_along_axis[] = "apply_along_axis";
static const char __pyx_k_argsort_line_624[] = "argsort (line 624)";
static const char __pyx_k_broadcast_arrays[] = "broadcast_arrays";
static const char __pyx_k_choose_line_2202[] = "choose (line 2202)";
static const char __pyx_k_cumsum_line_3053[] = "cumsum (line 3053)";
static const char __pyx_k_delete_line_3124[] = "delete (line 3124)";
static const char __pyx_k_dsplit_line_3487[] = "dsplit (line 3487)";
static const char __pyx_k_dstack_line_3530[] = "dstack (line 3530)";
static const char __pyx_k_einsum_line_3625[] = "einsum (line 3625)";
static const char __pyx_k_find_common_type[] = "find_common_type";
static const char __pyx_k_fliplr_line_4110[] = "fliplr (line 4110)";
static const char __pyx_k_flipud_line_4157[] = "flipud (line 4157)";
static const char __pyx_k_get_printoptions[] = "get_printoptions";
static const char __pyx_k_geterr_line_4869[] = "geterr (line 4869)";
static const char __pyx_k_hsplit_line_5471[] = "hsplit (line 5471)";
static const char __pyx_k_hstack_line_5528[] = "hstack (line 5528)";
static const char __pyx_k_insert_line_5895[] = "insert (line 5895)";
static const char __pyx_k_interp_line_5968[] = "interp (line 5968)";
static const char __pyx_k_isreal_line_6407[] = "isreal (line 6407)";
static const char __pyx_k_kaiser_line_6698[] = "kaiser (line 6698)";
static const char __pyx_k_may_share_memory[] = "may_share_memory";
static const char __pyx_k_median_line_7487[] = "median (line 7487)";
static const char __pyx_k_nanmax_line_7927[] = "nanmax (line 7927)";
static const char __pyx_k_nanmin_line_7984[] = "nanmin (line 7984)";
static const char __pyx_k_nansum_line_8039[] = "nansum (line 8039)";
static const char __pyx_k_roots_line_10526[] = "roots (line 10526)";
static const char __pyx_k_rot90_line_10577[] = "rot90 (line 10577)";
static const char __pyx_k_savez_compressed[] = "savez_compressed";
static const char __pyx_k_savez_line_10868[] = "savez (line 10868)";
static const char __pyx_k_set_printoptions[] = "set_printoptions";
static const char __pyx_k_split_line_11868[] = "split (line 11868)";
static const char __pyx_k_trace_line_12390[] = "trace (line 12390)";
static const char __pyx_k_trapz_line_12488[] = "trapz (line 12488)";
static const char __pyx_k_where_line_13464[] = "where (line 13464)";
static const char __pyx_k_argwhere_line_704[] = "argwhere (line 704)";
static const char __pyx_k_arrays_and_dtypes[] = "arrays_and_dtypes";
static const char __pyx_k_asarray_chkfinite[] = "asarray_chkfinite";
static const char __pyx_k_ascontiguousarray[] = "ascontiguousarray";
static const char __pyx_k_average_line_1529[] = "average (line 1529)";
static const char __pyx_k_cumprod_line_2979[] = "cumprod (line 2979)";
static const char __pyx_k_diag_indices_from[] = "diag_indices_from";
static const char __pyx_k_ediff1d_line_3580[] = "ediff1d (line 3580)";
static const char __pyx_k_extract_line_3870[] = "extract (line 3870)";
static const char __pyx_k_hamming_line_5058[] = "hamming (line 5058)";
static const char __pyx_k_hanning_line_5152[] = "hanning (line 5152)";
static const char __pyx_k_indices_line_5707[] = "indices (line 5707)";
static const char __pyx_k_lexsort_line_6897[] = "lexsort (line 6897)";
static const char __pyx_k_loadtxt_line_7045[] = "loadtxt (line 7045)";
static const char __pyx_k_lookfor_line_7132[] = "lookfor (line 7132)";
static const char __pyx_k_nonzero_line_8172[] = "nonzero (line 8172)";
static const char __pyx_k_polyadd_line_8917[] = "polyadd (line 8917)";
static const char __pyx_k_polyder_line_8963[] = "polyder (line 8963)";
static const char __pyx_k_polydiv_line_9017[] = "polydiv (line 9017)";
static const char __pyx_k_polyfit_line_9064[] = "polyfit (line 9064)";
static const char __pyx_k_polyint_line_9200[] = "polyint (line 9200)";
static const char __pyx_k_polymul_line_9269[] = "polymul (line 9269)";
static const char __pyx_k_polysub_line_9318[] = "polysub (line 9318)";
static const char __pyx_k_polyval_line_9350[] = "polyval (line 9350)";
static const char __pyx_k_putmask_line_9665[] = "putmask (line 9665)";
static const char __pyx_k_ravel_multi_index[] = "ravel_multi_index";
static const char __pyx_k_repeat_line_10146[] = "repeat (line 10146)";
static const char __pyx_k_resize_line_10308[] = "resize (line 10308)";
static const char __pyx_k_select_line_11064[] = "select (line 11064)";
static const char __pyx_k_seterr_line_11315[] = "seterr (line 11315)";
static const char __pyx_k_source_line_11828[] = "source (line 11828)";
static const char __pyx_k_tril_indices_from[] = "tril_indices_from";
static const char __pyx_k_triu_indices_from[] = "triu_indices_from";
static const char __pyx_k_unique_line_12957[] = "unique (line 12957)";
static const char __pyx_k_unwrap_line_13118[] = "unwrap (line 13118)";
static const char __pyx_k_vander_line_13161[] = "vander (line 13161)";
static const char __pyx_k_vsplit_line_13364[] = "vsplit (line 13364)";
static const char __pyx_k_vstack_line_13413[] = "vstack (line 13413)";
static const char __pyx_k_asfarray_line_1279[] = "asfarray (line 1279)";
static const char __pyx_k_asmatrix_line_1344[] = "asmatrix (line 1344)";
static const char __pyx_k_asscalar_line_1376[] = "asscalar (line 1376)";
static const char __pyx_k_bartlett_line_1604[] = "bartlett (line 1604)";
static const char __pyx_k_bincount_line_1808[] = "bincount (line 1808)";
static const char __pyx_k_blackman_line_1883[] = "blackman (line 1883)";
static const char __pyx_k_can_cast_line_2099[] = "can_cast (line 2099)";
static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
static const char __pyx_k_compare_chararrays[] = "compare_chararrays";
static const char __pyx_k_compress_line_2408[] = "compress (line 2408)";
static const char __pyx_k_convolve_line_2545[] = "convolve (line 2545)";
static const char __pyx_k_deprecate_with_doc[] = "deprecate_with_doc";
static const char __pyx_k_diagflat_line_3308[] = "diagflat (line 3308)";
static const char __pyx_k_digitize_line_3394[] = "digitize (line 3394)";
static const char __pyx_k_fromfile_line_4247[] = "fromfile (line 4247)";
static const char __pyx_k_fromiter_line_4324[] = "fromiter (line 4324)";
static const char __pyx_k_gradient_line_5018[] = "gradient (line 5018)";
static const char __pyx_k_isneginf_line_6290[] = "isneginf (line 6290)";
static const char __pyx_k_isposinf_line_6349[] = "isposinf (line 6349)";
static const char __pyx_k_isscalar_line_6471[] = "isscalar (line 6471)";
static const char __pyx_k_issctype_line_6497[] = "issctype (line 6497)";
static const char __pyx_k_iterable_line_6626[] = "iterable (line 6626)";
static const char __pyx_k_meshgrid_line_7563[] = "meshgrid (line 7563)";
static const char __pyx_k_packbits_line_8454[] = "packbits (line 8454)";
static const char __pyx_k_require_line_10187[] = "require (line 10187)";
static const char __pyx_k_reshape_line_10246[] = "reshape (line 10246)";
static const char __pyx_k_savetxt_line_10777[] = "savetxt (line 10777)";
static const char __pyx_k_squeeze_line_11935[] = "squeeze (line 11935)";
static const char __pyx_k_union1d_line_12927[] = "union1d (line 12927)";
static const char __pyx_k_NotImplementedError[] = "NotImplementedError";
static const char __pyx_k_array_str_line_1093[] = "array_str (line 1093)";
static const char __pyx_k_base_repr_line_1708[] = "base_repr (line 1708)";
static const char __pyx_k_correlate_line_2718[] = "correlate (line 2718)";
static const char __pyx_k_deprecate_line_3171[] = "deprecate (line 3171)";
static const char __pyx_k_fromregex_line_4402[] = "fromregex (line 4402)";
static const char __pyx_k_getbuffer_line_4826[] = "getbuffer (line 4826)";
static const char __pyx_k_geterrobj_line_4952[] = "geterrobj (line 4952)";
static const char __pyx_k_histogram_line_5248[] = "histogram (line 5248)";
static const char __pyx_k_indices_or_sections[] = "indices_or_sections";
static const char __pyx_k_iscomplex_line_6168[] = "iscomplex (line 6168)";
static const char __pyx_k_isfortran_line_6233[] = "isfortran (line 6233)";
static const char __pyx_k_isrealobj_line_6437[] = "isrealobj (line 6437)";
static const char __pyx_k_nanargmax_line_7857[] = "nanargmax (line 7857)";
static const char __pyx_k_nanargmin_line_7892[] = "nanargmin (line 7892)";
static const char __pyx_k_piecewise_line_8580[] = "piecewise (line 8580)";
static const char __pyx_k_rollaxis_line_10488[] = "rollaxis (line 10488)";
static const char __pyx_k_set_string_function[] = "set_string_function";
static const char __pyx_k_setxor1d_line_11538[] = "setxor1d (line 11538)";
static const char __pyx_k_swapaxes_line_12117[] = "swapaxes (line 12117)";
static const char __pyx_k_typename_line_12876[] = "typename (line 12876)";
static const char __pyx_k_array_equal_line_955[] = "array_equal (line 955)";
static const char __pyx_k_array_equiv_line_990[] = "array_equiv (line 990)";
static const char __pyx_k_array_repr_line_1027[] = "array_repr (line 1027)";
static const char __pyx_k_asanyarray_line_1129[] = "asanyarray (line 1129)";
static const char __pyx_k_atleast_1d_line_1398[] = "atleast_1d (line 1398)";
static const char __pyx_k_atleast_2d_line_1439[] = "atleast_2d (line 1439)";
static const char __pyx_k_atleast_3d_line_1478[] = "atleast_3d (line 1478)";
static const char __pyx_k_fastCopyAndTranspose[] = "_fastCopyAndTranspose";
static const char __pyx_k_frombuffer_line_4207[] = "frombuffer (line 4207)";
static const char __pyx_k_frompyfunc_line_4360[] = "frompyfunc (line 4360)";
static const char __pyx_k_fromstring_line_4459[] = "fromstring (line 4459)";
static const char __pyx_k_genfromtxt_line_4596[] = "genfromtxt (line 4596)";
static const char __pyx_k_get_numarray_include[] = "get_numarray_include";
static const char __pyx_k_geterrcall_line_4908[] = "geterrcall (line 4908)";
static const char __pyx_k_issubdtype_line_6568[] = "issubdtype (line 6568)";
static const char __pyx_k_nan_to_num_line_7810[] = "nan_to_num (line 7810)";
static const char __pyx_k_obj2sctype_line_8342[] = "obj2sctype (line 8342)";
static const char __pyx_k_percentile_line_8500[] = "percentile (line 8500)";
static const char __pyx_k_row_stack_line_10643[] = "row_stack (line 10643)";
static const char __pyx_k_safe_eval_line_10694[] = "safe_eval (line 10694)";
static const char __pyx_k_setdiff1d_line_11279[] = "setdiff1d (line 11279)";
static const char __pyx_k_seterrobj_line_11477[] = "seterrobj (line 11477)";
static const char __pyx_k_tensordot_line_12216[] = "tensordot (line 12216)";
static const char __pyx_k_transpose_line_12448[] = "transpose (line 12448)";
static const char __pyx_k_array2string_line_906[] = "array2string (line 906)";
static const char __pyx_k_array_split_line_1071[] = "array_split (line 1071)";
static const char __pyx_k_binary_repr_line_1748[] = "binary_repr (line 1748)";
static const char __pyx_k_byte_bounds_line_2067[] = "byte_bounds (line 2067)";
static const char __pyx_k_common_type_line_2362[] = "common_type (line 2362)";
static const char __pyx_k_concatenate_line_2469[] = "concatenate (line 2469)";
static const char __pyx_k_expand_dims_line_3817[] = "expand_dims (line 3817)";
static const char __pyx_k_flatnonzero_line_4071[] = "flatnonzero (line 4071)";
static const char __pyx_k_histogram2d_line_5333[] = "histogram2d (line 5333)";
static const char __pyx_k_histogramdd_line_5418[] = "histogramdd (line 5418)";
static const char __pyx_k_intersect1d_line_6039[] = "intersect1d (line 6039)";
static const char __pyx_k_issubclass__line_6533[] = "issubclass_ (line 6533)";
static const char __pyx_k_issubsctype_line_6596[] = "issubsctype (line 6596)";
static const char __pyx_k_mintypecode_line_7718[] = "mintypecode (line 7718)";
static const char __pyx_k_seterrcall_line_11394[] = "seterrcall (line 11394)";
static const char __pyx_k_trim_zeros_line_12719[] = "trim_zeros (line 12719)";
static const char __pyx_k_unpackbits_line_13028[] = "unpackbits (line 13028)";
static const char __pyx_k_column_stack_line_2323[] = "column_stack (line 2323)";
static const char __pyx_k_diag_indices_line_3221[] = "diag_indices (line 3221)";
static const char __pyx_k_iscomplexobj_line_6199[] = "iscomplexobj (line 6199)";
static const char __pyx_k_mask_indices_line_7192[] = "mask_indices (line 7192)";
static const char __pyx_k_result_type_line_10366[] = "result_type (line 10366)";
static const char __pyx_k_sctype2char_line_10972[] = "sctype2char (line 10972)";
static const char __pyx_k_count_nonzero_line_2758[] = "count_nonzero (line 2758)";
static const char __pyx_k_fill_diagonal_line_3921[] = "fill_diagonal (line 3921)";
static const char __pyx_k_promote_types_line_9525[] = "promote_types (line 9525)";
static const char __pyx_k_searchsorted_line_11016[] = "searchsorted (line 11016)";
static const char __pyx_k_sort_complex_line_11803[] = "sort_complex (line 11803)";
static const char __pyx_k_tril_indices_line_12622[] = "tril_indices (line 12622)";
static const char __pyx_k_triu_indices_line_12778[] = "triu_indices (line 12778)";
static const char __pyx_k_apply_over_axes_line_506[] = "apply_over_axes (line 506)";
static const char __pyx_k_asfortranarray_line_1308[] = "asfortranarray (line 1308)";
static const char __pyx_k_maximum_sctype_line_7348[] = "maximum_sctype (line 7348)";
static const char __pyx_k_real_if_close_line_10062[] = "real_if_close (line 10062)";
static const char __pyx_k_unravel_index_line_13073[] = "unravel_index (line 13073)";
static const char __pyx_k_apply_along_axis_line_449[] = "apply_along_axis (line 449)";
static const char __pyx_k_ga4py_gain_notimplemented[] = "ga4py.gain.notimplemented";
static const char __pyx_k_min_scalar_type_line_7668[] = "min_scalar_type (line 7668)";
static const char __pyx_k_broadcast_arrays_line_2026[] = "broadcast_arrays (line 2026)";
static const char __pyx_k_find_common_type_line_3982[] = "find_common_type (line 3982)";
static const char __pyx_k_may_share_memory_line_7388[] = "may_share_memory (line 7388)";
static const char __pyx_k_set_numeric_ops_line_11103[] = "set_numeric_ops (line 11103)";
static const char __pyx_k_asarray_chkfinite_line_1181[] = "asarray_chkfinite (line 1181)";
static const char __pyx_k_ascontiguousarray_line_1243[] = "ascontiguousarray (line 1243)";
static const char __pyx_k_ndarray_is_not_C_contiguous[] = "ndarray is not C contiguous";
static const char __pyx_k_ravel_multi_index_line_9968[] = "ravel_multi_index (line 9968)";
static const char __pyx_k_set_printoptions_line_11149[] = "set_printoptions (line 11149)";
static const char __pyx_k_ga4py_gain_notimplemented_pyx[] = "ga4py/gain/notimplemented.pyx";
static const char __pyx_k_set_string_function_line_11214[] = "set_string_function (line 11214)";
static const char __pyx_k_An_array_with_ones_at_and_below[] = "An array with ones at and below the given diagonal and zeros elsewhere.\n\n    Parameters\n    ----------\n    N : int\n        Number of rows in the array.\n    M : int, optional\n        Number of columns in the array.\n        By default, `M` is taken equal to `N`.\n    k : int, optional\n        The sub-diagonal at and below which the array is filled.\n        `k` = 0 is the main diagonal, while `k` < 0 is below it,\n        and `k` > 0 is above.  The default is 0.\n    dtype : dtype, optional\n        Data type of the returned array.  The default is float.\n\n    Returns\n    -------\n    T : ndarray of shape (N, M)\n        Array with its lower triangle filled with ones and zero elsewhere;\n        in other words ``T[i,j] == 1`` for ``i <= j + k``, 0 otherwise.\n\n    Examples\n    --------\n    >>> np.tri(3, 5, 2, dtype=int)\n    array([[1, 1, 1, 0, 0],\n           [1, 1, 1, 1, 0],\n           [1, 1, 1, 1, 1]])\n\n    >>> np.tri(3, 5, -1)\n    array([[ 0.,  0.,  0.,  0.,  0.],\n           [ 1.,  0.,  0.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.,  0.]])\n    \n    ";
static const char __pyx_k_Compute_the_present_value_Given[] = "Compute the present value.\n\n    Given:\n     * a future value, `fv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value now\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray, float\n        Present value of a series of payments or investments.\n\n    Notes\n    -----\n    The present value is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0\n\n    or, when ``rate = 0``::\n\n     fv + pv + pmt * nper = 0\n\n    for `pv`, which is then returned.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the present value (e.g., the initial investment)\n    of an investment that needs to total $15692.93\n    after 10 years of saving $100 every month?  Assume the\n    interest rate is 5% (annually) compounded monthly.\n\n    >>> np.pv(0.05/12, 10*12, -100, 15692.93)\n   "" -100.00067131625819\n\n    By convention, the negative sign represents cash flow out\n    (i.e., money not available today).  Thus, to end up with\n    $15,692.93 in 10 years saving $100 a month at 5% annual\n    interest, one's initial deposit should also be $100.\n\n    If any input is array_like, ``pv`` returns an array of equal shape.\n    Let's compare different interest rates in the example above:\n\n    >>> a = np.array((0.05, 0.04, 0.03))/12\n    >>> np.pv(a, 10*12, -100, 15692.93)\n    array([ -100.00067132,  -649.26771385, -1273.78633713])\n\n    So, to end up with the same $15692.93 under the same $100 per month\n    \"savings plan,\" for annual interest rates of 4% and 3%, one would\n    need initial investments of $649.27 and $1273.79, respectively.\n    \n    ";
static const char __pyx_k_Construct_an_array_by_repeating[] = "Construct an array by repeating A the number of times given by reps.\n\n    If `reps` has length ``d``, the result will have dimension of\n    ``max(d, A.ndim)``.\n\n    If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\n    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\n    or shape (1, 1, 3) for 3-D replication. If this is not the desired\n    behavior, promote `A` to d-dimensions manually before calling this\n    function.\n\n    If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.\n    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\n    (1, 1, 2, 2).\n\n    Parameters\n    ----------\n    A : array_like\n        The input array.\n    reps : array_like\n        The number of repetitions of `A` along each axis.\n\n    Returns\n    -------\n    c : ndarray\n        The tiled output array.\n\n    See Also\n    --------\n    repeat : Repeat elements of an array.\n\n    Examples\n    --------\n    >>> a = np.array([0, 1, 2])\n    >>> np.tile(a, 2)\n    array([0, 1, 2, 0, 1, 2])\n    >>> np.tile(a, (2, 2))\n    array([[0, 1, 2, 0, 1, 2],\n           [0, 1, 2, 0, 1, 2]])\n    >>> np.tile(a, (2, 1, 2))\n    array([[[0, 1, 2, 0, 1, 2]],\n           [[0, 1, 2, 0, 1, 2]]])\n\n    >>> b = np.array([[1, 2], [3, 4]])\n    >>> np.tile(b, 2)\n    array([[1, 2, 1, 2],\n           [3, 4, 3, 4]])\n    >>> np.tile(b, (2, 1))\n    array([[1, 2],\n           [3, 4],\n           [1, 2],\n           [3, 4]])\n    \n    ";
static const char __pyx_k_Convert_the_input_to_an_ndarray[] = "Convert the input to an ndarray, but pass ndarray subclasses through.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes scalars, lists, lists of tuples, tuples, tuples of tuples,\n        tuples of lists, and ndarrays.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('F') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray or an ndarray subclass\n        Array interpretation of `a`.  If `a` is an ndarray or a subclass\n        of ndarray, it is returned as-is and no copy is performed.\n\n    See Also\n    --------\n    asarray : Similar function which always returns ndarrays.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    asarray_chkfinite : Similar function which checks input for NaNs and\n                        Infs.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array:\n\n    >>> a = [1, 2]\n    >>> np.asanyarray(a)\n    array([1, 2])\n\n    Instances of `ndarray` subclasses are passed through as-is:\n\n    >>> a = np.matrix([1, 2])\n    >>> np.asanyarray(a) is a\n    True\n    \n    ";
static const char __pyx_k_Determine_common_type_following[] = "Determine common type following standard coercion rules.\n\n    Parameters\n    ----------\n    array_types : sequence\n        A list of dtypes or dtype convertible objects representing arrays.\n    scalar_types : sequence\n        A list of dtypes or dtype convertible objects representing scalars.\n\n    Returns\n    -------\n    datatype : dtype\n        The common data type, which is the maximum of `array_types` ignoring\n        `scalar_types`, unless the maximum of `scalar_types` is of a\n        different kind (`dtype.kind`). If the kind is not understood, then\n        None is returned.\n\n    See Also\n    --------\n    dtype, common_type, can_cast, mintypecode\n\n    Examples\n    --------\n    >>> np.find_common_type([], [np.int64, np.float32, np.complex])\n    dtype('complex128')\n    >>> np.find_common_type([np.int64, np.float32], [])\n    dtype('float64')\n\n    The standard casting rules ensure that a scalar cannot up-cast an\n    array unless the scalar is of a fundamentally different kind of data\n    (i.e. under a different hierarchy in the data type hierarchy) then\n    the array:\n\n    >>> np.find_common_type([np.float32], [np.int64, np.float64])\n    dtype('float32')\n\n    Complex is of a different type, so it up-casts the float in the\n    `array_types` argument:\n\n    >>> np.find_common_type([np.float32], [np.complex])\n    dtype('complex128')\n\n    Type specifier strings are convertible to dtypes and can therefore\n    be used instead of dtypes:\n\n    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\n    dtype('complex128')\n    \n    ";
static const char __pyx_k_Determine_if_the_first_argument[] = "Determine if the first argument is a subclass of the second argument.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype or dtype specifier\n        Data-types.\n\n    Returns\n    -------\n    out : bool\n        The result.\n\n    See Also\n    --------\n    issctype, issubdtype,obj2sctype\n\n    Examples\n    --------\n    >>> np.issubsctype('S8', str)\n    True\n    >>> np.issubsctype(np.array([1]), np.int)\n    True\n    >>> np.issubsctype(np.array([1]), np.float)\n    False\n    \n    ";
static const char __pyx_k_Find_the_sum_of_two_polynomials[] = "Find the sum of two polynomials.\n\n    Returns the polynomial resulting from the sum of two input polynomials.\n    Each input must be either a poly1d object or a 1D sequence of polynomial\n    coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The sum of the inputs. If either input is a poly1d object, then the\n        output is also a poly1d object. Otherwise, it is a 1D array of\n        polynomial coefficients from highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\n    Examples\n    --------\n    >>> np.polyadd([1, 2], [9, 5, 4])\n    array([9, 6, 6])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2])\n    >>> p2 = np.poly1d([9, 5, 4])\n    >>> print p1\n    1 x + 2\n    >>> print p2\n       2\n    9 x + 5 x + 4\n    >>> print np.polyadd(p1, p2)\n       2\n    9 x + 6 x + 6\n    \n    ";
static const char __pyx_k_Generate_a_Van_der_Monde_matrix[] = "Generate a Van der Monde matrix.\n\n    The columns of the output matrix are decreasing powers of the input\n    vector.  Specifically, the `i`-th output column is the input vector\n    raised element-wise to the power of ``N - i - 1``.  Such a matrix with\n    a geometric progression in each row is named for Alexandre-Theophile\n    Vandermonde.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D input array.\n    N : int, optional\n        Order of (number of columns in) the output.  If `N` is not specified,\n        a square array is returned (``N = len(x)``).\n\n    Returns\n    -------\n    out : ndarray\n        Van der Monde matrix of order `N`.  The first column is ``x^(N-1)``,\n        the second ``x^(N-2)`` and so forth.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3, 5])\n    >>> N = 3\n    >>> np.vander(x, N)\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> np.column_stack([x**(N-1-i) for i in range(N)])\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> x = np.array([1, 2, 3, 5])\n    >>> np.vander(x)\n    array([[  1,   1,   1,   1],\n           [  8,   4,   2,   1],\n           [ 27,   9,   3,   1],\n           [125,  25,   5,   1]])\n\n    The determinant of a square Vandermonde matrix is the product\n    of the differences between the values of the input vector:\n\n    >>> np.linalg.det(np.vander(x))\n    48.000000000000043\n    >>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n    48\n    \n    ";
static const char __pyx_k_Get_the_current_way_of_handling[] = "Get the current way of handling floating-point errors.\n\n    Returns\n    -------\n    res : dict\n        A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n        whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n        \"raise\", and \"call\". The keys represent possible floating-point\n        exceptions, and the values define how these exceptions are handled.\n\n    See Also\n    --------\n    geterrcall, seterr, seterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'warn', 'invalid': 'warn',\n    'under': 'ignore'}\n    >>> np.arange(3.) / np.arange(3.)\n    array([ NaN,   1.,   1.])\n\n    >>> oldsettings = np.seterr(all='warn', over='raise')\n    >>> np.geterr()\n    {'over': 'raise', 'divide': 'warn', 'invalid': 'warn', 'under': 'warn'}\n    >>> np.arange(3.) / np.arange(3.)\n    __main__:1: RuntimeWarning: invalid value encountered in divide\n    array([ NaN,   1.,   1.])\n    \n    ";
static const char __pyx_k_If_complex_input_returns_a_real[] = "If complex input returns a real array if complex parts are close to zero.\n\n    \"Close to zero\" is defined as `tol` * (machine epsilon of the type for\n    `a`).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    tol : float\n        Tolerance in machine epsilons for the complex part of the elements\n        in the array.\n\n    Returns\n    -------\n    out : ndarray\n        If `a` is real, the type of `a` is used for the output.  If `a`\n        has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, imag, angle\n\n    Notes\n    -----\n    Machine epsilon varies from machine to machine and between data types\n    but Python floats on most platforms have a machine epsilon equal to\n    2.2204460492503131e-16.  You can use 'np.finfo(np.float).eps' to print\n    out the machine epsilon for floats.\n\n    Examples\n    --------\n    >>> np.finfo(np.float).eps\n    2.2204460492503131e-16\n\n    >>> np.real_if_close([2.1 + 4e-14j], tol=1000)\n    array([ 2.1])\n    >>> np.real_if_close([2.1 + 4e-13j], tol=1000)\n    array([ 2.1 +4.00000000e-13j])\n    \n    ";
static const char __pyx_k_Interpret_the_input_as_a_matrix[] = "Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n    \n    ";
static const char __pyx_k_Kronecker_product_of_two_arrays[] = "Kronecker product of two arrays.\n\n    Computes the Kronecker product, a composite array made of blocks of the\n    second array scaled by the first.\n\n    Parameters\n    ----------\n    a, b : array_like\n\n    Returns\n    -------\n    out : ndarray\n\n    See Also\n    --------\n\n    outer : The outer product\n\n    Notes\n    -----\n\n    The function assumes that the number of dimenensions of `a` and `b`\n    are the same, if necessary prepending the smallest with ones.\n    If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,\n    the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.\n    The elements are products of elements from `a` and `b`, organized\n    explicitly by::\n\n        kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n    where::\n\n        kt = it * st + jt,  t = 0,...,N\n\n    In the common 2-D case (N=1), the block structure can be visualized::\n\n        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n         [  ...                              ...   ],\n         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\n    Examples\n    --------\n    >>> np.kron([1,10,100], [5,6,7])\n    array([  5,   6,   7,  50,  60,  70, 500, 600, 700])\n    >>> np.kron([5,6,7], [1,10,100])\n    array([  5,  50, 500,   6,  60, 600,   7,  70, 700])\n\n    >>> np.kron(np.eye(2), np.ones((2,2)))\n    array([[ 1.,  1.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.],\n           [ 0.,  0.,  1.,  1.],\n           [ 0.,  0.,  1.,  1.]])\n\n    >>> a = np.arange(100).reshape((2,5,2,5))\n    >>> b = np.arange(24).reshape((2,3,4))\n    >>> c = np.kron(a,b)\n    >>> c.shape\n    (2, 10, 6, 20)\n    >>> I = (1,3,0,2)\n    >>> J = (0,2,1)\n    >>> J1 = (0,) + J             # extend to ndim=4\n    >>> S1 = (1,) + b.shape\n    >>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n    >>> c[K] == a[I]*b[J]\n    True\n    \n    ";
static const char __pyx_k_Load_data_from_a_text_file_Each[] = "Load data from a text file.\n\n    Each row in the text file must have the same number of values.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        ``.gz`` or ``.bz2``, the file is first decompressed. Note that\n        generators should return byte strings for Python 3k.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this is a\n        record data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type.\n    comments : str, optional\n        The character used to indicate the start of a comment;\n        default: '#'.\n    delimiter : str, optional\n        The string used to separate values.  By default, this is any\n        whitespace.\n    converters : dict, optional\n        A dictionary mapping column number to a function that will convert\n        that column to a float.  E.g., if column 0 is a date string:\n        ``converters = {0: datestr2num}``.  Converters can also be used to\n        provide a default value for missing data (but see also `genfromtxt`):\n        ``converters = {3: lambda s: float(s.strip() or 0)}``.  Default: None.\n    skiprows : int, optional\n        Skip the first `skiprows` lines; default: 0.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``.  When used with a record\n        data-type, arrays are returned for each field.  Default is False.\n    ndmin : int, optional\n        The ""returned array will have at least `ndmin` dimensions.\n        Otherwise mono-dimensional axes will be squeezed. \n        Legal values: 0 (default), 1 or 2.\n        .. versionadded:: 1.6.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file.\n\n    See Also\n    --------\n    load, fromstring, fromregex\n    genfromtxt : Load data with missing values handled as specified.\n    scipy.io.loadmat : reads MATLAB data files\n\n    Notes\n    -----\n    This function aims to be a fast reader for simply formatted files.  The\n    `genfromtxt` function provides more sophisticated handling of, e.g.,\n    lines with missing values.\n\n    Examples\n    --------\n    >>> from StringIO import StringIO   # StringIO behaves like a file object\n    >>> c = StringIO(\"0 1\n2 3\")\n    >>> np.loadtxt(c)\n    array([[ 0.,  1.],\n           [ 2.,  3.]])\n\n    >>> d = StringIO(\"M 21 72\nF 35 58\")\n    >>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n    ...                      'formats': ('S1', 'i4', 'f4')})\n    array([('M', 21, 72.0), ('F', 35, 58.0)],\n          dtype=[('gender', '|S1'), ('age', '<i4'), ('weight', '<f4')])\n\n    >>> c = StringIO(\"1,0,2\n3,0,4\")\n    >>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n    >>> x\n    array([ 1.,  3.])\n    >>> y\n    array([ 2.,  4.])\n    \n    ";
static const char __pyx_k_Load_data_from_a_text_file_with[] = "Load data from a text file, with missing values handled as specified.\n\n    Each line past the first `skip_header` lines is split at the `delimiter`\n    character, and characters following the `comments` character are discarded.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        `.gz` or `.bz2`, the file is first decompressed. Note that\n        generators must return byte strings in Python 3k.\n    dtype : dtype, optional\n        Data type of the resulting array.\n        If None, the dtypes will be determined by the contents of each\n        column, individually.\n    comments : str, optional\n        The character used to indicate the start of a comment.\n        All the characters occurring on a line after a comment are discarded\n    delimiter : str, int, or sequence, optional\n        The string used to separate values.  By default, any consecutive\n        whitespaces act as delimiter.  An integer or sequence of integers\n        can also be provided as width(s) of each field.\n    skip_header : int, optional\n        The numbers of lines to skip at the beginning of the file.\n    skip_footer : int, optional\n        The numbers of lines to skip at the end of the file\n    converters : variable, optional\n        The set of functions that convert the data of a column to a value.\n        The converters can also be used to provide a default value\n        for missing data: ``converters = {3: lambda s: float(s or 0)}``.\n    missing_values : variable, optional\n        The set of strings corresponding to missing data.\n    filling_values : variable, optional\n        The set of values to be used as default when the data are missing.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.\n    names : {None, True, str, sequence}, optional\n     ""   If `names` is True, the field names are read from the first valid line\n        after the first `skip_header` lines.\n        If `names` is a sequence or a single-string of comma-separated names,\n        the names will be used to define the field names in a structured dtype.\n        If `names` is None, the names of the dtype fields will be used, if any.\n    excludelist : sequence, optional\n        A list of names to exclude. This list is appended to the default list\n        ['return','file','print']. Excluded names are appended an underscore:\n        for example, `file` would become `file_`.\n    deletechars : str, optional\n        A string combining invalid characters that must be deleted from the\n        names.\n    defaultfmt : str, optional\n        A format used to define default field names, such as \"f%i\" or \"f_%02i\".\n    autostrip : bool, optional\n        Whether to automatically strip white spaces from the variables.\n    replace_space : char, optional\n        Character(s) used in replacement of white spaces in the variables names.\n        By default, use a '_'.\n    case_sensitive : {True, False, 'upper', 'lower'}, optional\n        If True, field names are case sensitive.\n        If False or 'upper', field names are converted to upper case.\n        If 'lower', field names are converted to lower case.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``\n    usemask : bool, optional\n        If True, return a masked array.\n        If False, return a regular array.\n    invalid_raise : bool, optional\n        If True, an exception is raised if an inconsistency is detected in the\n        number of columns.\n        If False, a warning is emitted and the offending lines are skipped.\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file. If `usemask` is True, this is a\n        masked array.\n\n    See Als""o\n    --------\n    numpy.loadtxt : equivalent function when no data is missing.\n\n    Notes\n    -----\n    * When spaces are used as delimiters, or when no delimiter has been given\n      as input, there should not be any missing data between two fields.\n    * When the variables are named (either by a flexible dtype or with `names`,\n      there must not be any header in the file (else a ValueError\n      exception is raised).\n    * Individual values are not stripped of spaces by default.\n      When using a custom converter, make sure the function does remove spaces.\n\n    Examples\n    ---------\n    >>> from StringIO import StringIO\n    >>> import numpy as np\n\n    Comma delimited file with mixed dtype\n\n    >>> s = StringIO(\"1,1.3,abcde\")\n    >>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n    ... ('mystring','S5')], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Using dtype = None\n\n    >>> s.seek(0) # needed for StringIO example only\n    >>> data = np.genfromtxt(s, dtype=None,\n    ... names = ['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Specifying dtype and names\n\n    >>> s.seek(0)\n    >>> data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n    ... names=['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    An example with fixed-width columns\n\n    >>> s = StringIO(\"11.3abcde\")\n    >>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n    ...     delimiter=[1,3,5])\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '|S5')])\n    \n    ";
static const char __pyx_k_Modified_Bessel_function_of_the[] = "Modified Bessel function of the first kind, order 0.\n\n    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*\n    \"up-cast\" int dtype arguments unless accompanied by at least one float or\n    complex dtype argument (see Raises below).\n\n    Parameters\n    ----------\n    x : array_like, dtype float or complex\n        Argument of the Bessel function.\n\n    Returns\n    -------\n    out : ndarray, shape = x.shape, dtype = x.dtype\n        The modified Bessel function evaluated at each of the elements of `x`.\n\n    Raises\n    ------\n    TypeError: array cannot be safely cast to required type\n        If argument consists exclusively of int dtypes.\n\n    See Also\n    --------\n    scipy.special.iv, scipy.special.ive\n\n    Notes\n    -----\n    We use the algorithm published by Clenshaw [1]_ and referenced by\n    Abramowitz and Stegun [2]_, for which the function domain is partitioned\n    into the two intervals [0,8] and (8,inf), and Chebyshev polynomial\n    expansions are employed in each interval. Relative error on the domain\n    [0,30] using IEEE arithmetic is documented [3]_ as having a peak of 5.8e-16\n    with an rms of 1.4e-16 (n = 30000).\n\n    References\n    ----------\n    .. [1] C. W. Clenshaw, \"Chebyshev series for mathematical functions,\" in\n           *National Physical Laboratory Mathematical Tables*, vol. 5, London:\n           Her Majesty's Stationery Office, 1962.\n    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical\n           Functions*, 10th printing, New York: Dover, 1964, pp. 379.\n           http://www.math.sfu.ca/~cbm/aands/page_379.htm\n    .. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html\n\n    Examples\n    --------\n    >>> np.i0([0.])\n    array(1.0)\n    >>> np.i0([0., 1. + 2j])\n    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])\n    \n    ";
static const char __pyx_k_Range_of_values_maximum_minimum[] = "Range of values (maximum - minimum) along an axis.\n\n    The name of the function comes from the acronym for 'peak to peak'.\n\n    Parameters\n    ----------\n    a : array_like\n        Input values.\n    axis : int, optional\n        Axis along which to find the peaks.  By default, flatten the\n        array.\n    out : array_like\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type of the output values will be cast if necessary.\n\n    Returns\n    -------\n    ptp : ndarray\n        A new array holding the result, unless `out` was\n        specified, in which case a reference to `out` is returned.\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.ptp(x, axis=0)\n    array([2, 2])\n\n    >>> np.ptp(x, axis=1)\n    array([1, 1])\n    \n    ";
static const char __pyx_k_Return_coordinate_matrices_from[] = "Return coordinate matrices from two coordinate vectors.\n\n    Parameters\n    ----------\n    x, y : ndarray\n        Two 1-D arrays representing the x and y coordinates of a grid.\n\n    Returns\n    -------\n    X, Y : ndarray\n        For vectors `x`, `y` with lengths ``Nx=len(x)`` and ``Ny=len(y)``,\n        return `X`, `Y` where `X` and `Y` are ``(Ny, Nx)`` shaped arrays\n        with the elements of `x` and y repeated to fill the matrix along\n        the first dimension for `x`, the second for `y`.\n\n    See Also\n    --------\n    index_tricks.mgrid : Construct a multi-dimensional \"meshgrid\"\n                         using indexing notation.\n    index_tricks.ogrid : Construct an open multi-dimensional \"meshgrid\"\n                         using indexing notation.\n\n    Examples\n    --------\n    >>> X, Y = np.meshgrid([1,2,3], [4,5,6,7])\n    >>> X\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\n    >>> Y\n    array([[4, 4, 4],\n           [5, 5, 5],\n           [6, 6, 6],\n           [7, 7, 7]])\n\n    `meshgrid` is very useful to evaluate functions on a grid.\n\n    >>> x = np.arange(-5, 5, 0.1)\n    >>> y = np.arange(-5, 5, 0.1)\n    >>> xx, yy = np.meshgrid(x, y)\n    >>> z = np.sin(xx**2+yy**2)/(xx**2+yy**2)\n    \n    ";
static const char __pyx_k_Return_the_angle_of_the_complex[] = "Return the angle of the complex argument.\n\n    Parameters\n    ----------\n    z : array_like\n        A complex number or sequence of complex numbers.\n    deg : bool, optional\n        Return angle in degrees if True, radians if False (default).\n\n    Returns\n    -------\n    angle : {ndarray, scalar}\n        The counterclockwise angle from the positive real axis on\n        the complex plane, with dtype as numpy.float64.\n\n    See Also\n    --------\n    arctan2\n    absolute\n\n\n\n    Examples\n    --------\n    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians\n    array([ 0.        ,  1.57079633,  0.78539816])\n    >>> np.angle(1+1j, deg=True)                  # in degrees\n    45.0\n    \n    ";
static const char __pyx_k_Return_the_cross_product_of_two[] = "Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  By default, the\n        last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    ix_ : Construct index arrays.\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3""])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    -3\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the `right-hand rule`.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n    \n    ";
static const char __pyx_k_Return_the_elements_of_an_array[] = "Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Parameters\n    ----------\n    condition : array_like\n        An array whose nonzero or True entries indicate the elements of `arr`\n        to extract.\n    arr : array_like\n        Input array of the same size as `condition`.\n\n    See Also\n    --------\n    take, put, putmask, compress\n\n    Examples\n    --------\n    >>> arr = np.arange(12).reshape((3, 4))\n    >>> arr\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n    >>> condition = np.mod(arr, 3)==0\n    >>> condition\n    array([[ True, False, False,  True],\n           [False, False,  True, False],\n           [False,  True, False, False]], dtype=bool)\n    >>> np.extract(condition, arr)\n    array([0, 3, 6, 9])\n\n\n    If `condition` is boolean:\n\n    >>> arr[condition]\n    array([0, 3, 6, 9])\n    \n    ";
static const char __pyx_k_Return_the_number_of_dimensions[] = "Return the number of dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  If it is not already an ndarray, a conversion is\n        attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in `a`.  Scalars are zero-dimensional.\n\n    See Also\n    --------\n    ndarray.ndim : equivalent method\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Examples\n    --------\n    >>> np.ndim([[1,2,3],[4,5,6]])\n    2\n    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.ndim(1)\n    0\n    \n    ";
static const char __pyx_k_Returns_True_if_the_type_of_num[] = "Returns True if the type of `num` is a scalar type.\n\n    Parameters\n    ----------\n    num : any\n        Input argument, can be of any type and shape.\n\n    Returns\n    -------\n    val : bool\n        True if `num` is a scalar type, False if it is not.\n\n    Examples\n    --------\n    >>> np.isscalar(3.1)\n    True\n    >>> np.isscalar([3.1])\n    False\n    >>> np.isscalar(False)\n    True\n    \n    ";
static const char __pyx_k_Returns_a_bool_array_where_True[] = "Returns a bool array, where True if input element is complex.\n\n    What is tested is whether the input has a non-zero imaginary part, not if\n    the input type is complex.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray of bools\n        Output array.\n\n    See Also\n    --------\n    isreal\n    iscomplexobj : Return True if x is a complex type or an array of complex\n                   numbers.\n\n    Examples\n    --------\n    >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([ True, False, False, False, False,  True], dtype=bool)\n    \n    ";
static const char __pyx_k_Test_whether_all_array_elements[] = "Test whether all array elements along a given axis evaluate to True.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical AND is performed.\n        The default (`axis` = `None`) is to perform a logical AND\n        over a flattened input array.  `axis` may be negative, in which\n        case it counts from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.\n        It must have the same shape as the expected output and its\n        type is preserved (e.g., if ``dtype(out)`` is float, the result\n        will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section\n        \"Output arguments\") for more details.\n\n    Returns\n    -------\n    all : ndarray, bool\n        A new boolean or array is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.all : equivalent method\n\n    any : Test whether any element along a given axis evaluates to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.all([[True,False],[True,True]])\n    False\n\n    >>> np.all([[True,False],[True,True]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.all([-1, 4, 5])\n    True\n\n    >>> np.all([1.0, np.nan])\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.all([-1, 4, 5], out=o)\n    >>> id(z), id(o), z                             # doctest: +SKIP\n    (28293632, 28293632, array([ True], dtype=bool))\n    \n    ";
static const char __pyx_k_concatenate_a1_a2_axis_0_Join_a[] = "concatenate((a1, a2, ...), axis=0)\n\n    Join a sequence of arrays together.\n\n    Parameters\n    ----------\n    a1, a2, ... : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined.  Default is 0.\n\n    Returns\n    -------\n    res : ndarray\n        The concatenated array.\n\n    See Also\n    --------\n    ma.concatenate : Concatenate function that preserves input masks.\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    hsplit : Split array into multiple sub-arrays horizontally (column wise)\n    vsplit : Split array into multiple sub-arrays vertically (row wise)\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    hstack : Stack arrays in sequence horizontally (column wise)\n    vstack : Stack arrays in sequence vertically (row wise)\n    dstack : Stack arrays in sequence depth wise (along third dimension)\n\n    Notes\n    -----\n    When one or more of the arrays to be concatenated is a MaskedArray,\n    this function will return a MaskedArray object instead of an ndarray,\n    but the input masks are *not* preserved. In cases where a MaskedArray\n    is expected as input, use the ma.concatenate function from the masked\n    array module instead.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1, 2, 5],\n           [3, 4, 6]])\n\n    This function will not preserve masking of MaskedArray inputs.\n\n    >>> a = np.ma.arange(3)\n    >>> a[1] = np.ma.masked\n    >>> b = np.arange(2, 5)\n    >>> a\n    masked_arr""ay(data = [0 -- 2],\n                 mask = [False  True False],\n           fill_value = 999999)\n    >>> b\n    array([2, 3, 4])\n    >>> np.concatenate([a, b])\n    masked_array(data = [0 1 2 2 3 4],\n                 mask = False,\n           fill_value = 999999)\n    >>> np.ma.concatenate([a, b])\n    masked_array(data = [0 -- 2 2 3 4],\n                 mask = [False  True False False False False],\n           fill_value = 999999)\n    \n    ";
static const char __pyx_k_fromfile_file_dtype_float_count[] = "fromfile(file, dtype=float, count=-1, sep='')\n\n    Construct an array from data in a text or binary file.\n\n    A highly efficient way of reading binary data with a known data-type,\n    as well as parsing simply formatted text files.  Data written using the\n    `tofile` method can be read using this function.\n\n    Parameters\n    ----------\n    file : file or str\n        Open file object or filename.\n    dtype : data-type\n        Data type of the returned array.\n        For binary files, it is used to determine the size and byte-order\n        of the items in the file.\n    count : int\n        Number of items to read. ``-1`` means all items (i.e., the complete\n        file).\n    sep : str\n        Separator between items if file is a text file.\n        Empty (\"\") separator means the file should be treated as binary.\n        Spaces (\" \") in the separator match zero or more whitespace characters.\n        A separator consisting only of spaces must match at least one\n        whitespace.\n\n    See also\n    --------\n    load, save\n    ndarray.tofile\n    loadtxt : More flexible way of loading data from a text file.\n\n    Notes\n    -----\n    Do not rely on the combination of `tofile` and `fromfile` for\n    data storage, as the binary files generated are are not platform\n    independent.  In particular, no byte-order or data-type information is\n    saved.  Data can be stored in the platform independent ``.npy`` format\n    using `save` and `load` instead.\n\n    Examples\n    --------\n    Construct an ndarray:\n\n    >>> dt = np.dtype([('time', [('min', int), ('sec', int)]),\n    ...                ('temp', float)])\n    >>> x = np.zeros((1,), dtype=dt)\n    >>> x['time']['min'] = 10; x['temp'] = 98.25\n    >>> x\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    Save the raw data to disk:\n\n    >>> import os\n    >>> fname = os.tmpnam()\n    >>> x.tofile(fname)\n\n    Read"" the raw data from disk:\n\n    >>> np.fromfile(fname, dtype=dt)\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    The recommended way to store and load data:\n\n    >>> np.save(fname, x)\n    >>> np.load(fname + '.npy')\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n    \n    ";
static const char __pyx_k_fromiter_iterable_dtype_count_1[] = "fromiter(iterable, dtype, count=-1)\n\n    Create a new 1-dimensional array from an iterable object.\n\n    Parameters\n    ----------\n    iterable : iterable object\n        An iterable object providing data for the array.\n    dtype : data-type\n        The data-type of the returned array.\n    count : int, optional\n        The number of items to read from *iterable*.  The default is -1,\n        which means all data is read.\n\n    Returns\n    -------\n    out : ndarray\n        The output array.\n\n    Notes\n    -----\n    Specify `count` to improve performance.  It allows ``fromiter`` to\n    pre-allocate the output array, instead of resizing it on demand.\n\n    Examples\n    --------\n    >>> iterable = (x*x for x in range(5))\n    >>> np.fromiter(iterable, np.float)\n    array([  0.,   1.,   4.,   9.,  16.])\n    \n    ";
static const char __pyx_k_numpy_core_multiarray_failed_to[] = "numpy.core.multiarray failed to import";
static const char __pyx_k_seterrobj_errobj_Set_the_object[] = "seterrobj(errobj)\n\n    Set the object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `seterrobj` is used internally by the other\n    functions that set error handling behavior (`seterr`, `seterrcall`).\n\n    Parameters\n    ----------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    geterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> old_errobj = np.geterrobj()  # first get the defaults\n    >>> old_errobj\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> new_errobj = [20000, 12, err_handler]\n    >>> np.seterrobj(new_errobj)\n    >>> np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n    '14'\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n    >>> np.geterrcall() is err_handler\n    True\n    \n    ";
static const char __pyx_k_unknown_dtype_code_in_numpy_pxd[] = "unknown dtype code in numpy.pxd (%d)";
static const char __pyx_k_Append_values_to_the_end_of_an_a[] = "Append values to the end of an array.\n\n    Parameters\n    ----------\n    arr : array_like\n        Values are appended to a copy of this array.\n    values : array_like\n        These values are appended to a copy of `arr`.  It must be of the\n        correct shape (the same shape as `arr`, excluding `axis`).  If `axis`\n        is not specified, `values` can be any shape and will be flattened\n        before use.\n    axis : int, optional\n        The axis along which `values` are appended.  If `axis` is not given,\n        both `arr` and `values` are flattened before use.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` appended to `axis`.  Note that `append`\n        does not occur in-place: a new array is allocated and filled.  If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\n    array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    When `axis` is specified, `values` must have the correct shape.\n\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\n    array([[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]])\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\n    Traceback (most recent call last):\n    ...\n    ValueError: arrays must have same number of dimensions\n    \n    ";
static const char __pyx_k_Apply_a_function_repeatedly_over[] = "Apply a function repeatedly over multiple axes.\n\n    `func` is called as `res = func(a, axis)`, where `axis` is the first\n    element of `axes`.  The result `res` of the function call must have\n    either the same dimensions as `a` or one less dimension.  If `res`\n    has one less dimension than `a`, a dimension is inserted before\n    `axis`.  The call to `func` is then repeated for each axis in `axes`,\n    with `res` as the first argument.\n\n    Parameters\n    ----------\n    func : function\n        This function must take two arguments, `func(a, axis)`.\n    a : array_like\n        Input array.\n    axes : array_like\n        Axes over which `func` is applied; the elements must be integers.\n\n    Returns\n    -------\n    val : ndarray\n        The output array.  The number of dimensions is the same as `a`,\n        but the shape can be different.  This depends on whether `func`\n        changes the shape of its output with respect to its input.\n\n    See Also\n    --------\n    apply_along_axis :\n        Apply a function to 1-D slices of an array along the given axis.\n\n    Examples\n    --------\n    >>> a = np.arange(24).reshape(2,3,4)\n    >>> a\n    array([[[ 0,  1,  2,  3],\n            [ 4,  5,  6,  7],\n            [ 8,  9, 10, 11]],\n           [[12, 13, 14, 15],\n            [16, 17, 18, 19],\n            [20, 21, 22, 23]]])\n\n    Sum over axes 0 and 2. The result has same number of dimensions\n    as the original array:\n\n    >>> np.apply_over_axes(np.sum, a, [0,2])\n    array([[[ 60],\n            [ 92],\n            [124]]])\n    \n    ";
static const char __pyx_k_Apply_a_function_to_1_D_slices_a[] = "Apply a function to 1-D slices along the given axis.\n\n    Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`\n    is a 1-D slice of `arr` along `axis`.\n\n    Parameters\n    ----------\n    func1d : function\n        This function should accept 1-D arrays. It is applied to 1-D\n        slices of `arr` along the specified axis.\n    axis : integer\n        Axis along which `arr` is sliced.\n    arr : ndarray\n        Input array.\n    args : any\n        Additional arguments to `func1d`.\n\n    Returns\n    -------\n    outarr : ndarray\n        The output array. The shape of `outarr` is identical to the shape of\n        `arr`, except along the `axis` dimension, where the length of `outarr`\n        is equal to the size of the return value of `func1d`.  If `func1d`\n        returns a scalar `outarr` will have one fewer dimensions than `arr`.\n\n    See Also\n    --------\n    apply_over_axes : Apply a function repeatedly over multiple axes.\n\n    Examples\n    --------\n    >>> def my_func(a):\n    ...     '''Average first and last element of a 1-D array'''\n    ...     return (a[0] + a[-1]) * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(my_func, 0, b)\n    array([ 4.,  5.,  6.])\n    >>> np.apply_along_axis(my_func, 1, b)\n    array([ 2.,  5.,  8.])\n\n    For a function that doesn't return a scalar, the number of dimensions in\n    `outarr` is the same as `arr`.\n\n    >>> def new_func(a):\n    ...     '''Divide elements of a by 2.'''\n    ...     return a * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(new_func, 0, b)\n    array([[ 0.5,  1. ,  1.5],\n           [ 2. ,  2.5,  3. ],\n           [ 3.5,  4. ,  4.5]])\n    \n    ";
static const char __pyx_k_Broadcast_any_number_of_arrays_a[] = "Broadcast any number of arrays against each other.\n\n    Parameters\n    ----------\n    `*args` : array_likes\n        The arrays to broadcast.\n\n    Returns\n    -------\n    broadcasted : list of arrays\n        These arrays are views on the original arrays.  They are typically\n        not contiguous.  Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location.  If you\n        need to write to the arrays, make copies first.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> y = np.array([[1],[2],[3]])\n    >>> np.broadcast_arrays(x, y)\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n\n    Here is a useful idiom for getting contiguous copies instead of\n    non-contiguous views.\n\n    >>> map(np.array, np.broadcast_arrays(x, y))\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n    \n    ";
static const char __pyx_k_Build_a_matrix_object_from_a_str[] = "Build a matrix object from a string, nested sequence, or array.\n\n    Parameters\n    ----------\n    obj : str or array_like\n        Input data.  Names of variables in the current scope may be\n        referenced, even if `obj` is a string.\n\n    Returns\n    -------\n    out : matrix\n        Returns a matrix object, which is a specialized 2-D array.\n\n    See Also\n    --------\n    matrix\n\n    Examples\n    --------\n    >>> A = np.mat('1 1; 1 1')\n    >>> B = np.mat('2 2; 2 2')\n    >>> C = np.mat('3 4; 5 6')\n    >>> D = np.mat('7 8; 9 0')\n\n    All the following expressions construct the same block matrix:\n\n    >>> np.bmat([[A, B], [C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat('A,B; C,D')\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    \n    ";
static const char __pyx_k_Calculate_the_n_th_order_discret[] = "Calculate the n-th order discrete difference along given axis.\n\n    The first order difference is given by ``out[n] = a[n+1] - a[n]`` along\n    the given axis, higher order differences are calculated by using `diff`\n    recursively.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n    n : int, optional\n        The number of times values are differenced.\n    axis : int, optional\n        The axis along which the difference is taken, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        The `n` order differences. The shape of the output is the same as `a`\n        except along `axis` where the dimension is smaller by `n`.\n\n    See Also\n    --------\n    gradient, ediff1d\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.diff(x)\n    array([ 1,  2,  3, -7])\n    >>> np.diff(x, n=2)\n    array([  1,   1, -10])\n\n    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n    >>> np.diff(x)\n    array([[2, 3, 4],\n           [5, 1, 2]])\n    >>> np.diff(x, axis=0)\n    array([[-1,  2,  0, -2]])\n    \n    ";
static const char __pyx_k_Change_elements_of_an_array_base[] = "Change elements of an array based on conditional and input values.\n\n    Similar to ``np.putmask(arr, mask, vals)``, the difference is that `place`\n    uses the first N elements of `vals`, where N is the number of True values\n    in `mask`, while `putmask` uses the elements where `mask` is True.\n\n    Note that `extract` does the exact opposite of `place`.\n\n    Parameters\n    ----------\n    arr : array_like\n        Array to put data into.\n    mask : array_like\n        Boolean mask array. Must have the same size as `a`.\n    vals : 1-D sequence\n        Values to put into `a`. Only the first N elements are used, where\n        N is the number of True values in `mask`. If `vals` is smaller\n        than N it will be repeated.\n\n    See Also\n    --------\n    putmask, put, take, extract\n\n    Examples\n    --------\n    >>> arr = np.arange(6).reshape(2, 3)\n    >>> np.place(arr, arr>2, [44, 55])\n    >>> arr\n    array([[ 0,  1,  2],\n           [44, 55, 44]])\n    \n    ";
static const char __pyx_k_Check_whether_or_not_an_object_c[] = "Check whether or not an object can be iterated over.\n\n    Parameters\n    ----------\n    y : object\n      Input object.\n\n    Returns\n    -------\n    b : {0, 1}\n      Return 1 if the object has an iterator method or is a sequence,\n      and 0 otherwise.\n\n\n    Examples\n    --------\n    >>> np.iterable([1, 2, 3])\n    1\n    >>> np.iterable(2)\n    0\n    \n    ";
static const char __pyx_k_Compute_tensor_dot_product_along[] = "Compute tensor dot product along specified axes for arrays >= 1-D.\n\n    Given two tensors (arrays of dimension greater than or equal to one),\n    ``a`` and ``b``, and an array_like object containing two array_like\n    objects, ``(a_axes, b_axes)``, sum the products of ``a``'s and ``b``'s\n    elements (components) over the axes specified by ``a_axes`` and\n    ``b_axes``. The third argument can be a single non-negative\n    integer_like scalar, ``N``; if it is such, then the last ``N``\n    dimensions of ``a`` and the first ``N`` dimensions of ``b`` are summed\n    over.\n\n    Parameters\n    ----------\n    a, b : array_like, len(shape) >= 1\n        Tensors to \"dot\".\n\n    axes : variable type\n\n    * integer_like scalar\n      Number of axes to sum over (applies to both arrays); or\n\n    * array_like, shape = (2,), both elements array_like\n      Axes to be summed over, first sequence applying to ``a``, second\n      to ``b``.\n\n    See Also\n    --------\n    dot, einsum\n\n    Notes\n    -----\n    When there is more than one axis to sum over - and they are not the last\n    (first) axes of ``a`` (``b``) - the argument ``axes`` should consist of\n    two sequences of the same length, with the first axis to sum over given\n    first in both sequences, the second axis second, and so forth.\n\n    Examples\n    --------\n    A \"traditional\" example:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n    >>> c.shape\n    (5, 2)\n    >>> c\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> # A slower but equivalent way of computing the same...\n    >>> d = np.zeros((5,2))\n    >>> for i in range(5):\n    ...   for j in range(2):\n    ...     for k in range(3):\n    ...       for n in range(4):\n    ...         d[i,j] += a[k,n,i] * b[n,k,j]\n    >>> c == d""\n    array([[ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True]], dtype=bool)\n\n    An extended example taking advantage of the overloading of + and \\*:\n\n    >>> a = np.array(range(1, 9))\n    >>> a.shape = (2, 2, 2)\n    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n    >>> A.shape = (2, 2)\n    >>> a; A\n    array([[[1, 2],\n            [3, 4]],\n           [[5, 6],\n            [7, 8]]])\n    array([[a, b],\n           [c, d]], dtype=object)\n\n    >>> np.tensordot(a, A) # third argument default is 2\n    array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, 1)\n    array([[[acc, bdd],\n            [aaacccc, bbbdddd]],\n           [[aaaaacccccc, bbbbbdddddd],\n            [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, 0) # \"Left for reader\" (result too long to incl.)\n    array([[[[[a, b],\n              [c, d]],\n              ...\n\n    >>> np.tensordot(a, A, (0, 1))\n    array([[[abbbbb, cddddd],\n            [aabbbbbb, ccdddddd]],\n           [[aaabbbbbbb, cccddddddd],\n            [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, (2, 1))\n    array([[[abb, cdd],\n            [aaabbbb, cccdddd]],\n           [[aaaaabbbbbb, cccccdddddd],\n            [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, ((0, 1), (0, 1)))\n    array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, ((2, 1), (1, 0)))\n    array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)\n    \n    ";
static const char __pyx_k_Compute_the_arithmetic_mean_alon[] = "Compute the arithmetic mean along the specified axis.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the means are computed. The default is to compute\n        the mean of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.\n        See `doc.ufuncs` for details.\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n        If `out=None`, returns a new array containing the mean values,\n        otherwise a reference to the output array is returned.\n\n    See Also\n    --------\n    average : Weighted average\n\n    Notes\n    -----\n    The arithmetic mean is the sum of the elements along the axis divided\n    by the number of elements.\n\n    Note that for floating-point input, the mean is computed using the\n    same precision the input has.  Depending on the input data, this can\n    cause the results to be inaccurate, especially for `float32` (see\n    example below).  Specifying a higher-precision accumulator using the\n    `dtype` keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.mean(a)\n    2.5\n    >>> np.mean(a, axis=0)\n    array([ 2.,  3.])\n    >>> np.mean(a, axis=1)\n    ""array([ 1.5,  3.5])\n\n    In single precision, `mean` can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.mean(a)\n    0.546875\n\n    Computing the mean in float64 is more accurate:\n\n    >>> np.mean(a, dtype=np.float64)\n    0.55000000074505806\n    \n    ";
static const char __pyx_k_Compute_the_bi_dimensional_histo[] = "Compute the bi-dimensional histogram of two data samples.\n\n    Parameters\n    ----------\n    x : array_like, shape(N,)\n        A sequence of values to be histogrammed along the first dimension.\n    y : array_like, shape(M,)\n        A sequence of values to be histogrammed along the second dimension.\n    bins : int or [int, int] or array_like or [array, array], optional\n        The bin specification:\n\n          * If int, the number of bins for the two dimensions (nx=ny=bins).\n          * If [int, int], the number of bins in each dimension (nx, ny = bins).\n          * If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).\n          * If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).\n\n    range : array_like, shape(2,2), optional\n        The leftmost and rightmost edges of the bins along each dimension\n        (if not specified explicitly in the `bins` parameters):\n        ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range\n        will be considered outliers and not tallied in the histogram.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, i.e. the bin count divided by the bin area.\n    weights : array_like, shape(N,), optional\n        An array of values ``w_i`` weighing each sample ``(x_i, y_i)``. Weights\n        are normalized to 1 if `normed` is True. If `normed` is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray, shape(nx, ny)\n        The bi-dimensional histogram of samples `x` and `y`. Values in `x`\n        are histogrammed along the first dimension and values in `y` are\n        histogrammed along the second dimension.\n    xedges : ndarray, shape(nx,)\n        The bin edges along the first dimension.\n    yedges : ndarray, shape(ny,)\n        The bin e""dges along the second dimension.\n\n    See Also\n    --------\n    histogram: 1D histogram\n    histogramdd: Multidimensional histogram\n\n    Notes\n    -----\n    When `normed` is True, then the returned histogram is the sample density,\n    defined such that:\n\n    .. math::\n      \\sum_{i=0}^{nx-1} \\sum_{j=0}^{ny-1} H_{i,j} \\Delta x_i \\Delta y_j = 1\n\n    where `H` is the histogram array and :math:`\\Delta x_i \\Delta y_i`\n    the area of bin `{i,j}`.\n\n    Please note that the histogram does not follow the Cartesian convention\n    where `x` values are on the abcissa and `y` values on the ordinate axis.\n    Rather, `x` is histogrammed along the first dimension of the array\n    (vertical), and `y` along the second dimension of the array (horizontal).\n    This ensures compatibility with `histogramdd`.\n\n    Examples\n    --------\n    >>> x, y = np.random.randn(2, 100)\n    >>> H, xedges, yedges = np.histogram2d(x, y, bins=(5, 8))\n    >>> H.shape, xedges.shape, yedges.shape\n    ((5, 8), (6,), (9,))\n\n    We can now use the Matplotlib to visualize this 2-dimensional histogram:\n\n    >>> extent = [yedges[0], yedges[-1], xedges[-1], xedges[0]]\n    >>> import matplotlib.pyplot as plt\n    >>> plt.imshow(H, extent=extent, interpolation='nearest')\n    <matplotlib.image.AxesImage object at ...>\n    >>> plt.colorbar()\n    <matplotlib.colorbar.Colorbar instance at ...>\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Compute_the_future_value_Given_a[] = "Compute the future value.\n\n    Given:\n     * a present value, `pv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value at the end of the `nper` periods\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pmt : scalar or array_like of shape(M, )\n        Payment\n    pv : scalar or array_like of shape(M, )\n        Present value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Future values.  If all input is scalar, returns a scalar float.  If\n        any input is array_like, returns future values for each input element.\n        If multiple inputs are array_like, they all must have the same shape.\n\n    Notes\n    -----\n    The future value is computed by solving the equation::\n\n     fv +\n     pv*(1+rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n     fv + pv + pmt * nper == 0\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Example""s\n    --------\n    What is the future value after 10 years of saving $100 now, with\n    an additional monthly savings of $100.  Assume the interest rate is\n    5% (annually) compounded monthly?\n\n    >>> np.fv(0.05/12, 10*12, -100, -100)\n    15692.928894335748\n\n    By convention, the negative sign represents cash flow out (i.e. money not\n    available today).  Thus, saving $100 a month at 5% annual interest leads\n    to $15,692.93 available to spend in 10 years.\n\n    If any input is array_like, returns an array of equal shape.  Let's\n    compare different interest rates from the example above.\n\n    >>> a = np.array((0.05, 0.06, 0.07))/12\n    >>> np.fv(a, 10*12, -100, -100)\n    array([ 15692.92889434,  16569.87435405,  17509.44688102])\n    \n    ";
static const char __pyx_k_Compute_the_histogram_of_a_set_o[] = "Compute the histogram of a set of data.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data. The histogram is computed over the flattened array.\n    bins : int or sequence of scalars, optional\n        If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a sequence,\n        it defines the bin edges, including the rightmost edge, allowing\n        for non-uniform bin widths.\n    range : (float, float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored.\n    normed : bool, optional\n        This keyword is deprecated in Numpy 1.6 due to confusing/buggy\n        behavior. It will be removed in Numpy 2.0. Use the density keyword\n        instead.\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that this latter behavior is\n        known to be buggy with unequal bin widths; use `density` instead.\n    weights : array_like, optional\n        An array of weights, of the same shape as `a`.  Each value in `a`\n        only contributes its associated weight towards the bin count\n        (instead of 1).  If `normed` is True, the weights are normalized,\n        so that the integral of the density over the range remains 1\n    density : bool, optional\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that the sum of the\n        histogram values will not be equal to 1 unless bins of unity\n        width are chosen; it is not a probability *mass* function.\n        Overr""ides the `normed` keyword if given.\n\n    Returns\n    -------\n    hist : array\n        The values of the histogram. See `normed` and `weights` for a\n        description of the possible semantics.\n    bin_edges : array of dtype float\n        Return the bin edges ``(length(hist)+1)``.\n\n\n    See Also\n    --------\n    histogramdd, bincount, searchsorted, digitize\n\n    Notes\n    -----\n    All but the last (righthand-most) bin is half-open.  In other words, if\n    `bins` is::\n\n      [1, 2, 3, 4]\n\n    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and the\n    second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which *includes*\n    4.\n\n    Examples\n    --------\n    >>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n    (array([0, 2, 1]), array([0, 1, 2, 3]))\n    >>> np.histogram(np.arange(4), bins=np.arange(5), density=True)\n    (array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))\n    >>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n    (array([1, 4, 1]), array([0, 1, 2, 3]))\n\n    >>> a = np.arange(5)\n    >>> hist, bin_edges = np.histogram(a, density=True)\n    >>> hist\n    array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])\n    >>> hist.sum()\n    2.4999999999999996\n    >>> np.sum(hist*np.diff(bin_edges))\n    1.0\n    \n    ";
static const char __pyx_k_Compute_the_median_along_the_spe[] = "Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : {None, int}, optional\n        Axis along which the medians are computed. The default (axis=None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : {False, True}, optional\n       If True, then allow use of memory of input array (a) for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. Note that, if `overwrite_input` is True and the input\n       is not already an ndarray, an error will be raised.\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, percentile\n\n    Notes\n    -----\n    Given a vector V of length N, the median of V is the middle value of\n    a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is\n    odd.  When N is even, it is the average of the two middle values of\n    ``V_sorted``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])""\n    >>> np.median(a)\n    3.5\n    >>> np.median(a, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.median(a, axis=1)\n    array([ 7.,  2.])\n    >>> m = np.median(a, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.median(a, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n    >>> b = a.copy()\n    >>> np.median(b, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.median(b, axis=None, overwrite_input=True)\n    3.5\n    >>> assert not np.all(a==b)\n    \n    ";
static const char __pyx_k_Compute_the_multidimensional_his[] = "Compute the multidimensional histogram of some data.\n\n    Parameters\n    ----------\n    sample : array_like\n        The data to be histogrammed. It must be an (N,D) array or data\n        that can be converted to such. The rows of the resulting array\n        are the coordinates of points in a D dimensional polytope.\n    bins : sequence or int, optional\n        The bin specification:\n\n        * A sequence of arrays describing the bin edges along each dimension.\n        * The number of bins for each dimension (nx, ny, ... =bins)\n        * The number of bins for all dimensions (nx=ny=...=bins).\n\n    range : sequence, optional\n        A sequence of lower and upper bin edges to be used if the edges are\n        not given explicitely in `bins`. Defaults to the minimum and maximum\n        values along each dimension.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, ie, the bin count divided by the bin hypervolume.\n    weights : array_like (N,), optional\n        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.\n        Weights are normalized to 1 if normed is True. If normed is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray\n        The multidimensional histogram of sample x. See normed and weights for\n        the different possible semantics.\n    edges : list\n        A list of D arrays describing the bin edges for each dimension.\n\n    See Also\n    --------\n    histogram: 1-D histogram\n    histogram2d: 2-D histogram\n\n    Examples\n    --------\n    >>> r = np.random.randn(100,3)\n    >>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n    >>> H.shape, edges[0].size, edges[1].size, edges[2].size\n    ((5, 8, 4), 6, 9, 5)\n    \n    ";
static const char __pyx_k_Compute_the_number_of_periodic_p[] = "Compute the number of periodic payments.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Notes\n    -----\n    The number of periods ``nper`` is computed by solving the equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0\n\n    but if ``rate = 0`` then::\n\n     fv + pv + pmt*nper = 0\n\n    Examples\n    --------\n    If you only had $150/month to pay towards the loan, how long would it take\n    to pay-off a loan of $8,000 at 7% annual interest?\n\n    >>> np.nper(0.07/12, -150, 8000)\n    64.073348770661852\n\n    So, over 64 months would be required to pay off the loan.\n\n    The same analysis could be done with several different interest rates\n    and/or payments and/or total amounts to produce an entire table.\n\n    >>> np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n    ...                    -150   : -99     : 50    ,\n    ...                    8000   : 9001    : 1000]))\n    array([[[  64.07334877,   74.06368256],\n            [ 108.07548412,  127.99022654]],\n           [[  66.12443902,   76.87897353],\n            [ 114.70165583,  137.90124779]]])\n    \n    ";
static const char __pyx_k_Compute_the_outer_product_of_two[] = "Compute the outer product of two vectors.\n\n    Given two vectors, ``a = [a0, a1, ..., aM]`` and\n    ``b = [b0, b1, ..., bN]``,\n    the outer product [1]_ is::\n\n      [[a0*b0  a0*b1 ... a0*bN ]\n       [a1*b0    .\n       [ ...          .\n       [aM*b0            aM*bN ]]\n\n    Parameters\n    ----------\n    a, b : array_like, shape (M,), (N,)\n        First and second input vectors.  Inputs are flattened if they\n        are not already 1-dimensional.\n\n    Returns\n    -------\n    out : ndarray, shape (M, N)\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner, einsum\n\n    References\n    ----------\n    .. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd\n             ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n             pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.]])\n    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n    >>> im\n    array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],\n           [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],\n           [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n           [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],\n           [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])\n    >>> grid = rl + im\n    >>> grid\n    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n    An example using a \"vector\" of letters:\n\n    >>> x = np.array(['a', 'b', 'c'], dtype=object)\n    >>> np.""outer(x, [1, 2, 3])\n    array([[a, aa, aaa],\n           [b, bb, bbb],\n           [c, cc, ccc]], dtype=object)\n    \n    ";
static const char __pyx_k_Compute_the_payment_against_loan[] = "Compute the payment against loan principal plus interest.\n\n    Given:\n     * a present value, `pv` (e.g., an amount borrowed)\n     * a future value, `fv` (e.g., 0)\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * and (optional) specification of whether payment is made\n       at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the (fixed) periodic payment.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like (optional)\n        Future value (default = 0)\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray\n        Payment against loan plus interest.  If all input is scalar, returns a\n        scalar float.  If any input is array_like, returns payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    Notes\n    -----\n    The payment is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n      fv + pv + pmt * nper == 0\n\n    for ``pmt``.\n\n    Note that computing a monthly mortgage payment is only\n    one use for this function.  For example, pmt returns the\n    periodic deposit one must make to achieve a specified\n    future balance given an initial deposit, a fixed,\n    periodically compounded interest rate, and the total\n    number of periods.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) F""ormat - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php\n       ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the monthly payment needed to pay off a $200,000 loan in 15\n    years at an annual interest rate of 7.5%?\n\n    >>> np.pmt(0.075/12, 12*15, 200000)\n    -1854.0247200054619\n\n    In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained\n    today, a monthly payment of $1,854.02 would be required.  Note that this\n    example illustrates usage of `fv` having a default value of 0.\n    \n    ";
static const char __pyx_k_Compute_the_qth_percentile_of_th[] = "Compute the qth percentile of the data along the specified axis.\n\n    Returns the qth percentile of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    q : float in range of [0,100] (or sequence of floats)\n        Percentile to compute which must be between 0 and 100 inclusive.\n    axis : int, optional\n        Axis along which the percentiles are computed. The default (None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n       If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted.\n       Default is False. Note that, if `overwrite_input` is True and the\n       input is not already an array, an error will be raised.\n\n    Returns\n    -------\n    pcntile : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, median\n\n    Notes\n    -----\n    Given a vector V of length N, the qth percentile of V is the qth ranked\n    value in a sorted copy of V.  A weighted average of the two nearest\n    neighbors is used if the normalized ranking does not match q exactly.\n    The same as the med""ian if ``q=0.5``, the same as the minimum if ``q=0``\n    and the same as the maximum if ``q=1``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.percentile(a, 50)\n    3.5\n    >>> np.percentile(a, 0.5, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.percentile(a, 50, axis=1)\n    array([ 7.,  2.])\n\n    >>> m = np.percentile(a, 50, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.percentile(a, 50, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=None, overwrite_input=True)\n    3.5\n    \n    ";
static const char __pyx_k_Compute_the_standard_deviation_a[] = "Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the array elements. The standard deviation is computed for the\n    flattened array by default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Calculate the standard deviation of these values.\n    axis : int, optional\n        Axis along which the standard deviation is computed. The default is\n        to compute the standard deviation of the flattened array.\n    dtype : dtype, optional\n        Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it is\n        the same as the array type.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the calculated\n        values) will be cast if necessary.\n    ddof : int, optional\n        Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of elements.\n        By default `ddof` is zero.\n\n    Returns\n    -------\n    standard_deviation : ndarray, see dtype parameter above.\n        If `out` is None, return a new array containing the standard deviation,\n        otherwise return a reference to the output array.\n\n    See Also\n    --------\n    var, mean\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The standard deviation is the square root of the average of the squared\n    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.\n\n    The average squared deviation is normally calculated as ``x.sum() / N``, where\n    ``N = len(x)``.  If, however, `ddof` is specified, the divisor ``N - ddof``\n    is used instead. In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of t""he variance of the infinite population. ``ddof=0``\n    provides a maximum likelihood estimate of the variance for normally\n    distributed variables. The standard deviation computed in this function\n    is the square root of the estimated variance, so even with ``ddof=1``, it\n    will not be an unbiased estimate of the standard deviation per se.\n\n    Note that, for complex numbers, `std` takes the absolute\n    value before squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the *std* is computed using the same\n    precision the input has. Depending on the input data, this can cause\n    the results to be inaccurate, especially for float32 (see example below).\n    Specifying a higher-accuracy accumulator using the `dtype` keyword can\n    alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.std(a)\n    1.1180339887498949\n    >>> np.std(a, axis=0)\n    array([ 1.,  1.])\n    >>> np.std(a, axis=1)\n    array([ 0.5,  0.5])\n\n    In single precision, std() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.std(a)\n    0.45172946707416706\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.std(a, dtype=np.float64)\n    0.44999999925552653\n    \n    ";
static const char __pyx_k_Compute_the_variance_along_the_s[] = "Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose variance is desired.  If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the variance is computed.  The default is to compute\n        the variance of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the variance.  For arrays of integer type\n        the default is `float32`; for arrays of float types it is the same as\n        the array type.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary.\n    ddof : int, optional\n        \"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero.\n\n    Returns\n    -------\n    variance : ndarray, see dtype parameter above\n        If ``out=None``, returns a new array containing the variance;\n        otherwise, a reference to the output array is returned.\n\n    See Also\n    --------\n    std : Standard deviation\n    mean : Average\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The variance is the average of the squared deviations from the mean,\n    i.e.,  ``var = mean(abs(x - x.mean())**2)``.\n\n    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.\n    If, however, `ddof` is specified, the divisor ``N - ddof`` is used\n    instead.  In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of the variance of a hypothetical infinite population.\n    ""``ddof=0`` provides a maximum likelihood estimate of the variance for\n    normally distributed variables.\n\n    Note that for complex numbers, the absolute value is taken before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the variance is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32` (see example\n    below).  Specifying a higher-accuracy accumulator using the ``dtype``\n    keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2],[3,4]])\n    >>> np.var(a)\n    1.25\n    >>> np.var(a,0)\n    array([ 1.,  1.])\n    >>> np.var(a,1)\n    array([ 0.25,  0.25])\n\n    In single precision, var() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.var(a)\n    0.20405951142311096\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.var(a, dtype=np.float64)\n    0.20249999932997387\n    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n    0.20250000000000001\n    \n    ";
static const char __pyx_k_Compute_the_weighted_average_alo[] = "Compute the weighted average along the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing data to be averaged. If `a` is not an array, a\n        conversion is attempted.\n    axis : int, optional\n        Axis along which to average `a`. If `None`, averaging is done over\n        the flattened array.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n    returned : bool, optional\n        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n        is returned, otherwise only the average is returned.\n        If `weights=None`, `sum_of_weights` is equivalent to the number of\n        elements over which the average is taken.\n\n\n    Returns\n    -------\n    average, [sum_of_weights] : {array_type, double}\n        Return the average along the specified axis. When returned is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. The return type is `Float`\n        if `a` is of integer type, otherwise it is of the same type as `a`.\n        `sum_of_weights` is of the same type as `average`.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When the length of 1D `weights` is not the same as the shape of `a`\n        along axis.\n\n    See Also\n    --------\n    mean\n\n    ma.average : average for masked arrays\n\n    Examples\n    --------\n    >>> data = range(1,5)\n    >>> data\n    [1, 2, 3, 4""]\n    >>> np.average(data)\n    2.5\n    >>> np.average(range(1,11), weights=range(10,0,-1))\n    4.0\n\n    >>> data = np.arange(6).reshape((3,2))\n    >>> data\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> np.average(data, axis=1, weights=[1./4, 3./4])\n    array([ 0.75,  2.75,  4.75])\n    >>> np.average(data, weights=[1./4, 3./4])\n    Traceback (most recent call last):\n    ...\n    TypeError: Axis must be specified when shapes of a and weights differ.\n    \n    ";
static const char __pyx_k_Construct_an_array_from_a_text_f[] = "Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.\n\n    Parameters\n    ----------\n    file : str or file\n        File name or file object to read.\n    regexp : str or regexp\n        Regular expression used to parse the file.\n        Groups in the regular expression correspond to fields in the dtype.\n    dtype : dtype or list of dtypes\n        Dtype for the structured array.\n\n    Returns\n    -------\n    output : ndarray\n        The output array, containing the part of the content of `file` that\n        was matched by `regexp`. `output` is always a structured array.\n\n    Raises\n    ------\n    TypeError\n        When `dtype` is not a valid dtype for a structured array.\n\n    See Also\n    --------\n    fromstring, loadtxt\n\n    Notes\n    -----\n    Dtypes for structured arrays can be specified in several forms, but all\n    forms specify at least the data type and field name. For details see\n    `doc.structured_arrays`.\n\n    Examples\n    --------\n    >>> f = open('test.dat', 'w')\n    >>> f.write(\"1312 foo\n1534  bar\n444   qux\")\n    >>> f.close()\n\n    >>> regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n    >>> output = np.fromregex('test.dat', regexp,\n    ...                       [('num', np.int64), ('key', 'S3')])\n    >>> output\n    array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],\n          dtype=[('num', '<i8'), ('key', '|S3')])\n    >>> output['num']\n    array([1312, 1534,  444], dtype=int64)\n    \n    ";
static const char __pyx_k_Construct_an_array_from_an_index[] = "Construct an array from an index array and a set of arrays to choose from.\n\n    First of all, if confused or uncertain, definitely look at the Examples -\n    in its full generality, this function is less simple than it might\n    seem from the following code description (below ndi =\n    `numpy.lib.index_tricks`):\n\n    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.\n\n    But this omits some subtleties.  Here is a fully general summary:\n\n    Given an \"index\" array (`a`) of integers and a sequence of `n` arrays\n    (`choices`), `a` and each choice array are first broadcast, as necessary,\n    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =\n    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``\n    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as\n    follows:\n\n    * if ``mode=raise`` (the default), then, first of all, each element of\n      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that\n      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position\n      in `Ba` - then the value at the same position in the new array is the\n      value in `Bchoices[i]` at that same position;\n\n    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; modular arithmetic is used to map integers outside the range\n      `[0, n-1]` back into that range; and then the new array is constructed\n      as above;\n\n    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; negative integers are mapped to 0; values greater than `n-1`\n      are mapped to `n-1`; and then the new array is constructed as above.\n\n    Parameters\n    ----------\n    a : int array\n        This array must contain integers in `[0, n-1]`, where `n` is the number\n        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any\n        integers are permissible.\n    choices : sequence of arrays""\n        Choice arrays. `a` and all of the choices must be broadcastable to the\n        same shape.  If `choices` is itself an array (not recommended), then\n        its outermost dimension (i.e., the one corresponding to\n        ``choices.shape[0]``) is taken as defining the \"sequence\".\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise' (default), 'wrap', 'clip'}, optional\n        Specifies how indices outside `[0, n-1]` will be treated:\n\n          * 'raise' : an exception is raised\n          * 'wrap' : value becomes value mod `n`\n          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1\n\n    Returns\n    -------\n    merged_array : array\n        The merged result.\n\n    Raises\n    ------\n    ValueError: shape mismatch\n        If `a` and each choice array are not all broadcastable to the same\n        shape.\n\n    See Also\n    --------\n    ndarray.choose : equivalent method\n\n    Notes\n    -----\n    To reduce the chance of misinterpretation, even though the following\n    \"abuse\" is nominally supported, `choices` should neither be, nor be\n    thought of as, a single array, i.e., the outermost sequence-like container\n    should be either a list or a tuple.\n\n    Examples\n    --------\n\n    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n    ...   [20, 21, 22, 23], [30, 31, 32, 33]]\n    >>> np.choose([2, 3, 1, 0], choices\n    ... # the first element of the result will be the first element of the\n    ... # third (2+1) \"array\" in choices, namely, 20; the second element\n    ... # will be the second element of the fourth (3+1) choice array, i.e.,\n    ... # 31, etc.\n    ... )\n    array([20, 31, 12,  3])\n    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\n    array([20, 31, 12,  3])\n    >>> # because there are 4 choice arrays\n    >>> np.choose([2, 4, 1, 0], choices, m""ode='wrap') # 4 goes to (4 mod 4)\n    array([20,  1, 12,  3])\n    >>> # i.e., 0\n\n    A couple examples illustrating how choose broadcasts:\n\n    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    >>> choices = [-10, 10]\n    >>> np.choose(a, choices)\n    array([[ 10, -10,  10],\n           [-10,  10, -10],\n           [ 10, -10,  10]])\n\n    >>> # With thanks to Anne Archibald\n    >>> a = np.array([0, 1]).reshape((2,1,1))\n    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))\n    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\n    array([[[ 1,  1,  1,  1,  1],\n            [ 2,  2,  2,  2,  2],\n            [ 3,  3,  3,  3,  3]],\n           [[-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5]]])\n    \n    ";
static const char __pyx_k_Construct_an_open_mesh_from_mult[] = "Construct an open mesh from multiple sequences.\n\n    This function takes N 1-D sequences and returns N outputs with N\n    dimensions each, such that the shape is 1 in all but one dimension\n    and the dimension with the non-unit shape value cycles through all\n    N dimensions.\n\n    Using `ix_` one can quickly construct index arrays that will index\n    the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array\n    ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.\n\n    Parameters\n    ----------\n    args : 1-D sequences\n\n    Returns\n    -------\n    out : tuple of ndarrays\n        N arrays with N dimensions each, with N the number of input\n        sequences. Together these arrays form an open mesh.\n\n    See Also\n    --------\n    ogrid, mgrid, meshgrid\n\n    Examples\n    --------\n    >>> a = np.arange(10).reshape(2, 5)\n    >>> a\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> ixgrid = np.ix_([0,1], [2,4])\n    >>> ixgrid\n    (array([[0],\n           [1]]), array([[2, 4]]))\n    >>> ixgrid[0].shape, ixgrid[1].shape\n    ((2, 1), (1, 2))\n    >>> a[ixgrid]\n    array([[2, 4],\n           [7, 9]])\n    \n    ";
static const char __pyx_k_Convert_an_array_of_size_1_to_it[] = "Convert an array of size 1 to its scalar equivalent.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array of size 1.\n\n    Returns\n    -------\n    out : scalar\n        Scalar representation of `a`. The input data type is preserved.\n\n    Examples\n    --------\n    >>> np.asscalar(np.array([24]))\n    24\n    \n    ";
static const char __pyx_k_Convert_inputs_to_arrays_with_at[] = "Convert inputs to arrays with at least one dimension.\n\n    Scalar inputs are converted to 1-dimensional arrays, whilst\n    higher-dimensional inputs are preserved.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more input arrays.\n\n    Returns\n    -------\n    ret : ndarray\n        An array, or sequence of arrays, each with ``a.ndim >= 1``.\n        Copies are made only if necessary.\n\n    See Also\n    --------\n    atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_1d(1.0)\n    array([ 1.])\n\n    >>> x = np.arange(9.0).reshape(3,3)\n    >>> np.atleast_1d(x)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.],\n           [ 6.,  7.,  8.]])\n    >>> np.atleast_1d(x) is x\n    True\n\n    >>> np.atleast_1d(1, [3, 4])\n    [array([1]), array([3, 4])]\n    \n    ";
static const char __pyx_k_Convert_the_input_to_an_array_ch[] = "Convert the input to an array, checking for NaNs or Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and ndarrays.  Success requires no NaNs or Infs.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray\n        Array interpretation of `a`.  No copy is performed if the input\n        is already an ndarray.  If `a` is a subclass of ndarray, a base\n        class ndarray is returned.\n\n    Raises\n    ------\n    ValueError\n        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\n    See Also\n    --------\n    asarray : Create and array.\n    asanyarray : Similar function which passes through subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array.  If all elements are finite\n    ``asarray_chkfinite`` is identical to ``asarray``.\n\n    >>> a = [1, 2]\n    >>> np.asarray_chkfinite(a)\n    array([1, 2])\n\n    Raises ValueError if array_like contains Nans or Infs.\n\n    >>> a = [1, 2, np.inf]\n    >>> try:\n    ...     np.asarray_chkfinite(a)\n    ... except ValueError:\n    ...     print 'ValueError'\n    ...\n    ValueError\n    \n    ";
static const char __pyx_k_Create_a_two_dimensional_array_w[] = "Create a two-dimensional array with the flattened input as a diagonal.\n\n    Parameters\n    ----------\n    v : array_like\n        Input data, which is flattened and set as the `k`-th\n        diagonal of the output.\n    k : int, optional\n        Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n        a positive (negative) `k` giving the number of the diagonal above\n        (below) the main.\n\n    Returns\n    -------\n    out : ndarray\n        The 2-D output array.\n\n    See Also\n    --------\n    diag : MATLAB work-alike for 1-D and 2-D arrays.\n    diagonal : Return specified diagonals.\n    trace : Sum along diagonals.\n\n    Examples\n    --------\n    >>> np.diagflat([[1,2], [3,4]])\n    array([[1, 0, 0, 0],\n           [0, 2, 0, 0],\n           [0, 0, 3, 0],\n           [0, 0, 0, 4]])\n\n    >>> np.diagflat([1,2], 1)\n    array([[0, 1, 0],\n           [0, 0, 2],\n           [0, 0, 0]])\n    \n    ";
static const char __pyx_k_Cross_correlation_of_two_1_dimen[] = "Cross-correlation of two 1-dimensional sequences.\n\n    This function computes the correlation as generally defined in signal\n    processing texts::\n\n        z[k] = sum_n a[n] * conj(v[n+k])\n\n    with a and v sequences being zero-padded where necessary and conj being\n    the conjugate.\n\n    Parameters\n    ----------\n    a, v : array_like\n        Input sequences.\n    mode : {'valid', 'same', 'full'}, optional\n        Refer to the `convolve` docstring.  Note that the default\n        is `valid`, unlike `convolve`, which uses `full`.\n    old_behavior : bool\n        If True, uses the old behavior from Numeric, (correlate(a,v) == correlate(v,\n        a), and the conjugate is not taken for complex arrays). If False, uses\n        the conventional signal processing definition (see note).\n\n    See Also\n    --------\n    convolve : Discrete, linear convolution of two one-dimensional sequences.\n\n    Examples\n    --------\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5])\n    array([ 3.5])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\n    array([ 2. ,  3.5,  3. ])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\n    array([ 0.5,  2. ,  3.5,  3. ,  0. ])\n    \n    ";
static const char __pyx_k_Determine_if_a_class_is_a_subcla[] = "Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError is one\n    of the arguments is not a class.\n\n    Parameters\n    ----------\n    arg1 : class\n        Input class. True is returned if `arg1` is a subclass of `arg2`.\n    arg2 : class or tuple of classes.\n        Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements.\n\n    Returns\n    -------\n    out : bool\n        Whether `arg1` is a subclass of `arg2` or not.\n\n    See Also\n    --------\n    issubsctype, issubdtype, issctype\n\n    Examples\n    --------\n    >>> np.issubclass_(np.int32, np.int)\n    True\n    >>> np.issubclass_(np.int32, np.float)\n    False\n    \n    ";
static const char __pyx_k_Determine_if_two_arrays_can_shar[] = "Determine if two arrays can share memory\n\n    The memory-bounds of a and b are computed.  If they overlap then\n    this function returns True.  Otherwise, it returns False.\n\n    A return of True does not necessarily mean that the two arrays\n    share any element.  It just means that they *might*.\n\n    Parameters\n    ----------\n    a, b : ndarray\n\n    Returns\n    -------\n    out : bool\n\n    Examples\n    --------\n    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\n    False\n    \n    ";
static const char __pyx_k_Determines_whether_the_given_obj[] = "Determines whether the given object represents a scalar data-type.\n\n    Parameters\n    ----------\n    rep : any\n        If `rep` is an instance of a scalar dtype, True is returned. If not,\n        False is returned.\n\n    Returns\n    -------\n    out : bool\n        Boolean result of check whether `rep` is a scalar dtype.\n\n    See Also\n    --------\n    issubsctype, issubdtype, obj2sctype, sctype2char\n\n    Examples\n    --------\n    >>> np.issctype(np.int32)\n    True\n    >>> np.issctype(list)\n    False\n    >>> np.issctype(1.1)\n    False\n\n    Strings are also a scalar type:\n\n    >>> np.issctype(np.dtype('str'))\n    True\n    \n    ";
static const char __pyx_k_Difference_subtraction_of_two_po[] = "Difference (subtraction) of two polynomials.\n\n    Given two polynomials `a1` and `a2`, returns ``a1 - a2``.\n    `a1` and `a2` can be either array_like sequences of the polynomials'\n    coefficients (including coefficients equal to zero), or `poly1d` objects.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d\n        Minuend and subtrahend polynomials, respectively.\n\n    Returns\n    -------\n    out : ndarray or poly1d\n        Array or `poly1d` object of the difference polynomial's coefficients.\n\n    See Also\n    --------\n    polyval, polydiv, polymul, polyadd\n\n    Examples\n    --------\n    .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\n\n    >>> np.polysub([2, 10, -2], [3, 10, -4])\n    array([-1,  0,  2])\n    \n    ";
static const char __pyx_k_Display_a_message_on_a_device_Pa[] = "Display a message on a device.\n\n    Parameters\n    ----------\n    mesg : str\n        Message to display.\n    device : object\n        Device to write message. If None, defaults to ``sys.stdout`` which is\n        very similar to ``print``. `device` needs to have ``write()`` and\n        ``flush()`` methods.\n    linefeed : bool, optional\n        Option whether to print a line feed or not. Defaults to True.\n\n    Raises\n    ------\n    AttributeError\n        If `device` does not have a ``write()`` or ``flush()`` method.\n\n    Examples\n    --------\n    Besides ``sys.stdout``, a file-like object can also be used as it has\n    both required methods:\n\n    >>> from StringIO import StringIO\n    >>> buf = StringIO()\n    >>> np.disp('\"Display\" in a file', device=buf)\n    >>> buf.getvalue()\n    '\"Display\" in a file\n'\n    \n    ";
static const char __pyx_k_Do_a_keyword_search_on_docstring[] = "Do a keyword search on docstrings.\n\n    A list of of objects that matched the search is displayed,\n    sorted by relevance. All given keywords need to be found in the\n    docstring for it to be returned as a result, but the order does\n    not matter.\n\n    Parameters\n    ----------\n    what : str\n        String containing words to look for.\n    module : str or list, optional\n        Name of module(s) whose docstrings to go through.\n    import_modules : bool, optional\n        Whether to import sub-modules in packages. Default is True.\n    regenerate : bool, optional\n        Whether to re-generate the docstring cache. Default is False.\n    output : file-like, optional\n        File-like object to write the output to. If omitted, use a pager.\n\n    See Also\n    --------\n    source, info\n\n    Notes\n    -----\n    Relevance is determined only roughly, by checking if the keywords occur\n    in the function name, at the start of a docstring, etc.\n\n    Examples\n    --------\n    >>> np.lookfor('binary representation')\n    Search results for 'binary representation'\n    ------------------------------------------\n    numpy.binary_repr\n        Return the binary representation of the input number as a string.\n    numpy.core.setup_common.long_double_representation\n        Given a binary dump as given by GNU od -b, look for long double\n    numpy.base_repr\n        Return a string representation of a number in the given base system.\n    ...\n    \n    ";
static const char __pyx_k_Estimate_a_covariance_matrix_giv[] = "Estimate a covariance matrix, given data.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    Parameters\n    ----------\n    m : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        form as that of `m`.\n    rowvar : int, optional\n        If `rowvar` is non-zero (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : int, optional\n        Default normalization is by ``(N - 1)``, where ``N`` is the number of\n        observations given (unbiased estimate). If `bias` is 1, then\n        normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : int, optional\n        .. versionadded:: 1.5\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n\n    Returns\n    -------\n    out : ndarray\n        The covariance matrix of the variables.\n\n    See Also\n    --------\n    corrcoef : Normalized covariance matrix\n\n    Examples\n    --------\n    Consider two variables, :math:`x_0` and :math:`x_1`, which\n    correlate perfectly, but in opposite directions:\n\n    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T\n   "" >>> x\n    array([[0, 1, 2],\n           [2, 1, 0]])\n\n    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance\n    matrix shows this clearly:\n\n    >>> np.cov(x)\n    array([[ 1., -1.],\n           [-1.,  1.]])\n\n    Note that element :math:`C_{0,1}`, which shows the correlation between\n    :math:`x_0` and :math:`x_1`, is negative.\n\n    Further, note how `x` and `y` are combined:\n\n    >>> x = [-2.1, -1,  4.3]\n    >>> y = [3,  1.1,  0.12]\n    >>> X = np.vstack((x,y))\n    >>> print np.cov(X)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x, y)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x)\n    11.71\n    \n    ";
static const char __pyx_k_Evaluate_a_piecewise_defined_fun[] = "Evaluate a piecewise-defined function.\n\n    Given a set of conditions and corresponding functions, evaluate each\n    function on the input data wherever its condition is true.\n\n    Parameters\n    ----------\n    x : ndarray\n        The input domain.\n    condlist : list of bool arrays\n        Each boolean array corresponds to a function in `funclist`.  Wherever\n        `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n        Each boolean array in `condlist` selects a piece of `x`,\n        and should therefore be of the same shape as `x`.\n\n        The length of `condlist` must correspond to that of `funclist`.\n        If one extra function is given, i.e. if\n        ``len(funclist) - len(condlist) == 1``, then that extra function\n        is the default value, used wherever all conditions are false.\n    funclist : list of callables, f(x,*args,**kw), or scalars\n        Each function is evaluated over `x` wherever its corresponding\n        condition is True.  It should take an array as input and give an array\n        or a scalar value as output.  If, instead of a callable,\n        a scalar is provided then a constant function (``lambda x: scalar``) is\n        assumed.\n    args : tuple, optional\n        Any further arguments given to `piecewise` are passed to the functions\n        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n        each function is called as ``f(x, 1, 'a')``.\n    kw : dict, optional\n        Keyword arguments used in calling `piecewise` are passed to the\n        functions upon execution, i.e., if called\n        ``piecewise(..., ..., lambda=1)``, then each function is called as\n        ``f(x, lambda=1)``.\n\n    Returns\n    -------\n    out : ndarray\n        The output is the same shape and type as x and is found by\n        calling the functions in `funclist` on the appropriate portions of `x`,\n        as defined by the boolean arrays in `condlist`.  Portions not covered\n   ""     by any condition have undefined values.\n\n\n    See Also\n    --------\n    choose, select, where\n\n    Notes\n    -----\n    This is similar to choose or select, except that functions are\n    evaluated on elements of `x` that satisfy the corresponding condition from\n    `condlist`.\n\n    The result is::\n\n            |--\n            |funclist[0](x[condlist[0]])\n      out = |funclist[1](x[condlist[1]])\n            |...\n            |funclist[n2](x[condlist[n2]])\n            |--\n\n    Examples\n    --------\n    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.\n\n    >>> x = np.arange(6) - 2.5\n    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])\n    array([-1., -1., -1.,  1.,  1.,  1.])\n\n    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for\n    ``x >= 0``.\n\n    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])\n    array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n    \n    ";
static const char __pyx_k_Evaluate_a_polynomial_at_specifi[] = "Evaluate a polynomial at specific values.\n\n    If `p` is of length N, this function returns the value:\n\n        ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``\n\n    If `x` is a sequence, then `p(x)` is returned for each element of `x`.\n    If `x` is another polynomial then the composite polynomial `p(x(t))`\n    is returned.\n\n    Parameters\n    ----------\n    p : array_like or poly1d object\n       1D array of polynomial coefficients (including coefficients equal\n       to zero) from highest degree to the constant term, or an\n       instance of poly1d.\n    x : array_like or poly1d object\n       A number, a 1D array of numbers, or an instance of poly1d, \"at\"\n       which to evaluate `p`.\n\n    Returns\n    -------\n    values : ndarray or poly1d\n       If `x` is a poly1d instance, the result is the composition of the two\n       polynomials, i.e., `x` is \"substituted\" in `p` and the simplified\n       result is returned. In addition, the type of `x` - array_like or\n       poly1d - governs the type of the output: `x` array_like => `values`\n       array_like, `x` a poly1d object => `values` is also.\n\n    See Also\n    --------\n    poly1d: A polynomial class.\n\n    Notes\n    -----\n    Horner's scheme [1]_ is used to evaluate the polynomial. Even so,\n    for polynomials of high degree the values may be inaccurate due to\n    rounding errors. Use carefully.\n\n    References\n    ----------\n    .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.\n       trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand\n       Reinhold Co., 1985, pg. 720.\n\n    Examples\n    --------\n    >>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n    76\n    >>> np.polyval([3,0,1], np.poly1d(5))\n    poly1d([ 76.])\n    >>> np.polyval(np.poly1d([3,0,1]), 5)\n    76\n    >>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\n    poly1d([ 76.])\n    \n    ";
static const char __pyx_k_Evenly_round_to_the_given_number[] = "Evenly round to the given number of decimals.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    decimals : int, optional\n        Number of decimal places to round to (default: 0).  If\n        decimals is negative, it specifies the number of positions to\n        the left of the decimal point.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary. See `doc.ufuncs` (Section\n        \"Output arguments\") for details.\n\n    Returns\n    -------\n    rounded_array : ndarray\n        An array of the same type as `a`, containing the rounded values.\n        Unless `out` was specified, a new array is created.  A reference to\n        the result is returned.\n\n        The real and imaginary parts of complex numbers are rounded\n        separately.  The result of rounding a float is a float.\n\n    See Also\n    --------\n    ndarray.round : equivalent method\n\n    ceil, fix, floor, rint, trunc\n\n\n    Notes\n    -----\n    For values exactly halfway between rounded decimal values, Numpy\n    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,\n    -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due\n    to the inexact representation of decimal fractions in the IEEE\n    floating point standard [1]_ and errors introduced when scaling\n    by powers of ten.\n\n    References\n    ----------\n    .. [1] \"Lecture Notes on the Status of  IEEE 754\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n    .. [2] \"How Futile are Mindless Assessments of\n           Roundoff in Floating-Point Computation?\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/Mindless.pdf\n\n    Examples\n    --------\n    >>> np.around([0.37, 1.64])\n    array([ 0.,  2.])\n    >>> np.around([0.37, 1.64], decimals=1)\n    ""array([ 0.4,  1.6])\n    >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\n    array([ 0.,  2.,  2.,  4.,  4.])\n    >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\n    array([ 1,  2,  3, 11])\n    >>> np.around([1,2,3,11], decimals=-1)\n    array([ 0,  0,  0, 10])\n    \n    ";
static const char __pyx_k_Expand_the_shape_of_an_array_Ins[] = "Expand the shape of an array.\n\n    Insert a new axis, corresponding to a given position in the array shape.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int\n        Position (amongst axes) where new axis is to be inserted.\n\n    Returns\n    -------\n    res : ndarray\n        Output array. The number of dimensions is one greater than that of\n        the input array.\n\n    See Also\n    --------\n    doc.indexing, atleast_1d, atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> x = np.array([1,2])\n    >>> x.shape\n    (2,)\n\n    The following is equivalent to ``x[np.newaxis,:]`` or ``x[np.newaxis]``:\n\n    >>> y = np.expand_dims(x, axis=0)\n    >>> y\n    array([[1, 2]])\n    >>> y.shape\n    (1, 2)\n\n    >>> y = np.expand_dims(x, axis=1)  # Equivalent to x[:,newaxis]\n    >>> y\n    array([[1],\n           [2]])\n    >>> y.shape\n    (2, 1)\n\n    Note that some examples may use ``None`` instead of ``np.newaxis``.  These\n    are the same objects:\n\n    >>> np.newaxis is None\n    True\n    \n    ";
static const char __pyx_k_Fill_the_main_diagonal_of_the_gi[] = "Fill the main diagonal of the given array of any dimensionality.\n\n    For an array `a` with ``a.ndim > 2``, the diagonal is the list of\n    locations with indices ``a[i, i, ..., i]`` all identical. This function\n    modifies the input array in-place, it does not return a value.\n\n    Parameters\n    ----------\n    a : array, at least 2-D.\n      Array whose diagonal is to be filled, it gets modified in-place.\n\n    val : scalar\n      Value to be written on the diagonal, its type must be compatible with\n      that of the array a.\n\n    See also\n    --------\n    diag_indices, diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    This functionality can be obtained via `diag_indices`, but internally\n    this version uses a much faster implementation that never constructs the\n    indices and uses simple slicing.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 3), int)\n    >>> np.fill_diagonal(a, 5)\n    >>> a\n    array([[5, 0, 0],\n           [0, 5, 0],\n           [0, 0, 5]])\n\n    The same function can operate on a 4-D array:\n\n    >>> a = np.zeros((3, 3, 3, 3), int)\n    >>> np.fill_diagonal(a, 4)\n\n    We only show a few blocks for clarity:\n\n    >>> a[0, 0]\n    array([[4, 0, 0],\n           [0, 0, 0],\n           [0, 0, 0]])\n    >>> a[1, 1]\n    array([[0, 0, 0],\n           [0, 4, 0],\n           [0, 0, 0]])\n    >>> a[2, 2]\n    array([[0, 0, 0],\n           [0, 0, 0],\n           [0, 0, 4]])\n    \n    ";
static const char __pyx_k_Find_indices_where_elements_shou[] = "Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `a` such that, if the corresponding\n    elements in `v` were inserted before the indices, the order of `a` would\n    be preserved.\n\n    Parameters\n    ----------\n    a : 1-D array_like\n        Input array, sorted in ascending order.\n    v : array_like\n        Values to insert into `a`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.  If\n        'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `a`).\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `v`.\n\n    See Also\n    --------\n    sort : Return a sorted copy of an array.\n    histogram : Produce histogram from 1-D data.\n\n    Notes\n    -----\n    Binary search is used to find the required insertion points.\n\n    As of Numpy 1.4.0 `searchsorted` works with real/complex arrays containing\n    `nan` values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    >>> np.searchsorted([1,2,3,4,5], 3)\n    2\n    >>> np.searchsorted([1,2,3,4,5], 3, side='right')\n    3\n    >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\n    array([0, 5, 1, 2])\n    \n    ";
static const char __pyx_k_Find_the_coefficients_of_a_polyn[] = "Find the coefficients of a polynomial with the given sequence of roots.\n\n    Returns the coefficients of the polynomial whose leading coefficient\n    is one for the given sequence of zeros (multiple roots must be included\n    in the sequence as many times as their multiplicity; see Examples).\n    A square matrix (or array, which will be treated as a matrix) can also\n    be given, in which case the coefficients of the characteristic polynomial\n    of the matrix are returned.\n\n    Parameters\n    ----------\n    seq_of_zeros : array_like, shape (N,) or (N, N)\n        A sequence of polynomial roots, or a square array or matrix object.\n\n    Returns\n    -------\n    c : ndarray\n        1D array of polynomial coefficients from highest to lowest degree:\n\n        ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``\n        where c[0] always equals 1.\n\n    Raises\n    ------\n    ValueError\n        If input is the wrong shape (the input must be a 1-D or square\n        2-D array).\n\n    See Also\n    --------\n    polyval : Evaluate a polynomial at a point.\n    roots : Return the roots of a polynomial.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    Specifying the roots of a polynomial still leaves one degree of\n    freedom, typically represented by an undetermined leading\n    coefficient. [1]_ In the case of this function, that coefficient -\n    the first one in the returned array - is always taken as one. (If\n    for some reason you have one other point, the only automatic way\n    presently to leverage that information is to use ``polyfit``.)\n\n    The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`\n    matrix **A** is given by\n\n        :math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`,\n\n    where **I** is the `n`-by-`n` identity matrix. [2]_\n\n    References\n    ----------\n    .. [1] M. Sullivan and M. Sullivan, III, \"Algebra a""nd Trignometry,\n       Enhanced With Graphing Utilities,\" Prentice-Hall, pg. 318, 1996.\n\n    .. [2] G. Strang, \"Linear Algebra and Its Applications, 2nd Edition,\"\n       Academic Press, pg. 182, 1980.\n\n    Examples\n    --------\n    Given a sequence of a polynomial's zeros:\n\n    >>> np.poly((0, 0, 0)) # Multiple root example\n    array([1, 0, 0, 0])\n    \n    The line above represents z**3 + 0*z**2 + 0*z + 0.\n\n    >>> np.poly((-1./2, 0, 1./2))\n    array([ 1.  ,  0.  , -0.25,  0.  ])\n    \n    The line above represents z**3 - z/4\n\n    >>> np.poly((np.random.random(1.)[0], 0, np.random.random(1.)[0]))\n    array([ 1.        , -0.77086955,  0.08618131,  0.        ]) #random\n\n    Given a square array object:\n\n    >>> P = np.array([[0, 1./3], [-1./2, 0]])\n    >>> np.poly(P)\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Or a square matrix object:\n\n    >>> np.poly(np.matrix(P))\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Note how in all cases the leading coefficient is always 1.\n    \n    ";
static const char __pyx_k_Find_the_indices_of_array_elemen[] = "Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``where(a)`` instead.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n    \n    ";
static const char __pyx_k_Find_the_intersection_of_two_arr[] = "Find the intersection of two arrays.\n\n    Return the sorted, unique values that are in both of the input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    out : ndarray\n        Sorted 1D array of common and unique elements.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\n    array([1, 3])\n    \n    ";
static const char __pyx_k_Find_the_product_of_two_polynomi[] = "Find the product of two polynomials.\n\n    Finds the polynomial resulting from the multiplication of the two input\n    polynomials. Each input must be either a poly1d object or a 1D sequence\n    of polynomial coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The polynomial resulting from the multiplication of the inputs. If\n        either inputs is a poly1d object, then the output is also a poly1d\n        object. Otherwise, it is a 1D array of polynomial coefficients from\n        highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,\n    polyval\n\n    Examples\n    --------\n    >>> np.polymul([1, 2, 3], [9, 5, 1])\n    array([ 9, 23, 38, 17,  3])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2, 3])\n    >>> p2 = np.poly1d([9, 5, 1])\n    >>> print p1\n       2\n    1 x + 2 x + 3\n    >>> print p2\n       2\n    9 x + 5 x + 1\n    >>> print np.polymul(p1, p2)\n       4      3      2\n    9 x + 23 x + 38 x + 17 x + 3\n    \n    ";
static const char __pyx_k_Find_the_set_difference_of_two_a[] = "Find the set difference of two arrays.\n\n    Return the sorted, unique values in `ar1` that are not in `ar2`.\n\n    Parameters\n    ----------\n    ar1 : array_like\n        Input array.\n    ar2 : array_like\n        Input comparison array.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    difference : ndarray\n        Sorted 1D array of values in `ar1` that are not in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4, 1])\n    >>> b = np.array([3, 4, 5, 6])\n    >>> np.setdiff1d(a, b)\n    array([1, 2])\n    \n    ";
static const char __pyx_k_Find_the_set_exclusive_or_of_two[] = "Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    xor : ndarray\n        Sorted 1D array of unique values that are in only one of the input\n        arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4])\n    >>> b = np.array([2, 3, 5, 7, 5])\n    >>> np.setxor1d(a,b)\n    array([1, 4, 5, 7])\n    \n    ";
static const char __pyx_k_Find_the_union_of_two_arrays_Ret[] = "Find the union of two arrays.\n\n    Return the unique, sorted array of values that are in either of the two\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. They are flattened if they are not already 1D.\n\n    Returns\n    -------\n    union : ndarray\n        Unique, sorted union of the input arrays.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.union1d([-1, 0, 1], [-2, 0, 2])\n    array([-2, -1,  0,  1,  2])\n    \n    ";
static const char __pyx_k_Find_the_unique_elements_of_an_a[] = "Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are two optional\n    outputs in addition to the unique elements: the indices of the input array\n    that give the unique values, and the indices of the unique array that\n    reconstruct the input array.\n\n    Parameters\n    ----------\n    ar : array_like\n        Input array. This will be flattened if it is not already 1-D.\n    return_index : bool, optional\n        If True, also return the indices of `ar` that result in the unique\n        array.\n    return_inverse : bool, optional\n        If True, also return the indices of the unique array that can be used\n        to reconstruct `ar`.\n\n    Returns\n    -------\n    unique : ndarray\n        The sorted unique values.\n    unique_indices : ndarray, optional\n        The indices of the unique values in the (flattened) original array.\n        Only provided if `return_index` is True.\n    unique_inverse : ndarray, optional\n        The indices to reconstruct the (flattened) original array from the\n        unique array. Only provided if `return_inverse` is True.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.unique([1, 1, 2, 2, 3, 3])\n    array([1, 2, 3])\n    >>> a = np.array([[1, 1], [2, 3]])\n    >>> np.unique(a)\n    array([1, 2, 3])\n\n    Return the indices of the original array that give the unique values:\n\n    >>> a = np.array(['a', 'b', 'b', 'c', 'a'])\n    >>> u, indices = np.unique(a, return_index=True)\n    >>> u\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n    >>> indices\n    array([0, 1, 3])\n    >>> a[indices]\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n\n    Reconstruct the input array from the unique values:\n\n    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])\n    >>> u, indices = np.unique(a, return_inverse=True"")\n    >>> u\n    array([1, 2, 3, 4, 6])\n    >>> indices\n    array([0, 1, 4, 3, 1, 2, 1])\n    >>> u[indices]\n    array([1, 2, 6, 4, 2, 3, 2])\n    \n    ";
static const char __pyx_k_Flip_array_in_the_left_right_dir[] = "Flip array in the left/right direction.\n\n    Flip the entries in each row in the left/right direction.\n    Columns are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    f : ndarray\n        A view of `m` with the columns reversed.  Since a view\n        is returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    flipud : Flip array in the up/down direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to A[:,::-1]. Does not require the array to be\n    two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.,2.,3.])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.fliplr(A)\n    array([[ 0.,  0.,  1.],\n           [ 0.,  2.,  0.],\n           [ 3.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.fliplr(A)==A[:,::-1,...])\n    True\n    \n    ";
static const char __pyx_k_Flip_array_in_the_up_down_direct[] = "Flip array in the up/down direction.\n\n    Flip the entries in each column in the up/down direction.\n    Rows are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    out : array_like\n        A view of `m` with the rows reversed.  Since a view is\n        returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    fliplr : Flip array in the left/right direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to ``A[::-1,...]``.\n    Does not require the array to be two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.0, 2, 3])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.flipud(A)\n    array([[ 0.,  0.,  3.],\n           [ 0.,  2.,  0.],\n           [ 1.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.flipud(A)==A[::-1,...])\n    True\n\n    >>> np.flipud([1,2])\n    array([2, 1])\n    \n    ";
static const char __pyx_k_Format_string_allocated_too_shor[] = "Format string allocated too short, see comment in numpy.pxd";
static const char __pyx_k_Get_help_information_for_a_funct[] = "Get help information for a function, class, or module.\n\n    Parameters\n    ----------\n    object : object or str, optional\n        Input object or name to get information about. If `object` is a\n        numpy object, its docstring is given. If it is a string, available\n        modules are searched for matching objects.\n        If None, information about `info` itself is returned.\n    maxwidth : int, optional\n        Printing width.\n    output : file like object, optional\n        File like object that the output is written to, default is ``stdout``.\n        The object has to be opened in 'w' or 'a' mode.\n    toplevel : str, optional\n        Start search at this level.\n\n    See Also\n    --------\n    source, lookfor\n\n    Notes\n    -----\n    When used interactively with an object, ``np.info(obj)`` is equivalent to\n    ``help(obj)`` on the Python prompt or ``obj?`` on the IPython prompt.\n\n    Examples\n    --------\n    >>> np.info(np.polyval) # doctest: +SKIP\n       polyval(p, x)\n         Evaluate the polynomial p at x.\n         ...\n\n    When using a string for `object` it is possible to get multiple results.\n\n    >>> np.info('fft') # doctest: +SKIP\n         *** Found in numpy ***\n    Core FFT routines\n    ...\n         *** Found in numpy.fft ***\n     fft(a, n=None, axis=-1)\n    ...\n         *** Repeat reference found in numpy.fft.fftpack ***\n         *** Total of 3 references found. ***\n    \n    ";
static const char __pyx_k_Gives_a_new_shape_to_an_array_wi[] = "Gives a new shape to an array without changing its data.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be reshaped.\n    newshape : int or tuple of ints\n        The new shape should be compatible with the original shape. If\n        an integer, then the result will be a 1-D array of that length.\n        One shape dimension can be -1. In this case, the value is inferred\n        from the length of the array and remaining dimensions.\n    order : {'C', 'F', 'A'}, optional\n        Determines whether the array data should be viewed as in C\n        (row-major) order, FORTRAN (column-major) order, or the C/FORTRAN\n        order should be preserved.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        This will be a new view object if possible; otherwise, it will\n        be a copy.\n\n\n    See Also\n    --------\n    ndarray.reshape : Equivalent method.\n\n    Notes\n    -----\n\n    It is not always possible to change the shape of an array without\n    copying the data. If you want an error to be raise if the data is copied,\n    you should assign the new shape to the shape attribute of the array::\n\n     >>> a = np.zeros((10, 2))\n     # A transpose make the array non-contiguous\n     >>> b = a.T\n     # Taking a view makes it possible to modify the shape without modiying the\n     # initial object.\n     >>> c = b.view()\n     >>> c.shape = (20)\n     AttributeError: incompatible shape for a non-contiguous array\n\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1, 2, 3, 4, 5, 6])\n    >>> np.reshape(a, 6, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    \n    ";
static const char __pyx_k_Indices_of_the_maximum_values_al[] = "Indices of the maximum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed.\n\n    See Also\n    --------\n    ndarray.argmax, argmin\n    amax : The maximum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n\n    Notes\n    -----\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> a = np.arange(6).reshape(2,3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argmax(a)\n    5\n    >>> np.argmax(a, axis=0)\n    array([1, 1, 1])\n    >>> np.argmax(a, axis=1)\n    array([2, 2])\n\n    >>> b = np.arange(6)\n    >>> b[1] = 5\n    >>> b\n    array([0, 5, 2, 3, 4, 5])\n    >>> np.argmax(b) # Only the first occurrence is returned.\n    1\n    \n    ";
static const char __pyx_k_Insert_values_along_the_given_ax[] = "Insert values along the given axis before the given indices.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input array.\n    obj : int, slice or sequence of ints\n        Object that defines the index or indices before which `values` is\n        inserted.\n    values : array_like\n        Values to insert into `arr`. If the type of `values` is different\n        from that of `arr`, `values` is converted to the type of `arr`.\n    axis : int, optional\n        Axis along which to insert `values`.  If `axis` is None then `arr`\n        is flattened first.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` inserted.  Note that `insert`\n        does not occur in-place: a new array is returned. If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    append : Append elements at the end of an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 1], [2, 2], [3, 3]])\n    >>> a\n    array([[1, 1],\n           [2, 2],\n           [3, 3]])\n    >>> np.insert(a, 1, 5)\n    array([1, 5, 1, 2, 2, 3, 3])\n    >>> np.insert(a, 1, 5, axis=1)\n    array([[1, 5, 1],\n           [2, 5, 2],\n           [3, 5, 3]])\n\n    >>> b = a.flatten()\n    >>> b\n    array([1, 1, 2, 2, 3, 3])\n    >>> np.insert(b, [2, 2], [5, 6])\n    array([1, 1, 5, 6, 2, 2, 3, 3])\n\n    >>> np.insert(b, slice(2, 4), [5, 6])\n    array([1, 1, 5, 2, 6, 2, 3, 3])\n\n    >>> np.insert(b, [2, 2], [7.13, False]) # type casting\n    array([1, 1, 7, 0, 2, 2, 3, 3])\n\n    >>> x = np.arange(8).reshape(2, 4)\n    >>> idx = (1, 3)\n    >>> np.insert(x, idx, 999, axis=1)\n    array([[  0, 999,   1,   2, 999,   3],\n           [  4, 999,   5,   6, 999,   7]])\n    \n    ";
static const char __pyx_k_Integrate_along_the_given_axis_u[] = "Integrate along the given axis using the composite trapezoidal rule.\n\n    Integrate `y` (`x`) along given axis.\n\n    Parameters\n    ----------\n    y : array_like\n        Input array to integrate.\n    x : array_like, optional\n        If `x` is None, then spacing between all `y` elements is `dx`.\n    dx : scalar, optional\n        If `x` is None, spacing given by `dx` is assumed. Default is 1.\n    axis : int, optional\n        Specify the axis.\n\n    Returns\n    -------\n    out : float\n        Definite integral as approximated by trapezoidal rule.\n\n    See Also\n    --------\n    sum, cumsum\n\n    Notes\n    -----\n    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points will\n    be taken from `y` array, by default x-axis distances between points will be\n    1.0, alternatively they can be provided with `x` array or with `dx` scalar.\n    Return value will be equal to combined area under the red lines.\n\n\n    References\n    ----------\n    .. [1] Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule\n\n    .. [2] Illustration image:\n           http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\n    Examples\n    --------\n    >>> np.trapz([1,2,3])\n    4.0\n    >>> np.trapz([1,2,3], x=[4,6,8])\n    8.0\n    >>> np.trapz([1,2,3], dx=2)\n    8.0\n    >>> a = np.arange(6).reshape(2, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.trapz(a, axis=0)\n    array([ 1.5,  2.5,  3.5])\n    >>> np.trapz(a, axis=1)\n    array([ 2.,  8.])\n    \n    ";
static const char __pyx_k_Interchange_two_axes_of_an_array[] = "Interchange two axes of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis1 : int\n        First axis.\n    axis2 : int\n        Second axis.\n\n    Returns\n    -------\n    a_swapped : ndarray\n        If `a` is an ndarray, then a view of `a` is returned; otherwise\n        a new array is created.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> np.swapaxes(x,0,1)\n    array([[1],\n           [2],\n           [3]])\n\n    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n\n    >>> np.swapaxes(x,0,2)\n    array([[[0, 4],\n            [2, 6]],\n           [[1, 5],\n            [3, 7]]])\n    \n    ";
static const char __pyx_k_Issues_a_DeprecationWarning_adds[] = "Issues a DeprecationWarning, adds warning to `old_name`'s\n    docstring, rebinds ``old_name.__name__`` and returns the new\n    function object.\n\n    This function may also be used as a decorator.\n\n    Parameters\n    ----------\n    func : function\n        The function to be deprecated.\n    old_name : str, optional\n        The name of the function to be deprecated. Default is None, in which\n        case the name of `func` is used.\n    new_name : str, optional\n        The new name for the function. Default is None, in which case\n        the deprecation message is that `old_name` is deprecated. If given,\n        the deprecation message is that `old_name` is deprecated and `new_name`\n        should be used instead.\n    message : str, optional\n        Additional explanation of the deprecation.  Displayed in the docstring\n        after the warning.\n\n    Returns\n    -------\n    old_func : function\n        The deprecated function.\n\n    Examples\n    --------\n    Note that ``olduint`` returns a value after printing Deprecation Warning:\n\n    >>> olduint = np.deprecate(np.uint)\n    >>> olduint(6)\n    /usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:\n    DeprecationWarning: uint32 is deprecated\n      warnings.warn(str1, DeprecationWarning)\n    6\n    \n    ";
static const char __pyx_k_Least_squares_polynomial_fit_Fit[] = "Least squares polynomial fit.\n\n    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\n    to points `(x, y)`. Returns a vector of coefficients `p` that minimises\n    the squared error.\n\n    Parameters\n    ----------\n    x : array_like, shape (M,)\n        x-coordinates of the M sample points ``(x[i], y[i])``.\n    y : array_like, shape (M,) or (M, K)\n        y-coordinates of the sample points. Several data sets of sample\n        points sharing the same x-coordinates can be fitted at once by\n        passing in a 2D-array that contains one dataset per column.\n    deg : int\n        Degree of the fitting polynomial\n    rcond : float, optional\n        Relative condition number of the fit. Singular values smaller than this\n        relative to the largest singular value will be ignored. The default\n        value is len(x)*eps, where eps is the relative precision of the float\n        type, about 2e-16 in most cases.\n    full : bool, optional\n        Switch determining nature of return value. When it is\n        False (the default) just the coefficients are returned, when True\n        diagnostic information from the singular value decomposition is also\n        returned.\n\n    Returns\n    -------\n    p : ndarray, shape (M,) or (M, K)\n        Polynomial coefficients, highest power first.\n        If `y` was 2-D, the coefficients for `k`-th data set are in ``p[:,k]``.\n\n    residuals, rank, singular_values, rcond : present only if `full` = True\n        Residuals of the least-squares fit, the effective rank of the scaled\n        Vandermonde coefficient matrix, its singular values, and the specified\n        value of `rcond`. For more details, see `linalg.lstsq`.\n\n    Warns\n    -----\n    RankWarning\n        The rank of the coefficient matrix in the least-squares fit is\n        deficient. The warning is only raised if `full` = False.\n\n        The warnings can be turned off by\n\n        >>> import warnings\n        >>> war""nings.simplefilter('ignore', np.RankWarning)\n\n    See Also\n    --------\n    polyval : Computes polynomial values.\n    linalg.lstsq : Computes a least-squares fit.\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\n\n    Notes\n    -----\n    The solution minimizes the squared error\n\n    .. math ::\n        E = \\sum_{j=0}^k |p(x_j) - y_j|^2\n\n    in the equations::\n\n        x[0]**n * p[n] + ... + x[0] * p[1] + p[0] = y[0]\n        x[1]**n * p[n] + ... + x[1] * p[1] + p[0] = y[1]\n        ...\n        x[k]**n * p[n] + ... + x[k] * p[1] + p[0] = y[k]\n\n    The coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n\n    `polyfit` issues a `RankWarning` when the least-squares fit is badly\n    conditioned. This implies that the best fit is not well-defined due\n    to numerical error. The results may be improved by lowering the polynomial\n    degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\n    can also be set to a value smaller than its default, but the resulting\n    fit may be spurious: including contributions from the small singular\n    values can add numerical noise to the result.\n\n    Note that fitting polynomial coefficients is inherently badly conditioned\n    when the degree of the polynomial is large or the interval of sample points\n    is badly centered. The quality of the fit should always be checked in these\n    cases. When polynomial fits are not satisfactory, splines may be a good\n    alternative.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Curve fitting\",\n           http://en.wikipedia.org/wiki/Curve_fitting\n    .. [2] Wikipedia, \"Polynomial interpolation\",\n           http://en.wikipedia.org/wiki/Polynomial_interpolation\n\n    Examples\n    --------\n    >>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n    >>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n    >>> z = np.polyfit(x, y, 3)\n    >>> z\n    array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]"")\n\n    It is convenient to use `poly1d` objects for dealing with polynomials:\n\n    >>> p = np.poly1d(z)\n    >>> p(0.5)\n    0.6143849206349179\n    >>> p(3.5)\n    -0.34732142857143039\n    >>> p(10)\n    22.579365079365115\n\n    High-order polynomials may oscillate wildly:\n\n    >>> p30 = np.poly1d(np.polyfit(x, y, 30))\n    /... RankWarning: Polyfit may be poorly conditioned...\n    >>> p30(4)\n    -0.80000000000000204\n    >>> p30(5)\n    -0.99999999999999445\n    >>> p30(4.5)\n    -0.10547061179440398\n\n    Illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> xp = np.linspace(-2, 6, 100)\n    >>> plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n    [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim(-2,2)\n    (-2, 2)\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Load_a_pickled_npy_or_npz_binary[] = "Load a pickled, ``.npy``, or ``.npz`` binary file.\n\n    Parameters\n    ----------\n    file : file-like object or string\n        The file to read.  It must support ``seek()`` and ``read()`` methods.\n        If the filename extension is ``.gz``, the file is first decompressed.\n    mmap_mode: {None, 'r+', 'r', 'w+', 'c'}, optional\n        If not None, then memory-map the file, using the given mode\n        (see `numpy.memmap`).  The mode has no effect for pickled or\n        zipped files.\n        A memory-mapped array is stored on disk, and not directly loaded\n        into memory.  However, it can be accessed and sliced like any\n        ndarray.  Memory mapping is especially useful for accessing\n        small fragments of large files without reading the entire file\n        into memory.\n\n    Returns\n    -------\n    result : array, tuple, dict, etc.\n        Data stored in the file.\n\n    Raises\n    ------\n    IOError\n        If the input file does not exist or cannot be read.\n\n    See Also\n    --------\n    save, savez, loadtxt\n    memmap : Create a memory-map to an array stored in a file on disk.\n\n    Notes\n    -----\n    - If the file contains pickle data, then whatever is stored in the\n      pickle is returned.\n    - If the file is a ``.npy`` file, then an array is returned.\n    - If the file is a ``.npz`` file, then a dictionary-like object is\n      returned, containing ``{filename: array}`` key-value pairs, one for\n      each file in the archive.\n\n    Examples\n    --------\n    Store data to disk, and load it again:\n\n    >>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n    >>> np.load('/tmp/123.npy')\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    Mem-map the stored array, and then access the second row\n    directly from disk:\n\n    >>> X = np.load('/tmp/123.npy', mmap_mode='r')\n    >>> X[1, :]\n    memmap([4, 5, 6])\n    \n    ";
static const char __pyx_k_Lower_triangle_of_an_array_Retur[] = "Lower triangle of an array.\n\n    Return a copy of an array with elements above the `k`-th diagonal zeroed.\n\n    Parameters\n    ----------\n    m : array_like, shape (M, N)\n        Input array.\n    k : int, optional\n        Diagonal above which to zero elements.  `k = 0` (the default) is the\n        main diagonal, `k < 0` is below it and `k > 0` is above.\n\n    Returns\n    -------\n    L : ndarray, shape (M, N)\n        Lower triangle of `m`, of same shape and data-type as `m`.\n\n    See Also\n    --------\n    triu : same thing, only for the upper triangle\n\n    Examples\n    --------\n    >>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 0,  0,  0],\n           [ 4,  0,  0],\n           [ 7,  8,  0],\n           [10, 11, 12]])\n    \n    ";
static const char __pyx_k_Non_native_byte_order_not_suppor[] = "Non-native byte order not supported";
static const char __pyx_k_One_dimensional_linear_interpola[] = "One-dimensional linear interpolation.\n\n    Returns the one-dimensional piecewise linear interpolant to a function\n    with given values at discrete data-points.\n\n    Parameters\n    ----------\n    x : array_like\n        The x-coordinates of the interpolated values.\n\n    xp : 1-D sequence of floats\n        The x-coordinates of the data points, must be increasing.\n\n    fp : 1-D sequence of floats\n        The y-coordinates of the data points, same length as `xp`.\n\n    left : float, optional\n        Value to return for `x < xp[0]`, default is `fp[0]`.\n\n    right : float, optional\n        Value to return for `x > xp[-1]`, defaults is `fp[-1]`.\n\n    Returns\n    -------\n    y : {float, ndarray}\n        The interpolated values, same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `xp` and `fp` have different length\n\n    Notes\n    -----\n    Does not check that the x-coordinate sequence `xp` is increasing.\n    If `xp` is not increasing, the results are nonsense.\n    A simple check for increasingness is::\n\n        np.all(np.diff(xp) > 0)\n\n\n    Examples\n    --------\n    >>> xp = [1, 2, 3]\n    >>> fp = [3, 2, 0]\n    >>> np.interp(2.5, xp, fp)\n    1.0\n    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\n    array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])\n    >>> UNDEF = -99.0\n    >>> np.interp(3.14, xp, fp, right=UNDEF)\n    -99.0\n\n    Plot an interpolant to the sine function:\n\n    >>> x = np.linspace(0, 2*np.pi, 10)\n    >>> y = np.sin(x)\n    >>> xvals = np.linspace(0, 2*np.pi, 50)\n    >>> yinterp = np.interp(xvals, x, y)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(xvals, yinterp, '-x')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Permute_the_dimensions_of_an_arr[] = "Permute the dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axes : list of ints, optional\n        By default, reverse the dimensions, otherwise permute the axes\n        according to the values given.\n\n    Returns\n    -------\n    p : ndarray\n        `a` with its axes permuted.  A view is returned whenever\n        possible.\n\n    See Also\n    --------\n    rollaxis\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.transpose(x)\n    array([[0, 2],\n           [1, 3]])\n\n    >>> x = np.ones((1, 2, 3))\n    >>> np.transpose(x, (1, 0, 2)).shape\n    (2, 1, 3)\n    \n    ";
static const char __pyx_k_Print_or_write_to_a_file_the_sou[] = "Print or write to a file the source code for a Numpy object.\n\n    The source code is only returned for objects written in Python. Many\n    functions and classes are defined in C and will therefore not return\n    useful information.\n\n    Parameters\n    ----------\n    object : numpy object\n        Input object. This can be any object (function, class, module, ...).\n    output : file object, optional\n        If `output` not supplied then source code is printed to screen\n        (sys.stdout).  File object must be created with either write 'w' or\n        append 'a' modes.\n\n    See Also\n    --------\n    lookfor, info\n\n    Examples\n    --------\n    >>> np.source(np.interp)                        #doctest: +SKIP\n    In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\n    def interp(x, xp, fp, left=None, right=None):\n        '''.... (full docstring printed)'''\n        if isinstance(x, (float, int, number)):\n            return compiled_interp([x], xp, fp, left, right).item()\n        else:\n            return compiled_interp(x, xp, fp, left, right)\n\n    The source code is only returned for objects written in Python.\n\n    >>> np.source(np.array)                         #doctest: +SKIP\n    Not available for this object.\n    \n    ";
static const char __pyx_k_Print_the_Numpy_arrays_in_the_gi[] = "Print the Numpy arrays in the given dictionary.\n\n    If there is no dictionary passed in or `vardict` is None then returns\n    Numpy arrays in the globals() dictionary (all Numpy arrays in the\n    namespace).\n\n    Parameters\n    ----------\n    vardict : dict, optional\n        A dictionary possibly containing ndarrays.  Default is globals().\n\n    Returns\n    -------\n    out : None\n        Returns 'None'.\n\n    Notes\n    -----\n    Prints out the name, shape, bytes and type of all of the ndarrays present\n    in `vardict`.\n\n    Examples\n    --------\n    >>> a = np.arange(10)\n    >>> b = np.ones(20)\n    >>> np.who()\n    Name            Shape            Bytes            Type\n    ===========================================================\n    a               10               40               int32\n    b               20               160              float64\n    Upper bound on total bytes  =       200\n\n    >>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n    ... 'idx':5}\n    >>> np.who(d)\n    Name            Shape            Bytes            Type\n    ===========================================================\n    y               3                24               float64\n    x               2                16               float64\n    Upper bound on total bytes  =       40\n    \n    ";
static const char __pyx_k_Protected_string_evaluation_Eval[] = "Protected string evaluation.\n\n    Evaluate a string containing a Python literal expression without\n    allowing the execution of arbitrary non-literal code.\n\n    Parameters\n    ----------\n    source : str\n        The string to evaluate.\n\n    Returns\n    -------\n    obj : object\n       The result of evaluating `source`.\n\n    Raises\n    ------\n    SyntaxError\n        If the code has invalid Python syntax, or if it contains non-literal\n        code.\n\n    Examples\n    --------\n    >>> np.safe_eval('1')\n    1\n    >>> np.safe_eval('[1, 2, 3]')\n    [1, 2, 3]\n    >>> np.safe_eval('{\"foo\": (\"bar\", 10.0)}')\n    {'foo': ('bar', 10.0)}\n\n    >>> np.safe_eval('import os')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: invalid syntax\n\n    >>> np.safe_eval('open(\"/home/user/.ssh/id_dsa\").read()')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: Unsupported source construct: compiler.ast.CallFunc\n    \n    ";
static const char __pyx_k_Remove_single_dimensional_entrie[] = "Remove single-dimensional entries from the shape of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    squeezed : ndarray\n        The input array, but with with all dimensions of length 1\n        removed.  Whenever possible, a view on `a` is returned.\n\n    Examples\n    --------\n    >>> x = np.array([[[0], [1], [2]]])\n    >>> x.shape\n    (1, 3, 1)\n    >>> np.squeeze(x).shape\n    (3,)\n    \n    ";
static const char __pyx_k_Repeat_elements_of_an_array_Para[] = "Repeat elements of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    repeats : {int, array of ints}\n        The number of repetitions for each element.  `repeats` is broadcasted\n        to fit the shape of the given axis.\n    axis : int, optional\n        The axis along which to repeat values.  By default, use the\n        flattened input array, and return a flat output array.\n\n    Returns\n    -------\n    repeated_array : ndarray\n        Output array which has the same shape as `a`, except along\n        the given axis.\n\n    See Also\n    --------\n    tile : Tile an array.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2],[3,4]])\n    >>> np.repeat(x, 2)\n    array([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> np.repeat(x, 3, axis=1)\n    array([[1, 1, 1, 2, 2, 2],\n           [3, 3, 3, 4, 4, 4]])\n    >>> np.repeat(x, [1, 2], axis=0)\n    array([[1, 2],\n           [3, 4],\n           [3, 4]])\n    \n    ";
static const char __pyx_k_Replace_nan_with_zero_and_inf_wi[] = "Replace nan with zero and inf with finite numbers.\n\n    Returns an array or scalar replacing Not a Number (NaN) with zero,\n    (positive) infinity with a very large number and negative infinity\n    with a very small (or negative) number.\n\n    Parameters\n    ----------\n    x : array_like\n        Input data.\n\n    Returns\n    -------\n    out : ndarray, float\n        Array with the same shape as `x` and dtype of the element in `x`  with\n        the greatest precision. NaN is replaced by zero, and infinity\n        (-infinity) is replaced by the largest (smallest or most negative)\n        floating point value that fits in the output dtype. All finite numbers\n        are upcast to the output dtype (default float64).\n\n    See Also\n    --------\n    isinf : Shows which elements are negative or negative infinity.\n    isneginf : Shows which elements are negative infinity.\n    isposinf : Shows which elements are positive infinity.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite : Shows which elements are finite (not NaN, not infinity)\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n\n    Examples\n    --------\n    >>> np.set_printoptions(precision=8)\n    >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n    >>> np.nan_to_num(x)\n    array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n            -1.28000000e+002,   1.28000000e+002])\n    \n    ";
static const char __pyx_k_Replaces_specified_elements_of_a[] = "Replaces specified elements of an array with given values.\n\n    The indexing works on the flattened target array. `put` is roughly\n    equivalent to:\n\n    ::\n\n        a.flat[ind] = v\n\n    Parameters\n    ----------\n    a : ndarray\n        Target array.\n    ind : array_like\n        Target indices, interpreted as integers.\n    v : array_like\n        Values to place in `a` at target indices. If `v` is shorter than\n        `ind` it will be repeated as necessary.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    See Also\n    --------\n    putmask, place\n\n    Examples\n    --------\n    >>> a = np.arange(5)\n    >>> np.put(a, [0, 2], [-44, -55])\n    >>> a\n    array([-44,   1, -55,   3,   4])\n\n    >>> a = np.arange(5)\n    >>> np.put(a, 22, -5, mode='clip')\n    >>> a\n    array([ 0,  1,  2,  3, -5])\n    \n    ";
static const char __pyx_k_Return_True_if_x_is_a_complex_ty[] = "Return True if x is a complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `iscomplexobj` evaluates to True\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, True if `x` is of a complex type.\n\n    See Also\n    --------\n    isrealobj, iscomplex\n\n    Examples\n    --------\n    >>> np.iscomplexobj(1)\n    False\n    >>> np.iscomplexobj(1+0j)\n    True\n    >>> np.iscomplexobj([3, 1+0j, True])\n    True\n    \n    ";
static const char __pyx_k_Return_True_if_x_is_a_not_comple[] = "Return True if x is a not complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `isrealobj` evaluates to False\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, False if `x` is of a complex type.\n\n    See Also\n    --------\n    iscomplexobj, isreal\n\n    Examples\n    --------\n    >>> np.isrealobj(1)\n    True\n    >>> np.isrealobj(1+0j)\n    False\n    >>> np.isrealobj([3, 1+0j, True])\n    False\n    \n    ";
static const char __pyx_k_Return_a_contiguous_array_in_mem[] = "Return a contiguous array in memory (C order).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        Data-type of returned array.\n\n    Returns\n    -------\n    out : ndarray\n        Contiguous array of same shape and content as `a`, with type `dtype`\n        if specified.\n\n    See Also\n    --------\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> np.ascontiguousarray(x, dtype=np.float32)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.]], dtype=float32)\n    >>> x.flags['C_CONTIGUOUS']\n    True\n    \n    ";
static const char __pyx_k_Return_a_description_for_the_giv[] = "Return a description for the given data type code.\n\n    Parameters\n    ----------\n    char : str\n        Data type code.\n\n    Returns\n    -------\n    out : str\n        Description of the input data type code.\n\n    See Also\n    --------\n    dtype, typecodes\n\n    Examples\n    --------\n    >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n    ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n    >>> for typechar in typechars:\n    ...     print typechar, ' : ', np.typename(typechar)\n    ...\n    S1  :  character\n    ?  :  bool\n    B  :  unsigned char\n    D  :  complex double precision\n    G  :  complex long double precision\n    F  :  complex single precision\n    I  :  unsigned integer\n    H  :  unsigned short\n    L  :  unsigned long integer\n    O  :  object\n    Q  :  unsigned long long integer\n    S  :  string\n    U  :  unicode\n    V  :  void\n    b  :  signed char\n    d  :  double precision\n    g  :  long precision\n    f  :  single precision\n    i  :  integer\n    h  :  short\n    l  :  long integer\n    q  :  long long integer\n    \n    ";
static const char __pyx_k_Return_a_flattened_array_A_1_D_a[] = "Return a flattened array.\n\n    A 1-D array, containing the elements of the input, is returned.  A copy is\n    made only if needed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  The elements in ``a`` are read in the order specified by\n        `order`, and packed as a 1-D array.\n    order : {'C','F', 'A', 'K'}, optional\n        The elements of ``a`` are read in this order. 'C' means to view\n        the elements in C (row-major) order. 'F' means to view the elements\n        in Fortran (column-major) order. 'A' means to view the elements\n        in 'F' order if a is Fortran contiguous, 'C' order otherwise.\n        'K' means to view the elements in the order they occur in memory,\n        except for reversing the data when strides are negative.\n        By default, 'C' order is used.\n\n    Returns\n    -------\n    1d_array : ndarray\n        Output of the same dtype as `a`, and of shape ``(a.size(),)``.\n\n    See Also\n    --------\n    ndarray.flat : 1-D iterator over an array.\n    ndarray.flatten : 1-D array copy of the elements of an array\n                      in row-major order.\n\n    Notes\n    -----\n    In row-major order, the row index varies the slowest, and the column\n    index the quickest.  This can be generalized to multiple dimensions,\n    where row-major order implies that the index along the first axis\n    varies slowest, and the index along the last quickest.  The opposite holds\n    for Fortran-, or column-major, mode.\n\n    Examples\n    --------\n    It is equivalent to ``reshape(-1, order=order)``.\n\n    >>> x = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> print np.ravel(x)\n    [1 2 3 4 5 6]\n\n    >>> print x.reshape(-1)\n    [1 2 3 4 5 6]\n\n    >>> print np.ravel(x, order='F')\n    [1 4 2 5 3 6]\n\n    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:\n\n    >>> print np.ravel(x.T)\n    [1 4 2 5 3 6]\n    >>> print np.ravel(x.T, order='A')\n    [1 2 3 4 5 6]\n\n    When ``or""der`` is 'K', it will preserve orderings that are neither 'C'\n    nor 'F', but won't reverse axes:\n\n    >>> a = np.arange(3)[::-1]; a\n    array([2, 1, 0])\n    >>> a.ravel(order='C')\n    array([2, 1, 0])\n    >>> a.ravel(order='K')\n    array([2, 1, 0])\n\n    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\n    array([[[ 0,  2,  4],\n            [ 1,  3,  5]],\n           [[ 6,  8, 10],\n            [ 7,  9, 11]]])\n    >>> a.ravel(order='C')\n    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n    >>> a.ravel(order='K')\n    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n    \n    ";
static const char __pyx_k_Return_a_new_array_with_sub_arra[] = "Return a new array with sub-arrays along an axis deleted.\n\n    Parameters\n    ----------\n    arr : array_like\n      Input array.\n    obj : slice, int or array of ints\n      Indicate which sub-arrays to remove.\n    axis : int, optional\n      The axis along which to delete the subarray defined by `obj`.\n      If `axis` is None, `obj` is applied to the flattened array.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with the elements specified by `obj` removed. Note\n        that `delete` does not occur in-place. If `axis` is None, `out` is\n        a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    append : Append elements at the end of an array.\n\n    Examples\n    --------\n    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n    >>> arr\n    array([[ 1,  2,  3,  4],\n           [ 5,  6,  7,  8],\n           [ 9, 10, 11, 12]])\n    >>> np.delete(arr, 1, 0)\n    array([[ 1,  2,  3,  4],\n           [ 9, 10, 11, 12]])\n\n    >>> np.delete(arr, np.s_[::2], 1)\n    array([[ 2,  4],\n           [ 6,  8],\n           [10, 12]])\n    >>> np.delete(arr, [1,3,5], None)\n    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n    \n    ";
static const char __pyx_k_Return_a_new_array_with_the_spec[] = "Return a new array with the specified shape.\n\n    If the new array is larger than the original array, then the new\n    array is filled with repeated copies of `a`.  Note that this behavior\n    is different from a.resize(new_shape) which fills with zeros instead\n    of repeated copies of `a`.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be resized.\n\n    new_shape : int or tuple of int\n        Shape of resized array.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        The new array is formed from the data in the old array, repeated\n        if necessary to fill out the required number of elements.  The\n        data are repeated in the order that they are stored in memory.\n\n    See Also\n    --------\n    ndarray.resize : resize an array in-place.\n\n    Examples\n    --------\n    >>> a=np.array([[0,1],[2,3]])\n    >>> np.resize(a,(1,4))\n    array([[0, 1, 2, 3]])\n    >>> np.resize(a,(2,4))\n    array([[0, 1, 2, 3],\n           [0, 1, 2, 3]])\n    \n    ";
static const char __pyx_k_Return_a_scalar_type_which_is_co[] = "Return a scalar type which is common to the input arrays.\n\n    The return type will always be an inexact (i.e. floating point) scalar\n    type, even if all the arrays are integer arrays. If one of the inputs is\n    an integer array, the minimum precision type that is returned is a\n    64-bit floating point dtype.\n\n    All input arrays can be safely cast to the returned dtype without loss\n    of information.\n\n    Parameters\n    ----------\n    array1, array2, ... : ndarrays\n        Input arrays.\n\n    Returns\n    -------\n    out : data type code\n        Data type code.\n\n    See Also\n    --------\n    dtype, mintypecode\n\n    Examples\n    --------\n    >>> np.common_type(np.arange(2, dtype=np.float32))\n    <type 'numpy.float32'>\n    >>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n    <type 'numpy.float64'>\n    >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n    <type 'numpy.complex128'>\n    \n    ";
static const char __pyx_k_Return_a_sorted_copy_of_an_array[] = "Return a sorted copy of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm. Default is 'quicksort'.\n    order : list, optional\n        When `a` is a structured array, this argument specifies which fields\n        to compare first, second, and so on.  This list does not need to\n        include all of the fields.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.sort : Method to sort an array in-place.\n    argsort : Indirect sort.\n    lexsort : Indirect stable sort on multiple keys.\n    searchsorted : Find elements in a sorted array.\n\n    Notes\n    -----\n    The various sorting algorithms are characterized by their average speed,\n    worst case performance, work space size, and whether they are stable. A\n    stable sort keeps items with the same key in the same relative\n    order. The three available algorithms have the following\n    properties:\n\n    =========== ======= ============= ============ =======\n       kind      speed   worst case    work space  stable\n    =========== ======= ============= ============ =======\n    'quicksort'    1     O(n^2)            0          no\n    'mergesort'    2     O(n*log(n))      ~n/2        yes\n    'heapsort'     3     O(n*log(n))       0          no\n    =========== ======= ============= ============ =======\n\n    All the sort algorithms make temporary copies of the data when\n    sorting along any but the last axis.  Consequently, sorting along\n    the last axis is faster and uses less space than sorting along\n    any other axis.\n\n    The sort order for complex numbers is lexicographic. If both the real""\n    and imaginary parts are non-nan then the order is determined by the\n    real parts except when they are equal, in which case the order is\n    determined by the imaginary parts.\n\n    Previous to numpy 1.4.0 sorting real and complex arrays containing nan\n    values led to undefined behaviour. In numpy versions >= 1.4.0 nan\n    values are sorted to the end. The extended sort order is:\n\n      * Real: [R, nan]\n      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]\n\n    where R is a non-nan real value. Complex values with the same nan\n    placements are sorted according to the non-nan part if it exists.\n    Non-nan values are sorted as before.\n\n    Examples\n    --------\n    >>> a = np.array([[1,4],[3,1]])\n    >>> np.sort(a)                # sort along the last axis\n    array([[1, 4],\n           [1, 3]])\n    >>> np.sort(a, axis=None)     # sort the flattened array\n    array([1, 1, 3, 4])\n    >>> np.sort(a, axis=0)        # sort along the first axis\n    array([[1, 1],\n           [3, 4]])\n\n    Use the `order` keyword to specify a field to use when sorting a\n    structured array:\n\n    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]\n    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n    ...           ('Galahad', 1.7, 38)]\n    >>> a = np.array(values, dtype=dtype)       # create a structured array\n    >>> np.sort(a, order='height')                        # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n           ('Lancelot', 1.8999999999999999, 38)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    Sort by age, then height if ages are equal:\n\n    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n           ('Arthur', 1.8, 41)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n    \n    ";
static const char __pyx_k_Return_a_string_representation_o[] = "Return a string representation of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters splits the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing\n        precision (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero. A number is \"very small\" if it\n        is smaller than the current printing precision.\n    separator : str, optional\n        Inserted between elements.\n    prefix : str, optional\n        An array is typically printed as::\n\n          'prefix(' + array2string(a) + ')'\n\n        The length of the prefix string is used to align the\n        output correctly.\n    style : function, optional\n        A function that accepts an ndarray and returns a string.  Used only\n        when the shape of `a` is equal to ().\n\n    Returns\n    -------\n    array_str : str\n        String representation of the array.\n\n    See Also\n    --------\n    array_str, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> x = np.array([1e-16,1,2,3])\n    >>> print np.array2string(x, precision=2, separator=',',\n    ...                       suppress_small=True)\n    [ 0., 1., 2., 3.]\n    \n    ";
static const char __pyx_k_Return_an_antiderivative_indefin[] = "Return an antiderivative (indefinite integral) of a polynomial.\n\n    The returned order `m` antiderivative `P` of polynomial `p` satisfies\n    :math:`\014rac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`\n    integration constants `k`. The constants determine the low-order\n    polynomial part\n\n    .. math:: \014rac{k_{m-1}}{0!} x^0 + \\ldots + \014rac{k_0}{(m-1)!}x^{m-1}\n\n    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.\n\n    Parameters\n    ----------\n    p : {array_like, poly1d}\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of the antiderivative. (Default: 1)\n    k : {None, list of `m` scalars, scalar}, optional\n        Integration constants. They are given in the order of integration:\n        those corresponding to highest-order terms come first.\n\n        If ``None`` (default), all constants are assumed to be zero.\n        If `m = 1`, a single scalar can be given instead of a list.\n\n    See Also\n    --------\n    polyder : derivative of a polynomial\n    poly1d.integ : equivalent method\n\n    Examples\n    --------\n    The defining property of the antiderivative:\n\n    >>> p = np.poly1d([1,1,1])\n    >>> P = np.polyint(p)\n    >>> P\n    poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])\n    >>> np.polyder(P) == p\n    True\n\n    The integration constants default to zero, but can be specified:\n\n    >>> P = np.polyint(p, 3)\n    >>> P(0)\n    0.0\n    >>> np.polyder(P)(0)\n    0.0\n    >>> np.polyder(P, 2)(0)\n    0.0\n    >>> P = np.polyint(p, 3, k=[6,5,3])\n    >>> P\n    poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ])\n\n    Note that 3 = 6 / 2!, and that the constants are given in the order of\n    integrations. Constant of the highest-order polynomial term comes first:\n\n    >>> np.polyder(P, 2)(0)\n    6.0\n    >>> np.polyder(P, 1)(0)\n    5.0\n    >>> P(0)\n    3.0\n    \n    ";
static const char __pyx_k_Return_an_array_converted_to_a_f[] = "Return an array converted to a float type.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    dtype : str or dtype object, optional\n        Float type code to coerce input array `a`.  If `dtype` is one of the\n        'int' dtypes, it is replaced with float64.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` as a float ndarray.\n\n    Examples\n    --------\n    >>> np.asfarray([2, 3])\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='float')\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='int8')\n    array([ 2.,  3.])\n    \n    ";
static const char __pyx_k_Return_an_array_copy_of_the_give[] = "Return an array copy of the given object.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    arr : ndarray\n        Array interpretation of `a`.\n\n    Notes\n    -----\n    This is equivalent to\n\n    >>> np.array(a, copy=True)                              #doctest: +SKIP\n\n    Examples\n    --------\n    Create an array x, with a reference y and a copy z:\n\n    >>> x = np.array([1, 2, 3])\n    >>> y = x\n    >>> z = np.copy(x)\n\n    Note that, when we modify x, y changes, but not z:\n\n    >>> x[0] = 10\n    >>> x[0] == y[0]\n    True\n    >>> x[0] == z[0]\n    False\n    \n    ";
static const char __pyx_k_Return_an_array_drawn_from_eleme[] = "Return an array drawn from elements in choicelist, depending on conditions.\n\n    Parameters\n    ----------\n    condlist : list of bool ndarrays\n        The list of conditions which determine from which array in `choicelist`\n        the output elements are taken. When multiple conditions are satisfied,\n        the first one encountered in `condlist` is used.\n    choicelist : list of ndarrays\n        The list of arrays from which the output elements are taken. It has\n        to be of the same length as `condlist`.\n    default : scalar, optional\n        The element inserted in `output` when all conditions evaluate to False.\n\n    Returns\n    -------\n    output : ndarray\n        The output at position m is the m-th element of the array in\n        `choicelist` where the m-th element of the corresponding array in\n        `condlist` is True.\n\n    See Also\n    --------\n    where : Return elements from one of two arrays depending on condition.\n    take, choose, compress, diag, diagonal\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> condlist = [x<3, x>5]\n    >>> choicelist = [x, x**2]\n    >>> np.select(condlist, choicelist)\n    array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])\n    \n    ";
static const char __pyx_k_Return_an_array_laid_out_in_Fort[] = "Return an array laid out in Fortran order in memory.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        By default, the data-type is inferred from the input data.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` in Fortran, or column-major, order.\n\n    See Also\n    --------\n    ascontiguousarray : Convert input to a contiguous (C order) array.\n    asanyarray : Convert input to an ndarray with either row or\n        column-major memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> y = np.asfortranarray(x)\n    >>> x.flags['F_CONTIGUOUS']\n    False\n    >>> y.flags['F_CONTIGUOUS']\n    True\n    \n    ";
static const char __pyx_k_Return_an_array_representing_the[] = "Return an array representing the indices of a grid.\n\n    Compute an array where the subarrays contain index values 0,1,...\n    varying only along the corresponding axis.\n\n    Parameters\n    ----------\n    dimensions : sequence of ints\n        The shape of the grid.\n    dtype : dtype, optional\n        Data type of the result.\n\n    Returns\n    -------\n    grid : ndarray\n        The array of grid indices,\n        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n\n    See Also\n    --------\n    mgrid, meshgrid\n\n    Notes\n    -----\n    The output shape is obtained by prepending the number of dimensions\n    in front of the tuple of dimensions, i.e. if `dimensions` is a tuple\n    ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n    ``(N,r0,...,rN-1)``.\n\n    The subarrays ``grid[k]`` contains the N-D array of indices along the\n    ``k-th`` axis. Explicitly::\n\n        grid[k,i0,i1,...,iN-1] = ik\n\n    Examples\n    --------\n    >>> grid = np.indices((2, 3))\n    >>> grid.shape\n    (2, 2, 3)\n    >>> grid[0]        # row indices\n    array([[0, 0, 0],\n           [1, 1, 1]])\n    >>> grid[1]        # column indices\n    array([[0, 1, 2],\n           [0, 1, 2]])\n\n    The indices can be used as an index into an array.\n\n    >>> x = np.arange(20).reshape(5, 4)\n    >>> row, col = np.indices((2, 3))\n    >>> x[row, col]\n    array([[0, 1, 2],\n           [4, 5, 6]])\n\n    Note that it would be more straightforward in the above example to\n    extract the required elements directly with ``x[:2, :3]``.\n    \n    ";
static const char __pyx_k_Return_an_ndarray_of_the_provide[] = "Return an ndarray of the provided type that satisfies requirements.\n\n    This function is useful to be sure that an array with the correct flags\n    is returned for passing to compiled code (perhaps through ctypes).\n\n    Parameters\n    ----------\n    a : array_like\n       The object to be converted to a type-and-requirement-satisfying array.\n    dtype : data-type\n       The required data-type, the default data-type is float64).\n    requirements : str or list of str\n       The requirements list can be any of the following\n\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\n       * 'WRITEABLE' ('W')    - ensure a writable array\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\n\n    See Also\n    --------\n    asarray : Convert input to an ndarray.\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Notes\n    -----\n    The returned array will be guaranteed to have the listed requirements\n    by making a copy if needed.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : False\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n    >>> y.flags\n      C_CONTIGUOUS : False\n      F_CONTIGUOUS : True\n      OWNDATA : True\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n    \n    ";
static const char __pyx_k_Return_indices_of_the_maximum_va[] = "Return indices of the maximum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmax, nanargmin\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmax(a)\n    0\n    >>> np.nanargmax(a)\n    1\n    >>> np.nanargmax(a, axis=0)\n    array([1, 0])\n    >>> np.nanargmax(a, axis=1)\n    array([1, 1])\n    \n    ";
static const char __pyx_k_Return_indices_of_the_minimum_va[] = "Return indices of the minimum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmin, nanargmax\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmin(a)\n    0\n    >>> np.nanargmin(a)\n    2\n    >>> np.nanargmin(a, axis=0)\n    array([1, 1])\n    >>> np.nanargmin(a, axis=1)\n    array([1, 0])\n    \n    ";
static const char __pyx_k_Return_indices_that_are_non_zero[] = "Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to a.ravel().nonzero()[0].\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of `a.ravel()`\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n    \n    ";
static const char __pyx_k_Return_selected_slices_of_an_arr[] = "Return selected slices of an array along given axis.\n\n    When working along a given axis, a slice along that axis is returned in\n    `output` for each index where `condition` evaluates to True. When\n    working on a 1-D array, `compress` is equivalent to `extract`.\n\n    Parameters\n    ----------\n    condition : 1-D array of bools\n        Array that selects which entries to return. If len(condition)\n        is less than the size of `a` along the given axis, then output is\n        truncated to the length of the condition array.\n    a : array_like\n        Array from which to extract a part.\n    axis : int, optional\n        Axis along which to take slices. If None (default), work on the\n        flattened array.\n    out : ndarray, optional\n        Output array.  Its type is preserved and it must be of the right\n        shape to hold the output.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        A copy of `a` without the slices along axis for which `condition`\n        is false.\n\n    See Also\n    --------\n    take, choose, diag, diagonal, select\n    ndarray.compress : Equivalent method.\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> a\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.compress([0, 1], a, axis=0)\n    array([[3, 4]])\n    >>> np.compress([False, True, True], a, axis=0)\n    array([[3, 4],\n           [5, 6]])\n    >>> np.compress([False, True], a, axis=1)\n    array([[2],\n           [4],\n           [6]])\n\n    Working on the flattened array does not return slices along an axis but\n    selects elements.\n\n    >>> np.compress([False, True], a)\n    array([2])\n    \n    ";
static const char __pyx_k_Return_the_Bartlett_window_The_B[] = "Return the Bartlett window.\n\n    The Bartlett window is very similar to a triangular window, except\n    that the end points are at zero.  It is often used in signal\n    processing for tapering a signal, without generating too much\n    ripple in the frequency domain.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : array\n        The triangular window, normalized to one (the value one\n        appears only if the number of samples is odd), with the first\n        and last samples equal to zero.\n\n    See Also\n    --------\n    blackman, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Bartlett window is defined as\n\n    .. math:: w(n) = \014rac{2}{M-1} \\left(\n              \014rac{M-1}{2} - \\left|n - \014rac{M-1}{2}\right|\n              \right)\n\n    Most references to the Bartlett window come from the signal\n    processing literature, where it is used as one of many windowing\n    functions for smoothing values.  Note that convolution with this\n    window produces linear interpolation.  It is also known as an\n    apodization (which means\"removing the foot\", i.e. smoothing\n    discontinuities at the beginning and end of the sampled signal) or\n    tapering function. The fourier transform of the Bartlett is the product\n    of two sinc functions.\n    Note the excellent discussion in Kanasewich.\n\n    References\n    ----------\n    .. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n           Biometrika 37, 1-16, 1950.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 109-110.\n    .. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n           Processing\", Prentice-Hall, 1999, pp. 468-471.\n    .. [4] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    "".. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\n\n    Examples\n    --------\n    >>> np.bartlett(12)\n    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,\n            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n            0.18181818,  0.        ])\n\n    Plot the window and its frequency response (requires SciPy and matplotlib):\n\n    >>> from numpy import clip, log10, array, bartlett, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = bartlett(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Return_the_Blackman_window_The_B[] = "Return the Blackman window.\n\n    The Blackman window is a taper formed by using the the first three\n    terms of a summation of cosines. It was designed to have close to the\n    minimal leakage possible.  It is close to optimal, only slightly worse\n    than a Kaiser window.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an empty\n        array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one appears only if the\n        number of samples is odd).\n\n    See Also\n    --------\n    bartlett, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Blackman window is defined as\n\n    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)\n\n    Most references to the Blackman window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function. It is known as a\n    \"near optimal\" tapering function, almost as good (by some measures)\n    as the kaiser window.\n\n    References\n    ----------\n    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\n    Dover Publications, New York.\n\n    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\n    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\n    Examples\n    --------\n    >>> from numpy import blackman\n    >>> blackman(12)\n    array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,\n             4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n             9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n             1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, lo""g10, array, blackman, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = blackman(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Return_the_Hamming_window_The_Ha[] = "Return the Hamming window.\n\n    The Hamming window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hanning, kaiser\n\n    Notes\n    -----\n    The Hamming window is defined as\n\n    .. math::  w(n) = 0.54 + 0.46cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and\n    is described in Blackman and Tukey. It was recommended for smoothing the\n    truncated autocovariance function in the time domain.\n    Most references to the Hamming window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 109-110.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> np.hamming(12)\n    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,\n            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n         ""   0.15302337,  0.08      ])\n\n    Plot the window and the frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hamming(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> response = 20 * np.log10(mag)\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Return_the_Hanning_window_The_Ha[] = "Return the Hanning window.\n\n    The Hanning window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray, shape(M,)\n        The window, normalized to one (the value one\n        appears only if `M` is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, kaiser\n\n    Notes\n    -----\n    The Hanning window is defined as\n\n    .. math::  w(n) = 0.5 - 0.5cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hanning was named for Julius van Hann, an Austrian meterologist. It is\n    also known as the Cosine Bell. Some authors prefer that it be called a\n    Hann window, to help avoid confusion with the very similar Hamming window.\n\n    Most references to the Hanning window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 106-108.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> from numpy import hanning\n    >>> hanning(12)\n    array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,\n            0.97974649,  0.97974649,  0.""82743037,  0.57115742,  0.29229249,\n            0.07937323,  0.        ])\n\n    Plot the window and its frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hanning(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = np.linspace(-0.5,0.5,len(A))\n    >>> response = 20*np.log10(mag)\n    >>> response = np.clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of the Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Return_the_Internal_Rate_of_Retu[] = "Return the Internal Rate of Return (IRR).\n\n    This is the \"average\" periodically compounded rate of return\n    that gives a net present value of 0.0; for a more complete explanation,\n    see Notes below.\n\n    Parameters\n    ----------\n    values : array_like, shape(N,)\n        Input cash flows per time period.  By convention, net \"deposits\"\n        are negative and net \"withdrawals\" are positive.  Thus, for example,\n        at least the first element of `values`, which represents the initial\n        investment, will typically be negative.\n\n    Returns\n    -------\n    out : float\n        Internal Rate of Return for periodic input values.\n\n    Notes\n    -----\n    The IRR is perhaps best understood through an example (illustrated\n    using np.irr in the Examples section below).  Suppose one invests\n    100 units and then makes the following withdrawals at regular\n    (fixed) intervals: 39, 59, 55, 20.  Assuming the ending value is 0,\n    one's 100 unit investment yields 173 units; however, due to the\n    combination of compounding and the periodic withdrawals, the\n    \"average\" rate of return is neither simply 0.73/4 nor (1.73)^0.25-1.\n    Rather, it is the solution (for :math:`r`) of the equation:\n\n    .. math:: -100 + \014rac{39}{1+r} + \014rac{59}{(1+r)^2}\n     + \014rac{55}{(1+r)^3} + \014rac{20}{(1+r)^4} = 0\n\n    In general, for `values` :math:`= [v_0, v_1, ... v_M]`,\n    irr is the solution of the equation: [G]_\n\n    .. math:: \\sum_{t=0}^M{\014rac{v_t}{(1+irr)^{t}}} = 0\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 348.\n\n    Examples\n    --------\n    >>> np.irr([-100, 39, 59, 55, 20])\n    0.2809484211599611\n\n    (Compare with the Example given for numpy.lib.financial.npv)\n    \n    ";
static const char __pyx_k_Return_the_Kaiser_window_The_Kai[] = "Return the Kaiser window.\n\n    The Kaiser window is a taper formed by using a Bessel function.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n    beta : float\n        Shape parameter for window.\n\n    Returns\n    -------\n    out : array\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, hanning\n\n    Notes\n    -----\n    The Kaiser window is defined as\n\n    .. math::  w(n) = I_0\\left( \010eta \\sqrt{1-\014rac{4n^2}{(M-1)^2}}\n               \right)/I_0(\010eta)\n\n    with\n\n    .. math:: \\quad -\014rac{M-1}{2} \\leq n \\leq \014rac{M-1}{2},\n\n    where :math:`I_0` is the modified zeroth-order Bessel function.\n\n    The Kaiser was named for Jim Kaiser, who discovered a simple approximation\n    to the DPSS window based on Bessel functions.\n    The Kaiser window is a very good approximation to the Digital Prolate\n    Spheroidal Sequence, or Slepian window, which is the transform which\n    maximizes the energy in the main lobe of the window relative to total\n    energy.\n\n    The Kaiser can approximate many other windows by varying the beta\n    parameter.\n\n    ====  =======================\n    beta  Window shape\n    ====  =======================\n    0     Rectangular\n    5     Similar to a Hamming\n    6     Similar to a Hanning\n    8.6   Similar to a Blackman\n    ====  =======================\n\n    A beta value of 14 is probably a good starting point. Note that as beta\n    gets large, the window narrows, and so the number of samples needs to be\n    large enough to sample the increasingly narrow spike, otherwise nans will\n    get returned.\n\n\n    Most references to the Kaiser window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It"" is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n           digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n           John Wiley and Sons, New York, (1966).\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 177-178.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n\n    Examples\n    --------\n    >>> from numpy import kaiser\n    >>> kaiser(12, 14)\n    array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,\n             2.29737120e-01,   5.99885316e-01,   9.45674898e-01,\n             9.45674898e-01,   5.99885316e-01,   2.29737120e-01,\n             4.65200189e-02,   3.46009194e-03,   7.72686684e-06])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, log10, array, kaiser, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = kaiser(51, 14)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Kaiser window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Kaiser window\")\n    <matplot""lib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static const char __pyx_k_Return_the_binary_representation[] = "Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, the length of\n        the two's complement if `num` is negative.\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        http://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=4)\n    '1101'\n    \n    ";
static const char __pyx_k_Return_the_character_for_the_min[] = "Return the character for the minimum-size type to which given types can\n    be safely cast.\n\n    The returned type character must represent the smallest size dtype such\n    that an array of the returned type can handle the data from an array of\n    all types in `typechars` (or if `typechars` is an array, then its\n    dtype.char).\n\n    Parameters\n    ----------\n    typechars : list of str or array_like\n        If a list of strings, each string should represent a dtype.\n        If array_like, the character representation of the array dtype is used.\n    typeset : str or list of str, optional\n        The set of characters that the returned character is chosen from.\n        The default set is 'GDFgdf'.\n    default : str, optional\n        The default character, this is returned if none of the characters in\n        `typechars` matches a character in `typeset`.\n\n    Returns\n    -------\n    typechar : str\n        The character representing the minimum-size type that was found.\n\n    See Also\n    --------\n    dtype, sctype2char, maximum_sctype\n\n    Examples\n    --------\n    >>> np.mintypecode(['d', 'f', 'S'])\n    'd'\n    >>> x = np.array([1.1, 2-3.j])\n    >>> np.mintypecode(x)\n    'D'\n\n    >>> np.mintypecode('abceh', default='G')\n    'G'\n    \n    ";
static const char __pyx_k_Return_the_cumulative_product_of[] = "Return the cumulative product of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed.  By default\n        the input is flattened.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n\n    Returns\n    -------\n    cumprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to out is returned.\n\n    See Also\n    --------\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([1,2,3])\n    >>> np.cumprod(a) # intermediate results 1, 1*2\n    ...               # total product 1*2*3 = 6\n    array([1, 2, 6])\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumprod(a, dtype=float) # specify type of output\n    array([   1.,    2.,    6.,   24.,  120.,  720.])\n\n    The cumulative product for each column (i.e., over the rows) of `a`:\n\n    >>> np.cumprod(a, axis=0)\n    array([[ 1,  2,  3],\n           [ 4, 10, 18]])\n\n    The cumulative product for each row (i.e. over the columns) of `a`:\n\n    >>> np.cumprod(a,axis=1)\n    array([[  1,   2,   6],\n           [  4,  20, 120]])\n    \n    ";
static const char __pyx_k_Return_the_cumulative_sum_of_the[] = "Return the cumulative sum of the elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See `doc.ufuncs`\n        (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    cumsum_along_axis : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to `out` is returned. The\n        result has the same size as `a`, and the same shape as `a` if\n        `axis` is not None or `a` is a 1-d array.\n\n\n    See Also\n    --------\n    sum : Sum array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.cumsum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n\n    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> ""np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])\n    \n    ";
static const char __pyx_k_Return_the_current_callback_func[] = "Return the current callback function used on floating-point errors.\n\n    When the error handling for a floating-point error (one of \"divide\",\n    \"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\n    that is called or the log instance that is written to is returned by\n    `geterrcall`. This function or log instance has been set with\n    `seterrcall`.\n\n    Returns\n    -------\n    errobj : callable, log instance or None\n        The current error handler. If no handler was set through `seterrcall`,\n        ``None`` is returned.\n\n    See Also\n    --------\n    seterrcall, seterr, geterr\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrcall()  # we did not yet set a handler, returns None\n\n    >>> oldsettings = np.seterr(all='call')\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    >>> oldhandler = np.seterrcall(err_handler)\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> cur_handler = np.geterrcall()\n    >>> cur_handler is err_handler\n    True\n    \n    ";
static const char __pyx_k_Return_the_derivative_of_the_spe[] = "Return the derivative of the specified order of a polynomial.\n\n    Parameters\n    ----------\n    p : poly1d or sequence\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of differentiation (default: 1)\n\n    Returns\n    -------\n    der : poly1d\n        A new polynomial representing the derivative.\n\n    See Also\n    --------\n    polyint : Anti-derivative of a polynomial.\n    poly1d : Class for one-dimensional polynomials.\n\n    Examples\n    --------\n    The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:\n\n    >>> p = np.poly1d([1,1,1,1])\n    >>> p2 = np.polyder(p)\n    >>> p2\n    poly1d([3, 2, 1])\n\n    which evaluates to:\n\n    >>> p2(2.)\n    17.0\n\n    We can verify this, approximating the derivative with\n    ``(f(x + h) - f(x))/h``:\n\n    >>> (p(2. + 0.001) - p(2.)) / 0.001\n    17.007000999997857\n\n    The fourth-order derivative of a 3rd-order polynomial is zero:\n\n    >>> np.polyder(p, 2)\n    poly1d([6, 2])\n    >>> np.polyder(p, 3)\n    poly1d([6])\n    >>> np.polyder(p, 4)\n    poly1d([ 0.])\n    \n    ";
static const char __pyx_k_Return_the_dot_product_of_two_ve[] = "Return the dot product of two vectors.\n\n    The vdot(`a`, `b`) function handles complex numbers differently than\n    dot(`a`, `b`).  If the first argument is complex the complex conjugate\n    of the first argument is used for the calculation of the dot product.\n\n    Note that `vdot` handles multidimensional arrays differently than `dot`:\n    it does *not* perform a matrix product, but flattens input arguments\n    to 1-D vectors first. Consequently, it should only be used for vectors.\n\n    Parameters\n    ----------\n    a : array_like\n        If `a` is complex the complex conjugate is taken before calculation\n        of the dot product.\n    b : array_like\n        Second argument to the dot product.\n\n    Returns\n    -------\n    output : ndarray\n        Dot product of `a` and `b`.  Can be an int, float, or\n        complex depending on the types of `a` and `b`.\n\n    See Also\n    --------\n    dot : Return the dot product without using the complex conjugate of the\n          first argument.\n\n    Examples\n    --------\n    >>> a = np.array([1+2j,3+4j])\n    >>> b = np.array([5+6j,7+8j])\n    >>> np.vdot(a, b)\n    (70-8j)\n    >>> np.vdot(b, a)\n    (70+8j)\n\n    Note that higher-dimensional arrays are flattened!\n\n    >>> a = np.array([[1, 4], [5, 6]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.vdot(a, b)\n    30\n    >>> np.vdot(b, a)\n    30\n    >>> 1*4 + 4*1 + 5*2 + 6*2\n    30\n    \n    ";
static const char __pyx_k_Return_the_gradient_of_an_N_dime[] = "Return the gradient of an N-dimensional array.\n\n    The gradient is computed using central differences in the interior\n    and first differences at the boundaries. The returned gradient hence has\n    the same shape as the input array.\n\n    Parameters\n    ----------\n    f : array_like\n      An N-dimensional array containing samples of a scalar function.\n    `*varargs` : scalars\n      0, 1, or N scalars specifying the sample distances in each direction,\n      that is: `dx`, `dy`, `dz`, ... The default distance is 1.\n\n\n    Returns\n    -------\n    g : ndarray\n      N arrays of the same shape as `f` giving the derivative of `f` with\n      respect to each dimension.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)\n    >>> np.gradient(x)\n    array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n    >>> np.gradient(x, 2)\n    array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float))\n    [array([[ 2.,  2., -1.],\n           [ 2.,  2., -1.]]),\n    array([[ 1. ,  2.5,  4. ],\n           [ 1. ,  1. ,  1. ]])]\n    \n    ";
static const char __pyx_k_Return_the_imaginary_part_of_the[] = "Return the imaginary part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, angle, real_if_close\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.imag\n    array([ 2.,  4.,  6.])\n    >>> a.imag = np.array([8, 10, 12])\n    >>> a\n    array([ 1. +8.j,  3.+10.j,  5.+12.j])\n    \n    ";
static const char __pyx_k_Return_the_indices_for_the_lower[] = "Return the indices for the lower-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The row dimension of the square arrays for which the returned\n        indices will be valid.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    triu_indices : similar function, for upper-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    tril, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    lower triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> il1 = np.tril_indices(4)\n    >>> il2 = np.tril_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[il1]\n    array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])\n\n    And for assigning values:\n\n    >>> a[il1] = -1\n    >>> a\n    array([[-1,  1,  2,  3],\n           [-1, -1,  6,  7],\n           [-1, -1, -1, 11],\n           [-1, -1, -1, -1]])\n\n    These cover almost the whole array (two diagonals right of the main one):\n\n    >>> a[il2] = -10\n    >>> a\n    array([[-10, -10, -10,   3],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10]])\n    \n    ";
static const char __pyx_k_Return_the_indices_for_the_upper[] = "Return the indices for the upper-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The size of the arrays for which the returned indices will\n        be valid.\n    k : int, optional\n        Diagonal offset (see `triu` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    tril_indices : similar function, for lower-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    triu, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    upper triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> iu1 = np.triu_indices(4)\n    >>> iu2 = np.triu_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[iu1]\n    array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])\n\n    And for assigning values:\n\n    >>> a[iu1] = -1\n    >>> a\n    array([[-1, -1, -1, -1],\n           [ 4, -1, -1, -1],\n           [ 8,  9, -1, -1],\n           [12, 13, 14, -1]])\n\n    These cover only a small part of the whole array (two diagonals right\n    of the main one):\n\n    >>> a[iu2] = -10\n    >>> a\n    array([[ -1,  -1, -10, -10],\n           [  4,  -1,  -1, -10],\n           [  8,   9,  -1,  -1],\n           [ 12,  13,  14,  -1]])\n    \n    ";
static const char __pyx_k_Return_the_indices_of_the_elemen[] = "Return the indices of the elements that are non-zero.\n\n    Returns a tuple of arrays, one for each dimension of `a`, containing\n    the indices of the non-zero elements in that dimension. The\n    corresponding non-zero values can be obtained with::\n\n        a[nonzero(a)]\n\n    To group the indices by element, rather than dimension, use::\n\n        transpose(nonzero(a))\n\n    The result of this is always a 2-D array, with a row for\n    each non-zero element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    tuple_of_arrays : tuple\n        Indices of elements that are non-zero.\n\n    See Also\n    --------\n    flatnonzero :\n        Return indices that are non-zero in the flattened version of the input\n        array.\n    ndarray.nonzero :\n        Equivalent ndarray method.\n    count_nonzero :\n        Counts the number of non-zero elements in the input array.\n\n    Examples\n    --------\n    >>> x = np.eye(3)\n    >>> x\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 0.,  0.,  1.]])\n    >>> np.nonzero(x)\n    (array([0, 1, 2]), array([0, 1, 2]))\n\n    >>> x[np.nonzero(x)]\n    array([ 1.,  1.,  1.])\n    >>> np.transpose(np.nonzero(x))\n    array([[0, 0],\n           [1, 1],\n           [2, 2]])\n\n    A common use for ``nonzero`` is to find the indices of an array, where\n    a condition is True.  Given an array `a`, the condition `a` > 3 is a\n    boolean array and since False is interpreted as 0, np.nonzero(a > 3)\n    yields the indices of the `a` where the condition is true.\n\n    >>> a = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    >>> a > 3\n    array([[False, False, False],\n           [ True,  True,  True],\n           [ True,  True,  True]], dtype=bool)\n    >>> np.nonzero(a > 3)\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    The ``nonzero`` method of the boolean array can also be called.\n\n    >>> (a > 3).nonzero()\n    (array([1, 1, 1, ""2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n    \n    ";
static const char __pyx_k_Return_the_indices_to_access_n_n[] = "Return the indices to access (n, n) arrays, given a masking function.\n\n    Assume `mask_func` is a function that, for a square array a of size\n    ``(n, n)`` with a possible offset argument `k`, when called as\n    ``mask_func(a, k)`` returns a new array with zeros in certain locations\n    (functions like `triu` or `tril` do precisely this). Then this function\n    returns the indices where the non-zero values would be located.\n\n    Parameters\n    ----------\n    n : int\n        The returned indices will be valid to access arrays of shape (n, n).\n    mask_func : callable\n        A function whose call signature is similar to that of `triu`, `tril`.\n        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n        `k` is an optional argument to the function.\n    k : scalar\n        An optional argument which is passed through to `mask_func`. Functions\n        like `triu`, `tril` take a second argument that is interpreted as an\n        offset.\n\n    Returns\n    -------\n    indices : tuple of arrays.\n        The `n` arrays of indices corresponding to the locations where\n        ``mask_func(np.ones((n, n)), k)`` is True.\n\n    See Also\n    --------\n    triu, tril, triu_indices, tril_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    These are the indices that would allow you to access the upper triangular\n    part of any 3x3 array:\n\n    >>> iu = np.mask_indices(3, np.triu)\n\n    For example, if `a` is a 3x3 array:\n\n    >>> a = np.arange(9).reshape(3, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n    >>> a[iu]\n    array([0, 1, 2, 4, 5, 8])\n\n    An offset can be passed also to the masking function.  This gets us the\n    indices starting on the first diagonal right of the main one:\n\n    >>> iu1 = np.mask_indices(3, np.triu, 1)\n\n    with which we now extract only three elements:\n\n    >>> a[iu1]\n    array([1, 2, 5])\n    \n    ";
static const char __pyx_k_Return_the_indices_to_access_the[] = "Return the indices to access the main diagonal of an array.\n\n    This returns a tuple of indices that can be used to access the main\n    diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape\n    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for\n    ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``\n    for ``i = [0..n-1]``.\n\n    Parameters\n    ----------\n    n : int\n      The size, along each dimension, of the arrays for which the returned\n      indices can be used.\n\n    ndim : int, optional\n      The number of dimensions.\n\n    See also\n    --------\n    diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Create a set of indices to access the diagonal of a (4, 4) array:\n\n    >>> di = np.diag_indices(4)\n    >>> di\n    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> a[di] = 100\n    >>> a\n    array([[100,   1,   2,   3],\n           [  4, 100,   6,   7],\n           [  8,   9, 100,  11],\n           [ 12,  13,  14, 100]])\n\n    Now, we create indices to manipulate a 3-D array:\n\n    >>> d3 = np.diag_indices(2, 3)\n    >>> d3\n    (array([0, 1]), array([0, 1]), array([0, 1]))\n\n    And use it to set the diagonal of an array of zeros to 1:\n\n    >>> a = np.zeros((2, 2, 2), dtype=np.int)\n    >>> a[d3] = 1\n    >>> a\n    array([[[1, 0],\n            [0, 0]],\n           [[0, 0],\n            [0, 1]]])\n    \n    ";
static const char __pyx_k_Return_the_maximum_of_an_array_o[] = "Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  Must be of\n        the same shape and buffer length as the expected output.  See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    nanmax : NaN values are ignored instead of being propagated.\n    fmax : same behavior as the C99 fmax function.\n    argmax : indices of the maximum values.\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well.  To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)\n    3\n    >>> np.amax(a, axis=0)\n    array([2, 3])\n    >>> np.amax(a, axis=1)\n    array([1, 3])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.nanmax(b)\n    4.0\n    \n    ";
static const char __pyx_k_Return_the_minimum_of_an_array_o[] = "Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default a flattened input is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    nanmin: nan values are ignored instead of being propagated\n    fmin: same behavior as the C99 fmin function\n    argmin: Return the indices of the minimum values.\n\n    amax, nanmax, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is nan, the\n    corresponding min value will be nan as well. To ignore NaN values (matlab\n    behavior), please use nanmin.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)         # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)         # Minima along the second axis\n    array([0, 2])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.nanmin(b)\n    0.0\n    \n    ";
static const char __pyx_k_Return_the_number_of_elements_al[] = "Return the number of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which the elements are counted.  By default, give\n        the total number of elements.\n\n    Returns\n    -------\n    element_count : int\n        Number of elements along the specified axis.\n\n    See Also\n    --------\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n    ndarray.size : number of elements in array\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3],[4,5,6]])\n    >>> np.size(a)\n    6\n    >>> np.size(a,1)\n    3\n    >>> np.size(a,0)\n    2\n    \n    ";
static const char __pyx_k_Return_the_product_of_array_elem[] = "Return the product of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis over which the product is taken.  By default, the product\n        of all elements is calculated.\n    dtype : data-type, optional\n        The data-type of the returned array, as well as of the accumulator\n        in which the elements are multiplied.  By default, if `a` is of\n        integer type, `dtype` is the default platform integer. (Note: if\n        the type of `a` is unsigned, then so is `dtype`.)  Otherwise,\n        the dtype is the same as that of `a`.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the\n        output values will be cast if necessary.\n\n    Returns\n    -------\n    product_along_axis : ndarray, see `dtype` parameter above.\n        An array shaped as `a` but with the specified axis removed.\n        Returns a reference to `out` if specified.\n\n    See Also\n    --------\n    ndarray.prod : equivalent method\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.  That means that, on a 32-bit platform:\n\n    >>> x = np.array([536870910, 536870910, 536870910, 536870910])\n    >>> np.prod(x) #random\n    16\n\n    Examples\n    --------\n    By default, calculate the product of all elements:\n\n    >>> np.prod([1.,2.])\n    2.0\n\n    Even when the input array is two-dimensional:\n\n    >>> np.prod([[1.,2.],[3.,4.]])\n    24.0\n\n    But we can also specify the axis over which to multiply:\n\n    >>> np.prod([[1.,2.],[3.,4.]], axis=1)\n    array([  2.,  12.])\n\n    If the type of `x` is unsigned, then the output type is\n    the unsigned platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.uint8)\n    >>> np.prod(x).dtype ""== np.uint\n    True\n\n    If `x` is of a signed integer type, then the output type\n    is the default platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.int8)\n    >>> np.prod(x).dtype == np.int\n    True\n    \n    ";
static const char __pyx_k_Return_the_real_part_of_the_elem[] = "Return the real part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real_if_close, imag, angle\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.real\n    array([ 1.,  3.,  5.])\n    >>> a.real = 9\n    >>> a\n    array([ 9.+2.j,  9.+4.j,  9.+6.j])\n    >>> a.real = np.array([9, 8, 7])\n    >>> a\n    array([ 9.+2.j,  8.+4.j,  7.+6.j])\n    \n    ";
static const char __pyx_k_Return_the_roots_of_a_polynomial[] = "Return the roots of a polynomial with coefficients given in p.\n\n    The values in the rank-1 array `p` are coefficients of a polynomial.\n    If the length of `p` is n+1 then the polynomial is described by::\n\n      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\n    Parameters\n    ----------\n    p : array_like\n        Rank-1 array of polynomial coefficients.\n\n    Returns\n    -------\n    out : ndarray\n        An array containing the complex roots of the polynomial.\n\n    Raises\n    ------\n    ValueError :\n        When `p` cannot be converted to a rank-1 array.\n\n    See also\n    --------\n    poly : Find the coefficients of a polynomial with a given sequence\n           of roots.\n    polyval : Evaluate a polynomial at a point.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    The algorithm relies on computing the eigenvalues of the\n    companion matrix [1]_.\n\n    References\n    ----------\n    .. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:\n        Cambridge University Press, 1999, pp. 146-7.\n\n    Examples\n    --------\n    >>> coeff = [3.2, 2, 1]\n    >>> np.roots(coeff)\n    array([-0.3125+0.46351241j, -0.3125-0.46351241j])\n    \n    ";
static const char __pyx_k_Return_the_scalar_dtype_or_NumPy[] = "Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Parameters\n    ----------\n    rep : any\n        The object of which the type is returned.\n    default : any, optional\n        If given, this is returned for objects whose types can not be\n        determined. If not given, None is returned for those objects.\n\n    Returns\n    -------\n    dtype : dtype or Python type\n        The data type of `rep`.\n\n    See Also\n    --------\n    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype\n\n    Examples\n    --------\n    >>> np.obj2sctype(np.int32)\n    <type 'numpy.int32'>\n    >>> np.obj2sctype(np.array([1., 2.]))\n    <type 'numpy.float64'>\n    >>> np.obj2sctype(np.array([1.j]))\n    <type 'numpy.complex128'>\n\n    >>> np.obj2sctype(dict)\n    <type 'numpy.object_'>\n    >>> np.obj2sctype('string')\n    <type 'numpy.string_'>\n\n    >>> np.obj2sctype(1, default=list)\n    <type 'list'>\n    \n    ";
static const char __pyx_k_Return_the_scalar_type_of_highes[] = "Return the scalar type of highest precision of the same kind as the input.\n\n    Parameters\n    ----------\n    t : dtype or dtype specifier\n        The input data type. This can be a `dtype` object or an object that\n        is convertible to a `dtype`.\n\n    Returns\n    -------\n    out : dtype\n        The highest precision data type of the same kind (`dtype.kind`) as `t`.\n\n    See Also\n    --------\n    obj2sctype, mintypecode, sctype2char\n    dtype\n\n    Examples\n    --------\n    >>> np.maximum_sctype(np.int)\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype(np.uint8)\n    <type 'numpy.uint64'>\n    >>> np.maximum_sctype(np.complex)\n    <type 'numpy.complex192'>\n\n    >>> np.maximum_sctype(str)\n    <type 'numpy.string_'>\n\n    >>> np.maximum_sctype('i2')\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype('f4')\n    <type 'numpy.float96'>\n    \n    ";
static const char __pyx_k_Return_the_sinc_function_The_sin[] = "Return the sinc function.\n\n    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array (possibly multi-dimensional) of values for which to to\n        calculate ``sinc(x)``.\n\n    Returns\n    -------\n    out : ndarray\n        ``sinc(x)``, which has the same shape as the input.\n\n    Notes\n    -----\n    ``sinc(0)`` is the limit value 1.\n\n    The name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\n    The sinc function is used in various signal processing applications,\n    including in anti-aliasing, in the construction of a\n    Lanczos resampling filter, and in interpolation.\n\n    For bandlimited interpolation of discrete-time signals, the ideal\n    interpolation kernel is proportional to the sinc function.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n           Resource. http://mathworld.wolfram.com/SincFunction.html\n    .. [2] Wikipedia, \"Sinc function\",\n           http://en.wikipedia.org/wiki/Sinc_function\n\n    Examples\n    --------\n    >>> x = np.arange(-20., 21.)/5.\n    >>> np.sinc(x)\n    array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n             6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n             8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n             3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n             7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n             9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n             2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n            -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n            -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n             1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n            -5.84680802e-02,""  -8.90384387e-02,  -8.40918587e-02,\n            -4.92362781e-02,  -3.89804309e-17])\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, np.sinc(x))\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Sinc Function\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"X\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    It works in 2-D as well:\n\n    >>> x = np.arange(-200., 201.)/50.\n    >>> xx = np.outer(x, x)\n    >>> plt.imshow(np.sinc(xx))\n    <matplotlib.image.AxesImage object at 0x...>\n    \n    ";
static const char __pyx_k_Return_the_string_representation[] = "Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters split the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero, default is False. Very small\n        is defined by `precision`, if the precision is 8 then\n        numbers smaller than 5e-9 are represented as zero.\n\n    Returns\n    -------\n    string : str\n      The string representation of an array.\n\n    See Also\n    --------\n    array_str, array2string, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_repr(np.array([1,2]))\n    'array([1, 2])'\n    >>> np.array_repr(np.ma.array([0.]))\n    'MaskedArray([ 0.])'\n    >>> np.array_repr(np.array([], np.int32))\n    'array([], dtype=int32)'\n\n    >>> x = np.array([1e-6, 4e-7, 2, 3])\n    >>> np.array_repr(x, precision=6, suppress_small=True)\n    'array([ 0.000001,  0.      ,  2.      ,  3.      ])'\n    \n    ";
static const char __pyx_k_Return_the_sum_along_diagonals_o[] = "Return the sum along diagonals of the array.\n\n    If `a` is 2-D, the sum along its diagonal with the given offset\n    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.\n\n    If `a` has more than two dimensions, then the axes specified by axis1 and\n    axis2 are used to determine the 2-D sub-arrays whose traces are returned.\n    The shape of the resulting array is the same as that of `a` with `axis1`\n    and `axis2` removed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal. Can be both positive\n        and negative. Defaults to 0.\n    axis1, axis2 : int, optional\n        Axes to be used as the first and second axis of the 2-D sub-arrays\n        from which the diagonals should be taken. Defaults are the first two\n        axes of `a`.\n    dtype : dtype, optional\n        Determines the data-type of the returned array and of the accumulator\n        where the elements are summed. If dtype has the value None and `a` is\n        of integer type of precision less than the default integer\n        precision, then the default integer precision is used. Otherwise,\n        the precision is the same as that of `a`.\n    out : ndarray, optional\n        Array into which the output is placed. Its type is preserved and\n        it must be of the right shape to hold the output.\n\n    Returns\n    -------\n    sum_along_diagonals : ndarray\n        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has\n        larger dimensions, then an array of sums along diagonals is returned.\n\n    See Also\n    --------\n    diag, diagonal, diagflat\n\n    Examples\n    --------\n    >>> np.trace(np.eye(3))\n    3.0\n    >>> a = np.arange(8).reshape((2,2,2))\n    >>> np.trace(a)\n    array([6, 8])\n\n    >>> a = np.arange(24).reshape((2,2,2,3))\n    >>> np.trace(a).shape\n    (2, 3)\n    \n    ";
static const char __pyx_k_Return_the_sum_of_array_elements[] = "Return the sum of array elements over a given axis treating\n    Not a Numbers (NaNs) as zero.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose sum is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the sum is computed. The default is to compute\n        the sum of the flattened array.\n\n    Returns\n    -------\n    y : ndarray\n        An array with the same shape as a, with the specified axis removed.\n        If a is a 0-d array, or if axis is None, a scalar is returned with\n        the same dtype as `a`.\n\n    See Also\n    --------\n    numpy.sum : Sum across array including Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    If positive or negative infinity are present the result is positive or\n    negative infinity. But if both positive and negative infinity are present,\n    the result is Not A Number (NaN).\n\n    Arithmetic is modular when using integer types (all elements of `a` must\n    be finite i.e. no elements that are NaNs, positive infinity and negative\n    infinity because NaNs are floating point types), and no error is raised\n    on overflow.\n\n\n    Examples\n    --------\n    >>> np.nansum(1)\n    1\n    >>> np.nansum([1])\n    1\n    >>> np.nansum([1, np.nan])\n    1.0\n    >>> a = np.array([[1, 1], [1, np.nan]])\n    >>> np.nansum(a)\n    3.0\n    >>> np.nansum(a, axis=0)\n    array([ 2.,  1.])\n\n    When positive infinity and negative infinity are present\n\n    >>> np.nansum([1, np.nan, np.inf])\n    inf\n    >>> np.nansum([1, np.nan, np.NINF])\n    -inf\n    >>> np.nansum([1, np.nan, np.inf, np.NINF])\n    nan\n   "" \n    ";
static const char __pyx_k_Returns_True_if_array_is_arrange[] = "Returns True if array is arranged in Fortran-order in memory\n    and dimension > 1.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n\n    Examples\n    --------\n\n    np.array allows to specify whether the array is written in C-contiguous\n    order (last index varies the fastest), or FORTRAN-contiguous order in\n    memory (first index varies the fastest).\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')\n    >>> b\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(b)\n    True\n\n\n    The transpose of a C-ordered array is a FORTRAN-ordered array.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n    >>> b = a.T\n    >>> b\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.isfortran(b)\n    True\n\n    1-D arrays always evaluate as False.\n\n    >>> np.isfortran(np.array([1, 2], order='FORTRAN'))\n    False\n    \n    ";
static const char __pyx_k_Returns_True_if_first_argument_i[] = "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype_like\n        dtype or string representing a typecode.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    issubsctype, issubclass_\n    numpy.core.numerictypes : Overview of numpy type hierarchy.\n\n    Examples\n    --------\n    >>> np.issubdtype('S1', str)\n    True\n    >>> np.issubdtype(np.float64, np.float32)\n    False\n    \n    ";
static const char __pyx_k_Returns_True_if_input_arrays_are[] = "Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n    \n    ";
static const char __pyx_k_Returns_True_if_two_arrays_are_e[] = "Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise. If either array contains NaN, then\n        False is returned.\n\n    See Also\n    --------\n    all, any, alltrue, sometrue\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    `allclose(a, b)` might be different from `allclose(b, a)` in\n    some rare cases.\n\n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    \n    ";
static const char __pyx_k_Returns_pointers_to_the_end_poin[] = "Returns pointers to the end-points of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array. It must conform to the Python-side of the array interface.\n\n    Returns\n    -------\n    (low, high) : tuple of 2 integers\n        The first integer is the first byte of the array, the second integer is\n        just past the last byte of the array.  If `a` is not contiguous it\n        will not use every byte between the (`low`, `high`) values.\n\n    Examples\n    --------\n    >>> I = np.eye(2, dtype='f'); I.dtype\n    dtype('float32')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    >>> I = np.eye(2, dtype='G'); I.dtype\n    dtype('complex192')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    \n    ";
static const char __pyx_k_Returns_the_NPV_Net_Present_Valu[] = "Returns the NPV (Net Present Value) of a cash flow series.\n\n    Parameters\n    ----------\n    rate : scalar\n        The discount rate.\n    values : array_like, shape(M, )\n        The values of the time series of cash flows.  The (fixed) time\n        interval between cash flow \"events\" must be the same as that\n        for which `rate` is given (i.e., if `rate` is per year, then\n        precisely a year is understood to elapse between each cash flow\n        event).  By convention, investments or \"deposits\" are negative,\n        income or \"withdrawals\" are positive; `values` must begin with\n        the initial investment, thus `values[0]` will typically be\n        negative.\n\n    Returns\n    -------\n    out : float\n        The NPV of the input cash flow series `values` at the discount `rate`.\n\n    Notes\n    -----\n    Returns the result of: [G]_\n\n    .. math :: \\sum_{t=0}^M{\014rac{values_t}{(1+rate)^{t}}}\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 346.\n\n    Examples\n    --------\n    >>> np.npv(0.281,[-100, 39, 59, 55, 20])\n    -0.0066187288356340801\n\n    (Compare with the Example given for numpy.lib.financial.irr)\n    \n    ";
static const char __pyx_k_Returns_the_discrete_linear_conv[] = "Returns the discrete, linear convolution of two one-dimensional sequences.\n\n    The convolution operator is often seen in signal processing, where it\n    models the effect of a linear time-invariant system on a signal [1]_.  In\n    probability theory, the sum of two independent random variables is\n    distributed according to the convolution of their individual\n    distributions.\n\n    Parameters\n    ----------\n    a : (N,) array_like\n        First one-dimensional input array.\n    v : (M,) array_like\n        Second one-dimensional input array.\n    mode : {'full', 'valid', 'same'}, optional\n        'full':\n          By default, mode is 'full'.  This returns the convolution\n          at each point of overlap, with an output shape of (N+M-1,). At\n          the end-points of the convolution, the signals do not overlap\n          completely, and boundary effects may be seen.\n\n        'same':\n          Mode `same` returns output of length ``max(M, N)``.  Boundary\n          effects are still visible.\n\n        'valid':\n          Mode `valid` returns output of length\n          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given\n          for points where the signals overlap completely.  Values outside\n          the signal boundary have no effect.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete, linear convolution of `a` and `v`.\n\n    See Also\n    --------\n    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier\n                               Transform.\n    scipy.linalg.toeplitz : Used to construct the convolution operator.\n\n    Notes\n    -----\n    The discrete convolution operation is defined as\n\n    .. math:: (f * g)[n] = \\sum_{m = -\\infty}^{\\infty} f[m] g[n - m]\n\n    It can be shown that a convolution :math:`x(t) * y(t)` in time/space\n    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier\n    domain, after appropriate padding (padding is necessary to prevent""\n    circular convolution).  Since multiplication is more efficient (faster)\n    than convolution, the function `scipy.signal.fftconvolve` exploits the\n    FFT to calculate the convolution of large data-sets.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Convolution\", http://en.wikipedia.org/wiki/Convolution.\n\n    Examples\n    --------\n    Note how the convolution operator flips the second array\n    before \"sliding\" the two across one another:\n\n    >>> np.convolve([1, 2, 3], [0, 1, 0.5])\n    array([ 0. ,  1. ,  2.5,  4. ,  1.5])\n\n    Only return the middle values of the convolution.\n    Contains boundary effects, where zeros are taken\n    into account:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'same')\n    array([ 1. ,  2.5,  4. ])\n\n    The two arrays are of the same length, so there\n    is only one position where they completely overlap:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')\n    array([ 2.5])\n    \n    ";
static const char __pyx_k_Returns_the_indices_that_would_s[] = "Returns the indices that would sort an array.\n\n    Perform an indirect sort along the given axis using the algorithm specified\n    by the `kind` keyword. It returns an array of indices of the same shape as\n    `a` that index data along the given axis in sorted order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    axis : int or None, optional\n        Axis along which to sort.  The default is -1 (the last axis). If None,\n        the flattened array is used.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    order : list, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  Not all fields need be\n        specified.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that sort `a` along the specified axis.\n        In other words, ``a[index_array]`` yields a sorted `a`.\n\n    See Also\n    --------\n    sort : Describes sorting algorithms used.\n    lexsort : Indirect stable sort with multiple keys.\n    ndarray.sort : Inplace sort.\n\n    Notes\n    -----\n    See `sort` for notes on the different sorting algorithms.\n\n    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing\n    nan values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> x = np.array([3, 1, 2])\n    >>> np.argsort(x)\n    array([1, 2, 0])\n\n    Two-dimensional array:\n\n    >>> x = np.array([[0, 3], [2, 2]])\n    >>> x\n    array([[0, 3],\n           [2, 2]])\n\n    >>> np.argsort(x, axis=0)\n    array([[0, 1],\n           [1, 0]])\n\n    >>> np.argsort(x, axis=1)\n    array([[0, 1],\n           [0, 1]])\n\n    Sorting with keys:\n\n    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])\n    >>> x\n    array([(1, 0), (0, 1)],\n          dtype=[('x', '<i4'), ('y', '<i4')])\n\n    >>> np.argsor""t(x, order=('x','y'))\n    array([1, 0])\n\n    >>> np.argsort(x, order=('y','x'))\n    array([0, 1])\n    \n    ";
static const char __pyx_k_Returns_the_quotient_and_remaind[] = "Returns the quotient and remainder of polynomial division.\n\n    The input arrays are the coefficients (including any coefficients\n    equal to zero) of the \"numerator\" (dividend) and \"denominator\"\n    (divisor) polynomials, respectively.\n\n    Parameters\n    ----------\n    u : array_like or poly1d\n        Dividend polynomial's coefficients.\n\n    v : array_like or poly1d\n        Divisor polynomial's coefficients.\n\n    Returns\n    -------\n    q : ndarray\n        Coefficients, including those equal to zero, of the quotient.\n    r : ndarray\n        Coefficients, including those equal to zero, of the remainder.\n\n    See Also\n    --------\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,\n    polyval\n\n    Notes\n    -----\n    Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need\n    not equal `v.ndim`. In other words, all four possible combinations -\n    ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,\n    ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.\n\n    Examples\n    --------\n    .. math:: \014rac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\n\n    >>> x = np.array([3.0, 5.0, 2.0])\n    >>> y = np.array([2.0, 1.0])\n    >>> np.polydiv(x, y)\n    (array([ 1.5 ,  1.75]), array([ 0.25]))\n    \n    ";
static const char __pyx_k_Roll_array_elements_along_a_give[] = "Roll array elements along a given axis.\n\n    Elements that roll beyond the last position are re-introduced at\n    the first.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    shift : int\n        The number of places by which elements are shifted.\n    axis : int, optional\n        The axis along which elements are shifted.  By default, the array\n        is flattened before shifting, after which the original\n        shape is restored.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, with the same shape as `a`.\n\n    See Also\n    --------\n    rollaxis : Roll the specified axis backwards, until it lies in a\n               given position.\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> np.roll(x, 2)\n    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n\n    >>> x2 = np.reshape(x, (2,5))\n    >>> x2\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> np.roll(x2, 1)\n    array([[9, 0, 1, 2, 3],\n           [4, 5, 6, 7, 8]])\n    >>> np.roll(x2, 1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, 1, axis=1)\n    array([[4, 0, 1, 2, 3],\n           [9, 5, 6, 7, 8]])\n    \n    ";
static const char __pyx_k_Roll_the_specified_axis_backward[] = "Roll the specified axis backwards, until it lies in a given position.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    axis : int\n        The axis to roll backwards.  The positions of the other axes do not\n        change relative to one another.\n    start : int, optional\n        The axis is rolled until it lies before this position.  The default,\n        0, results in a \"complete\" roll.\n\n    Returns\n    -------\n    res : ndarray\n        Output array.\n\n    See Also\n    --------\n    roll : Roll the elements of an array by a number of positions along a\n        given axis.\n\n    Examples\n    --------\n    >>> a = np.ones((3,4,5,6))\n    >>> np.rollaxis(a, 3, 1).shape\n    (3, 6, 4, 5)\n    >>> np.rollaxis(a, 2).shape\n    (5, 3, 4, 6)\n    >>> np.rollaxis(a, 1, 4).shape\n    (3, 5, 6, 4)\n    \n    ";
static const char __pyx_k_Rotate_an_array_by_90_degrees_in[] = "Rotate an array by 90 degrees in the counter-clockwise direction.\n\n    The first two dimensions are rotated; therefore, the array must be at\n    least 2-D.\n\n    Parameters\n    ----------\n    m : array_like\n        Array of two or more dimensions.\n    k : integer\n        Number of times the array is rotated by 90 degrees.\n\n    Returns\n    -------\n    y : ndarray\n        Rotated array.\n\n    See Also\n    --------\n    fliplr : Flip an array horizontally.\n    flipud : Flip an array vertically.\n\n    Examples\n    --------\n    >>> m = np.array([[1,2],[3,4]], int)\n    >>> m\n    array([[1, 2],\n           [3, 4]])\n    >>> np.rot90(m)\n    array([[2, 4],\n           [1, 3]])\n    >>> np.rot90(m, 2)\n    array([[4, 3],\n           [2, 1]])\n    \n    ";
static const char __pyx_k_Round_to_nearest_integer_towards[] = "Round to nearest integer towards zero.\n\n    Round an array of floats element-wise to nearest integer towards zero.\n    The rounded values are returned as floats.\n\n    Parameters\n    ----------\n    x : array_like\n        An array of floats to be rounded\n    y : ndarray, optional\n        Output array\n\n    Returns\n    -------\n    out : ndarray of floats\n        The array of rounded numbers\n\n    See Also\n    --------\n    trunc, floor, ceil\n    around : Round to given number of decimals\n\n    Examples\n    --------\n    >>> np.fix(3.14)\n    3.0\n    >>> np.fix(3)\n    3.0\n    >>> np.fix([2.1, 2.9, -2.1, -2.9])\n    array([ 2.,  2., -2., -2.])\n    \n    ";
static const char __pyx_k_Save_an_array_to_a_binary_file_i[] = "Save an array to a binary file in NumPy ``.npy`` format.\n\n    Parameters\n    ----------\n    file : file or str\n        File or filename to which the data is saved.  If file is a file-object,\n        then the filename is unchanged.  If file is a string, a ``.npy``\n        extension will be appended to the file name if it does not already\n        have one.\n    arr : array_like\n        Array data to be saved.\n\n    See Also\n    --------\n    savez : Save several arrays into a ``.npz`` archive\n    savetxt, load\n\n    Notes\n    -----\n    For a description of the ``.npy`` format, see `format`.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n\n    >>> x = np.arange(10)\n    >>> np.save(outfile, x)\n\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> np.load(outfile)\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    \n    ";
static const char __pyx_k_Save_an_array_to_a_text_file_Par[] = "Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename or file handle\n        If the filename ends in ``.gz``, the file is automatically saved in\n        compressed gzip format.  `loadtxt` understands gzipped files\n        transparently.\n    X : array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored.\n    delimiter : str\n        Character separating columns.\n    newline : str\n        .. versionadded:: 1.5.0\n\n        Character separating lines.\n\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy ``.npy`` format\n    savez : Save several arrays into a ``.npz`` compressed archive\n\n    Notes\n    -----\n    Further explanation of the `fmt` parameter\n    (``%[flag]width[.precision]specifier``):\n\n    flags:\n        ``-`` : left justify\n\n        ``+`` : Forces to preceed result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters.\n\n    specifiers:\n        ``c`` : character\n\n        ``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : un""signed decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <http://docs.python.org/library/string.html#\n           format-specification-mini-language>`_, Python Documentation.\n\n    Examples\n    --------\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n    \n    ";
static const char __pyx_k_Save_several_arrays_into_a_singl[] = "Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    If arguments are passed in with no keywords, the corresponding variable\n    names, in the .npz file, are 'arr_0', 'arr_1', etc. If keyword arguments\n    are given, the corresponding variable names, in the ``.npz`` file will\n    match the keyword names.\n\n    Parameters\n    ----------\n    file : str or file\n        Either the file name (string) or an open file (file-like object)\n        where the data will be saved. If file is a string, the ``.npz``\n        extension will be appended to the file name if it is not already there.\n    *args : Arguments, optional\n        Arrays to save to the file. Since it is not possible for Python to\n        know the names of the arrays outside `savez`, the arrays will be saved\n        with names \"arr_0\", \"arr_1\", and so on. These arguments can be any\n        expression.\n    **kwds : Keyword arguments, optional\n        Arrays to save to the file. Arrays will be saved in the file with the\n        keyword names.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    save : Save a single array to a binary file in NumPy format.\n    savetxt : Save an array to a file as plain text.\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is not compressed and each file\n    in the archive contains one variable in ``.npy`` format. For a\n    description of the ``.npy`` format, see `format`.\n\n    When opening the saved ``.npz`` file with `load` a `NpzFile` object is\n    returned. This is a dictionary-like object which can be queried for\n    its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n    >>> x = np.arange(10)\n    >>> y = np.sin(x)\n\n    Using `savez` with *args, the arrays are saved wit""h default names.\n\n    >>> np.savez(outfile, x, y)\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['arr_1', 'arr_0']\n    >>> npzfile['arr_0']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    Using `savez` with **kwds, the arrays are saved with the keyword names.\n\n    >>> outfile = TemporaryFile()\n    >>> np.savez(outfile, x=x, y=y)\n    >>> outfile.seek(0)\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['y', 'x']\n    >>> npzfile['x']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    See Also\n    --------\n    numpy.savez_compressed : Save several arrays into a compressed .npz file format\n    \n    ";
static const char __pyx_k_Set_a_Python_function_to_be_used[] = "Set a Python function to be used when pretty printing arrays.\n\n    Parameters\n    ----------\n    f : function or None\n        Function to be used to pretty print arrays. The function should expect\n        a single array argument and return a string of the representation of\n        the array. If None, the function is reset to the default NumPy function\n        to print arrays.\n    repr : bool, optional\n        If True (default), the function for pretty printing (``__repr__``)\n        is set, if False the function that returns the default string\n        representation (``__str__``) is set.\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    Examples\n    --------\n    >>> def pprint(arr):\n    ...     return 'HA! - What are you going to do now?'\n    ...\n    >>> np.set_string_function(pprint)\n    >>> a = np.arange(10)\n    >>> a\n    HA! - What are you going to do now?\n    >>> print a\n    [0 1 2 3 4 5 6 7 8 9]\n\n    We can reset the function to the default:\n\n    >>> np.set_string_function(None)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    `repr` affects either pretty printing or normal string representation.\n    Note that ``__repr__`` is still affected by setting ``__str__``\n    because the width of each array element in the returned string becomes\n    equal to the length of the result of ``__str__()``.\n\n    >>> x = np.arange(4)\n    >>> np.set_string_function(lambda x:'random', repr=False)\n    >>> x.__str__()\n    'random'\n    >>> x.__repr__()\n    'array([     0,      1,      2,      3])'\n    \n    ";
static const char __pyx_k_Set_how_floating_point_errors_ar[] = "Set how floating-point errors are handled.\n\n    Note that operations on integer scalar types (such as `int16`) are\n    handled like floating point, and are affected by these settings.\n\n    Parameters\n    ----------\n    all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Set treatment for all types of floating-point errors at once:\n\n        - ignore: Take no action when the exception occurs.\n        - warn: Print a `RuntimeWarning` (via the Python `warnings` module).\n        - raise: Raise a `FloatingPointError`.\n        - call: Call a function specified using the `seterrcall` function.\n        - print: Print a warning directly to ``stdout``.\n        - log: Record error in a Log object specified by `seterrcall`.\n\n        The default is not to change the current behavior.\n    divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for division by zero.\n    over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point overflow.\n    under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point underflow.\n    invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for invalid floating-point operation.\n\n    Returns\n    -------\n    old_settings : dict\n        Dictionary containing the old settings.\n\n    See also\n    --------\n    seterrcall : Set a callback function for the 'call' mode.\n    geterr, geterrcall\n\n    Notes\n    -----\n    The floating-point exceptions are defined in the IEEE 754 standard [1]:\n\n    - Division by zero: infinite result obtained from finite numbers.\n    - Overflow: result too large to be expressed.\n    - Underflow: result so close to zero that some precision\n      was lost.\n    - Invalid operation: result is not an expressible number, typically\n      indicates that a NaN was produced.\n\n    .. [1] http://en.wikipedia.org/wiki/""IEEE_754\n\n    Examples\n    --------\n    >>> old_settings = np.seterr(all='ignore')  #seterr to known value\n    >>> np.seterr(over='raise')\n    {'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',\n     'under': 'ignore'}\n    >>> np.seterr(all='ignore')  # reset to default\n    {'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}\n\n    >>> np.int16(32000) * np.int16(3)\n    30464\n    >>> old_settings = np.seterr(all='warn', over='raise')\n    >>> np.int16(32000) * np.int16(3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    FloatingPointError: overflow encountered in short_scalars\n\n    >>> old_settings = np.seterr(all='print')\n    >>> np.geterr()\n    {'over': 'print', 'divide': 'print', 'invalid': 'print', 'under': 'print'}\n    >>> np.int16(32000) * np.int16(3)\n    Warning: overflow encountered in short_scalars\n    30464\n    \n    ";
static const char __pyx_k_Set_printing_options_These_optio[] = "Set printing options.\n\n    These options determine the way floating point numbers, arrays and\n    other NumPy objects are displayed.\n\n    Parameters\n    ----------\n    precision : int, optional\n        Number of digits of precision for floating point output (default 8).\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr (default 1000).\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension (default 3).\n    linewidth : int, optional\n        The number of characters per line for the purpose of inserting\n        line breaks (default 75).\n    suppress : bool, optional\n        Whether or not suppress printing of small floating point values\n        using scientific notation (default False).\n    nanstr : str, optional\n        String representation of floating point not-a-number (default nan).\n    infstr : str, optional\n        String representation of floating point infinity (default inf).\n\n    See Also\n    --------\n    get_printoptions, set_string_function\n\n    Examples\n    --------\n    Floating point precision can be set:\n\n    >>> np.set_printoptions(precision=4)\n    >>> print np.array([1.123456789])\n    [ 1.1235]\n\n    Long arrays can be summarised:\n\n    >>> np.set_printoptions(threshold=5)\n    >>> print np.arange(10)\n    [0 1 2 ..., 7 8 9]\n\n    Small results can be suppressed:\n\n    >>> eps = np.finfo(float).eps\n    >>> x = np.arange(4.)\n    >>> x**2 - (x + eps)**2\n    array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])\n    >>> np.set_printoptions(suppress=True)\n    >>> x**2 - (x + eps)**2\n    array([-0., -0.,  0.,  0.])\n\n    To put back the default options, you can use:\n\n    >>> np.set_printoptions(edgeitems=3,infstr='Inf',\n    ... linewidth=75, nanstr='NaN', precision=8,\n    ... suppress=False, threshold=1000)\n    \n    ";
static const char __pyx_k_Set_the_floating_point_error_cal[] = "Set the floating-point error callback function or log object.\n\n    There are two ways to capture floating-point error messages.  The first\n    is to set the error-handler to 'call', using `seterr`.  Then, set\n    the function to call using this function.\n\n    The second is to set the error-handler to 'log', using `seterr`.\n    Floating-point errors then trigger a call to the 'write' method of\n    the provided object.\n\n    Parameters\n    ----------\n    func : callable f(err, flag) or object with write method\n        Function to call upon floating-point errors ('call'-mode) or\n        object whose 'write' method is used to log such message ('log'-mode).\n\n        The call function takes two arguments. The first is the\n        type of error (one of \"divide\", \"over\", \"under\", or \"invalid\"),\n        and the second is the status flag.  The flag is a byte, whose\n        least-significant bits indicate the status::\n\n          [0 0 0 0 invalid over under invalid]\n\n        In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n        If an object is provided, its write method should take one argument,\n        a string.\n\n    Returns\n    -------\n    h : callable, log instance or None\n        The old error handler.\n\n    See Also\n    --------\n    seterr, geterr, geterrcall\n\n    Examples\n    --------\n    Callback upon error:\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n\n    >>> saved_handler = np.seterrcall(err_handler)\n    >>> save_err = np.seterr(all='call')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <function err_handler at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'call', 'divide': 'call', 'invalid': 'call', 'under': 'call'}\n\n    Log error message:\n\n    >>> class Log(object):\n    ...     def writ""e(self, msg):\n    ...         print \"LOG: %s\" % msg\n    ...\n\n    >>> log = Log()\n    >>> saved_handler = np.seterrcall(log)\n    >>> save_err = np.seterr(all='log')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    LOG: Warning: divide by zero encountered in divide\n    <BLANKLINE>\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <__main__.Log object at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'log', 'divide': 'log', 'invalid': 'log', 'under': 'log'}\n    \n    ";
static const char __pyx_k_Sort_a_complex_array_using_the_r[] = "Sort a complex array using the real part first, then the imaginary part.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n\n    Returns\n    -------\n    out : complex ndarray\n        Always returns a sorted complex array.\n\n    Examples\n    --------\n    >>> np.sort_complex([5, 3, 6, 2, 1])\n    array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])\n\n    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\n    array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n    \n    ";
static const char __pyx_k_Split_an_array_into_multiple_sub[] = "Split an array into multiple sub-arrays of equal or near-equal size.\n\n    Please refer to the ``split`` documentation.  The only difference\n    between these functions is that ``array_split`` allows\n    `indices_or_sections` to be an integer that does *not* equally\n    divide the axis.\n\n    See Also\n    --------\n    split : Split array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(8.0)\n    >>> np.array_split(x, 3)\n        [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]\n    \n    ";
static const char __pyx_k_Split_array_into_multiple_sub_ar[] = "Split array into multiple sub-arrays along the 3rd axis (depth).\n\n    Please refer to the `split` documentation.  `dsplit` is equivalent\n    to `split` with ``axis=2``, the array is always split along the third\n    axis provided the array dimension is greater than or equal to 3.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(2, 2, 4)\n    >>> x\n    array([[[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.]],\n           [[  8.,   9.,  10.,  11.],\n            [ 12.,  13.,  14.,  15.]]])\n    >>> np.dsplit(x, 2)\n    [array([[[  0.,   1.],\n            [  4.,   5.]],\n           [[  8.,   9.],\n            [ 12.,  13.]]]),\n     array([[[  2.,   3.],\n            [  6.,   7.]],\n           [[ 10.,  11.],\n            [ 14.,  15.]]])]\n    >>> np.dsplit(x, np.array([3, 6]))\n    [array([[[  0.,   1.,   2.],\n            [  4.,   5.,   6.]],\n           [[  8.,   9.,  10.],\n            [ 12.,  13.,  14.]]]),\n     array([[[  3.],\n            [  7.]],\n           [[ 11.],\n            [ 15.]]]),\n     array([], dtype=float64)]\n    \n    ";
static const char __pyx_k_Stack_1_D_arrays_as_columns_into[] = "Stack 1-D arrays as columns into a 2-D array.\n\n    Take a sequence of 1-D arrays and stack them as columns\n    to make a single 2-D array. 2-D arrays are stacked as-is,\n    just like with `hstack`.  1-D arrays are turned into 2-D columns\n    first.\n\n    Parameters\n    ----------\n    tup : sequence of 1-D or 2-D arrays.\n        Arrays to stack. All of them must have the same first dimension.\n\n    Returns\n    -------\n    stacked : 2-D array\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack, vstack, concatenate\n\n    Notes\n    -----\n    This function is equivalent to ``np.vstack(tup).T``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.column_stack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static const char __pyx_k_Stack_arrays_in_sequence_depth_w[] = "Stack arrays in sequence depth wise (along third axis).\n\n    Takes a sequence of arrays and stack them along the third axis\n    to make a single array. Rebuilds arrays divided by `dsplit`.\n    This is a simple way to stack 2D arrays (images) into a single\n    3D array for processing.\n\n    Parameters\n    ----------\n    tup : sequence of arrays\n        Arrays to stack. All of them must have the same shape along all\n        but the third axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack along first axis.\n    hstack : Stack along second axis.\n    concatenate : Join arrays.\n    dsplit : Split array along third axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=2)``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.dstack((a,b))\n    array([[[1, 2],\n            [2, 3],\n            [3, 4]]])\n\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.dstack((a,b))\n    array([[[1, 2]],\n           [[2, 3]],\n           [[3, 4]]])\n    \n    ";
static const char __pyx_k_Stack_arrays_in_sequence_horizon[] = "Stack arrays in sequence horizontally (column wise).\n\n    Take a sequence of arrays and stack them horizontally to make\n    a single array. Rebuild arrays divided by `hsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        All arrays must have the same shape along all but the second axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    concatenate : Join a sequence of arrays together.\n    hsplit : Split array along second axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=1)``\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.hstack((a,b))\n    array([1, 2, 3, 2, 3, 4])\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.hstack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static const char __pyx_k_Stack_arrays_in_sequence_vertica[] = "Stack arrays in sequence vertically (row wise).\n\n    Take a sequence of arrays and stack them vertically to make a single\n    array. Rebuild arrays divided by `vsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        Tuple containing arrays to be stacked. The arrays must have the same\n        shape along all but the first axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays together.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=0)``\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n    \n    ";
static const char __pyx_k_Sum_of_array_elements_over_a_giv[] = "Sum of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Elements to sum.\n    axis : integer, optional\n        Axis over which the sum is taken. By default `axis` is None,\n        and all elements are summed.\n    dtype : dtype, optional\n        The type of the returned array and of the accumulator in which\n        the elements are summed.  By default, the dtype of `a` is used.\n        An exception is when `a` has an integer type with less precision\n        than the default platform integer.  In that case, the default\n        platform integer is used instead.\n    out : ndarray, optional\n        Array into which the output is placed.  By default, a new array is\n        created.  If `out` is given, it must be of the appropriate shape\n        (the shape of `a` with `axis` removed, i.e.,\n        ``numpy.delete(a.shape, axis)``).  Its type is preserved. See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    sum_along_axis : ndarray\n        An array with the same shape as `a`, with the specified\n        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n        is returned.  If an output array is specified, a reference to\n        `out` is returned.\n\n    See Also\n    --------\n    ndarray.sum : Equivalent method.\n\n    cumsum : Cumulative sum of array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    mean, average\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> np.sum([0.5, 1.5])\n    2.0\n    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n    1\n    >>> np.sum([[0, 1], [0, 5]])\n    6\n    >>> np.sum([[0, 1], [0, 5]], axis=0)\n    array([0, 6])\n    >>> np.sum([[0, 1], [0, 5]], axis=1)\n    array([1, 5])\n\n    If the accumulator is too small, overflow occurs:\n\n    >>> np.one""s(128, dtype=np.int8).sum(dtype=np.int8)\n    -128\n    \n    ";
static const char __pyx_k_Take_elements_from_an_array_alon[] = "Take elements from an array along an axis.\n\n    This function does the same thing as \"fancy\" indexing (indexing arrays\n    using arrays); however, it can be easier to use if you need elements\n    along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        The source array.\n    indices : array_like\n        The indices of the values to extract.\n    axis : int, optional\n        The axis over which to select values. By default, the flattened\n        input array is used.\n    out : ndarray, optional\n        If provided, the result will be placed in this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    Returns\n    -------\n    subarray : ndarray\n        The returned array has the same type as `a`.\n\n    See Also\n    --------\n    ndarray.take : equivalent method\n\n    Examples\n    --------\n    >>> a = [4, 3, 5, 7, 6, 8]\n    >>> indices = [0, 1, 4]\n    >>> np.take(a, indices)\n    array([4, 3, 6])\n\n    In this example if `a` is an ndarray, \"fancy\" indexing can be used.\n\n    >>> a = np.array(a)\n    >>> a[indices]\n    array([4, 3, 6])\n    \n    ";
static const char __pyx_k_Test_element_wise_for_negative_i[] = "Test element-wise for negative infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape and type as `x` to store the\n        result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a numpy boolean array is\n        returned with values True where the corresponding element of the\n        input is negative infinity and values False where the element of\n        the input is not negative infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True. The\n        return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isposinf, isnan, isfinite\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isneginf(np.NINF)\n    array(True, dtype=bool)\n    >>> np.isneginf(np.inf)\n    array(False, dtype=bool)\n    >>> np.isneginf(np.PINF)\n    array(False, dtype=bool)\n    >>> np.isneginf([-np.inf, 0., np.inf])\n    array([ True, False, False], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isneginf(x, y)\n    array([1, 0, 0])\n    >>> y\n    array([1, 0, 0])\n    \n    ";
static const char __pyx_k_Test_element_wise_for_positive_i[] = "Test element-wise for positive infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape as `x` to store the result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a boolean array is returned\n        with values True where the corresponding element of the input is\n        positive infinity and values False where the element of the input is\n        not positive infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as zeros\n        and ones, if the type is boolean then as False and True.\n        The return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isneginf, isfinite, isnan\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when `x` is a\n    scalar input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isposinf(np.PINF)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.inf)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.NINF)\n    array(False, dtype=bool)\n    >>> np.isposinf([-np.inf, 0., np.inf])\n    array([False, False,  True], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isposinf(x, y)\n    array([0, 0, 1])\n    >>> y\n    array([0, 0, 1])\n    \n    ";
static const char __pyx_k_Test_whether_any_array_element_a[] = "Test whether any array element along a given axis evaluates to True.\n\n    Returns single boolean unless `axis` is not ``None``\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical OR is performed.  The default\n        (`axis` = `None`) is to perform a logical OR over a flattened\n        input array. `axis` may be negative, in which case it counts\n        from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output and its type is preserved\n        (e.g., if it is of type float, then it will remain so, returning\n        1.0 for True and 0.0 for False, regardless of the type of `a`).\n        See `doc.ufuncs` (Section \"Output arguments\") for details.\n\n    Returns\n    -------\n    any : bool or ndarray\n        A new boolean or `ndarray` is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.any : equivalent method\n\n    all : Test whether all elements along a given axis evaluate to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity evaluate\n    to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.any([[True, False], [True, True]])\n    True\n\n    >>> np.any([[True, False], [False, False]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.any([-1, 0, 5])\n    True\n\n    >>> np.any(np.nan)\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.any([-1, 4, 5], out=o)\n    >>> z, o\n    (array([ True], dtype=bool), array([ True], dtype=bool))\n    >>> # Check now that z is a reference to o\n    >>> z is o\n    True\n    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n    (191614240, 191614240)\n    \n    ";
static const char __pyx_k_Test_whether_each_element_of_a_1[] = "Test whether each element of a 1D array is also present in a second array.\n\n    Returns a boolean array the same length as `ar1` that is True\n    where an element of `ar1` is in `ar2` and False otherwise.\n\n    Parameters\n    ----------\n    ar1 : array_like, shape (M,)\n        Input array.\n    ar2 : array_like\n        The values against which to test each value of `ar1`.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    mask : ndarray of bools, shape(M,)\n        The values `ar1[mask]` are in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Notes\n    -----\n    `in1d` can be considered as an element-wise function version of the\n    python keyword `in`, for 1D sequences. ``in1d(a, b)`` is roughly\n    equivalent to ``np.array([item in b for item in a])``.\n\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> test = np.array([0, 1, 2, 5, 0])\n    >>> states = [0, 2]\n    >>> mask = np.in1d(test, states)\n    >>> mask\n    array([ True, False,  True, False,  True], dtype=bool)\n    >>> test[mask]\n    array([0, 2, 0])\n    \n    ";
static const char __pyx_k_The_differences_between_consecut[] = "The differences between consecutive elements of an array.\n\n    Parameters\n    ----------\n    ary : array_like\n        If necessary, will be flattened before the differences are taken.\n    to_end : array_like, optional\n        Number(s) to append at the end of the returned differences.\n    to_begin : array_like, optional\n        Number(s) to prepend at the beginning of the returned differences.\n\n    Returns\n    -------\n    ed : ndarray\n        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.\n\n    See Also\n    --------\n    diff, gradient\n\n    Notes\n    -----\n    When applied to masked arrays, this function drops the mask information\n    if the `to_begin` and/or `to_end` parameters are used.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.ediff1d(x)\n    array([ 1,  2,  3, -7])\n\n    >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\n    array([-99,   1,   2,   3,  -7,  88,  99])\n\n    The returned array is always 1D.\n\n    >>> y = [[1, 2, 4], [1, 6, 24]]\n    >>> np.ediff1d(y)\n    array([ 1,  2, -3,  5, 18])\n    \n    ";
static const char __pyx_k_Trim_the_leading_and_or_trailing[] = "Trim the leading and/or trailing zeros from a 1-D array or sequence.\n\n    Parameters\n    ----------\n    filt : 1-D array or sequence\n        Input array.\n    trim : str, optional\n        A string with 'f' representing trim from front and 'b' to trim from\n        back. Default is 'fb', trim zeros from both front and back of the\n        array.\n\n    Returns\n    -------\n    trimmed : 1-D array or sequence\n        The result of trimming the input. The input data type is preserved.\n\n    Examples\n    --------\n    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n    >>> np.trim_zeros(a)\n    array([1, 2, 3, 0, 2, 1])\n\n    >>> np.trim_zeros(a, 'b')\n    array([0, 0, 0, 1, 2, 3, 0, 2, 1])\n\n    The input data type is preserved, list/tuple in means list/tuple out.\n\n    >>> np.trim_zeros([0, 1, 2, 0])\n    [1, 2]\n    \n    ";
static const char __pyx_k_True_if_two_arrays_have_the_same[] = "True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n    \n    ";
static const char __pyx_k_Unwrap_by_changing_deltas_betwee[] = "Unwrap by changing deltas between values to 2*pi complement.\n\n    Unwrap radian phase `p` by changing absolute jumps greater than\n    `discont` to their 2*pi complement along the given axis.\n\n    Parameters\n    ----------\n    p : array_like\n        Input array.\n    discont : float, optional\n        Maximum discontinuity between values, default is ``pi``.\n    axis : int, optional\n        Axis along which unwrap will operate, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        Output array.\n\n    See Also\n    --------\n    rad2deg, deg2rad\n\n    Notes\n    -----\n    If the discontinuity in `p` is smaller than ``pi``, but larger than\n    `discont`, no unwrapping is done because taking the 2*pi complement\n    would only make the discontinuity larger.\n\n    Examples\n    --------\n    >>> phase = np.linspace(0, np.pi, num=5)\n    >>> phase[3:] += np.pi\n    >>> phase\n    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])\n    >>> np.unwrap(phase)\n    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])\n    \n    ";
static const char __pyx_k_Upper_triangle_of_an_array_Retur[] = "Upper triangle of an array.\n\n    Return a copy of a matrix with the elements below the `k`-th diagonal\n    zeroed.\n\n    Please refer to the documentation for `tril` for further details.\n\n    See Also\n    --------\n    tril : lower triangle of an array\n\n    Examples\n    --------\n    >>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 1,  2,  3],\n           [ 4,  5,  6],\n           [ 0,  8,  9],\n           [ 0,  0, 12]])\n    \n    ";
static const char __pyx_k_View_inputs_as_arrays_with_at_le[] = "View inputs as arrays with at least two dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted\n        to arrays.  Arrays that already have two or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 2``.\n        Copies are avoided where possible, and views with two or more\n        dimensions are returned.\n\n    See Also\n    --------\n    atleast_1d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_2d(3.0)\n    array([[ 3.]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_2d(x)\n    array([[ 0.,  1.,  2.]])\n    >>> np.atleast_2d(x).base is x\n    True\n\n    >>> np.atleast_2d(1, [1, 2], [[1, 2]])\n    [array([[1]]), array([[1, 2]]), array([[1, 2]])]\n    \n    ";
static const char __pyx_k_array_object_dtype_None_copy_Tru[] = "array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)\n\n    Create an array.\n\n    Parameters\n    ----------\n    object : array_like\n        An array, any object exposing the array interface, an\n        object whose __array__ method returns an array, or any\n        (nested) sequence.\n    dtype : data-type, optional\n        The desired data-type for the array.  If not given, then\n        the type will be determined as the minimum type required\n        to hold the objects in the sequence.  This argument can only\n        be used to 'upcast' the array.  For downcasting, use the\n        .astype(t) method.\n    copy : bool, optional\n        If true (default), then the object is copied.  Otherwise, a copy\n        will only be made if __array__ returns a copy, if obj is a\n        nested sequence, or if a copy is needed to satisfy any of the other\n        requirements (`dtype`, `order`, etc.).\n    order : {'C', 'F', 'A'}, optional\n        Specify the order of the array.  If order is 'C' (default), then the\n        array will be in C-contiguous order (last-index varies the\n        fastest).  If order is 'F', then the returned array\n        will be in Fortran-contiguous order (first-index varies the\n        fastest).  If order is 'A', then the returned array may\n        be in any order (either C-, Fortran-contiguous, or even\n        discontiguous).\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n    ndmin : int, optional\n        Specifies the minimum number of dimensions that the resulting\n        array should have.  Ones will be pre-pended to the shape as\n        needed to meet this requirement.\n\n    Returns\n    -------\n    out : ndarray\n        An array object satisfying the specified requirements.\n\n    See Also\n    --------\n    empty, empty_like, zeros, zeros_like, ones, ones_like, fill\n\n    ""Examples\n    --------\n    >>> np.array([1, 2, 3])\n    array([1, 2, 3])\n\n    Upcasting:\n\n    >>> np.array([1, 2, 3.0])\n    array([ 1.,  2.,  3.])\n\n    More than one dimension:\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1, 2],\n           [3, 4]])\n\n    Minimum dimensions 2:\n\n    >>> np.array([1, 2, 3], ndmin=2)\n    array([[1, 2, 3]])\n\n    Type provided:\n\n    >>> np.array([1, 2, 3], dtype=complex)\n    array([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n    Data-type consisting of more than one element:\n\n    >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])\n    >>> x['a']\n    array([1, 3])\n\n    Creating an array from sub-classes:\n\n    >>> np.array(np.mat('1 2; 3 4'))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> np.array(np.mat('1 2; 3 4'), subok=True)\n    matrix([[1, 2],\n            [3, 4]])\n    \n    ";
static const char __pyx_k_bincount_x_weights_None_minlengt[] = "bincount(x, weights=None, minlength=None)\n\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.\n\n    Parameters\n    ----------\n    x : array_like, 1 dimension, nonnegative ints\n        Input array.\n    weights : array_like, optional\n        Weights, array of the same shape as `x`.\n    minlength : int, optional\n        .. versionadded:: 1.6.0\n\n        A minimum number of bins for the output array.\n\n    Returns\n    -------\n    out : ndarray of ints\n        The result of binning the input array.\n        The length of `out` is equal to ``np.amax(x)+1``.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or contains elements with negative\n        values, or if `minlength` is non-positive.\n    TypeError\n        If the type of the input is float or complex.\n\n    See Also\n    --------\n    histogram, digitize, unique\n\n    Examples\n    --------\n    >>> np.bincount(np.arange(5))\n    array([1, 1, 1, 1, 1])\n    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\n    array([1, 3, 1, 1, 0, 0, 0, 1])\n\n    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n    >>> np.bincount(x).size == np.amax(x)+1\n    True\n\n    The input array needs to be of integer dtype, otherwise a\n    TypeError is raised:\n\n    >>> np.bincount(np.arange(5, dtype=np.float))\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: array cannot be safely cast to required type""\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])\n    \n    ";
static const char __pyx_k_can_cast_from_totype_casting_saf[] = "can_cast(from, totype, casting = 'safe')\n\n    Returns True if cast between data types can occur according to the\n    casting rule.  If from is a scalar or array scalar, also returns\n    True if the scalar value can be cast without overflow or truncation\n    to an integer.\n\n    Parameters\n    ----------\n    from : dtype, dtype specifier, scalar, or array\n        Data type, scalar, or array to cast from.\n    totype : dtype or dtype specifier\n        Data type to cast to.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    out : bool\n        True if cast can occur according to the casting rule.\n\n    See also\n    --------\n    dtype, result_type\n\n    Examples\n    --------\n\n    Basic examples\n\n    >>> np.can_cast(np.int32, np.int64)\n    True\n    >>> np.can_cast(np.float64, np.complex)\n    True\n    >>> np.can_cast(np.complex, np.float)\n    False\n\n    >>> np.can_cast('i8', 'f8')\n    True\n    >>> np.can_cast('i8', 'f4')\n    False\n    >>> np.can_cast('i4', 'S4')\n    True\n\n    Casting scalars\n\n    >>> np.can_cast(100, 'i1')\n    True\n    >>> np.can_cast(150, 'i1')\n    False\n    >>> np.can_cast(150, 'u1')\n    True\n\n    >>> np.can_cast(3.5e100, np.float32)\n    False\n    >>> np.can_cast(1000.0, np.float32)\n    True\n\n    Array scalar checks the value, array does not\n\n    >>> np.can_cast(np.array(1000.0), np.float32)\n    True\n    >>> np.can_cast(np.array([1000.0]), np.float32)\n    False\n\n    Using the casting rules\n\n    >>> np.can_c""ast('i8', 'i8', 'no')\n    True\n    >>> np.can_cast('<i8', '>i8', 'no')\n    False\n\n    >>> np.can_cast('<i8', '>i8', 'equiv')\n    True\n    >>> np.can_cast('<i4', '>i8', 'equiv')\n    False\n\n    >>> np.can_cast('<i4', '>i8', 'safe')\n    True\n    >>> np.can_cast('<i8', '>i4', 'safe')\n    False\n\n    >>> np.can_cast('<i8', '>i4', 'same_kind')\n    True\n    >>> np.can_cast('<i8', '>u4', 'same_kind')\n    False\n\n    >>> np.can_cast('<i8', '>u4', 'unsafe')\n    True\n    \n    ";
static const char __pyx_k_count_nonzero_a_Counts_the_numbe[] = "count_nonzero(a)\n\n    Counts the number of non-zero values in the array ``a``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n\n    Returns\n    -------\n    count : int\n        Number of non-zero values in the array.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    Examples\n    --------\n    >>> np.count_nonzero(np.eye(4))\n    4\n\n    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n    5\n    \n    ";
static const char __pyx_k_digitize_x_bins_Return_the_indic[] = "digitize(x, bins)\n\n    Return the indices of the bins to which each value in input array belongs.\n\n    Each index ``i`` returned is such that ``bins[i-1] <= x < bins[i]`` if\n    `bins` is monotonically increasing, or ``bins[i-1] > x >= bins[i]`` if\n    `bins` is monotonically decreasing. If values in `x` are beyond the\n    bounds of `bins`, 0 or ``len(bins)`` is returned as appropriate.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array to be binned. It has to be 1-dimensional.\n    bins : array_like\n        Array of bins. It has to be 1-dimensional and monotonic.\n\n    Returns\n    -------\n    out : ndarray of ints\n        Output array of indices, of same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or if `bins` is not monotonic.\n    TypeError\n        If the type of the input is complex.\n\n    See Also\n    --------\n    bincount, histogram, unique\n\n    Notes\n    -----\n    If values in `x` are such that they fall outside the bin range,\n    attempting to index `bins` with the indices that `digitize` returns\n    will result in an IndexError.\n\n    Examples\n    --------\n    >>> x = np.array([0.2, 6.4, 3.0, 1.6])\n    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n    >>> inds = np.digitize(x, bins)\n    >>> inds\n    array([1, 4, 3, 2])\n    >>> for n in range(x.size):\n    ...   print bins[inds[n]-1], \"<=\", x[n], \"<\", bins[inds[n]]\n    ...\n    0.0 <= 0.2 < 1.0\n    4.0 <= 6.4 < 10.0\n    2.5 <= 3.0 < 4.0\n    1.0 <= 1.6 < 2.5\n    \n    ";
static const char __pyx_k_einsum_subscripts_operands_out_N[] = "einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')\n\n    Evaluates the Einstein summation convention on the operands.\n\n    Using the Einstein summation convention, many common multi-dimensional\n    array operations can be represented in a simple fashion.  This function\n    provides a way compute such summations. The best way to understand this\n    function is to try the examples below, which show how many common NumPy\n    functions can be implemented as calls to `einsum`.\n\n    Parameters\n    ----------\n    subscripts : str\n        Specifies the subscripts for summation.\n    operands : list of array_like\n        These are the arrays for the operation.\n    out : ndarray, optional\n        If provided, the calculation is done into this array.\n    dtype : data-type, optional\n        If provided, forces the calculation to use the data type specified.\n        Note that you may have to also give a more liberal `casting`\n        parameter to allow the conversions.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Controls the memory layout of the output. 'C' means it should\n        be C contiguous. 'F' means it should be Fortran contiguous,\n        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.\n        'K' means it should be as close to the layout as the inputs as\n        is possible, including arbitrarily permuted axes.\n        Default is 'K'.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.  Setting this to\n        'unsafe' is not recommended, as it can adversely affect accumulations.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n      ""    * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    output : ndarray\n        The calculation based on the Einstein summation convention.\n\n    See Also\n    --------\n    dot, inner, outer, tensordot\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The subscripts string is a comma-separated list of subscript labels,\n    where each label refers to a dimension of the corresponding operand.\n    Repeated subscripts labels in one operand take the diagonal.  For example,\n    ``np.einsum('ii', a)`` is equivalent to ``np.trace(a)``.\n\n    Whenever a label is repeated, it is summed, so ``np.einsum('i,i', a, b)``\n    is equivalent to ``np.inner(a,b)``.  If a label appears only once,\n    it is not summed, so ``np.einsum('i', a)`` produces a view of ``a``\n    with no changes.\n\n    The order of labels in the output is by default alphabetical.  This\n    means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while\n    ``np.einsum('ji', a)`` takes its transpose.\n\n    The output can be controlled by specifying output subscript labels\n    as well.  This specifies the label order, and allows summing to\n    be disallowed or forced when desired.  The call ``np.einsum('i->', a)``\n    is like ``np.sum(a, axis=-1)``, and ``np.einsum('ii->i', a)``\n    is like ``np.diag(a)``.  The difference is that `einsum` does not\n    allow broadcasting by default.\n\n    To enable and control broadcasting, use an ellipsis.  Default\n    NumPy-style broadcasting is done by adding an ellipsis\n    to the left of each term, like ``np.einsum('...ii->...i', a)``.\n    To take the trace along the first and last axes,\n    you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix\n    product with the left-most indices instead of rightmost, you can do\n    ``np.einsum('ij...,jk...->ik...', a, b)``.\n\n    When there is only one operand, no axes are summed, and no output\n    parameter is provided, a view into the operand is returned i""nstead\n    of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``\n    produces a view.\n\n    An alternative way to provide the subscripts and operands is as\n    ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``. The examples\n    below have corresponding `einsum` calls with the two parameter methods.\n\n    Examples\n    --------\n    >>> a = np.arange(25).reshape(5,5)\n    >>> b = np.arange(5)\n    >>> c = np.arange(6).reshape(2,3)\n\n    >>> np.einsum('ii', a)\n    60\n    >>> np.einsum(a, [0,0])\n    60\n    >>> np.trace(a)\n    60\n\n    >>> np.einsum('ii->i', a)\n    array([ 0,  6, 12, 18, 24])\n    >>> np.einsum(a, [0,0], [0])\n    array([ 0,  6, 12, 18, 24])\n    >>> np.diag(a)\n    array([ 0,  6, 12, 18, 24])\n\n    >>> np.einsum('ij,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum(a, [0,1], b, [1])\n    array([ 30,  80, 130, 180, 230])\n    >>> np.dot(a, b)\n    array([ 30,  80, 130, 180, 230])\n\n    >>> np.einsum('ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum(c, [1,0])\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> c.T\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n\n    >>> np.einsum('..., ...', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(3, [Ellipsis], c, [Ellipsis])\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.multiply(3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n\n    >>> np.einsum('i,i', b, b)\n    30\n    >>> np.einsum(b, [0], b, [0])\n    30\n    >>> np.inner(b,b)\n    30\n\n    >>> np.einsum('i,j', np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.einsum(np.arange(2)+1, [0], b, [1])\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.outer(np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n\n    >>> np.einsum('i...->...', a)\n    array([50, 55, 60, 65, 70])\n    >>> n""p.einsum(a, [0,Ellipsis], [Ellipsis])\n    array([50, 55, 60, 65, 70])\n    >>> np.sum(a, axis=0)\n    array([50, 55, 60, 65, 70])\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> np.einsum('ijk,jil->kl', a, b)\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.tensordot(a,b, axes=([1,0],[0,1]))\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    \n    ";
static const char __pyx_k_frombuffer_buffer_dtype_float_co[] = "frombuffer(buffer, dtype=float, count=-1, offset=0)\n\n    Interpret a buffer as a 1-dimensional array.\n\n    Parameters\n    ----------\n    buffer : buffer_like\n        An object that exposes the buffer interface.\n    dtype : data-type, optional\n        Data-type of the returned array; default: float.\n    count : int, optional\n        Number of items to read. ``-1`` means all data in the buffer.\n    offset : int, optional\n        Start reading the buffer from this offset; default: 0.\n\n    Notes\n    -----\n    If the buffer has data that is not in machine byte-order, this should\n    be specified as part of the data-type, e.g.::\n\n      >>> dt = np.dtype(int)\n      >>> dt = dt.newbyteorder('>')\n      >>> np.frombuffer(buf, dtype=dt)\n\n    The data of the resulting array will not be byteswapped, but will be\n    interpreted correctly.\n\n    Examples\n    --------\n    >>> s = 'hello world'\n    >>> np.frombuffer(s, dtype='S1', count=5, offset=6)\n    array(['w', 'o', 'r', 'l', 'd'],\n          dtype='|S1')\n    \n    ";
static const char __pyx_k_frompyfunc_func_nin_nout_Takes_a[] = "frompyfunc(func, nin, nout)\n\n    Takes an arbitrary Python function and returns a Numpy ufunc.\n\n    Can be used, for example, to add broadcasting to a built-in Python\n    function (see Examples section).\n\n    Parameters\n    ----------\n    func : Python function object\n        An arbitrary Python function.\n    nin : int\n        The number of input arguments.\n    nout : int\n        The number of objects returned by `func`.\n\n    Returns\n    -------\n    out : ufunc\n        Returns a Numpy universal function (``ufunc``) object.\n\n    Notes\n    -----\n    The returned ufunc always returns PyObject arrays.\n\n    Examples\n    --------\n    Use frompyfunc to add broadcasting to the Python function ``oct``:\n\n    >>> oct_array = np.frompyfunc(oct, 1, 1)\n    >>> oct_array(np.array((10, 30, 100)))\n    array([012, 036, 0144], dtype=object)\n    >>> np.array((oct(10), oct(30), oct(100))) # for comparison\n    array(['012', '036', '0144'],\n          dtype='|S4')\n    \n    ";
static const char __pyx_k_fromstring_string_dtype_float_co[] = "fromstring(string, dtype=float, count=-1, sep='')\n\n    A new 1-D array initialized from raw binary or text data in a string.\n\n    Parameters\n    ----------\n    string : str\n        A string containing the data.\n    dtype : data-type, optional\n        The data type of the array; default: float.  For binary input data,\n        the data must be in exactly this format.\n    count : int, optional\n        Read this number of `dtype` elements from the data.  If this is\n        negative (the default), the count will be determined from the\n        length of the data.\n    sep : str, optional\n        If not provided or, equivalently, the empty string, the data will\n        be interpreted as binary data; otherwise, as ASCII text with\n        decimal numbers.  Also in this latter case, this argument is\n        interpreted as the string separating numbers in the data; extra\n        whitespace between elements is also ignored.\n\n    Returns\n    -------\n    arr : ndarray\n        The constructed array.\n\n    Raises\n    ------\n    ValueError\n        If the string is not the correct size to satisfy the requested\n        `dtype` and `count`.\n\n    See Also\n    --------\n    frombuffer, fromfile, fromiter\n\n    Examples\n    --------\n    >>> np.fromstring('\001\002', dtype=np.uint8)\n    array([1, 2], dtype=uint8)\n    >>> np.fromstring('1 2', dtype=int, sep=' ')\n    array([1, 2])\n    >>> np.fromstring('1, 2', dtype=int, sep=',')\n    array([1, 2])\n    >>> np.fromstring('\001\002\003\004\005', dtype=np.uint8, count=3)\n    array([1, 2, 3], dtype=uint8)\n    \n    ";
static const char __pyx_k_getbuffer_obj_offset_size_Create[] = "getbuffer(obj [,offset[, size]])\n\n    Create a buffer object from the given object referencing a slice of\n    length size starting at offset.\n\n    Default is the entire buffer. A read-write buffer is attempted followed\n    by a read-only buffer.\n\n    Parameters\n    ----------\n    obj : object\n\n    offset : int, optional\n\n    size : int, optional\n\n    Returns\n    -------\n    buffer_obj : buffer\n\n    Examples\n    --------\n    >>> buf = np.getbuffer(np.ones(5), 1, 3)\n    >>> len(buf)\n    3\n    >>> buf[0]\n    '\000'\n    >>> buf\n    <read-write buffer for 0x8af1e70, size 3, offset 1 at 0x8ba4ec0>\n    \n    ";
static const char __pyx_k_geterrobj_Return_the_current_obj[] = "geterrobj()\n\n    Return the current object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `geterrobj` is used internally by the other\n    functions that get and set error handling behavior (`geterr`, `seterr`,\n    `geterrcall`, `seterrcall`).\n\n    Returns\n    -------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    seterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrobj()  # first get the defaults\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> old_bufsize = np.setbufsize(20000)\n    >>> old_err = np.seterr(divide='raise')\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.geterrobj()\n    [20000, 2, <function err_handler at 0x91dcaac>]\n\n    >>> old_err = np.seterr(all='ignore')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    '0'\n    >>> old_err = np.seterr(divide='warn', over='log', under='call',\n                            invalid='print')\n    >>> np.b""ase_repr(np.geterrobj()[1], 8)\n    '4351'\n    \n    ";
static const char __pyx_k_inner_a_b_Inner_product_of_two_a[] = "inner(a, b)\n\n    Inner product of two arrays.\n\n    Ordinary inner product of vectors for 1-D arrays (without complex\n    conjugation), in higher dimensions a sum product over the last axes.\n\n    Parameters\n    ----------\n    a, b : array_like\n        If `a` and `b` are nonscalar, their last dimensions of must match.\n\n    Returns\n    -------\n    out : ndarray\n        `out.shape = a.shape[:-1] + b.shape[:-1]`\n\n    Raises\n    ------\n    ValueError\n        If the last dimension of `a` and `b` has different size.\n\n    See Also\n    --------\n    tensordot : Sum products over arbitrary axes.\n    dot : Generalised matrix product, using second last dimension of `b`.\n    einsum : Einstein summation convention.\n\n    Notes\n    -----\n    For vectors (1-D arrays) it computes the ordinary inner-product::\n\n        np.inner(a, b) = sum(a[:]*b[:])\n\n    More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::\n\n        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n    or explicitly::\n\n        np.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n             = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n    In addition `a` or `b` may be scalars, in which case::\n\n       np.inner(a,b) = a*b\n\n    Examples\n    --------\n    Ordinary inner product for vectors:\n\n    >>> a = np.array([1,2,3])\n    >>> b = np.array([0,1,0])\n    >>> np.inner(a, b)\n    2\n\n    A multidimensional example:\n\n    >>> a = np.arange(24).reshape((2,3,4))\n    >>> b = np.arange(4)\n    >>> np.inner(a, b)\n    array([[ 14,  38,  62],\n           [ 86, 110, 134]])\n\n    An example where `b` is a scalar:\n\n    >>> np.inner(np.eye(2), 7)\n    array([[ 7.,  0.],\n           [ 0.,  7.]])\n    \n    ";
static const char __pyx_k_lexsort_keys_axis_1_Perform_an_i[] = "lexsort(keys, axis=-1)\n\n    Perform an indirect sort using a sequence of keys.\n\n    Given multiple sorting keys, which can be interpreted as columns in a\n    spreadsheet, lexsort returns an array of integer indices that describes\n    the sort order by multiple columns. The last key in the sequence is used\n    for the primary sort order, the second-to-last key for the secondary sort\n    order, and so on. The keys argument must be a sequence of objects that\n    can be converted to arrays of the same shape. If a 2D array is provided\n    for the keys argument, it's rows are interpreted as the sorting keys and\n    sorting is according to the last row, second last row etc.\n\n    Parameters\n    ----------\n    keys : (k,N) array or tuple containing k (N,)-shaped sequences\n        The `k` different \"columns\" to be sorted.  The last column (or row if\n        `keys` is a 2D array) is the primary sort key.\n    axis : int, optional\n        Axis to be indirectly sorted.  By default, sort over the last axis.\n\n    Returns\n    -------\n    indices : (N,) ndarray of ints\n        Array of indices that sort the keys along the specified axis.\n\n    See Also\n    --------\n    argsort : Indirect sort.\n    ndarray.sort : In-place sort.\n    sort : Return a sorted copy of an array.\n\n    Examples\n    --------\n    Sort names: first by surname, then by name.\n\n    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n    >>> ind = np.lexsort((first_names, surnames))\n    >>> ind\n    array([1, 2, 0])\n\n    >>> [surnames[i] + \", \" + first_names[i] for i in ind]\n    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n    Sort two columns of numbers:\n\n    >>> a = [1,5,1,4,3,4,4] # First column\n    >>> b = [9,4,0,4,0,2,1] # Second column\n    >>> ind = np.lexsort((b,a)) # Sort by a, then by b\n    >>> print ind\n    [2 0 4 6 5 3 1]\n\n    >>> [(a[i],b[i]) for i in ind]\n    [(1, 0), (1, 9), (3, 0)"", (4, 1), (4, 2), (4, 4), (5, 4)]\n\n    Note that sorting is first according to the elements of ``a``.\n    Secondary sorting is according to the elements of ``b``.\n\n    A normal ``argsort`` would have yielded:\n\n    >>> [(a[i],b[i]) for i in np.argsort(a)]\n    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n\n    Structured arrays are sorted lexically by ``argsort``:\n\n    >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n    ...              dtype=np.dtype([('x', int), ('y', int)]))\n\n    >>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))\n    array([2, 0, 4, 6, 5, 3, 1])\n    \n    ";
static const char __pyx_k_min_scalar_type_a_For_scalar_a_r[] = "min_scalar_type(a)\n\n    For scalar ``a``, returns the data type with the smallest size\n    and smallest scalar kind which can hold its value.  For non-scalar\n    array ``a``, returns the vector's dtype unmodified.\n\n    Floating point values are not demoted to integers,\n    and complex values are not demoted to floats.\n\n    Parameters\n    ----------\n    a : scalar or array_like\n        The value whose minimal data type is to be found.\n\n    Returns\n    -------\n    out : dtype\n        The minimal data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, promote_types, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.min_scalar_type(10)\n    dtype('uint8')\n\n    >>> np.min_scalar_type(-260)\n    dtype('int16')\n\n    >>> np.min_scalar_type(3.1)\n    dtype('float16')\n\n    >>> np.min_scalar_type(1e50)\n    dtype('float64')\n\n    >>> np.min_scalar_type(np.arange(4,dtype='f8'))\n    dtype('float64')\n    \n    ";
static const char __pyx_k_ndarray_is_not_Fortran_contiguou[] = "ndarray is not Fortran contiguous";
static const char __pyx_k_numpy_core_umath_failed_to_impor[] = "numpy.core.umath failed to import";
static const char __pyx_k_packbits_myarray_axis_None_Packs[] = "packbits(myarray, axis=None)\n\n    Packs the elements of a binary-valued array into bits in a uint8 array.\n\n    The result is padded to full bytes by inserting zero bits at the end.\n\n    Parameters\n    ----------\n    myarray : array_like\n        An integer type array whose elements should be packed to bits.\n    axis : int, optional\n        The dimension over which bit-packing is done.\n        ``None`` implies packing the flattened array.\n\n    Returns\n    -------\n    packed : ndarray\n        Array of type uint8 whose elements represent bits corresponding to the\n        logical (0 or nonzero) value of the input elements. The shape of\n        `packed` has the same number of dimensions as the input (unless `axis`\n        is None, in which case the output is 1-D).\n\n    See Also\n    --------\n    unpackbits: Unpacks elements of a uint8 array into a binary-valued output\n                array.\n\n    Examples\n    --------\n    >>> a = np.array([[[1,0,1],\n    ...                [0,1,0]],\n    ...               [[1,1,0],\n    ...                [0,0,1]]])\n    >>> b = np.packbits(a, axis=-1)\n    >>> b\n    array([[[160],[64]],[[192],[32]]], dtype=uint8)\n\n    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\n    and 32 = 0010 0000.\n    \n    ";
static const char __pyx_k_promote_types_type1_type2_Return[] = "promote_types(type1, type2)\n\n    Returns the data type with the smallest size and smallest scalar\n    kind to which both ``type1`` and ``type2`` may be safely cast.\n    The returned data type is always in native byte order.\n\n    This function is symmetric and associative.\n\n    Parameters\n    ----------\n    type1 : dtype or dtype specifier\n        First data type.\n    type2 : dtype or dtype specifier\n        Second data type.\n\n    Returns\n    -------\n    out : dtype\n        The promoted data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.promote_types('f4', 'f8')\n    dtype('float64')\n\n    >>> np.promote_types('i8', 'f4')\n    dtype('float64')\n\n    >>> np.promote_types('>i8', '<c8')\n    dtype('complex128')\n\n    >>> np.promote_types('i1', 'S8')\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: invalid type promotion\n    \n    ";
static const char __pyx_k_putmask_a_mask_values_Changes_el[] = "putmask(a, mask, values)\n\n    Changes elements of an array based on conditional and input values.\n\n    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.\n\n    If `values` is not the same size as `a` and `mask` then it will repeat.\n    This gives behavior different from ``a[mask] = values``.\n\n    Parameters\n    ----------\n    a : array_like\n        Target array.\n    mask : array_like\n        Boolean mask array. It has to be the same shape as `a`.\n    values : array_like\n        Values to put into `a` where `mask` is True. If `values` is smaller\n        than `a` it will be repeated.\n\n    See Also\n    --------\n    place, put, take\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> np.putmask(x, x>2, x**2)\n    >>> x\n    array([[ 0,  1,  2],\n           [ 9, 16, 25]])\n\n    If `values` is smaller than `a` it is repeated:\n\n    >>> x = np.arange(5)\n    >>> np.putmask(x, x>1, [-33, -44])\n    >>> x\n    array([  0,   1, -33, -44, -33])\n    \n    ";
static const char __pyx_k_ravel_multi_index_multi_index_di[] = "ravel_multi_index(multi_index, dims, mode='raise', order='C')\n\n    Converts a tuple of index arrays into an array of flat\n    indices, applying boundary modes to the multi-index.\n\n    Parameters\n    ----------\n    multi_index : tuple of array_like\n        A tuple of integer arrays, one array for each dimension.\n    dims : tuple of ints\n        The shape of array into which the indices from ``multi_index`` apply.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices are handled.  Can specify\n        either one mode or a tuple of modes, one mode per index.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        In 'clip' mode, a negative index which would normally\n        wrap will clip to 0 instead.\n    order : {'C', 'F'}, optional\n        Determines whether the multi-index should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    raveled_indices : ndarray\n        An array of indices into the flattened version of an array\n        of dimensions ``dims``.\n\n    See Also\n    --------\n    unravel_index\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    Examples\n    --------\n    >>> arr = np.array([[3,6,6],[4,5,1]])\n    >>> np.ravel_multi_index(arr, (7,6))\n    array([22, 41, 37])\n    >>> np.ravel_multi_index(arr, (7,6), order='F')\n    array([31, 41, 13])\n    >>> np.ravel_multi_index(arr, (4,6), mode='clip')\n    array([22, 23, 19])\n    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\n    array([12, 13, 13])\n\n    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n    1621\n    \n    ";
static const char __pyx_k_result_type_arrays_and_dtypes_Re[] = "result_type(*arrays_and_dtypes)\n\n    Returns the type that results from applying the NumPy\n    type promotion rules to the arguments.\n\n    Type promotion in NumPy works similarly to the rules in languages\n    like C++, with some slight differences.  When both scalars and\n    arrays are used, the array's type takes precedence and the actual value\n    of the scalar is taken into account.\n\n    For example, calculating 3*a, where a is an array of 32-bit floats,\n    intuitively should result in a 32-bit float output.  If the 3 is a\n    32-bit integer, the NumPy rules indicate it can't convert losslessly\n    into a 32-bit float, so a 64-bit float should be the result type.\n    By examining the value of the constant, '3', we see that it fits in\n    an 8-bit integer, which can be cast losslessly into the 32-bit float.\n\n    Parameters\n    ----------\n    arrays_and_dtypes : list of arrays and dtypes\n        The operands of some operation whose result type is needed.\n\n    Returns\n    -------\n    out : dtype\n        The result type.\n\n    See also\n    --------\n    dtype, promote_types, min_scalar_type, can_cast\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The specific algorithm used is as follows.\n\n    Categories are determined by first checking which of boolean,\n    integer (int/uint), or floating point (float/complex) the maximum\n    kind of all the arrays and the scalars are.\n    \n    If there are only scalars or the maximum category of the scalars\n    is higher than the maximum category of the arrays,\n    the data types are combined with :func:`promote_types`\n    to produce the return value.\n\n    Otherwise, `min_scalar_type` is called on each array, and\n    the resulting data types are all combined with :func:`promote_types`\n    to produce the return value.\n\n    The set of int values is not a subset of the uint values for types\n    with the same number of bits, something not reflected in\n    :func:`min_scalar_type`"", but handled as a special case in `result_type`.\n\n    Examples\n    --------\n    >>> np.result_type(3, np.arange(7, dtype='i1'))\n    dtype('int8')\n\n    >>> np.result_type('i4', 'c8')\n    dtype('complex128')\n\n    >>> np.result_type(3.0, -2)\n    dtype('float64')\n    \n    ";
static const char __pyx_k_set_numeric_ops_op1_func1_op2_fu[] = "set_numeric_ops(op1=func1, op2=func2, ...)\n\n    Set numerical operators for array objects.\n\n    Parameters\n    ----------\n    op1, op2, ... : callable\n        Each ``op = func`` pair describes an operator to be replaced.\n        For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace\n        addition by modulus 5 addition.\n\n    Returns\n    -------\n    saved_ops : list of callables\n        A list of all operators, stored before making replacements.\n\n    Notes\n    -----\n    .. WARNING::\n       Use with care!  Incorrect usage may lead to memory errors.\n\n    A function replacing an operator cannot make use of that operator.\n    For example, when replacing add, you may not use ``+``.  Instead,\n    directly call ufuncs.\n\n    Examples\n    --------\n    >>> def add_mod5(x, y):\n    ...     return np.add(x, y) % 5\n    ...\n    >>> old_funcs = np.set_numeric_ops(add=add_mod5)\n\n    >>> x = np.arange(12).reshape((3, 4))\n    >>> x + x\n    array([[0, 2, 4, 1],\n           [3, 0, 2, 4],\n           [1, 3, 0, 2]])\n\n    >>> ignore = np.set_numeric_ops(**old_funcs) # restore operators\n    \n    ";
static const char __pyx_k_unpackbits_myarray_axis_None_Unp[] = "unpackbits(myarray, axis=None)\n\n    Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of `myarray` represents a bit-field that should be unpacked\n    into a binary-valued output array. The shape of the output array is either\n    1-D (if `axis` is None) or the same shape as the input array with unpacking\n    done along the axis specified.\n\n    Parameters\n    ----------\n    myarray : ndarray, uint8 type\n       Input array.\n    axis : int, optional\n       Unpacks along this axis.\n\n    Returns\n    -------\n    unpacked : ndarray, uint8 type\n       The elements are binary-valued (0 or 1).\n\n    See Also\n    --------\n    packbits : Packs the elements of a binary-valued array into bits in a uint8\n               array.\n\n    Examples\n    --------\n    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n    >>> a\n    array([[ 2],\n           [ 7],\n           [23]], dtype=uint8)\n    >>> b = np.unpackbits(a, axis=1)\n    >>> b\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n    \n    ";
static const char __pyx_k_unravel_index_indices_dims_order[] = "unravel_index(indices, dims, order='C')\n\n    Converts a flat index or array of flat indices into a tuple\n    of coordinate arrays.\n\n    Parameters\n    ----------\n    indices : array_like\n        An integer array whose elements are indices into the flattened\n        version of an array of dimensions ``dims``. Before version 1.6.0,\n        this function accepted just one index value.\n    dims : tuple of ints\n        The shape of the array to use for unraveling ``indices``.\n    order : {'C', 'F'}, optional\n        .. versionadded:: 1.6.0\n\n        Determines whether the indices should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    unraveled_coords : tuple of ndarray\n        Each array in the tuple has the same shape as the ``indices``\n        array.\n\n    See Also\n    --------\n    ravel_multi_index\n\n    Examples\n    --------\n    >>> np.unravel_index([22, 41, 37], (7,6))\n    (array([3, 6, 6]), array([4, 5, 1]))\n    >>> np.unravel_index([31, 41, 13], (7,6), order='F')\n    (array([3, 6, 6]), array([4, 5, 1]))\n\n    >>> np.unravel_index(1621, (6,7,8,9))\n    (3, 1, 4, 1)\n    \n    ";
static const char __pyx_k_where_condition_x_y_Return_eleme[] = "where(condition, [x, y])\n\n    Return elements, either from `x` or `y`, depending on `condition`.\n\n    If only `condition` is given, return ``condition.nonzero()``.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        When True, yield `x`, otherwise yield `y`.\n    x, y : array_like, optional\n        Values from which to choose. `x` and `y` need to have the same\n        shape as `condition`.\n\n    Returns\n    -------\n    out : ndarray or tuple of ndarrays\n        If both `x` and `y` are specified, the output array contains\n        elements of `x` where `condition` is True, and elements from\n        `y` elsewhere.\n\n        If only `condition` is given, return the tuple\n        ``condition.nonzero()``, the indices where `condition` is True.\n\n    See Also\n    --------\n    nonzero, choose\n\n    Notes\n    -----\n    If `x` and `y` are given and input arrays are 1-D, `where` is\n    equivalent to::\n\n        [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]\n\n    Examples\n    --------\n    >>> np.where([[True, False], [True, True]],\n    ...          [[1, 2], [3, 4]],\n    ...          [[9, 8], [7, 6]])\n    array([[1, 8],\n           [3, 4]])\n\n    >>> np.where([[0, 1], [1, 0]])\n    (array([0, 1]), array([1, 0]))\n\n    >>> x = np.arange(9.).reshape(3, 3)\n    >>> np.where( x > 5 )\n    (array([2, 2, 2]), array([0, 1, 2]))\n    >>> x[np.where( x > 3.0 )]               # Note: result is 1D.\n    array([ 4.,  5.,  6.,  7.,  8.])\n    >>> np.where(x < 5, x, -1)               # Note: broadcasting.\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4., -1.],\n           [-1., -1., -1.]])\n    \n    ";
static const char __pyx_k_Return_the_number_of_dimensions_2[] = "Return the number of dimensions of an array.\n\n    If `a` is not already an array, a conversion is attempted.\n    Scalars are zero dimensional.\n\n    Parameters\n    ----------\n    a : array_like\n        Array whose number of dimensions is desired. If `a` is not an array,\n        a conversion is attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in the array.\n\n    See Also\n    --------\n    ndim : equivalent function\n    ndarray.ndim : equivalent property\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Notes\n    -----\n    In the old Numeric package, `rank` was the term used for the number of\n    dimensions, but in Numpy `ndim` is used instead.\n\n    Examples\n    --------\n    >>> np.rank([1,2,3])\n    1\n    >>> np.rank(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.rank(1)\n    0\n    \n    ";
static const char __pyx_k_Returns_a_bool_array_where_True_2[] = "Returns a bool array, where True if input element is real.\n\n    If element has complex type with zero complex part, the return value\n    for that element is True.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray, bool\n        Boolean array of same shape as `x`.\n\n    See Also\n    --------\n    iscomplex\n    isrealobj : Return True if x is not a complex type.\n\n    Examples\n    --------\n    >>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([False,  True,  True,  True,  True, False], dtype=bool)\n    \n    ";
static const char __pyx_k_Format_string_allocated_too_shor_2[] = "Format string allocated too short.";
static const char __pyx_k_Return_a_string_representation_o_2[] = "Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.  The\n        default is, indirectly, 75.\n    precision : int, optional\n        Floating point precision.  Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n\n    See Also\n    --------\n    array2string, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_str(np.arange(3))\n    '[0 1 2]'\n    \n    ";
static const char __pyx_k_Return_a_string_representation_o_3[] = "Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Only positive values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n    \n    ";
static const char __pyx_k_Return_the_maximum_of_an_array_o_2[] = "Return the maximum of an array or maximum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose maximum is desired. If `a` is not\n        an array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the maximum is computed. The default is to compute\n        the maximum of the flattened array.\n\n    Returns\n    -------\n    nanmax : ndarray\n        An array with the same shape as `a`, with the specified axis removed.\n        If `a` is a 0-d array, or if axis is None, a ndarray scalar is\n        returned.  The the same dtype as `a` is returned.\n\n    See Also\n    --------\n    numpy.amax : Maximum across array including any Not a Numbers.\n    numpy.nanmin : Minimum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.max.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmax(a)\n    3.0\n    >>> np.nanmax(a, axis=0)\n    array([ 3.,  2.])\n    >>> np.nanmax(a, axis=1)\n    array([ 2.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmax([1, 2, np.nan, np.NINF])\n    2.0\n    >>> np.nanmax([1, 2, np.nan, np.inf])\n    inf\n    \n    ";
static const char __pyx_k_Return_the_minimum_of_an_array_o_2[] = "Return the minimum of an array or minimum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose minimum is desired.\n    axis : int, optional\n        Axis along which the minimum is computed.The default is to compute\n        the minimum of the flattened array.\n\n    Returns\n    -------\n    nanmin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    numpy.amin : Minimum across array including any Not a Numbers.\n    numpy.nanmax : Maximum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.min.\n\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmin(a)\n    1.0\n    >>> np.nanmin(a, axis=0)\n    array([ 1.,  2.])\n    >>> np.nanmin(a, axis=1)\n    array([ 1.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmin([1, 2, np.nan, np.inf])\n    1.0\n    >>> np.nanmin([1, 2, np.nan, np.NINF])\n    -inf\n    \n    ";
static const char __pyx_k_Return_the_string_representation_2[] = "Return the string representation of a scalar dtype.\n\n    Parameters\n    ----------\n    sctype : scalar dtype or object\n        If a scalar dtype, the corresponding string character is\n        returned. If an object, `sctype2char` tries to infer its scalar type\n        and then return the corresponding string character.\n\n    Returns\n    -------\n    typechar : str\n        The string character corresponding to the scalar type.\n\n    Raises\n    ------\n    ValueError\n        If `sctype` is an object for which the type can not be inferred.\n\n    See Also\n    --------\n    obj2sctype, issctype, issubsctype, mintypecode\n\n    Examples\n    --------\n    >>> for sctype in [np.int32, np.float, np.complex, np.string_, np.ndarray]:\n    ...     print np.sctype2char(sctype)\n    l\n    d\n    D\n    S\n    O\n\n    >>> x = np.array([1., 2-1.j])\n    >>> np.sctype2char(x)\n    'D'\n    >>> np.sctype2char(list)\n    'O'\n    \n    ";
static const char __pyx_k_Split_an_array_into_multiple_sub_2[] = "Split an array into multiple sub-arrays horizontally (column-wise).\n\n    Please refer to the `split` documentation.  `hsplit` is equivalent\n    to `split` with ``axis=1``, the array is always split along the second\n    axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.hsplit(x, 2)\n    [array([[  0.,   1.],\n           [  4.,   5.],\n           [  8.,   9.],\n           [ 12.,  13.]]),\n     array([[  2.,   3.],\n           [  6.,   7.],\n           [ 10.,  11.],\n           [ 14.,  15.]])]\n    >>> np.hsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.],\n           [  4.,   5.,   6.],\n           [  8.,   9.,  10.],\n           [ 12.,  13.,  14.]]),\n     array([[  3.],\n           [  7.],\n           [ 11.],\n           [ 15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the second axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.hsplit(x, 2)\n    [array([[[ 0.,  1.]],\n           [[ 4.,  5.]]]),\n     array([[[ 2.,  3.]],\n           [[ 6.,  7.]]])]\n    \n    ";
static const char __pyx_k_Split_an_array_into_multiple_sub_3[] = "Split an array into multiple sub-arrays of equal size.\n\n    Parameters\n    ----------\n    ary : ndarray\n        Array to be divided into sub-arrays.\n    indices_or_sections : int or 1-D array\n        If `indices_or_sections` is an integer, N, the array will be divided\n        into N equal arrays along `axis`.  If such a split is not possible,\n        an error is raised.\n\n        If `indices_or_sections` is a 1-D array of sorted integers, the entries\n        indicate where along `axis` the array is split.  For example,\n        ``[2, 3]`` would, for ``axis=0``, result in\n\n          - ary[:2]\n          - ary[2:3]\n          - ary[3:]\n\n        If an index exceeds the dimension of the array along `axis`,\n        an empty sub-array is returned correspondingly.\n    axis : int, optional\n        The axis along which to split, default is 0.\n\n    Returns\n    -------\n    sub-arrays : list of ndarrays\n        A list of sub-arrays.\n\n    Raises\n    ------\n    ValueError\n        If `indices_or_sections` is given as an integer, but\n        a split does not result in equal division.\n\n    See Also\n    --------\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.  Does not raise an exception if\n                  an equal division cannot be made.\n    hsplit : Split array into multiple sub-arrays horizontally (column-wise).\n    vsplit : Split array into multiple sub-arrays vertically (row wise).\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    concatenate : Join arrays together.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n\n    Examples\n    --------\n    >>> x = np.arange(9.0)\n    >>> np.split(x, 3)\n    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]\n\n    >>> x = np.arange(8.""0)\n    >>> np.split(x, [3, 5, 6, 10])\n    [array([ 0.,  1.,  2.]),\n     array([ 3.,  4.]),\n     array([ 5.]),\n     array([ 6.,  7.]),\n     array([], dtype=float64)]\n    \n    ";
static const char __pyx_k_Split_an_array_into_multiple_sub_4[] = "Split an array into multiple sub-arrays vertically (row-wise).\n\n    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent\n    to ``split`` with `axis=0` (default), the array is always split along the\n    first axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.vsplit(x, 2)\n    [array([[ 0.,  1.,  2.,  3.],\n           [ 4.,  5.,  6.,  7.]]),\n     array([[  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])]\n    >>> np.vsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.]]),\n     array([[ 12.,  13.,  14.,  15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the first axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.vsplit(x, 2)\n    [array([[[ 0.,  1.],\n            [ 2.,  3.]]]),\n     array([[[ 4.,  5.],\n            [ 6.,  7.]]])]\n    \n    ";
static const char __pyx_k_View_inputs_as_arrays_with_at_le_2[] = "View inputs as arrays with at least three dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted to\n        arrays.  Arrays that already have three or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res1, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are\n        avoided where possible, and views with three or more dimensions are\n        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n        view of shape ``(M, N, 1)``.\n\n    See Also\n    --------\n    atleast_1d, atleast_2d\n\n    Examples\n    --------\n    >>> np.atleast_3d(3.0)\n    array([[[ 3.]]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_3d(x).shape\n    (1, 3, 1)\n\n    >>> x = np.arange(12.0).reshape(4,3)\n    >>> np.atleast_3d(x).shape\n    (4, 3, 1)\n    >>> np.atleast_3d(x).base is x\n    True\n\n    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n    ...     print arr, arr.shape\n    ...\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1 2]]] (1, 1, 2)\n    \n    ";
static PyObject *__pyx_kp_s_;
static PyObject *__pyx_kp_s_18e;
static PyObject *__pyx_n_s_A;
static PyObject *__pyx_kp_u_An_array_with_ones_at_and_below;
static PyObject *__pyx_kp_u_Append_values_to_the_end_of_an_a;
static PyObject *__pyx_kp_u_Apply_a_function_repeatedly_over;
static PyObject *__pyx_kp_u_Apply_a_function_to_1_D_slices_a;
static PyObject *__pyx_kp_u_Broadcast_any_number_of_arrays_a;
static PyObject *__pyx_kp_u_Build_a_matrix_object_from_a_str;
static PyObject *__pyx_n_s_C;
static PyObject *__pyx_kp_u_Calculate_the_n_th_order_discret;
static PyObject *__pyx_kp_u_Change_elements_of_an_array_base;
static PyObject *__pyx_kp_u_Check_whether_or_not_an_object_c;
static PyObject *__pyx_kp_u_Compute_tensor_dot_product_along;
static PyObject *__pyx_kp_u_Compute_the_arithmetic_mean_alon;
static PyObject *__pyx_kp_u_Compute_the_bi_dimensional_histo;
static PyObject *__pyx_kp_u_Compute_the_future_value_Given_a;
static PyObject *__pyx_kp_u_Compute_the_histogram_of_a_set_o;
static PyObject *__pyx_kp_u_Compute_the_median_along_the_spe;
static PyObject *__pyx_kp_u_Compute_the_multidimensional_his;
static PyObject *__pyx_kp_u_Compute_the_number_of_periodic_p;
static PyObject *__pyx_kp_u_Compute_the_outer_product_of_two;
static PyObject *__pyx_kp_u_Compute_the_payment_against_loan;
static PyObject *__pyx_kp_u_Compute_the_present_value_Given;
static PyObject *__pyx_kp_u_Compute_the_qth_percentile_of_th;
static PyObject *__pyx_kp_u_Compute_the_standard_deviation_a;
static PyObject *__pyx_kp_u_Compute_the_variance_along_the_s;
static PyObject *__pyx_kp_u_Compute_the_weighted_average_alo;
static PyObject *__pyx_kp_u_Construct_an_array_by_repeating;
static PyObject *__pyx_kp_u_Construct_an_array_from_a_text_f;
static PyObject *__pyx_kp_u_Construct_an_array_from_an_index;
static PyObject *__pyx_kp_u_Construct_an_open_mesh_from_mult;
static PyObject *__pyx_kp_u_Convert_an_array_of_size_1_to_it;
static PyObject *__pyx_kp_u_Convert_inputs_to_arrays_with_at;
static PyObject *__pyx_kp_u_Convert_the_input_to_an_array_ch;
static PyObject *__pyx_kp_u_Convert_the_input_to_an_ndarray;
static PyObject *__pyx_kp_u_Create_a_two_dimensional_array_w;
static PyObject *__pyx_kp_u_Cross_correlation_of_two_1_dimen;
static PyObject *__pyx_kp_u_Determine_common_type_following;
static PyObject *__pyx_kp_u_Determine_if_a_class_is_a_subcla;
static PyObject *__pyx_kp_u_Determine_if_the_first_argument;
static PyObject *__pyx_kp_u_Determine_if_two_arrays_can_shar;
static PyObject *__pyx_kp_u_Determines_whether_the_given_obj;
static PyObject *__pyx_kp_u_Difference_subtraction_of_two_po;
static PyObject *__pyx_kp_u_Display_a_message_on_a_device_Pa;
static PyObject *__pyx_kp_u_Do_a_keyword_search_on_docstring;
static PyObject *__pyx_kp_u_Estimate_a_covariance_matrix_giv;
static PyObject *__pyx_kp_u_Evaluate_a_piecewise_defined_fun;
static PyObject *__pyx_kp_u_Evaluate_a_polynomial_at_specifi;
static PyObject *__pyx_kp_u_Evenly_round_to_the_given_number;
static PyObject *__pyx_kp_u_Expand_the_shape_of_an_array_Ins;
static PyObject *__pyx_kp_u_Fill_the_main_diagonal_of_the_gi;
static PyObject *__pyx_kp_u_Find_indices_where_elements_shou;
static PyObject *__pyx_kp_u_Find_the_coefficients_of_a_polyn;
static PyObject *__pyx_kp_u_Find_the_indices_of_array_elemen;
static PyObject *__pyx_kp_u_Find_the_intersection_of_two_arr;
static PyObject *__pyx_kp_u_Find_the_product_of_two_polynomi;
static PyObject *__pyx_kp_u_Find_the_set_difference_of_two_a;
static PyObject *__pyx_kp_u_Find_the_set_exclusive_or_of_two;
static PyObject *__pyx_kp_u_Find_the_sum_of_two_polynomials;
static PyObject *__pyx_kp_u_Find_the_union_of_two_arrays_Ret;
static PyObject *__pyx_kp_u_Find_the_unique_elements_of_an_a;
static PyObject *__pyx_kp_u_Flip_array_in_the_left_right_dir;
static PyObject *__pyx_kp_u_Flip_array_in_the_up_down_direct;
static PyObject *__pyx_kp_u_Format_string_allocated_too_shor;
static PyObject *__pyx_kp_u_Format_string_allocated_too_shor_2;
static PyObject *__pyx_n_s_GDFgdf;
static PyObject *__pyx_kp_u_Generate_a_Van_der_Monde_matrix;
static PyObject *__pyx_kp_u_Get_help_information_for_a_funct;
static PyObject *__pyx_kp_u_Get_the_current_way_of_handling;
static PyObject *__pyx_kp_u_Gives_a_new_shape_to_an_array_wi;
static PyObject *__pyx_kp_u_If_complex_input_returns_a_real;
static PyObject *__pyx_n_s_ImportError;
static PyObject *__pyx_kp_u_Indices_of_the_maximum_values_al;
static PyObject *__pyx_kp_u_Insert_values_along_the_given_ax;
static PyObject *__pyx_kp_u_Integrate_along_the_given_axis_u;
static PyObject *__pyx_kp_u_Interchange_two_axes_of_an_array;
static PyObject *__pyx_kp_u_Interpret_the_input_as_a_matrix;
static PyObject *__pyx_kp_u_Issues_a_DeprecationWarning_adds;
static PyObject *__pyx_kp_u_Kronecker_product_of_two_arrays;
static PyObject *__pyx_kp_u_Least_squares_polynomial_fit_Fit;
static PyObject *__pyx_kp_u_Load_a_pickled_npy_or_npz_binary;
static PyObject *__pyx_kp_u_Load_data_from_a_text_file_Each;
static PyObject *__pyx_kp_u_Load_data_from_a_text_file_with;
static PyObject *__pyx_kp_u_Lower_triangle_of_an_array_Retur;
static PyObject *__pyx_n_s_M;
static PyObject *__pyx_kp_u_Modified_Bessel_function_of_the;
static PyObject *__pyx_n_s_N;
static PyObject *__pyx_kp_u_Non_native_byte_order_not_suppor;
static PyObject *__pyx_n_s_NotImplementedError;
static PyObject *__pyx_kp_u_One_dimensional_linear_interpola;
static PyObject *__pyx_kp_u_Permute_the_dimensions_of_an_arr;
static PyObject *__pyx_kp_u_Print_or_write_to_a_file_the_sou;
static PyObject *__pyx_kp_u_Print_the_Numpy_arrays_in_the_gi;
static PyObject *__pyx_kp_u_Protected_string_evaluation_Eval;
static PyObject *__pyx_kp_u_Range_of_values_maximum_minimum;
static PyObject *__pyx_kp_u_Remove_single_dimensional_entrie;
static PyObject *__pyx_kp_u_Repeat_elements_of_an_array_Para;
static PyObject *__pyx_kp_u_Replace_nan_with_zero_and_inf_wi;
static PyObject *__pyx_kp_u_Replaces_specified_elements_of_a;
static PyObject *__pyx_kp_u_Return_True_if_x_is_a_complex_ty;
static PyObject *__pyx_kp_u_Return_True_if_x_is_a_not_comple;
static PyObject *__pyx_kp_u_Return_a_contiguous_array_in_mem;
static PyObject *__pyx_kp_u_Return_a_description_for_the_giv;
static PyObject *__pyx_kp_u_Return_a_flattened_array_A_1_D_a;
static PyObject *__pyx_kp_u_Return_a_new_array_with_sub_arra;
static PyObject *__pyx_kp_u_Return_a_new_array_with_the_spec;
static PyObject *__pyx_kp_u_Return_a_scalar_type_which_is_co;
static PyObject *__pyx_kp_u_Return_a_sorted_copy_of_an_array;
static PyObject *__pyx_kp_u_Return_a_string_representation_o;
static PyObject *__pyx_kp_u_Return_a_string_representation_o_2;
static PyObject *__pyx_kp_u_Return_a_string_representation_o_3;
static PyObject *__pyx_kp_u_Return_an_antiderivative_indefin;
static PyObject *__pyx_kp_u_Return_an_array_converted_to_a_f;
static PyObject *__pyx_kp_u_Return_an_array_copy_of_the_give;
static PyObject *__pyx_kp_u_Return_an_array_drawn_from_eleme;
static PyObject *__pyx_kp_u_Return_an_array_laid_out_in_Fort;
static PyObject *__pyx_kp_u_Return_an_array_representing_the;
static PyObject *__pyx_kp_u_Return_an_ndarray_of_the_provide;
static PyObject *__pyx_kp_u_Return_coordinate_matrices_from;
static PyObject *__pyx_kp_u_Return_indices_of_the_maximum_va;
static PyObject *__pyx_kp_u_Return_indices_of_the_minimum_va;
static PyObject *__pyx_kp_u_Return_indices_that_are_non_zero;
static PyObject *__pyx_kp_u_Return_selected_slices_of_an_arr;
static PyObject *__pyx_kp_u_Return_the_Bartlett_window_The_B;
static PyObject *__pyx_kp_u_Return_the_Blackman_window_The_B;
static PyObject *__pyx_kp_u_Return_the_Hamming_window_The_Ha;
static PyObject *__pyx_kp_u_Return_the_Hanning_window_The_Ha;
static PyObject *__pyx_kp_u_Return_the_Internal_Rate_of_Retu;
static PyObject *__pyx_kp_u_Return_the_Kaiser_window_The_Kai;
static PyObject *__pyx_kp_u_Return_the_angle_of_the_complex;
static PyObject *__pyx_kp_u_Return_the_binary_representation;
static PyObject *__pyx_kp_u_Return_the_character_for_the_min;
static PyObject *__pyx_kp_u_Return_the_cross_product_of_two;
static PyObject *__pyx_kp_u_Return_the_cumulative_product_of;
static PyObject *__pyx_kp_u_Return_the_cumulative_sum_of_the;
static PyObject *__pyx_kp_u_Return_the_current_callback_func;
static PyObject *__pyx_kp_u_Return_the_derivative_of_the_spe;
static PyObject *__pyx_kp_u_Return_the_dot_product_of_two_ve;
static PyObject *__pyx_kp_u_Return_the_elements_of_an_array;
static PyObject *__pyx_kp_u_Return_the_gradient_of_an_N_dime;
static PyObject *__pyx_kp_u_Return_the_imaginary_part_of_the;
static PyObject *__pyx_kp_u_Return_the_indices_for_the_lower;
static PyObject *__pyx_kp_u_Return_the_indices_for_the_upper;
static PyObject *__pyx_kp_u_Return_the_indices_of_the_elemen;
static PyObject *__pyx_kp_u_Return_the_indices_to_access_n_n;
static PyObject *__pyx_kp_u_Return_the_indices_to_access_the;
static PyObject *__pyx_kp_u_Return_the_maximum_of_an_array_o;
static PyObject *__pyx_kp_u_Return_the_maximum_of_an_array_o_2;
static PyObject *__pyx_kp_u_Return_the_minimum_of_an_array_o;
static PyObject *__pyx_kp_u_Return_the_minimum_of_an_array_o_2;
static PyObject *__pyx_kp_u_Return_the_number_of_dimensions;
static PyObject *__pyx_kp_u_Return_the_number_of_dimensions_2;
static PyObject *__pyx_kp_u_Return_the_number_of_elements_al;
static PyObject *__pyx_kp_u_Return_the_product_of_array_elem;
static PyObject *__pyx_kp_u_Return_the_real_part_of_the_elem;
static PyObject *__pyx_kp_u_Return_the_roots_of_a_polynomial;
static PyObject *__pyx_kp_u_Return_the_scalar_dtype_or_NumPy;
static PyObject *__pyx_kp_u_Return_the_scalar_type_of_highes;
static PyObject *__pyx_kp_u_Return_the_sinc_function_The_sin;
static PyObject *__pyx_kp_u_Return_the_string_representation;
static PyObject *__pyx_kp_u_Return_the_string_representation_2;
static PyObject *__pyx_kp_u_Return_the_sum_along_diagonals_o;
static PyObject *__pyx_kp_u_Return_the_sum_of_array_elements;
static PyObject *__pyx_kp_u_Returns_True_if_array_is_arrange;
static PyObject *__pyx_kp_u_Returns_True_if_first_argument_i;
static PyObject *__pyx_kp_u_Returns_True_if_input_arrays_are;
static PyObject *__pyx_kp_u_Returns_True_if_the_type_of_num;
static PyObject *__pyx_kp_u_Returns_True_if_two_arrays_are_e;
static PyObject *__pyx_kp_u_Returns_a_bool_array_where_True;
static PyObject *__pyx_kp_u_Returns_a_bool_array_where_True_2;
static PyObject *__pyx_kp_u_Returns_pointers_to_the_end_poin;
static PyObject *__pyx_kp_u_Returns_the_NPV_Net_Present_Valu;
static PyObject *__pyx_kp_u_Returns_the_discrete_linear_conv;
static PyObject *__pyx_kp_u_Returns_the_indices_that_would_s;
static PyObject *__pyx_kp_u_Returns_the_quotient_and_remaind;
static PyObject *__pyx_kp_u_Roll_array_elements_along_a_give;
static PyObject *__pyx_kp_u_Roll_the_specified_axis_backward;
static PyObject *__pyx_kp_u_Rotate_an_array_by_90_degrees_in;
static PyObject *__pyx_kp_u_Round_to_nearest_integer_towards;
static PyObject *__pyx_n_s_RuntimeError;
static PyObject *__pyx_kp_u_Save_an_array_to_a_binary_file_i;
static PyObject *__pyx_kp_u_Save_an_array_to_a_text_file_Par;
static PyObject *__pyx_kp_u_Save_several_arrays_into_a_singl;
static PyObject *__pyx_kp_u_Set_a_Python_function_to_be_used;
static PyObject *__pyx_kp_u_Set_how_floating_point_errors_ar;
static PyObject *__pyx_kp_u_Set_printing_options_These_optio;
static PyObject *__pyx_kp_u_Set_the_floating_point_error_cal;
static PyObject *__pyx_kp_u_Sort_a_complex_array_using_the_r;
static PyObject *__pyx_kp_u_Split_an_array_into_multiple_sub;
static PyObject *__pyx_kp_u_Split_an_array_into_multiple_sub_2;
static PyObject *__pyx_kp_u_Split_an_array_into_multiple_sub_3;
static PyObject *__pyx_kp_u_Split_an_array_into_multiple_sub_4;
static PyObject *__pyx_kp_u_Split_array_into_multiple_sub_ar;
static PyObject *__pyx_kp_u_Stack_1_D_arrays_as_columns_into;
static PyObject *__pyx_kp_u_Stack_arrays_in_sequence_depth_w;
static PyObject *__pyx_kp_u_Stack_arrays_in_sequence_horizon;
static PyObject *__pyx_kp_u_Stack_arrays_in_sequence_vertica;
static PyObject *__pyx_kp_u_Sum_of_array_elements_over_a_giv;
static PyObject *__pyx_kp_u_Take_elements_from_an_array_alon;
static PyObject *__pyx_kp_u_Test_element_wise_for_negative_i;
static PyObject *__pyx_kp_u_Test_element_wise_for_positive_i;
static PyObject *__pyx_kp_u_Test_whether_all_array_elements;
static PyObject *__pyx_kp_u_Test_whether_any_array_element_a;
static PyObject *__pyx_kp_u_Test_whether_each_element_of_a_1;
static PyObject *__pyx_kp_u_The_differences_between_consecut;
static PyObject *__pyx_kp_u_Trim_the_leading_and_or_trailing;
static PyObject *__pyx_kp_u_True_if_two_arrays_have_the_same;
static PyObject *__pyx_kp_u_Unwrap_by_changing_deltas_betwee;
static PyObject *__pyx_kp_u_Upper_triangle_of_an_array_Retur;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_kp_u_View_inputs_as_arrays_with_at_le;
static PyObject *__pyx_kp_u_View_inputs_as_arrays_with_at_le_2;
static PyObject *__pyx_n_s_X;
static PyObject *__pyx_n_s__10;
static PyObject *__pyx_kp_s__14;
static PyObject *__pyx_kp_s__2;
static PyObject *__pyx_kp_s__9;
static PyObject *__pyx_n_s_a;
static PyObject *__pyx_n_s_a1;
static PyObject *__pyx_n_s_a2;
static PyObject *__pyx_n_s_add_newdoc;
static PyObject *__pyx_n_s_all;
static PyObject *__pyx_kp_u_all_line_40;
static PyObject *__pyx_n_s_allclose;
static PyObject *__pyx_kp_u_allclose_line_99;
static PyObject *__pyx_n_s_alltrue;
static PyObject *__pyx_n_s_alterdot;
static PyObject *__pyx_n_s_amax;
static PyObject *__pyx_kp_u_amax_line_187;
static PyObject *__pyx_n_s_amin;
static PyObject *__pyx_kp_u_amin_line_244;
static PyObject *__pyx_n_s_angle;
static PyObject *__pyx_kp_u_angle_line_301;
static PyObject *__pyx_n_s_any;
static PyObject *__pyx_kp_u_any_line_335;
static PyObject *__pyx_n_s_append;
static PyObject *__pyx_kp_u_append_line_401;
static PyObject *__pyx_n_s_apply_along_axis;
static PyObject *__pyx_kp_u_apply_along_axis_line_449;
static PyObject *__pyx_n_s_apply_over_axes;
static PyObject *__pyx_kp_u_apply_over_axes_line_506;
static PyObject *__pyx_n_s_ar;
static PyObject *__pyx_n_s_ar1;
static PyObject *__pyx_n_s_ar2;
static PyObject *__pyx_n_s_arg1;
static PyObject *__pyx_n_s_arg2;
static PyObject *__pyx_n_s_argmax;
static PyObject *__pyx_kp_u_argmax_line_560;
static PyObject *__pyx_n_s_argmin;
static PyObject *__pyx_n_s_argsort;
static PyObject *__pyx_kp_u_argsort_line_624;
static PyObject *__pyx_n_s_argwhere;
static PyObject *__pyx_kp_u_argwhere_line_704;
static PyObject *__pyx_n_s_around;
static PyObject *__pyx_kp_u_around_line_744;
static PyObject *__pyx_n_s_arr;
static PyObject *__pyx_n_s_array;
static PyObject *__pyx_n_s_array2string;
static PyObject *__pyx_kp_u_array2string_line_906;
static PyObject *__pyx_n_s_array_equal;
static PyObject *__pyx_kp_u_array_equal_line_955;
static PyObject *__pyx_n_s_array_equiv;
static PyObject *__pyx_kp_u_array_equiv_line_990;
static PyObject *__pyx_kp_u_array_line_812;
static PyObject *__pyx_kp_u_array_object_dtype_None_copy_Tru;
static PyObject *__pyx_n_s_array_repr;
static PyObject *__pyx_kp_u_array_repr_line_1027;
static PyObject *__pyx_n_s_array_split;
static PyObject *__pyx_kp_u_array_split_line_1071;
static PyObject *__pyx_n_s_array_str;
static PyObject *__pyx_kp_u_array_str_line_1093;
static PyObject *__pyx_n_s_array_types;
static PyObject *__pyx_n_s_arrays_and_dtypes;
static PyObject *__pyx_n_s_ary;
static PyObject *__pyx_n_s_asanyarray;
static PyObject *__pyx_kp_u_asanyarray_line_1129;
static PyObject *__pyx_n_s_asarray_chkfinite;
static PyObject *__pyx_kp_u_asarray_chkfinite_line_1181;
static PyObject *__pyx_n_s_ascontiguousarray;
static PyObject *__pyx_kp_u_ascontiguousarray_line_1243;
static PyObject *__pyx_n_s_asfarray;
static PyObject *__pyx_kp_u_asfarray_line_1279;
static PyObject *__pyx_n_s_asfortranarray;
static PyObject *__pyx_kp_u_asfortranarray_line_1308;
static PyObject *__pyx_n_s_asmatrix;
static PyObject *__pyx_kp_u_asmatrix_line_1344;
static PyObject *__pyx_n_s_asscalar;
static PyObject *__pyx_kp_u_asscalar_line_1376;
static PyObject *__pyx_n_s_assume_unique;
static PyObject *__pyx_n_s_atleast_1d;
static PyObject *__pyx_kp_u_atleast_1d_line_1398;
static PyObject *__pyx_n_s_atleast_2d;
static PyObject *__pyx_kp_u_atleast_2d_line_1439;
static PyObject *__pyx_n_s_atleast_3d;
static PyObject *__pyx_kp_u_atleast_3d_line_1478;
static PyObject *__pyx_n_s_atol;
static PyObject *__pyx_n_s_autostrip;
static PyObject *__pyx_n_s_average;
static PyObject *__pyx_kp_u_average_line_1529;
static PyObject *__pyx_n_s_axes;
static PyObject *__pyx_n_s_axis;
static PyObject *__pyx_n_s_axis1;
static PyObject *__pyx_n_s_axis2;
static PyObject *__pyx_n_s_axisa;
static PyObject *__pyx_n_s_axisb;
static PyObject *__pyx_n_s_axisc;
static PyObject *__pyx_n_s_b;
static PyObject *__pyx_n_s_bartlett;
static PyObject *__pyx_kp_u_bartlett_line_1604;
static PyObject *__pyx_n_s_base;
static PyObject *__pyx_n_s_base_repr;
static PyObject *__pyx_kp_u_base_repr_line_1708;
static PyObject *__pyx_n_s_beta;
static PyObject *__pyx_n_s_bias;
static PyObject *__pyx_n_s_binary_repr;
static PyObject *__pyx_kp_u_binary_repr_line_1748;
static PyObject *__pyx_n_s_bincount;
static PyObject *__pyx_kp_u_bincount_line_1808;
static PyObject *__pyx_kp_u_bincount_x_weights_None_minlengt;
static PyObject *__pyx_n_s_bins;
static PyObject *__pyx_n_s_blackman;
static PyObject *__pyx_kp_u_blackman_line_1883;
static PyObject *__pyx_n_s_bmat;
static PyObject *__pyx_kp_u_bmat_line_1979;
static PyObject *__pyx_n_s_broadcast_arrays;
static PyObject *__pyx_kp_u_broadcast_arrays_line_2026;
static PyObject *__pyx_n_s_buffer;
static PyObject *__pyx_n_s_byte_bounds;
static PyObject *__pyx_kp_u_byte_bounds_line_2067;
static PyObject *__pyx_n_s_can_cast;
static PyObject *__pyx_kp_u_can_cast_from_totype_casting_saf;
static PyObject *__pyx_kp_u_can_cast_line_2099;
static PyObject *__pyx_n_s_case_sensitive;
static PyObject *__pyx_n_s_char;
static PyObject *__pyx_n_s_choicelist;
static PyObject *__pyx_n_s_choices;
static PyObject *__pyx_n_s_choose;
static PyObject *__pyx_kp_u_choose_line_2202;
static PyObject *__pyx_n_s_cline_in_traceback;
static PyObject *__pyx_n_s_column_stack;
static PyObject *__pyx_kp_u_column_stack_line_2323;
static PyObject *__pyx_n_s_comments;
static PyObject *__pyx_n_s_common_type;
static PyObject *__pyx_kp_u_common_type_line_2362;
static PyObject *__pyx_n_s_compare_chararrays;
static PyObject *__pyx_n_s_compress;
static PyObject *__pyx_kp_u_compress_line_2408;
static PyObject *__pyx_n_s_concatenate;
static PyObject *__pyx_kp_u_concatenate_a1_a2_axis_0_Join_a;
static PyObject *__pyx_kp_u_concatenate_line_2469;
static PyObject *__pyx_n_s_condition;
static PyObject *__pyx_n_s_condlist;
static PyObject *__pyx_n_s_converters;
static PyObject *__pyx_n_s_convolve;
static PyObject *__pyx_kp_u_convolve_line_2545;
static PyObject *__pyx_n_s_copy;
static PyObject *__pyx_kp_u_copy_line_2630;
static PyObject *__pyx_n_s_corrcoef;
static PyObject *__pyx_n_s_correlate;
static PyObject *__pyx_kp_u_correlate_line_2718;
static PyObject *__pyx_n_s_count;
static PyObject *__pyx_n_s_count_nonzero;
static PyObject *__pyx_kp_u_count_nonzero_a_Counts_the_numbe;
static PyObject *__pyx_kp_u_count_nonzero_line_2758;
static PyObject *__pyx_n_s_cov;
static PyObject *__pyx_kp_u_cov_line_2790;
static PyObject *__pyx_n_s_cross;
static PyObject *__pyx_kp_u_cross_line_2871;
static PyObject *__pyx_n_s_cumprod;
static PyObject *__pyx_kp_u_cumprod_line_2979;
static PyObject *__pyx_n_s_cumproduct;
static PyObject *__pyx_n_s_cumsum;
static PyObject *__pyx_kp_u_cumsum_line_3053;
static PyObject *__pyx_n_s_d;
static PyObject *__pyx_n_s_data;
static PyObject *__pyx_n_s_datetime_data;
static PyObject *__pyx_n_s_ddof;
static PyObject *__pyx_n_s_decimals;
static PyObject *__pyx_n_s_default;
static PyObject *__pyx_n_s_defaultfmt;
static PyObject *__pyx_n_s_deg;
static PyObject *__pyx_n_s_delete;
static PyObject *__pyx_kp_u_delete_line_3124;
static PyObject *__pyx_n_s_deletechars;
static PyObject *__pyx_n_s_delimiter;
static PyObject *__pyx_n_s_density;
static PyObject *__pyx_n_s_deprecate;
static PyObject *__pyx_kp_u_deprecate_line_3171;
static PyObject *__pyx_n_s_deprecate_with_doc;
static PyObject *__pyx_n_s_device;
static PyObject *__pyx_n_s_diag_indices;
static PyObject *__pyx_n_s_diag_indices_from;
static PyObject *__pyx_kp_u_diag_indices_line_3221;
static PyObject *__pyx_n_s_diagflat;
static PyObject *__pyx_kp_u_diagflat_line_3308;
static PyObject *__pyx_n_s_diff;
static PyObject *__pyx_kp_u_diff_line_3349;
static PyObject *__pyx_n_s_digitize;
static PyObject *__pyx_kp_u_digitize_line_3394;
static PyObject *__pyx_kp_u_digitize_x_bins_Return_the_indic;
static PyObject *__pyx_n_s_dimensions;
static PyObject *__pyx_n_s_dims;
static PyObject *__pyx_n_s_discont;
static PyObject *__pyx_n_s_disp;
static PyObject *__pyx_kp_u_disp_line_3453;
static PyObject *__pyx_n_s_divide;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_n_s_docstring;
static PyObject *__pyx_n_s_dsplit;
static PyObject *__pyx_kp_u_dsplit_line_3487;
static PyObject *__pyx_n_s_dstack;
static PyObject *__pyx_kp_u_dstack_line_3530;
static PyObject *__pyx_n_s_dtype;
static PyObject *__pyx_n_s_dx;
static PyObject *__pyx_n_s_edgeitems;
static PyObject *__pyx_n_s_ediff1d;
static PyObject *__pyx_kp_u_ediff1d_line_3580;
static PyObject *__pyx_n_s_einsum;
static PyObject *__pyx_kp_u_einsum_line_3625;
static PyObject *__pyx_kp_u_einsum_subscripts_operands_out_N;
static PyObject *__pyx_n_s_end;
static PyObject *__pyx_n_s_errobj;
static PyObject *__pyx_n_s_excludelist;
static PyObject *__pyx_n_s_expand_dims;
static PyObject *__pyx_kp_u_expand_dims_line_3817;
static PyObject *__pyx_n_s_extract;
static PyObject *__pyx_kp_u_extract_line_3870;
static PyObject *__pyx_n_s_f;
static PyObject *__pyx_kp_s_f_i;
static PyObject *__pyx_n_s_fastCopyAndTranspose;
static PyObject *__pyx_n_s_fb;
static PyObject *__pyx_n_s_file;
static PyObject *__pyx_n_s_fill_diagonal;
static PyObject *__pyx_kp_u_fill_diagonal_line_3921;
static PyObject *__pyx_n_s_filling_values;
static PyObject *__pyx_n_s_filt;
static PyObject *__pyx_n_s_finance_rate;
static PyObject *__pyx_n_s_find_common_type;
static PyObject *__pyx_kp_u_find_common_type_line_3982;
static PyObject *__pyx_n_s_fix;
static PyObject *__pyx_kp_u_fix_line_4035;
static PyObject *__pyx_n_s_flatnonzero;
static PyObject *__pyx_kp_u_flatnonzero_line_4071;
static PyObject *__pyx_n_s_fliplr;
static PyObject *__pyx_kp_u_fliplr_line_4110;
static PyObject *__pyx_n_s_flipud;
static PyObject *__pyx_kp_u_flipud_line_4157;
static PyObject *__pyx_n_s_float64;
static PyObject *__pyx_n_s_fmt;
static PyObject *__pyx_n_s_fname;
static PyObject *__pyx_n_s_fp;
static PyObject *__pyx_n_s_frombuffer;
static PyObject *__pyx_kp_u_frombuffer_buffer_dtype_float_co;
static PyObject *__pyx_kp_u_frombuffer_line_4207;
static PyObject *__pyx_n_s_fromfile;
static PyObject *__pyx_kp_u_fromfile_file_dtype_float_count;
static PyObject *__pyx_kp_u_fromfile_line_4247;
static PyObject *__pyx_n_s_fromiter;
static PyObject *__pyx_kp_u_fromiter_iterable_dtype_count_1;
static PyObject *__pyx_kp_u_fromiter_line_4324;
static PyObject *__pyx_n_s_frompyfunc;
static PyObject *__pyx_kp_u_frompyfunc_func_nin_nout_Takes_a;
static PyObject *__pyx_kp_u_frompyfunc_line_4360;
static PyObject *__pyx_n_s_fromregex;
static PyObject *__pyx_kp_u_fromregex_line_4402;
static PyObject *__pyx_n_s_fromstring;
static PyObject *__pyx_kp_u_fromstring_line_4459;
static PyObject *__pyx_kp_u_fromstring_string_dtype_float_co;
static PyObject *__pyx_n_s_full;
static PyObject *__pyx_n_s_func;
static PyObject *__pyx_n_s_func1d;
static PyObject *__pyx_n_s_funclist;
static PyObject *__pyx_n_s_fv;
static PyObject *__pyx_kp_u_fv_line_4513;
static PyObject *__pyx_n_s_ga4py_gain_notimplemented;
static PyObject *__pyx_kp_s_ga4py_gain_notimplemented_pyx;
static PyObject *__pyx_n_s_gdict;
static PyObject *__pyx_n_s_genfromtxt;
static PyObject *__pyx_kp_u_genfromtxt_line_4596;
static PyObject *__pyx_n_s_get_array_wrap;
static PyObject *__pyx_n_s_get_include;
static PyObject *__pyx_n_s_get_numarray_include;
static PyObject *__pyx_n_s_get_printoptions;
static PyObject *__pyx_n_s_getbuffer;
static PyObject *__pyx_kp_u_getbuffer_line_4826;
static PyObject *__pyx_kp_u_getbuffer_obj_offset_size_Create;
static PyObject *__pyx_n_s_getbufsize;
static PyObject *__pyx_n_s_geterr;
static PyObject *__pyx_kp_u_geterr_line_4869;
static PyObject *__pyx_n_s_geterrcall;
static PyObject *__pyx_kp_u_geterrcall_line_4908;
static PyObject *__pyx_n_s_geterrobj;
static PyObject *__pyx_kp_u_geterrobj_Return_the_current_obj;
static PyObject *__pyx_kp_u_geterrobj_line_4952;
static PyObject *__pyx_n_s_gradient;
static PyObject *__pyx_kp_u_gradient_line_5018;
static PyObject *__pyx_n_s_guess;
static PyObject *__pyx_n_s_hamming;
static PyObject *__pyx_kp_u_hamming_line_5058;
static PyObject *__pyx_n_s_hanning;
static PyObject *__pyx_kp_u_hanning_line_5152;
static PyObject *__pyx_n_s_histogram;
static PyObject *__pyx_n_s_histogram2d;
static PyObject *__pyx_kp_u_histogram2d_line_5333;
static PyObject *__pyx_kp_u_histogram_line_5248;
static PyObject *__pyx_n_s_histogramdd;
static PyObject *__pyx_kp_u_histogramdd_line_5418;
static PyObject *__pyx_n_s_hsplit;
static PyObject *__pyx_kp_u_hsplit_line_5471;
static PyObject *__pyx_n_s_hstack;
static PyObject *__pyx_kp_u_hstack_line_5528;
static PyObject *__pyx_n_s_i0;
static PyObject *__pyx_kp_u_i0_line_5572;
static PyObject *__pyx_n_s_imag;
static PyObject *__pyx_kp_u_imag_line_5628;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_import_modules;
static PyObject *__pyx_n_s_in1d;
static PyObject *__pyx_kp_u_in1d_line_5659;
static PyObject *__pyx_n_s_ind;
static PyObject *__pyx_n_s_indices;
static PyObject *__pyx_kp_u_indices_line_5707;
static PyObject *__pyx_n_s_indices_or_sections;
static PyObject *__pyx_n_s_info;
static PyObject *__pyx_kp_u_info_line_5769;
static PyObject *__pyx_n_s_infstr;
static PyObject *__pyx_n_s_inner;
static PyObject *__pyx_kp_u_inner_a_b_Inner_product_of_two_a;
static PyObject *__pyx_kp_u_inner_line_5819;
static PyObject *__pyx_n_s_insert;
static PyObject *__pyx_kp_u_insert_line_5895;
static PyObject *__pyx_n_s_int_asbuffer;
static PyObject *__pyx_n_s_interp;
static PyObject *__pyx_kp_u_interp_line_5968;
static PyObject *__pyx_n_s_intersect1d;
static PyObject *__pyx_kp_u_intersect1d_line_6039;
static PyObject *__pyx_n_s_invalid;
static PyObject *__pyx_n_s_invalid_raise;
static PyObject *__pyx_n_s_ipmt;
static PyObject *__pyx_n_s_irr;
static PyObject *__pyx_kp_u_irr_line_6113;
static PyObject *__pyx_n_s_iscomplex;
static PyObject *__pyx_kp_u_iscomplex_line_6168;
static PyObject *__pyx_n_s_iscomplexobj;
static PyObject *__pyx_kp_u_iscomplexobj_line_6199;
static PyObject *__pyx_n_s_isfortran;
static PyObject *__pyx_kp_u_isfortran_line_6233;
static PyObject *__pyx_n_s_isneginf;
static PyObject *__pyx_kp_u_isneginf_line_6290;
static PyObject *__pyx_n_s_isposinf;
static PyObject *__pyx_kp_u_isposinf_line_6349;
static PyObject *__pyx_n_s_isreal;
static PyObject *__pyx_kp_u_isreal_line_6407;
static PyObject *__pyx_n_s_isrealobj;
static PyObject *__pyx_kp_u_isrealobj_line_6437;
static PyObject *__pyx_n_s_isscalar;
static PyObject *__pyx_kp_u_isscalar_line_6471;
static PyObject *__pyx_n_s_issctype;
static PyObject *__pyx_kp_u_issctype_line_6497;
static PyObject *__pyx_n_s_issubclass;
static PyObject *__pyx_kp_u_issubclass__line_6533;
static PyObject *__pyx_n_s_issubdtype;
static PyObject *__pyx_kp_u_issubdtype_line_6568;
static PyObject *__pyx_n_s_issubsctype;
static PyObject *__pyx_kp_u_issubsctype_line_6596;
static PyObject *__pyx_n_s_iterable;
static PyObject *__pyx_kp_u_iterable_line_6626;
static PyObject *__pyx_n_s_ix;
static PyObject *__pyx_kp_u_ix__line_6652;
static PyObject *__pyx_n_s_k;
static PyObject *__pyx_n_s_kaiser;
static PyObject *__pyx_kp_u_kaiser_line_6698;
static PyObject *__pyx_n_s_keys;
static PyObject *__pyx_n_s_kind;
static PyObject *__pyx_n_s_kron;
static PyObject *__pyx_kp_u_kron_line_6825;
static PyObject *__pyx_n_s_ldict;
static PyObject *__pyx_n_s_left;
static PyObject *__pyx_n_s_lexsort;
static PyObject *__pyx_kp_u_lexsort_keys_axis_1_Perform_an_i;
static PyObject *__pyx_kp_u_lexsort_line_6897;
static PyObject *__pyx_n_s_linefeed;
static PyObject *__pyx_n_s_linewidth;
static PyObject *__pyx_n_s_load;
static PyObject *__pyx_kp_u_load_line_6975;
static PyObject *__pyx_n_s_loads;
static PyObject *__pyx_n_s_loadtxt;
static PyObject *__pyx_kp_u_loadtxt_line_7045;
static PyObject *__pyx_n_s_lookfor;
static PyObject *__pyx_kp_u_lookfor_line_7132;
static PyObject *__pyx_n_s_loose;
static PyObject *__pyx_n_s_m;
static PyObject *__pyx_n_s_mafromtxt;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_mask;
static PyObject *__pyx_n_s_mask_func;
static PyObject *__pyx_n_s_mask_indices;
static PyObject *__pyx_kp_u_mask_indices_line_7192;
static PyObject *__pyx_n_s_mat;
static PyObject *__pyx_kp_u_mat_line_7259;
static PyObject *__pyx_n_s_max;
static PyObject *__pyx_kp_u_max_line_7291;
static PyObject *__pyx_n_s_max_line_width;
static PyObject *__pyx_n_s_maximum_sctype;
static PyObject *__pyx_kp_u_maximum_sctype_line_7348;
static PyObject *__pyx_n_s_maxiter;
static PyObject *__pyx_n_s_maxwidth;
static PyObject *__pyx_n_s_may_share_memory;
static PyObject *__pyx_kp_u_may_share_memory_line_7388;
static PyObject *__pyx_n_s_mean;
static PyObject *__pyx_kp_u_mean_line_7414;
static PyObject *__pyx_n_s_median;
static PyObject *__pyx_kp_u_median_line_7487;
static PyObject *__pyx_n_s_mesg;
static PyObject *__pyx_n_s_meshgrid;
static PyObject *__pyx_kp_u_meshgrid_line_7563;
static PyObject *__pyx_n_s_min;
static PyObject *__pyx_kp_u_min_line_7611;
static PyObject *__pyx_n_s_min_scalar_type;
static PyObject *__pyx_kp_u_min_scalar_type_a_For_scalar_a_r;
static PyObject *__pyx_kp_u_min_scalar_type_line_7668;
static PyObject *__pyx_n_s_minlength;
static PyObject *__pyx_n_s_mintypecode;
static PyObject *__pyx_kp_u_mintypecode_line_7718;
static PyObject *__pyx_n_s_mirr;
static PyObject *__pyx_n_s_missing;
static PyObject *__pyx_n_s_missing_values;
static PyObject *__pyx_n_s_mmap_mode;
static PyObject *__pyx_n_s_mode;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_msg;
static PyObject *__pyx_n_s_msort;
static PyObject *__pyx_n_s_multi_index;
static PyObject *__pyx_n_s_myarray;
static PyObject *__pyx_n_s_n;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_names;
static PyObject *__pyx_n_s_nan_to_num;
static PyObject *__pyx_kp_u_nan_to_num_line_7810;
static PyObject *__pyx_n_s_nanargmax;
static PyObject *__pyx_kp_u_nanargmax_line_7857;
static PyObject *__pyx_n_s_nanargmin;
static PyObject *__pyx_kp_u_nanargmin_line_7892;
static PyObject *__pyx_n_s_nanmax;
static PyObject *__pyx_kp_u_nanmax_line_7927;
static PyObject *__pyx_n_s_nanmin;
static PyObject *__pyx_kp_u_nanmin_line_7984;
static PyObject *__pyx_n_s_nanstr;
static PyObject *__pyx_n_s_nansum;
static PyObject *__pyx_kp_u_nansum_line_8039;
static PyObject *__pyx_kp_u_ndarray_is_not_C_contiguous;
static PyObject *__pyx_kp_u_ndarray_is_not_Fortran_contiguou;
static PyObject *__pyx_n_s_ndfromtxt;
static PyObject *__pyx_n_s_ndim;
static PyObject *__pyx_kp_u_ndim_line_8121;
static PyObject *__pyx_n_s_ndmin;
static PyObject *__pyx_n_s_nested_iters;
static PyObject *__pyx_n_s_new_shape;
static PyObject *__pyx_n_s_newbuffer;
static PyObject *__pyx_n_s_newline;
static PyObject *__pyx_n_s_newshape;
static PyObject *__pyx_n_s_nin;
static PyObject *__pyx_n_s_nonzero;
static PyObject *__pyx_kp_u_nonzero_line_8172;
static PyObject *__pyx_n_s_normed;
static PyObject *__pyx_n_s_nout;
static PyObject *__pyx_n_s_np;
static PyObject *__pyx_n_s_nper;
static PyObject *__pyx_kp_u_nper_line_8247;
static PyObject *__pyx_n_s_npv;
static PyObject *__pyx_kp_u_npv_line_8298;
static PyObject *__pyx_n_s_num;
static PyObject *__pyx_n_s_number;
static PyObject *__pyx_n_s_numpy;
static PyObject *__pyx_kp_s_numpy_core_multiarray_failed_to;
static PyObject *__pyx_kp_s_numpy_core_umath_failed_to_impor;
static PyObject *__pyx_n_s_obj;
static PyObject *__pyx_n_s_obj2sctype;
static PyObject *__pyx_kp_u_obj2sctype_line_8342;
static PyObject *__pyx_n_s_object;
static PyObject *__pyx_n_s_offset;
static PyObject *__pyx_n_s_old_behavior;
static PyObject *__pyx_n_s_order;
static PyObject *__pyx_n_s_out;
static PyObject *__pyx_n_s_outer;
static PyObject *__pyx_kp_u_outer_line_8383;
static PyObject *__pyx_n_s_output;
static PyObject *__pyx_n_s_over;
static PyObject *__pyx_n_s_overwrite_input;
static PyObject *__pyx_n_s_p;
static PyObject *__pyx_n_s_packbits;
static PyObject *__pyx_kp_u_packbits_line_8454;
static PyObject *__pyx_kp_u_packbits_myarray_axis_None_Packs;
static PyObject *__pyx_n_s_padding;
static PyObject *__pyx_n_s_per;
static PyObject *__pyx_n_s_percentile;
static PyObject *__pyx_kp_u_percentile_line_8500;
static PyObject *__pyx_n_s_piecewise;
static PyObject *__pyx_kp_u_piecewise_line_8580;
static PyObject *__pyx_n_s_pkgload;
static PyObject *__pyx_n_s_place;
static PyObject *__pyx_kp_u_place_line_8702;
static PyObject *__pyx_n_s_pmt;
static PyObject *__pyx_kp_u_pmt_line_8738;
static PyObject *__pyx_n_s_poly;
static PyObject *__pyx_kp_u_poly_line_8823;
static PyObject *__pyx_n_s_polyadd;
static PyObject *__pyx_kp_u_polyadd_line_8917;
static PyObject *__pyx_n_s_polyder;
static PyObject *__pyx_kp_u_polyder_line_8963;
static PyObject *__pyx_n_s_polydiv;
static PyObject *__pyx_kp_u_polydiv_line_9017;
static PyObject *__pyx_n_s_polyfit;
static PyObject *__pyx_kp_u_polyfit_line_9064;
static PyObject *__pyx_n_s_polyint;
static PyObject *__pyx_kp_u_polyint_line_9200;
static PyObject *__pyx_n_s_polymul;
static PyObject *__pyx_kp_u_polymul_line_9269;
static PyObject *__pyx_n_s_polysub;
static PyObject *__pyx_kp_u_polysub_line_9318;
static PyObject *__pyx_n_s_polyval;
static PyObject *__pyx_kp_u_polyval_line_9350;
static PyObject *__pyx_n_s_ppmt;
static PyObject *__pyx_n_s_precision;
static PyObject *__pyx_n_s_prefix;
static PyObject *__pyx_n_s_prod;
static PyObject *__pyx_kp_u_prod_line_9438;
static PyObject *__pyx_n_s_product;
static PyObject *__pyx_n_s_promote_types;
static PyObject *__pyx_kp_u_promote_types_line_9525;
static PyObject *__pyx_kp_u_promote_types_type1_type2_Return;
static PyObject *__pyx_n_s_ptp;
static PyObject *__pyx_kp_u_ptp_line_9575;
static PyObject *__pyx_n_s_put;
static PyObject *__pyx_kp_u_put_line_9615;
static PyObject *__pyx_n_s_putmask;
static PyObject *__pyx_kp_u_putmask_a_mask_values_Changes_el;
static PyObject *__pyx_kp_u_putmask_line_9665;
static PyObject *__pyx_n_s_pv;
static PyObject *__pyx_kp_u_pv_line_9709;
static PyObject *__pyx_n_s_q;
static PyObject *__pyx_n_s_quicksort;
static PyObject *__pyx_n_s_raise;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_rank;
static PyObject *__pyx_kp_u_rank_line_9797;
static PyObject *__pyx_n_s_rate;
static PyObject *__pyx_n_s_ravel;
static PyObject *__pyx_kp_u_ravel_line_9884;
static PyObject *__pyx_n_s_ravel_multi_index;
static PyObject *__pyx_kp_u_ravel_multi_index_line_9968;
static PyObject *__pyx_kp_u_ravel_multi_index_multi_index_di;
static PyObject *__pyx_n_s_rcond;
static PyObject *__pyx_n_s_real;
static PyObject *__pyx_n_s_real_if_close;
static PyObject *__pyx_kp_u_real_if_close_line_10062;
static PyObject *__pyx_kp_u_real_line_10028;
static PyObject *__pyx_n_s_recfromcsv;
static PyObject *__pyx_n_s_recfromtxt;
static PyObject *__pyx_n_s_regenerate;
static PyObject *__pyx_n_s_regexp;
static PyObject *__pyx_n_s_reinvest_rate;
static PyObject *__pyx_n_s_rep;
static PyObject *__pyx_n_s_repeat;
static PyObject *__pyx_kp_u_repeat_line_10146;
static PyObject *__pyx_n_s_repeats;
static PyObject *__pyx_n_s_replace_space;
static PyObject *__pyx_n_s_repr;
static PyObject *__pyx_n_s_reps;
static PyObject *__pyx_n_s_require;
static PyObject *__pyx_kp_u_require_line_10187;
static PyObject *__pyx_n_s_requirements;
static PyObject *__pyx_n_s_reshape;
static PyObject *__pyx_kp_u_reshape_line_10246;
static PyObject *__pyx_n_s_resize;
static PyObject *__pyx_kp_u_resize_line_10308;
static PyObject *__pyx_n_s_restoredot;
static PyObject *__pyx_n_s_result_type;
static PyObject *__pyx_kp_u_result_type_arrays_and_dtypes_Re;
static PyObject *__pyx_kp_u_result_type_line_10366;
static PyObject *__pyx_n_s_return_index;
static PyObject *__pyx_n_s_return_inverse;
static PyObject *__pyx_n_s_returned;
static PyObject *__pyx_n_s_right;
static PyObject *__pyx_n_s_roll;
static PyObject *__pyx_kp_u_roll_line_10437;
static PyObject *__pyx_n_s_rollaxis;
static PyObject *__pyx_kp_u_rollaxis_line_10488;
static PyObject *__pyx_n_s_roots;
static PyObject *__pyx_kp_u_roots_line_10526;
static PyObject *__pyx_n_s_rot90;
static PyObject *__pyx_kp_u_rot90_line_10577;
static PyObject *__pyx_n_s_round;
static PyObject *__pyx_n_s_round_2;
static PyObject *__pyx_n_s_row_stack;
static PyObject *__pyx_kp_u_row_stack_line_10643;
static PyObject *__pyx_n_s_rowvar;
static PyObject *__pyx_n_s_rtol;
static PyObject *__pyx_n_s_safe_eval;
static PyObject *__pyx_kp_u_safe_eval_line_10694;
static PyObject *__pyx_n_s_sample;
static PyObject *__pyx_n_s_save;
static PyObject *__pyx_kp_u_save_line_10739;
static PyObject *__pyx_n_s_savetxt;
static PyObject *__pyx_kp_u_savetxt_line_10777;
static PyObject *__pyx_n_s_savez;
static PyObject *__pyx_n_s_savez_compressed;
static PyObject *__pyx_kp_u_savez_line_10868;
static PyObject *__pyx_n_s_scalar_types;
static PyObject *__pyx_n_s_sctype;
static PyObject *__pyx_n_s_sctype2char;
static PyObject *__pyx_kp_u_sctype2char_line_10972;
static PyObject *__pyx_n_s_searchsorted;
static PyObject *__pyx_kp_u_searchsorted_line_11016;
static PyObject *__pyx_n_s_select;
static PyObject *__pyx_kp_u_select_line_11064;
static PyObject *__pyx_n_s_sep;
static PyObject *__pyx_n_s_separator;
static PyObject *__pyx_n_s_seq_of_zeros;
static PyObject *__pyx_n_s_set_numeric_ops;
static PyObject *__pyx_kp_u_set_numeric_ops_line_11103;
static PyObject *__pyx_kp_u_set_numeric_ops_op1_func1_op2_fu;
static PyObject *__pyx_n_s_set_printoptions;
static PyObject *__pyx_kp_u_set_printoptions_line_11149;
static PyObject *__pyx_n_s_set_string_function;
static PyObject *__pyx_kp_u_set_string_function_line_11214;
static PyObject *__pyx_n_s_setbufsize;
static PyObject *__pyx_n_s_setdiff1d;
static PyObject *__pyx_kp_u_setdiff1d_line_11279;
static PyObject *__pyx_n_s_seterr;
static PyObject *__pyx_kp_u_seterr_line_11315;
static PyObject *__pyx_n_s_seterrcall;
static PyObject *__pyx_kp_u_seterrcall_line_11394;
static PyObject *__pyx_n_s_seterrobj;
static PyObject *__pyx_kp_u_seterrobj_errobj_Set_the_object;
static PyObject *__pyx_kp_u_seterrobj_line_11477;
static PyObject *__pyx_n_s_setxor1d;
static PyObject *__pyx_kp_u_setxor1d_line_11538;
static PyObject *__pyx_n_s_shift;
static PyObject *__pyx_n_s_show_config;
static PyObject *__pyx_n_s_side;
static PyObject *__pyx_n_s_sinc;
static PyObject *__pyx_kp_u_sinc_line_11576;
static PyObject *__pyx_n_s_size;
static PyObject *__pyx_kp_u_size_line_11653;
static PyObject *__pyx_n_s_skip_footer;
static PyObject *__pyx_n_s_skip_header;
static PyObject *__pyx_n_s_skiprows;
static PyObject *__pyx_n_s_sometrue;
static PyObject *__pyx_n_s_sort;
static PyObject *__pyx_n_s_sort_complex;
static PyObject *__pyx_kp_u_sort_complex_line_11803;
static PyObject *__pyx_kp_u_sort_line_11702;
static PyObject *__pyx_n_s_source;
static PyObject *__pyx_kp_u_source_line_11828;
static PyObject *__pyx_n_s_split;
static PyObject *__pyx_kp_u_split_line_11868;
static PyObject *__pyx_n_s_squeeze;
static PyObject *__pyx_kp_u_squeeze_line_11935;
static PyObject *__pyx_n_s_start;
static PyObject *__pyx_n_s_std;
static PyObject *__pyx_kp_u_std_line_11961;
static PyObject *__pyx_n_s_stdout;
static PyObject *__pyx_n_s_string;
static PyObject *__pyx_n_s_style;
static PyObject *__pyx_n_s_subok;
static PyObject *__pyx_n_s_sum;
static PyObject *__pyx_kp_u_sum_line_12049;
static PyObject *__pyx_n_s_suppress;
static PyObject *__pyx_n_s_suppress_small;
static PyObject *__pyx_n_s_swapaxes;
static PyObject *__pyx_kp_u_swapaxes_line_12117;
static PyObject *__pyx_n_s_sys;
static PyObject *__pyx_n_s_t;
static PyObject *__pyx_n_s_take;
static PyObject *__pyx_kp_u_take_line_12160;
static PyObject *__pyx_n_s_tensordot;
static PyObject *__pyx_kp_u_tensordot_line_12216;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_threshold;
static PyObject *__pyx_n_s_tile;
static PyObject *__pyx_kp_u_tile_line_12332;
static PyObject *__pyx_n_s_to_begin;
static PyObject *__pyx_n_s_to_end;
static PyObject *__pyx_n_s_tol;
static PyObject *__pyx_n_s_toplevel;
static PyObject *__pyx_n_s_trace;
static PyObject *__pyx_kp_u_trace_line_12390;
static PyObject *__pyx_n_s_transpose;
static PyObject *__pyx_kp_u_transpose_line_12448;
static PyObject *__pyx_n_s_trapz;
static PyObject *__pyx_kp_u_trapz_line_12488;
static PyObject *__pyx_n_s_tri;
static PyObject *__pyx_kp_u_tri_line_12549;
static PyObject *__pyx_n_s_tril;
static PyObject *__pyx_n_s_tril_indices;
static PyObject *__pyx_n_s_tril_indices_from;
static PyObject *__pyx_kp_u_tril_indices_line_12622;
static PyObject *__pyx_kp_u_tril_line_12588;
static PyObject *__pyx_n_s_trim;
static PyObject *__pyx_n_s_trim_zeros;
static PyObject *__pyx_kp_u_trim_zeros_line_12719;
static PyObject *__pyx_n_s_triu;
static PyObject *__pyx_n_s_triu_indices;
static PyObject *__pyx_n_s_triu_indices_from;
static PyObject *__pyx_kp_u_triu_indices_line_12778;
static PyObject *__pyx_kp_u_triu_line_12754;
static PyObject *__pyx_n_s_tup;
static PyObject *__pyx_n_s_type;
static PyObject *__pyx_n_s_type1;
static PyObject *__pyx_n_s_type2;
static PyObject *__pyx_n_s_typechars;
static PyObject *__pyx_n_s_typename;
static PyObject *__pyx_kp_u_typename_line_12876;
static PyObject *__pyx_n_s_typeset;
static PyObject *__pyx_n_s_u;
static PyObject *__pyx_n_s_under;
static PyObject *__pyx_n_s_union1d;
static PyObject *__pyx_kp_u_union1d_line_12927;
static PyObject *__pyx_n_s_unique;
static PyObject *__pyx_kp_u_unique_line_12957;
static PyObject *__pyx_kp_u_unknown_dtype_code_in_numpy_pxd;
static PyObject *__pyx_n_s_unpack;
static PyObject *__pyx_n_s_unpackbits;
static PyObject *__pyx_kp_u_unpackbits_line_13028;
static PyObject *__pyx_kp_u_unpackbits_myarray_axis_None_Unp;
static PyObject *__pyx_n_s_unravel_index;
static PyObject *__pyx_kp_u_unravel_index_indices_dims_order;
static PyObject *__pyx_kp_u_unravel_index_line_13073;
static PyObject *__pyx_n_s_unwrap;
static PyObject *__pyx_kp_u_unwrap_line_13118;
static PyObject *__pyx_n_s_usecols;
static PyObject *__pyx_n_s_usemask;
static PyObject *__pyx_n_s_v;
static PyObject *__pyx_n_s_val;
static PyObject *__pyx_n_s_valid;
static PyObject *__pyx_n_s_vals;
static PyObject *__pyx_n_s_values;
static PyObject *__pyx_n_s_vander;
static PyObject *__pyx_kp_u_vander_line_13161;
static PyObject *__pyx_n_s_var;
static PyObject *__pyx_kp_u_var_line_13219;
static PyObject *__pyx_n_s_vardict;
static PyObject *__pyx_n_s_vdot;
static PyObject *__pyx_kp_u_vdot_line_13309;
static PyObject *__pyx_n_s_vsplit;
static PyObject *__pyx_kp_u_vsplit_line_13364;
static PyObject *__pyx_n_s_vstack;
static PyObject *__pyx_kp_u_vstack_line_13413;
static PyObject *__pyx_n_s_weights;
static PyObject *__pyx_n_s_what;
static PyObject *__pyx_n_s_when;
static PyObject *__pyx_n_s_where;
static PyObject *__pyx_kp_u_where_condition_x_y_Return_eleme;
static PyObject *__pyx_kp_u_where_line_13464;
static PyObject *__pyx_n_s_who;
static PyObject *__pyx_kp_u_who_line_13526;
static PyObject *__pyx_n_s_width;
static PyObject *__pyx_n_s_x;
static PyObject *__pyx_n_s_xp;
static PyObject *__pyx_n_s_y;
static PyObject *__pyx_n_s_z;
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_docstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_docstring); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_2add_newdoc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_place, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_doc); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_4all(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_6allclose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_rtol, CYTHON_UNUSED PyObject *__pyx_v_atol); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_8alltrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_10alterdot(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_12amax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_14amin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_16angle(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_z, CYTHON_UNUSED PyObject *__pyx_v_deg); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_18any(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_20append(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_22apply_along_axis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func1d, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_24apply_over_axes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_26argmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_28argmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_30argsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_32argwhere(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_34around(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_36array(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_copy, CYTHON_UNUSED PyObject *__pyx_v_order, CYTHON_UNUSED PyObject *__pyx_v_subok, CYTHON_UNUSED PyObject *__pyx_v_ndmin); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_38array2string(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small, CYTHON_UNUSED PyObject *__pyx_v_separator, CYTHON_UNUSED PyObject *__pyx_v_prefix, CYTHON_UNUSED PyObject *__pyx_v_style); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_40array_equal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_42array_equiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_44array_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_46array_split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_48array_str(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_50asanyarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_52asarray_chkfinite(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_54ascontiguousarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_56asfarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_58asfortranarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_60asmatrix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_62asscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_64atleast_1d(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_66atleast_2d(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_68atleast_3d(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_70average(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_returned); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_72bartlett(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_74base_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_number, CYTHON_UNUSED PyObject *__pyx_v_base, CYTHON_UNUSED PyObject *__pyx_v_padding); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_76binary_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num, CYTHON_UNUSED PyObject *__pyx_v_width); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_78bincount(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_minlength); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_80blackman(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_82bmat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_ldict, CYTHON_UNUSED PyObject *__pyx_v_gdict); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_84broadcast_arrays(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_86byte_bounds(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_88can_cast(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_90choose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_choices, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_92column_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_94common_type(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_96compare_chararrays(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_98compress(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_100concatenate(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_102convolve(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_104copy(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_106corrcoef(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_108correlate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_old_behavior); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_110count_nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_112cov(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_114cross(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axisa, CYTHON_UNUSED PyObject *__pyx_v_axisb, CYTHON_UNUSED PyObject *__pyx_v_axisc, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_116cumprod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_118cumproduct(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_120cumsum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_122datetime_data(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_124delete(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_126deprecate(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_128deprecate_with_doc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_msg); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_130diag_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_ndim); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_132diag_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_134diagflat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_136diff(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_138digitize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_bins); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_140disp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_mesg, CYTHON_UNUSED PyObject *__pyx_v_device, CYTHON_UNUSED PyObject *__pyx_v_linefeed); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_142dsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_144dstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_146ediff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_to_end, CYTHON_UNUSED PyObject *__pyx_v_to_begin); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_148einsum(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_150expand_dims(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_152extract(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_156fill_diagonal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_158find_common_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_array_types, CYTHON_UNUSED PyObject *__pyx_v_scalar_types); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_160fix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_162flatnonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_164fliplr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_166flipud(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_168frombuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_buffer, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_offset); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_170fromfile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_172fromiter(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_iterable, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_174frompyfunc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_nin, CYTHON_UNUSED PyObject *__pyx_v_nout); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_176fromregex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_regexp, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_178fromstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_string, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_180fv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_182genfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_skip_header, CYTHON_UNUSED PyObject *__pyx_v_skip_footer, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_missing, CYTHON_UNUSED PyObject *__pyx_v_missing_values, CYTHON_UNUSED PyObject *__pyx_v_filling_values, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_names, CYTHON_UNUSED PyObject *__pyx_v_excludelist, CYTHON_UNUSED PyObject *__pyx_v_deletechars, CYTHON_UNUSED PyObject *__pyx_v_replace_space, CYTHON_UNUSED PyObject *__pyx_v_autostrip, CYTHON_UNUSED PyObject *__pyx_v_case_sensitive, CYTHON_UNUSED PyObject *__pyx_v_defaultfmt, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_usemask, CYTHON_UNUSED PyObject *__pyx_v_loose, CYTHON_UNUSED PyObject *__pyx_v_invalid_raise); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_184get_array_wrap(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_186get_include(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_188get_numarray_include(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_190get_printoptions(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_192getbuffer(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_194getbufsize(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_196geterr(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_198geterrcall(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_200geterrobj(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_202gradient(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_204hamming(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_206hanning(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_208histogram(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_density); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_210histogram2d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_212histogramdd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sample, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_214hsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_216hstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_218i0(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_220imag(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_222in1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_224indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dimensions, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_226info(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_maxwidth, CYTHON_UNUSED PyObject *__pyx_v_output, CYTHON_UNUSED PyObject *__pyx_v_toplevel); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_228inner(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_230insert(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_232int_asbuffer(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_234interp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_xp, CYTHON_UNUSED PyObject *__pyx_v_fp, CYTHON_UNUSED PyObject *__pyx_v_left, CYTHON_UNUSED PyObject *__pyx_v_right); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_236intersect1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_238ipmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_240irr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_242iscomplex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_244iscomplexobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_246isfortran(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_248isneginf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_250isposinf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_252isreal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_254isrealobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_256isscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_258issctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_260issubclass_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_262issubdtype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_264issubsctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_266iterable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_268ix_(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_270kaiser(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_beta); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_272kron(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_274lexsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_keys, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_276load(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_mmap_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_278loads(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_280loadtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_ndmin); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_282lookfor(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_what, CYTHON_UNUSED PyObject *__pyx_v_module, CYTHON_UNUSED PyObject *__pyx_v_import_modules, CYTHON_UNUSED PyObject *__pyx_v_regenerate, CYTHON_UNUSED PyObject *__pyx_v_output); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_284mafromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_286mask_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_mask_func, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_288mat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_290max(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_292maximum_sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_t); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_294may_share_memory(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_296mean(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_298median(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_300meshgrid(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_302min(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_304min_scalar_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_306mintypecode(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_typechars, CYTHON_UNUSED PyObject *__pyx_v_typeset, CYTHON_UNUSED PyObject *__pyx_v_default); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_308mirr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_finance_rate, CYTHON_UNUSED PyObject *__pyx_v_reinvest_rate); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_310msort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_312nan_to_num(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_314nanargmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_316nanargmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_318nanmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_320nanmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_322nansum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_324ndfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_326ndim(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_328nested_iters(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_330newbuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_332nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_334nper(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_336npv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_values); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_338obj2sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep, CYTHON_UNUSED PyObject *__pyx_v_default); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_340outer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_342packbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_344percentile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_q, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_346piecewise(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_funclist); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_348pkgload(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_350place(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_vals); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_352pmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_354poly(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_seq_of_zeros); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_356polyadd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_358polyder(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_360polydiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_u, CYTHON_UNUSED PyObject *__pyx_v_v); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_362polyfit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_deg, CYTHON_UNUSED PyObject *__pyx_v_rcond, CYTHON_UNUSED PyObject *__pyx_v_full); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_364polyint(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_366polymul(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_368polysub(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_370polyval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_372ppmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_374prod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_376product(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_378promote_types(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type1, CYTHON_UNUSED PyObject *__pyx_v_type2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_380ptp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_382put(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_ind, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_384putmask(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_values); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_386pv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_388rank(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_390rate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when, CYTHON_UNUSED PyObject *__pyx_v_guess, CYTHON_UNUSED PyObject *__pyx_v_tol, CYTHON_UNUSED PyObject *__pyx_v_maxiter); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_392ravel(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_394ravel_multi_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_multi_index, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_396real(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_398real_if_close(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_tol); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_400recfromcsv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_402recfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_404repeat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_repeats, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_406require(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_requirements); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_408reshape(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_newshape, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_410resize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_new_shape); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_412restoredot(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_414result_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arrays_and_dtypes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_416roll(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_shift, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_418rollaxis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_start); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_420roots(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_422rot90(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_424round(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_426round_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_428row_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_430safe_eval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_source); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_432save(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_arr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_434savetxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_fmt, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_newline); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_436savez(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_438savez_compressed(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_440sctype2char(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sctype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_442searchsorted(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_side); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_444select(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_choicelist, CYTHON_UNUSED PyObject *__pyx_v_default); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_446set_numeric_ops(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_448set_printoptions(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_threshold, CYTHON_UNUSED PyObject *__pyx_v_edgeitems, CYTHON_UNUSED PyObject *__pyx_v_linewidth, CYTHON_UNUSED PyObject *__pyx_v_suppress, CYTHON_UNUSED PyObject *__pyx_v_nanstr, CYTHON_UNUSED PyObject *__pyx_v_infstr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_450set_string_function(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f, CYTHON_UNUSED PyObject *__pyx_v_repr); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_452setbufsize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_454setdiff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_456seterr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_all, CYTHON_UNUSED PyObject *__pyx_v_divide, CYTHON_UNUSED PyObject *__pyx_v_over, CYTHON_UNUSED PyObject *__pyx_v_under, CYTHON_UNUSED PyObject *__pyx_v_invalid); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_458seterrcall(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_460seterrobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_errobj); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_462setxor1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_464show_config(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_466sinc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_468size(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_470sometrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_472sort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_474sort_complex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_476source(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_output); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_478split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_480squeeze(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_482std(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_484sum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_486swapaxes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_488take(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_490tensordot(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_492tile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_A, CYTHON_UNUSED PyObject *__pyx_v_reps); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_494trace(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_offset, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_496transpose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_498trapz(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_dx, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_500tri(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_N, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_k, CYTHON_UNUSED PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_502tril(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_504tril_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_506tril_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_508trim_zeros(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_filt, CYTHON_UNUSED PyObject *__pyx_v_trim); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_510triu(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_512triu_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_514triu_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_516typename(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_char_); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_518union1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_520unique(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar, CYTHON_UNUSED PyObject *__pyx_v_return_index, CYTHON_UNUSED PyObject *__pyx_v_return_inverse); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_522unpackbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_524unravel_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_order); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_526unwrap(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_discont, CYTHON_UNUSED PyObject *__pyx_v_axis); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_528vander(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_N); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_530var(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_532vdot(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_534vsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_536vstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_538where(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_540who(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_vardict); /* proto */
static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
static PyObject *__pyx_float_0_0;
static PyObject *__pyx_float_0_1;
static PyObject *__pyx_float_1_0;
static PyObject *__pyx_float_1eneg_05;
static PyObject *__pyx_float_1eneg_06;
static PyObject *__pyx_float_1eneg_08;
static PyObject *__pyx_float_3_14159265359;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2;
static PyObject *__pyx_int_10;
static PyObject *__pyx_int_76;
static PyObject *__pyx_int_100;
static PyObject *__pyx_int_neg_1;
static PyObject *__pyx_k__3;
static PyObject *__pyx_k__4;
static PyObject *__pyx_k__5;
static PyObject *__pyx_k__6;
static PyObject *__pyx_k__7;
static PyObject *__pyx_k__8;
static PyObject *__pyx_k__11;
static PyObject *__pyx_k__12;
static PyObject *__pyx_k__13;
static PyObject *__pyx_k__15;
static PyObject *__pyx_k__16;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__19;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__23;
static PyObject *__pyx_tuple__24;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__35;
static PyObject *__pyx_tuple__37;
static PyObject *__pyx_tuple__39;
static PyObject *__pyx_tuple__41;
static PyObject *__pyx_tuple__43;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__49;
static PyObject *__pyx_tuple__51;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__63;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__69;
static PyObject *__pyx_tuple__71;
static PyObject *__pyx_tuple__73;
static PyObject *__pyx_tuple__75;
static PyObject *__pyx_tuple__77;
static PyObject *__pyx_tuple__79;
static PyObject *__pyx_tuple__81;
static PyObject *__pyx_tuple__83;
static PyObject *__pyx_tuple__85;
static PyObject *__pyx_tuple__90;
static PyObject *__pyx_tuple__92;
static PyObject *__pyx_tuple__94;
static PyObject *__pyx_tuple__96;
static PyObject *__pyx_tuple__98;
static PyObject *__pyx_tuple__100;
static PyObject *__pyx_tuple__102;
static PyObject *__pyx_tuple__105;
static PyObject *__pyx_tuple__108;
static PyObject *__pyx_tuple__110;
static PyObject *__pyx_tuple__114;
static PyObject *__pyx_tuple__117;
static PyObject *__pyx_tuple__119;
static PyObject *__pyx_tuple__121;
static PyObject *__pyx_tuple__123;
static PyObject *__pyx_tuple__125;
static PyObject *__pyx_tuple__127;
static PyObject *__pyx_tuple__129;
static PyObject *__pyx_tuple__131;
static PyObject *__pyx_tuple__133;
static PyObject *__pyx_tuple__135;
static PyObject *__pyx_tuple__137;
static PyObject *__pyx_tuple__139;
static PyObject *__pyx_tuple__142;
static PyObject *__pyx_tuple__144;
static PyObject *__pyx_tuple__146;
static PyObject *__pyx_tuple__148;
static PyObject *__pyx_tuple__150;
static PyObject *__pyx_tuple__152;
static PyObject *__pyx_tuple__154;
static PyObject *__pyx_tuple__156;
static PyObject *__pyx_tuple__158;
static PyObject *__pyx_tuple__160;
static PyObject *__pyx_tuple__163;
static PyObject *__pyx_tuple__165;
static PyObject *__pyx_tuple__167;
static PyObject *__pyx_tuple__169;
static PyObject *__pyx_tuple__171;
static PyObject *__pyx_tuple__173;
static PyObject *__pyx_tuple__175;
static PyObject *__pyx_tuple__177;
static PyObject *__pyx_tuple__179;
static PyObject *__pyx_tuple__181;
static PyObject *__pyx_tuple__183;
static PyObject *__pyx_tuple__185;
static PyObject *__pyx_tuple__187;
static PyObject *__pyx_tuple__189;
static PyObject *__pyx_tuple__191;
static PyObject *__pyx_tuple__193;
static PyObject *__pyx_tuple__195;
static PyObject *__pyx_tuple__199;
static PyObject *__pyx_tuple__207;
static PyObject *__pyx_tuple__209;
static PyObject *__pyx_tuple__211;
static PyObject *__pyx_tuple__213;
static PyObject *__pyx_tuple__215;
static PyObject *__pyx_tuple__217;
static PyObject *__pyx_tuple__219;
static PyObject *__pyx_tuple__221;
static PyObject *__pyx_tuple__223;
static PyObject *__pyx_tuple__225;
static PyObject *__pyx_tuple__227;
static PyObject *__pyx_tuple__229;
static PyObject *__pyx_tuple__231;
static PyObject *__pyx_tuple__233;
static PyObject *__pyx_tuple__235;
static PyObject *__pyx_tuple__238;
static PyObject *__pyx_tuple__240;
static PyObject *__pyx_tuple__242;
static PyObject *__pyx_tuple__244;
static PyObject *__pyx_tuple__246;
static PyObject *__pyx_tuple__248;
static PyObject *__pyx_tuple__250;
static PyObject *__pyx_tuple__252;
static PyObject *__pyx_tuple__254;
static PyObject *__pyx_tuple__256;
static PyObject *__pyx_tuple__258;
static PyObject *__pyx_tuple__260;
static PyObject *__pyx_tuple__262;
static PyObject *__pyx_tuple__264;
static PyObject *__pyx_tuple__266;
static PyObject *__pyx_tuple__268;
static PyObject *__pyx_tuple__270;
static PyObject *__pyx_tuple__273;
static PyObject *__pyx_tuple__275;
static PyObject *__pyx_tuple__277;
static PyObject *__pyx_tuple__279;
static PyObject *__pyx_tuple__282;
static PyObject *__pyx_tuple__284;
static PyObject *__pyx_tuple__286;
static PyObject *__pyx_tuple__288;
static PyObject *__pyx_tuple__290;
static PyObject *__pyx_tuple__292;
static PyObject *__pyx_tuple__294;
static PyObject *__pyx_tuple__296;
static PyObject *__pyx_tuple__298;
static PyObject *__pyx_tuple__300;
static PyObject *__pyx_tuple__302;
static PyObject *__pyx_tuple__304;
static PyObject *__pyx_tuple__306;
static PyObject *__pyx_tuple__308;
static PyObject *__pyx_tuple__310;
static PyObject *__pyx_tuple__312;
static PyObject *__pyx_tuple__314;
static PyObject *__pyx_tuple__316;
static PyObject *__pyx_tuple__318;
static PyObject *__pyx_tuple__320;
static PyObject *__pyx_tuple__322;
static PyObject *__pyx_tuple__324;
static PyObject *__pyx_tuple__326;
static PyObject *__pyx_tuple__328;
static PyObject *__pyx_tuple__331;
static PyObject *__pyx_tuple__333;
static PyObject *__pyx_tuple__335;
static PyObject *__pyx_tuple__337;
static PyObject *__pyx_tuple__339;
static PyObject *__pyx_tuple__341;
static PyObject *__pyx_tuple__343;
static PyObject *__pyx_tuple__345;
static PyObject *__pyx_tuple__347;
static PyObject *__pyx_tuple__350;
static PyObject *__pyx_tuple__352;
static PyObject *__pyx_tuple__354;
static PyObject *__pyx_tuple__356;
static PyObject *__pyx_tuple__358;
static PyObject *__pyx_tuple__360;
static PyObject *__pyx_tuple__362;
static PyObject *__pyx_tuple__364;
static PyObject *__pyx_tuple__366;
static PyObject *__pyx_tuple__368;
static PyObject *__pyx_tuple__370;
static PyObject *__pyx_tuple__372;
static PyObject *__pyx_tuple__374;
static PyObject *__pyx_tuple__376;
static PyObject *__pyx_tuple__378;
static PyObject *__pyx_tuple__380;
static PyObject *__pyx_tuple__382;
static PyObject *__pyx_tuple__384;
static PyObject *__pyx_tuple__386;
static PyObject *__pyx_tuple__388;
static PyObject *__pyx_tuple__390;
static PyObject *__pyx_tuple__392;
static PyObject *__pyx_tuple__394;
static PyObject *__pyx_tuple__396;
static PyObject *__pyx_tuple__398;
static PyObject *__pyx_tuple__400;
static PyObject *__pyx_tuple__402;
static PyObject *__pyx_tuple__404;
static PyObject *__pyx_tuple__406;
static PyObject *__pyx_tuple__408;
static PyObject *__pyx_tuple__410;
static PyObject *__pyx_tuple__413;
static PyObject *__pyx_tuple__415;
static PyObject *__pyx_tuple__417;
static PyObject *__pyx_tuple__419;
static PyObject *__pyx_tuple__421;
static PyObject *__pyx_tuple__423;
static PyObject *__pyx_tuple__425;
static PyObject *__pyx_tuple__427;
static PyObject *__pyx_tuple__429;
static PyObject *__pyx_tuple__431;
static PyObject *__pyx_tuple__433;
static PyObject *__pyx_tuple__435;
static PyObject *__pyx_tuple__437;
static PyObject *__pyx_tuple__439;
static PyObject *__pyx_tuple__441;
static PyObject *__pyx_tuple__443;
static PyObject *__pyx_tuple__446;
static PyObject *__pyx_tuple__448;
static PyObject *__pyx_tuple__450;
static PyObject *__pyx_tuple__452;
static PyObject *__pyx_tuple__454;
static PyObject *__pyx_tuple__456;
static PyObject *__pyx_tuple__458;
static PyObject *__pyx_tuple__460;
static PyObject *__pyx_tuple__463;
static PyObject *__pyx_tuple__465;
static PyObject *__pyx_tuple__467;
static PyObject *__pyx_tuple__469;
static PyObject *__pyx_tuple__471;
static PyObject *__pyx_tuple__473;
static PyObject *__pyx_tuple__475;
static PyObject *__pyx_tuple__477;
static PyObject *__pyx_tuple__479;
static PyObject *__pyx_tuple__481;
static PyObject *__pyx_tuple__483;
static PyObject *__pyx_tuple__485;
static PyObject *__pyx_tuple__487;
static PyObject *__pyx_tuple__489;
static PyObject *__pyx_tuple__491;
static PyObject *__pyx_tuple__493;
static PyObject *__pyx_tuple__495;
static PyObject *__pyx_tuple__497;
static PyObject *__pyx_tuple__499;
static PyObject *__pyx_tuple__501;
static PyObject *__pyx_tuple__503;
static PyObject *__pyx_tuple__505;
static PyObject *__pyx_tuple__507;
static PyObject *__pyx_tuple__509;
static PyObject *__pyx_tuple__511;
static PyObject *__pyx_tuple__513;
static PyObject *__pyx_tuple__515;
static PyObject *__pyx_tuple__517;
static PyObject *__pyx_tuple__519;
static PyObject *__pyx_tuple__521;
static PyObject *__pyx_tuple__523;
static PyObject *__pyx_tuple__525;
static PyObject *__pyx_tuple__527;
static PyObject *__pyx_tuple__530;
static PyObject *__pyx_tuple__532;
static PyObject *__pyx_tuple__535;
static PyObject *__pyx_codeobj__25;
static PyObject *__pyx_codeobj__27;
static PyObject *__pyx_codeobj__29;
static PyObject *__pyx_codeobj__31;
static PyObject *__pyx_codeobj__33;
static PyObject *__pyx_codeobj__34;
static PyObject *__pyx_codeobj__36;
static PyObject *__pyx_codeobj__38;
static PyObject *__pyx_codeobj__40;
static PyObject *__pyx_codeobj__42;
static PyObject *__pyx_codeobj__44;
static PyObject *__pyx_codeobj__46;
static PyObject *__pyx_codeobj__48;
static PyObject *__pyx_codeobj__50;
static PyObject *__pyx_codeobj__52;
static PyObject *__pyx_codeobj__54;
static PyObject *__pyx_codeobj__56;
static PyObject *__pyx_codeobj__58;
static PyObject *__pyx_codeobj__60;
static PyObject *__pyx_codeobj__62;
static PyObject *__pyx_codeobj__64;
static PyObject *__pyx_codeobj__66;
static PyObject *__pyx_codeobj__68;
static PyObject *__pyx_codeobj__70;
static PyObject *__pyx_codeobj__72;
static PyObject *__pyx_codeobj__74;
static PyObject *__pyx_codeobj__76;
static PyObject *__pyx_codeobj__78;
static PyObject *__pyx_codeobj__80;
static PyObject *__pyx_codeobj__82;
static PyObject *__pyx_codeobj__84;
static PyObject *__pyx_codeobj__86;
static PyObject *__pyx_codeobj__87;
static PyObject *__pyx_codeobj__88;
static PyObject *__pyx_codeobj__89;
static PyObject *__pyx_codeobj__91;
static PyObject *__pyx_codeobj__93;
static PyObject *__pyx_codeobj__95;
static PyObject *__pyx_codeobj__97;
static PyObject *__pyx_codeobj__99;
static PyObject *__pyx_codeobj__101;
static PyObject *__pyx_codeobj__103;
static PyObject *__pyx_codeobj__104;
static PyObject *__pyx_codeobj__106;
static PyObject *__pyx_codeobj__107;
static PyObject *__pyx_codeobj__109;
static PyObject *__pyx_codeobj__111;
static PyObject *__pyx_codeobj__112;
static PyObject *__pyx_codeobj__113;
static PyObject *__pyx_codeobj__115;
static PyObject *__pyx_codeobj__116;
static PyObject *__pyx_codeobj__118;
static PyObject *__pyx_codeobj__120;
static PyObject *__pyx_codeobj__122;
static PyObject *__pyx_codeobj__124;
static PyObject *__pyx_codeobj__126;
static PyObject *__pyx_codeobj__128;
static PyObject *__pyx_codeobj__130;
static PyObject *__pyx_codeobj__132;
static PyObject *__pyx_codeobj__134;
static PyObject *__pyx_codeobj__136;
static PyObject *__pyx_codeobj__138;
static PyObject *__pyx_codeobj__140;
static PyObject *__pyx_codeobj__141;
static PyObject *__pyx_codeobj__143;
static PyObject *__pyx_codeobj__145;
static PyObject *__pyx_codeobj__147;
static PyObject *__pyx_codeobj__149;
static PyObject *__pyx_codeobj__151;
static PyObject *__pyx_codeobj__153;
static PyObject *__pyx_codeobj__155;
static PyObject *__pyx_codeobj__157;
static PyObject *__pyx_codeobj__159;
static PyObject *__pyx_codeobj__161;
static PyObject *__pyx_codeobj__162;
static PyObject *__pyx_codeobj__164;
static PyObject *__pyx_codeobj__166;
static PyObject *__pyx_codeobj__168;
static PyObject *__pyx_codeobj__170;
static PyObject *__pyx_codeobj__172;
static PyObject *__pyx_codeobj__174;
static PyObject *__pyx_codeobj__176;
static PyObject *__pyx_codeobj__178;
static PyObject *__pyx_codeobj__180;
static PyObject *__pyx_codeobj__182;
static PyObject *__pyx_codeobj__184;
static PyObject *__pyx_codeobj__186;
static PyObject *__pyx_codeobj__188;
static PyObject *__pyx_codeobj__190;
static PyObject *__pyx_codeobj__192;
static PyObject *__pyx_codeobj__194;
static PyObject *__pyx_codeobj__196;
static PyObject *__pyx_codeobj__197;
static PyObject *__pyx_codeobj__198;
static PyObject *__pyx_codeobj__200;
static PyObject *__pyx_codeobj__201;
static PyObject *__pyx_codeobj__202;
static PyObject *__pyx_codeobj__203;
static PyObject *__pyx_codeobj__204;
static PyObject *__pyx_codeobj__205;
static PyObject *__pyx_codeobj__206;
static PyObject *__pyx_codeobj__208;
static PyObject *__pyx_codeobj__210;
static PyObject *__pyx_codeobj__212;
static PyObject *__pyx_codeobj__214;
static PyObject *__pyx_codeobj__216;
static PyObject *__pyx_codeobj__218;
static PyObject *__pyx_codeobj__220;
static PyObject *__pyx_codeobj__222;
static PyObject *__pyx_codeobj__224;
static PyObject *__pyx_codeobj__226;
static PyObject *__pyx_codeobj__228;
static PyObject *__pyx_codeobj__230;
static PyObject *__pyx_codeobj__232;
static PyObject *__pyx_codeobj__234;
static PyObject *__pyx_codeobj__236;
static PyObject *__pyx_codeobj__237;
static PyObject *__pyx_codeobj__239;
static PyObject *__pyx_codeobj__241;
static PyObject *__pyx_codeobj__243;
static PyObject *__pyx_codeobj__245;
static PyObject *__pyx_codeobj__247;
static PyObject *__pyx_codeobj__249;
static PyObject *__pyx_codeobj__251;
static PyObject *__pyx_codeobj__253;
static PyObject *__pyx_codeobj__255;
static PyObject *__pyx_codeobj__257;
static PyObject *__pyx_codeobj__259;
static PyObject *__pyx_codeobj__261;
static PyObject *__pyx_codeobj__263;
static PyObject *__pyx_codeobj__265;
static PyObject *__pyx_codeobj__267;
static PyObject *__pyx_codeobj__269;
static PyObject *__pyx_codeobj__271;
static PyObject *__pyx_codeobj__272;
static PyObject *__pyx_codeobj__274;
static PyObject *__pyx_codeobj__276;
static PyObject *__pyx_codeobj__278;
static PyObject *__pyx_codeobj__280;
static PyObject *__pyx_codeobj__281;
static PyObject *__pyx_codeobj__283;
static PyObject *__pyx_codeobj__285;
static PyObject *__pyx_codeobj__287;
static PyObject *__pyx_codeobj__289;
static PyObject *__pyx_codeobj__291;
static PyObject *__pyx_codeobj__293;
static PyObject *__pyx_codeobj__295;
static PyObject *__pyx_codeobj__297;
static PyObject *__pyx_codeobj__299;
static PyObject *__pyx_codeobj__301;
static PyObject *__pyx_codeobj__303;
static PyObject *__pyx_codeobj__305;
static PyObject *__pyx_codeobj__307;
static PyObject *__pyx_codeobj__309;
static PyObject *__pyx_codeobj__311;
static PyObject *__pyx_codeobj__313;
static PyObject *__pyx_codeobj__315;
static PyObject *__pyx_codeobj__317;
static PyObject *__pyx_codeobj__319;
static PyObject *__pyx_codeobj__321;
static PyObject *__pyx_codeobj__323;
static PyObject *__pyx_codeobj__325;
static PyObject *__pyx_codeobj__327;
static PyObject *__pyx_codeobj__329;
static PyObject *__pyx_codeobj__330;
static PyObject *__pyx_codeobj__332;
static PyObject *__pyx_codeobj__334;
static PyObject *__pyx_codeobj__336;
static PyObject *__pyx_codeobj__338;
static PyObject *__pyx_codeobj__340;
static PyObject *__pyx_codeobj__342;
static PyObject *__pyx_codeobj__344;
static PyObject *__pyx_codeobj__346;
static PyObject *__pyx_codeobj__348;
static PyObject *__pyx_codeobj__349;
static PyObject *__pyx_codeobj__351;
static PyObject *__pyx_codeobj__353;
static PyObject *__pyx_codeobj__355;
static PyObject *__pyx_codeobj__357;
static PyObject *__pyx_codeobj__359;
static PyObject *__pyx_codeobj__361;
static PyObject *__pyx_codeobj__363;
static PyObject *__pyx_codeobj__365;
static PyObject *__pyx_codeobj__367;
static PyObject *__pyx_codeobj__369;
static PyObject *__pyx_codeobj__371;
static PyObject *__pyx_codeobj__373;
static PyObject *__pyx_codeobj__375;
static PyObject *__pyx_codeobj__377;
static PyObject *__pyx_codeobj__379;
static PyObject *__pyx_codeobj__381;
static PyObject *__pyx_codeobj__383;
static PyObject *__pyx_codeobj__385;
static PyObject *__pyx_codeobj__387;
static PyObject *__pyx_codeobj__389;
static PyObject *__pyx_codeobj__391;
static PyObject *__pyx_codeobj__393;
static PyObject *__pyx_codeobj__395;
static PyObject *__pyx_codeobj__397;
static PyObject *__pyx_codeobj__399;
static PyObject *__pyx_codeobj__401;
static PyObject *__pyx_codeobj__403;
static PyObject *__pyx_codeobj__405;
static PyObject *__pyx_codeobj__407;
static PyObject *__pyx_codeobj__409;
static PyObject *__pyx_codeobj__411;
static PyObject *__pyx_codeobj__412;
static PyObject *__pyx_codeobj__414;
static PyObject *__pyx_codeobj__416;
static PyObject *__pyx_codeobj__418;
static PyObject *__pyx_codeobj__420;
static PyObject *__pyx_codeobj__422;
static PyObject *__pyx_codeobj__424;
static PyObject *__pyx_codeobj__426;
static PyObject *__pyx_codeobj__428;
static PyObject *__pyx_codeobj__430;
static PyObject *__pyx_codeobj__432;
static PyObject *__pyx_codeobj__434;
static PyObject *__pyx_codeobj__436;
static PyObject *__pyx_codeobj__438;
static PyObject *__pyx_codeobj__440;
static PyObject *__pyx_codeobj__442;
static PyObject *__pyx_codeobj__444;
static PyObject *__pyx_codeobj__445;
static PyObject *__pyx_codeobj__447;
static PyObject *__pyx_codeobj__449;
static PyObject *__pyx_codeobj__451;
static PyObject *__pyx_codeobj__453;
static PyObject *__pyx_codeobj__455;
static PyObject *__pyx_codeobj__457;
static PyObject *__pyx_codeobj__459;
static PyObject *__pyx_codeobj__461;
static PyObject *__pyx_codeobj__462;
static PyObject *__pyx_codeobj__464;
static PyObject *__pyx_codeobj__466;
static PyObject *__pyx_codeobj__468;
static PyObject *__pyx_codeobj__470;
static PyObject *__pyx_codeobj__472;
static PyObject *__pyx_codeobj__474;
static PyObject *__pyx_codeobj__476;
static PyObject *__pyx_codeobj__478;
static PyObject *__pyx_codeobj__480;
static PyObject *__pyx_codeobj__482;
static PyObject *__pyx_codeobj__484;
static PyObject *__pyx_codeobj__486;
static PyObject *__pyx_codeobj__488;
static PyObject *__pyx_codeobj__490;
static PyObject *__pyx_codeobj__492;
static PyObject *__pyx_codeobj__494;
static PyObject *__pyx_codeobj__496;
static PyObject *__pyx_codeobj__498;
static PyObject *__pyx_codeobj__500;
static PyObject *__pyx_codeobj__502;
static PyObject *__pyx_codeobj__504;
static PyObject *__pyx_codeobj__506;
static PyObject *__pyx_codeobj__508;
static PyObject *__pyx_codeobj__510;
static PyObject *__pyx_codeobj__512;
static PyObject *__pyx_codeobj__514;
static PyObject *__pyx_codeobj__516;
static PyObject *__pyx_codeobj__518;
static PyObject *__pyx_codeobj__520;
static PyObject *__pyx_codeobj__522;
static PyObject *__pyx_codeobj__524;
static PyObject *__pyx_codeobj__526;
static PyObject *__pyx_codeobj__528;
static PyObject *__pyx_codeobj__529;
static PyObject *__pyx_codeobj__531;
static PyObject *__pyx_codeobj__533;
static PyObject *__pyx_codeobj__534;
static PyObject *__pyx_codeobj__536;
/* Late includes */

/* "ga4py/gain/notimplemented.pyx":8
 * 
 * 
 * def docstring(obj, docstring):             # <<<<<<<<<<<<<<
 *     """docstring(obj, docstring)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_1docstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_docstring[] = "docstring(obj, docstring)\n\n    Add a docstring to a built-in obj if possible.\n    If the obj already has a docstring raise a RuntimeError\n    If this routine does not know how to add a docstring to the object\n    raise a TypeError\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_1docstring = {"docstring", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_1docstring, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_docstring};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_1docstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_docstring = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("docstring (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_obj,&__pyx_n_s_docstring,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_docstring)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("docstring", 1, 2, 2, 1); __PYX_ERR(0, 8, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "docstring") < 0)) __PYX_ERR(0, 8, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_obj = values[0];
    __pyx_v_docstring = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("docstring", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.docstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_docstring(__pyx_self, __pyx_v_obj, __pyx_v_docstring);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_docstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_docstring) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("docstring", 0);

  /* "ga4py/gain/notimplemented.pyx":18
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 18, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8
 * 
 * 
 * def docstring(obj, docstring):             # <<<<<<<<<<<<<<
 *     """docstring(obj, docstring)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.docstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":21
 * 
 * 
 * def add_newdoc(place, obj, doc):             # <<<<<<<<<<<<<<
 *     """Adds documentation to obj which is in module place.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_3add_newdoc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_2add_newdoc[] = "Adds documentation to obj which is in module place.\n\n    If doc is a string add it to obj as a docstring\n\n    If doc is a tuple, then the first element is interpreted as\n       an attribute of obj and the second as the docstring\n          (method, docstring)\n\n    If doc is a list, then each element of the list should be a\n       sequence of length two --> [(method1, docstring1),\n       (method2, docstring2), ...]\n\n    This routine never raises an error.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_3add_newdoc = {"add_newdoc", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_3add_newdoc, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_2add_newdoc};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_3add_newdoc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_place = 0;
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_doc = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("add_newdoc (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_place,&__pyx_n_s_obj,&__pyx_n_s_doc,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_place)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("add_newdoc", 1, 3, 3, 1); __PYX_ERR(0, 21, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_doc)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("add_newdoc", 1, 3, 3, 2); __PYX_ERR(0, 21, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "add_newdoc") < 0)) __PYX_ERR(0, 21, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_place = values[0];
    __pyx_v_obj = values[1];
    __pyx_v_doc = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("add_newdoc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 21, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.add_newdoc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_2add_newdoc(__pyx_self, __pyx_v_place, __pyx_v_obj, __pyx_v_doc);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_2add_newdoc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_place, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_doc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("add_newdoc", 0);

  /* "ga4py/gain/notimplemented.pyx":37
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 37, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":21
 * 
 * 
 * def add_newdoc(place, obj, doc):             # <<<<<<<<<<<<<<
 *     """Adds documentation to obj which is in module place.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.add_newdoc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":40
 * 
 * 
 * def all(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether all array elements along a given axis evaluate to True.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_5all(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_4all[] = "Test whether all array elements along a given axis evaluate to True.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical AND is performed.\n        The default (`axis` = `None`) is to perform a logical AND\n        over a flattened input array.  `axis` may be negative, in which\n        case it counts from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.\n        It must have the same shape as the expected output and its\n        type is preserved (e.g., if ``dtype(out)`` is float, the result\n        will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section\n        \"Output arguments\") for more details.\n\n    Returns\n    -------\n    all : ndarray, bool\n        A new boolean or array is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.all : equivalent method\n\n    any : Test whether any element along a given axis evaluates to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.all([[True,False],[True,True]])\n    False\n\n    >>> np.all([[True,False],[True,True]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.all([-1, 4, 5])\n    True\n\n    >>> np.all([1.0, np.nan])\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.all([-1, 4, 5], out=o)\n    >>> id(z), id(o), z                             # doctest: +SKIP\n    (28293632, 28293632, array([ True], dtype=bool))\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_5all = {"all", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_5all, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_4all};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_5all(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("all (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "all") < 0)) __PYX_ERR(0, 40, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("all", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 40, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.all", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_4all(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_4all(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("all", 0);

  /* "ga4py/gain/notimplemented.pyx":96
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 96, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":40
 * 
 * 
 * def all(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether all array elements along a given axis evaluate to True.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.all", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":99
 * 
 * 
 * def allclose(a, b, rtol=1e-05, atol=1e-08):             # <<<<<<<<<<<<<<
 *     """Returns True if two arrays are element-wise equal within a tolerance.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_7allclose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_6allclose[] = "Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise. If either array contains NaN, then\n        False is returned.\n\n    See Also\n    --------\n    all, any, alltrue, sometrue\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    `allclose(a, b)` might be different from `allclose(b, a)` in\n    some rare cases.\n\n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_7allclose = {"allclose", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_7allclose, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_6allclose};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_7allclose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rtol = 0;
  CYTHON_UNUSED PyObject *__pyx_v_atol = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("allclose (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,&__pyx_n_s_rtol,&__pyx_n_s_atol,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_float_1eneg_05);
    values[3] = ((PyObject *)__pyx_float_1eneg_08);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("allclose", 0, 2, 4, 1); __PYX_ERR(0, 99, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rtol);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_atol);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "allclose") < 0)) __PYX_ERR(0, 99, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
    __pyx_v_rtol = values[2];
    __pyx_v_atol = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("allclose", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 99, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.allclose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_6allclose(__pyx_self, __pyx_v_a, __pyx_v_b, __pyx_v_rtol, __pyx_v_atol);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_6allclose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_rtol, CYTHON_UNUSED PyObject *__pyx_v_atol) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("allclose", 0);

  /* "ga4py/gain/notimplemented.pyx":150
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 150, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":99
 * 
 * 
 * def allclose(a, b, rtol=1e-05, atol=1e-08):             # <<<<<<<<<<<<<<
 *     """Returns True if two arrays are element-wise equal within a tolerance.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.allclose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":153
 * 
 * 
 * def alltrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check if all elements of input array are true.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_9alltrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_8alltrue[] = "Check if all elements of input array are true.\n\n    See Also\n    --------\n    numpy.all : Equivalent function; see for details.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_9alltrue = {"alltrue", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_9alltrue, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_8alltrue};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_9alltrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("alltrue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "alltrue") < 0)) __PYX_ERR(0, 153, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("alltrue", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 153, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.alltrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_8alltrue(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_8alltrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("alltrue", 0);

  /* "ga4py/gain/notimplemented.pyx":161
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 161, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":153
 * 
 * 
 * def alltrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check if all elements of input array are true.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.alltrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":164
 * 
 * 
 * def alterdot():             # <<<<<<<<<<<<<<
 *     """Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_11alterdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_10alterdot[] = "Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.\n\n    Typically, as a user of Numpy, you do not explicitly call this function. If\n    Numpy is built with an accelerated BLAS, this function is automatically\n    called when Numpy is imported.\n\n    When Numpy is built with an accelerated BLAS like ATLAS, these functions\n    are replaced to make use of the faster implementations.  The faster\n    implementations only affect float32, float64, complex64, and complex128\n    arrays. Furthermore, the BLAS API only includes matrix-matrix,\n    matrix-vector, and vector-vector products. Products of arrays with larger\n    dimensionalities use the built in functions and are not accelerated.\n\n    See Also\n    --------\n    restoredot : `restoredot` undoes the effects of `alterdot`.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_11alterdot = {"alterdot", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_11alterdot, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_10alterdot};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_11alterdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("alterdot (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_10alterdot(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_10alterdot(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("alterdot", 0);

  /* "ga4py/gain/notimplemented.pyx":184
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 184, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":164
 * 
 * 
 * def alterdot():             # <<<<<<<<<<<<<<
 *     """Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.alterdot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":187
 * 
 * 
 * def amax(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_13amax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_12amax[] = "Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  Must be of\n        the same shape and buffer length as the expected output.  See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    nanmax : NaN values are ignored instead of being propagated.\n    fmax : same behavior as the C99 fmax function.\n    argmax : indices of the maximum values.\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well.  To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)\n    3\n    >>> np.amax(a, axis=0)\n    array([2, 3])\n    >>> np.amax(a, axis=1)\n    array([1, 3])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.nanmax(b)\n    4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_13amax = {"amax", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_13amax, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_12amax};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_13amax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("amax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "amax") < 0)) __PYX_ERR(0, 187, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("amax", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 187, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_12amax(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_12amax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("amax", 0);

  /* "ga4py/gain/notimplemented.pyx":241
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 241, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":187
 * 
 * 
 * def amax(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":244
 * 
 * 
 * def amin(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_15amin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_14amin[] = "Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default a flattened input is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    nanmin: nan values are ignored instead of being propagated\n    fmin: same behavior as the C99 fmin function\n    argmin: Return the indices of the minimum values.\n\n    amax, nanmax, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is nan, the\n    corresponding min value will be nan as well. To ignore NaN values (matlab\n    behavior), please use nanmin.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)         # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)         # Minima along the second axis\n    array([0, 2])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.nanmin(b)\n    0.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_15amin = {"amin", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_15amin, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_14amin};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_15amin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("amin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "amin") < 0)) __PYX_ERR(0, 244, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("amin", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 244, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_14amin(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_14amin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("amin", 0);

  /* "ga4py/gain/notimplemented.pyx":298
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 298, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":244
 * 
 * 
 * def amin(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.amin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":301
 * 
 * 
 * def angle(z, deg=0):             # <<<<<<<<<<<<<<
 *     """Return the angle of the complex argument.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_17angle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_16angle[] = "Return the angle of the complex argument.\n\n    Parameters\n    ----------\n    z : array_like\n        A complex number or sequence of complex numbers.\n    deg : bool, optional\n        Return angle in degrees if True, radians if False (default).\n\n    Returns\n    -------\n    angle : {ndarray, scalar}\n        The counterclockwise angle from the positive real axis on\n        the complex plane, with dtype as numpy.float64.\n\n    See Also\n    --------\n    arctan2\n    absolute\n\n\n\n    Examples\n    --------\n    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians\n    array([ 0.        ,  1.57079633,  0.78539816])\n    >>> np.angle(1+1j, deg=True)                  # in degrees\n    45.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_17angle = {"angle", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_17angle, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_16angle};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_17angle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_z = 0;
  CYTHON_UNUSED PyObject *__pyx_v_deg = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("angle (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_z,&__pyx_n_s_deg,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_z)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deg);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "angle") < 0)) __PYX_ERR(0, 301, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_z = values[0];
    __pyx_v_deg = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("angle", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 301, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.angle", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_16angle(__pyx_self, __pyx_v_z, __pyx_v_deg);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_16angle(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_z, CYTHON_UNUSED PyObject *__pyx_v_deg) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("angle", 0);

  /* "ga4py/gain/notimplemented.pyx":332
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 332, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":301
 * 
 * 
 * def angle(z, deg=0):             # <<<<<<<<<<<<<<
 *     """Return the angle of the complex argument.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.angle", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":335
 * 
 * 
 * def any(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether any array element along a given axis evaluates to True.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_19any(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_18any[] = "Test whether any array element along a given axis evaluates to True.\n\n    Returns single boolean unless `axis` is not ``None``\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which a logical OR is performed.  The default\n        (`axis` = `None`) is to perform a logical OR over a flattened\n        input array. `axis` may be negative, in which case it counts\n        from the last to the first axis.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output and its type is preserved\n        (e.g., if it is of type float, then it will remain so, returning\n        1.0 for True and 0.0 for False, regardless of the type of `a`).\n        See `doc.ufuncs` (Section \"Output arguments\") for details.\n\n    Returns\n    -------\n    any : bool or ndarray\n        A new boolean or `ndarray` is returned unless `out` is specified,\n        in which case a reference to `out` is returned.\n\n    See Also\n    --------\n    ndarray.any : equivalent method\n\n    all : Test whether all elements along a given axis evaluate to True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity evaluate\n    to `True` because these are not equal to zero.\n\n    Examples\n    --------\n    >>> np.any([[True, False], [True, True]])\n    True\n\n    >>> np.any([[True, False], [False, False]], axis=0)\n    array([ True, False], dtype=bool)\n\n    >>> np.any([-1, 0, 5])\n    True\n\n    >>> np.any(np.nan)\n    True\n\n    >>> o=np.array([False])\n    >>> z=np.any([-1, 4, 5], out=o)\n    >>> z, o\n    (array([ True], dtype=bool), array([ True], dtype=bool))\n    >>> # Check now that z is a reference to o\n    >>> z is o\n    True\n    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP\n    (191614240, 191614240)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_19any = {"any", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_19any, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_18any};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_19any(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("any (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "any") < 0)) __PYX_ERR(0, 335, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("any", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 335, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.any", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_18any(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_18any(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("any", 0);

  /* "ga4py/gain/notimplemented.pyx":398
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 398, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":335
 * 
 * 
 * def any(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether any array element along a given axis evaluates to True.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.any", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":401
 * 
 * 
 * def append(arr, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Append values to the end of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_21append(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_20append[] = "Append values to the end of an array.\n\n    Parameters\n    ----------\n    arr : array_like\n        Values are appended to a copy of this array.\n    values : array_like\n        These values are appended to a copy of `arr`.  It must be of the\n        correct shape (the same shape as `arr`, excluding `axis`).  If `axis`\n        is not specified, `values` can be any shape and will be flattened\n        before use.\n    axis : int, optional\n        The axis along which `values` are appended.  If `axis` is not given,\n        both `arr` and `values` are flattened before use.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` appended to `axis`.  Note that `append`\n        does not occur in-place: a new array is allocated and filled.  If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\n    array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    When `axis` is specified, `values` must have the correct shape.\n\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\n    array([[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]])\n    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\n    Traceback (most recent call last):\n    ...\n    ValueError: arrays must have same number of dimensions\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_21append = {"append", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_21append, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_20append};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_21append(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("append (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_values,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, 1); __PYX_ERR(0, 401, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "append") < 0)) __PYX_ERR(0, 401, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_values = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("append", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 401, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_20append(__pyx_self, __pyx_v_arr, __pyx_v_values, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_20append(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("append", 0);

  /* "ga4py/gain/notimplemented.pyx":446
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 446, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":401
 * 
 * 
 * def append(arr, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Append values to the end of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.append", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":449
 * 
 * 
 * def apply_along_axis(func1d, axis, arr):             # <<<<<<<<<<<<<<
 *     """Apply a function to 1-D slices along the given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_23apply_along_axis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_22apply_along_axis[] = "Apply a function to 1-D slices along the given axis.\n\n    Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`\n    is a 1-D slice of `arr` along `axis`.\n\n    Parameters\n    ----------\n    func1d : function\n        This function should accept 1-D arrays. It is applied to 1-D\n        slices of `arr` along the specified axis.\n    axis : integer\n        Axis along which `arr` is sliced.\n    arr : ndarray\n        Input array.\n    args : any\n        Additional arguments to `func1d`.\n\n    Returns\n    -------\n    outarr : ndarray\n        The output array. The shape of `outarr` is identical to the shape of\n        `arr`, except along the `axis` dimension, where the length of `outarr`\n        is equal to the size of the return value of `func1d`.  If `func1d`\n        returns a scalar `outarr` will have one fewer dimensions than `arr`.\n\n    See Also\n    --------\n    apply_over_axes : Apply a function repeatedly over multiple axes.\n\n    Examples\n    --------\n    >>> def my_func(a):\n    ...     '''Average first and last element of a 1-D array'''\n    ...     return (a[0] + a[-1]) * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(my_func, 0, b)\n    array([ 4.,  5.,  6.])\n    >>> np.apply_along_axis(my_func, 1, b)\n    array([ 2.,  5.,  8.])\n\n    For a function that doesn't return a scalar, the number of dimensions in\n    `outarr` is the same as `arr`.\n\n    >>> def new_func(a):\n    ...     '''Divide elements of a by 2.'''\n    ...     return a * 0.5\n    >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n    >>> np.apply_along_axis(new_func, 0, b)\n    array([[ 0.5,  1. ,  1.5],\n           [ 2. ,  2.5,  3. ],\n           [ 3.5,  4. ,  4.5]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_23apply_along_axis = {"apply_along_axis", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_23apply_along_axis, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_22apply_along_axis};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_23apply_along_axis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_func1d = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("apply_along_axis (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func1d,&__pyx_n_s_axis,&__pyx_n_s_arr,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_func1d)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_along_axis", 1, 3, 3, 1); __PYX_ERR(0, 449, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_along_axis", 1, 3, 3, 2); __PYX_ERR(0, 449, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "apply_along_axis") < 0)) __PYX_ERR(0, 449, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_func1d = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_arr = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("apply_along_axis", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 449, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_along_axis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_22apply_along_axis(__pyx_self, __pyx_v_func1d, __pyx_v_axis, __pyx_v_arr);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_22apply_along_axis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func1d, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("apply_along_axis", 0);

  /* "ga4py/gain/notimplemented.pyx":503
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 503, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":449
 * 
 * 
 * def apply_along_axis(func1d, axis, arr):             # <<<<<<<<<<<<<<
 *     """Apply a function to 1-D slices along the given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_along_axis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":506
 * 
 * 
 * def apply_over_axes(func, a, axes):             # <<<<<<<<<<<<<<
 *     """Apply a function repeatedly over multiple axes.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_25apply_over_axes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_24apply_over_axes[] = "Apply a function repeatedly over multiple axes.\n\n    `func` is called as `res = func(a, axis)`, where `axis` is the first\n    element of `axes`.  The result `res` of the function call must have\n    either the same dimensions as `a` or one less dimension.  If `res`\n    has one less dimension than `a`, a dimension is inserted before\n    `axis`.  The call to `func` is then repeated for each axis in `axes`,\n    with `res` as the first argument.\n\n    Parameters\n    ----------\n    func : function\n        This function must take two arguments, `func(a, axis)`.\n    a : array_like\n        Input array.\n    axes : array_like\n        Axes over which `func` is applied; the elements must be integers.\n\n    Returns\n    -------\n    val : ndarray\n        The output array.  The number of dimensions is the same as `a`,\n        but the shape can be different.  This depends on whether `func`\n        changes the shape of its output with respect to its input.\n\n    See Also\n    --------\n    apply_along_axis :\n        Apply a function to 1-D slices of an array along the given axis.\n\n    Examples\n    --------\n    >>> a = np.arange(24).reshape(2,3,4)\n    >>> a\n    array([[[ 0,  1,  2,  3],\n            [ 4,  5,  6,  7],\n            [ 8,  9, 10, 11]],\n           [[12, 13, 14, 15],\n            [16, 17, 18, 19],\n            [20, 21, 22, 23]]])\n\n    Sum over axes 0 and 2. The result has same number of dimensions\n    as the original array:\n\n    >>> np.apply_over_axes(np.sum, a, [0,2])\n    array([[[ 60],\n            [ 92],\n            [124]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_25apply_over_axes = {"apply_over_axes", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_25apply_over_axes, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_24apply_over_axes};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_25apply_over_axes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_func = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axes = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("apply_over_axes (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func,&__pyx_n_s_a,&__pyx_n_s_axes,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_over_axes", 1, 3, 3, 1); __PYX_ERR(0, 506, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axes)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("apply_over_axes", 1, 3, 3, 2); __PYX_ERR(0, 506, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "apply_over_axes") < 0)) __PYX_ERR(0, 506, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_func = values[0];
    __pyx_v_a = values[1];
    __pyx_v_axes = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("apply_over_axes", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 506, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_over_axes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_24apply_over_axes(__pyx_self, __pyx_v_func, __pyx_v_a, __pyx_v_axes);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_24apply_over_axes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("apply_over_axes", 0);

  /* "ga4py/gain/notimplemented.pyx":557
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 557, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":506
 * 
 * 
 * def apply_over_axes(func, a, axes):             # <<<<<<<<<<<<<<
 *     """Apply a function repeatedly over multiple axes.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.apply_over_axes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":560
 * 
 * 
 * def argmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Indices of the maximum values along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_27argmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_26argmax[] = "Indices of the maximum values along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        By default, the index is into the flattened array, otherwise\n        along the specified axis.\n\n    Returns\n    -------\n    index_array : ndarray of ints\n        Array of indices into the array. It has the same shape as `a.shape`\n        with the dimension along `axis` removed.\n\n    See Also\n    --------\n    ndarray.argmax, argmin\n    amax : The maximum value along a given axis.\n    unravel_index : Convert a flat index into an index tuple.\n\n    Notes\n    -----\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    Examples\n    --------\n    >>> a = np.arange(6).reshape(2,3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argmax(a)\n    5\n    >>> np.argmax(a, axis=0)\n    array([1, 1, 1])\n    >>> np.argmax(a, axis=1)\n    array([2, 2])\n\n    >>> b = np.arange(6)\n    >>> b[1] = 5\n    >>> b\n    array([0, 5, 2, 3, 4, 5])\n    >>> np.argmax(b) # Only the first occurrence is returned.\n    1\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_27argmax = {"argmax", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_27argmax, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_26argmax};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_27argmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argmax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "argmax") < 0)) __PYX_ERR(0, 560, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("argmax", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 560, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_26argmax(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_26argmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argmax", 0);

  /* "ga4py/gain/notimplemented.pyx":609
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 609, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":560
 * 
 * 
 * def argmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Indices of the maximum values along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":612
 * 
 * 
 * def argmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the indices of the minimum values along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_29argmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_28argmin[] = "Return the indices of the minimum values along an axis.\n\n    See Also\n    --------\n    argmax : Similar function.  Please refer to `numpy.argmax` for detailed\n        documentation.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_29argmin = {"argmin", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_29argmin, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_28argmin};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_29argmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argmin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "argmin") < 0)) __PYX_ERR(0, 612, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("argmin", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 612, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_28argmin(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_28argmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argmin", 0);

  /* "ga4py/gain/notimplemented.pyx":621
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 621, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":612
 * 
 * 
 * def argmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the indices of the minimum values along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":624
 * 
 * 
 * def argsort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Returns the indices that would sort an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_31argsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_30argsort[] = "Returns the indices that would sort an array.\n\n    Perform an indirect sort along the given axis using the algorithm specified\n    by the `kind` keyword. It returns an array of indices of the same shape as\n    `a` that index data along the given axis in sorted order.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to sort.\n    axis : int or None, optional\n        Axis along which to sort.  The default is -1 (the last axis). If None,\n        the flattened array is used.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    order : list, optional\n        When `a` is an array with fields defined, this argument specifies\n        which fields to compare first, second, etc.  Not all fields need be\n        specified.\n\n    Returns\n    -------\n    index_array : ndarray, int\n        Array of indices that sort `a` along the specified axis.\n        In other words, ``a[index_array]`` yields a sorted `a`.\n\n    See Also\n    --------\n    sort : Describes sorting algorithms used.\n    lexsort : Indirect stable sort with multiple keys.\n    ndarray.sort : Inplace sort.\n\n    Notes\n    -----\n    See `sort` for notes on the different sorting algorithms.\n\n    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing\n    nan values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    One dimensional array:\n\n    >>> x = np.array([3, 1, 2])\n    >>> np.argsort(x)\n    array([1, 2, 0])\n\n    Two-dimensional array:\n\n    >>> x = np.array([[0, 3], [2, 2]])\n    >>> x\n    array([[0, 3],\n           [2, 2]])\n\n    >>> np.argsort(x, axis=0)\n    array([[0, 1],\n           [1, 0]])\n\n    >>> np.argsort(x, axis=1)\n    array([[0, 1],\n           [0, 1]])\n\n    Sorting with keys:\n\n    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])\n    >>> x\n    array([(1, 0), (0, 1)],\n          dtype=[('x', '<i4'), ('y', '<i4')])\n\n    >>> np.argsor""t(x, order=('x','y'))\n    array([1, 0])\n\n    >>> np.argsort(x, order=('y','x'))\n    array([0, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_31argsort = {"argsort", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_31argsort, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_30argsort};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_31argsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_kind = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argsort (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_kind,&__pyx_n_s_order,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_neg_1);
    values[2] = ((PyObject *)__pyx_n_s_quicksort);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_kind);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "argsort") < 0)) __PYX_ERR(0, 624, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_kind = values[2];
    __pyx_v_order = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("argsort", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 624, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_30argsort(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_kind, __pyx_v_order);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_30argsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argsort", 0);

  /* "ga4py/gain/notimplemented.pyx":701
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 701, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":624
 * 
 * 
 * def argsort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Returns the indices that would sort an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":704
 * 
 * 
 * def argwhere(a):             # <<<<<<<<<<<<<<
 *     """Find the indices of array elements that are non-zero, grouped by element.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_33argwhere(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_32argwhere[] = "Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``where(a)`` instead.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_33argwhere = {"argwhere", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_33argwhere, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_32argwhere};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_33argwhere(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argwhere (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_32argwhere(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_32argwhere(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("argwhere", 0);

  /* "ga4py/gain/notimplemented.pyx":741
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 741, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":704
 * 
 * 
 * def argwhere(a):             # <<<<<<<<<<<<<<
 *     """Find the indices of array elements that are non-zero, grouped by element.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.argwhere", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":744
 * 
 * 
 * def around(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Evenly round to the given number of decimals.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_35around(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_34around[] = "Evenly round to the given number of decimals.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    decimals : int, optional\n        Number of decimal places to round to (default: 0).  If\n        decimals is negative, it specifies the number of positions to\n        the left of the decimal point.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the output\n        values will be cast if necessary. See `doc.ufuncs` (Section\n        \"Output arguments\") for details.\n\n    Returns\n    -------\n    rounded_array : ndarray\n        An array of the same type as `a`, containing the rounded values.\n        Unless `out` was specified, a new array is created.  A reference to\n        the result is returned.\n\n        The real and imaginary parts of complex numbers are rounded\n        separately.  The result of rounding a float is a float.\n\n    See Also\n    --------\n    ndarray.round : equivalent method\n\n    ceil, fix, floor, rint, trunc\n\n\n    Notes\n    -----\n    For values exactly halfway between rounded decimal values, Numpy\n    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,\n    -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due\n    to the inexact representation of decimal fractions in the IEEE\n    floating point standard [1]_ and errors introduced when scaling\n    by powers of ten.\n\n    References\n    ----------\n    .. [1] \"Lecture Notes on the Status of  IEEE 754\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n    .. [2] \"How Futile are Mindless Assessments of\n           Roundoff in Floating-Point Computation?\", William Kahan,\n           http://www.cs.berkeley.edu/~wkahan/Mindless.pdf\n\n    Examples\n    --------\n    >>> np.around([0.37, 1.64])\n    array([ 0.,  2.])\n    >>> np.around([0.37, 1.64], decimals=1)\n    ""array([ 0.4,  1.6])\n    >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\n    array([ 0.,  2.,  2.,  4.,  4.])\n    >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\n    array([ 1,  2,  3, 11])\n    >>> np.around([1,2,3,11], decimals=-1)\n    array([ 0,  0,  0, 10])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_35around = {"around", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_35around, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_34around};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_35around(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_decimals = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("around (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_decimals,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_decimals);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "around") < 0)) __PYX_ERR(0, 744, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_decimals = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("around", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 744, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.around", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_34around(__pyx_self, __pyx_v_a, __pyx_v_decimals, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_34around(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("around", 0);

  /* "ga4py/gain/notimplemented.pyx":809
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 809, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":744
 * 
 * 
 * def around(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Evenly round to the given number of decimals.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.around", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":812
 * 
 * 
 * def array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_37array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_36array[] = "array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)\n\n    Create an array.\n\n    Parameters\n    ----------\n    object : array_like\n        An array, any object exposing the array interface, an\n        object whose __array__ method returns an array, or any\n        (nested) sequence.\n    dtype : data-type, optional\n        The desired data-type for the array.  If not given, then\n        the type will be determined as the minimum type required\n        to hold the objects in the sequence.  This argument can only\n        be used to 'upcast' the array.  For downcasting, use the\n        .astype(t) method.\n    copy : bool, optional\n        If true (default), then the object is copied.  Otherwise, a copy\n        will only be made if __array__ returns a copy, if obj is a\n        nested sequence, or if a copy is needed to satisfy any of the other\n        requirements (`dtype`, `order`, etc.).\n    order : {'C', 'F', 'A'}, optional\n        Specify the order of the array.  If order is 'C' (default), then the\n        array will be in C-contiguous order (last-index varies the\n        fastest).  If order is 'F', then the returned array\n        will be in Fortran-contiguous order (first-index varies the\n        fastest).  If order is 'A', then the returned array may\n        be in any order (either C-, Fortran-contiguous, or even\n        discontiguous).\n    subok : bool, optional\n        If True, then sub-classes will be passed-through, otherwise\n        the returned array will be forced to be a base-class array (default).\n    ndmin : int, optional\n        Specifies the minimum number of dimensions that the resulting\n        array should have.  Ones will be pre-pended to the shape as\n        needed to meet this requirement.\n\n    Returns\n    -------\n    out : ndarray\n        An array object satisfying the specified requirements.\n\n    See Also\n    --------\n    empty, empty_like, zeros, zeros_like, ones, ones_like, fill\n\n    ""Examples\n    --------\n    >>> np.array([1, 2, 3])\n    array([1, 2, 3])\n\n    Upcasting:\n\n    >>> np.array([1, 2, 3.0])\n    array([ 1.,  2.,  3.])\n\n    More than one dimension:\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1, 2],\n           [3, 4]])\n\n    Minimum dimensions 2:\n\n    >>> np.array([1, 2, 3], ndmin=2)\n    array([[1, 2, 3]])\n\n    Type provided:\n\n    >>> np.array([1, 2, 3], dtype=complex)\n    array([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n    Data-type consisting of more than one element:\n\n    >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])\n    >>> x['a']\n    array([1, 3])\n\n    Creating an array from sub-classes:\n\n    >>> np.array(np.mat('1 2; 3 4'))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> np.array(np.mat('1 2; 3 4'), subok=True)\n    matrix([[1, 2],\n            [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_37array = {"array", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_37array, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_36array};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_37array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_object = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_copy = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  CYTHON_UNUSED PyObject *__pyx_v_subok = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ndmin = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_object,&__pyx_n_s_dtype,&__pyx_n_s_copy,&__pyx_n_s_order,&__pyx_n_s_subok,&__pyx_n_s_ndmin,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_True);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_False);
    values[5] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_object)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_copy);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_subok);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ndmin);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array") < 0)) __PYX_ERR(0, 812, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_object = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_copy = values[2];
    __pyx_v_order = values[3];
    __pyx_v_subok = values[4];
    __pyx_v_ndmin = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 812, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_36array(__pyx_self, __pyx_v_object, __pyx_v_dtype, __pyx_v_copy, __pyx_v_order, __pyx_v_subok, __pyx_v_ndmin);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_36array(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_copy, CYTHON_UNUSED PyObject *__pyx_v_order, CYTHON_UNUSED PyObject *__pyx_v_subok, CYTHON_UNUSED PyObject *__pyx_v_ndmin) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array", 0);

  /* "ga4py/gain/notimplemented.pyx":903
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 903, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":812
 * 
 * 
 * def array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":906
 * 
 * 
 * def array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=repr):             # <<<<<<<<<<<<<<
 *     """Return a string representation of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_39array2string(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_38array2string[] = "Return a string representation of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters splits the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing\n        precision (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero. A number is \"very small\" if it\n        is smaller than the current printing precision.\n    separator : str, optional\n        Inserted between elements.\n    prefix : str, optional\n        An array is typically printed as::\n\n          'prefix(' + array2string(a) + ')'\n\n        The length of the prefix string is used to align the\n        output correctly.\n    style : function, optional\n        A function that accepts an ndarray and returns a string.  Used only\n        when the shape of `a` is equal to ().\n\n    Returns\n    -------\n    array_str : str\n        String representation of the array.\n\n    See Also\n    --------\n    array_str, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> x = np.array([1e-16,1,2,3])\n    >>> print np.array2string(x, precision=2, separator=',',\n    ...                       suppress_small=True)\n    [ 0., 1., 2., 3.]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_39array2string = {"array2string", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_39array2string, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_38array2string};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_39array2string(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_max_line_width = 0;
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress_small = 0;
  CYTHON_UNUSED PyObject *__pyx_v_separator = 0;
  CYTHON_UNUSED PyObject *__pyx_v_prefix = 0;
  CYTHON_UNUSED PyObject *__pyx_v_style = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array2string (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_max_line_width,&__pyx_n_s_precision,&__pyx_n_s_suppress_small,&__pyx_n_s_separator,&__pyx_n_s_prefix,&__pyx_n_s_style,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_kp_s_);
    values[5] = ((PyObject *)__pyx_kp_s__2);
    values[6] = __pyx_k__3;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_max_line_width);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_precision);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_suppress_small);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_separator);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_prefix);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_style);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array2string") < 0)) __PYX_ERR(0, 906, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_max_line_width = values[1];
    __pyx_v_precision = values[2];
    __pyx_v_suppress_small = values[3];
    __pyx_v_separator = values[4];
    __pyx_v_prefix = values[5];
    __pyx_v_style = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array2string", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 906, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array2string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_38array2string(__pyx_self, __pyx_v_a, __pyx_v_max_line_width, __pyx_v_precision, __pyx_v_suppress_small, __pyx_v_separator, __pyx_v_prefix, __pyx_v_style);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_38array2string(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small, CYTHON_UNUSED PyObject *__pyx_v_separator, CYTHON_UNUSED PyObject *__pyx_v_prefix, CYTHON_UNUSED PyObject *__pyx_v_style) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array2string", 0);

  /* "ga4py/gain/notimplemented.pyx":952
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 952, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":906
 * 
 * 
 * def array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=repr):             # <<<<<<<<<<<<<<
 *     """Return a string representation of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array2string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":955
 * 
 * 
 * def array_equal(a1, a2):             # <<<<<<<<<<<<<<
 *     """True if two arrays have the same shape and elements, False otherwise.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_41array_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_40array_equal[] = "True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_41array_equal = {"array_equal", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_41array_equal, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_40array_equal};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_41array_equal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_equal (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a1,&__pyx_n_s_a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("array_equal", 1, 2, 2, 1); __PYX_ERR(0, 955, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_equal") < 0)) __PYX_ERR(0, 955, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_equal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 955, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_40array_equal(__pyx_self, __pyx_v_a1, __pyx_v_a2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_40array_equal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_equal", 0);

  /* "ga4py/gain/notimplemented.pyx":987
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 987, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":955
 * 
 * 
 * def array_equal(a1, a2):             # <<<<<<<<<<<<<<
 *     """True if two arrays have the same shape and elements, False otherwise.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":990
 * 
 * 
 * def array_equiv(a1, a2):             # <<<<<<<<<<<<<<
 *     """Returns True if input arrays are shape consistent and all elements equal.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_43array_equiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_42array_equiv[] = "Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_43array_equiv = {"array_equiv", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_43array_equiv, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_42array_equiv};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_43array_equiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_equiv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a1,&__pyx_n_s_a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("array_equiv", 1, 2, 2, 1); __PYX_ERR(0, 990, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_equiv") < 0)) __PYX_ERR(0, 990, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_equiv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 990, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_42array_equiv(__pyx_self, __pyx_v_a1, __pyx_v_a2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_42array_equiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_equiv", 0);

  /* "ga4py/gain/notimplemented.pyx":1024
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1024, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":990
 * 
 * 
 * def array_equiv(a1, a2):             # <<<<<<<<<<<<<<
 *     """Returns True if input arrays are shape consistent and all elements equal.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_equiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1027
 * 
 * 
 * def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return the string representation of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_45array_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_44array_repr[] = "Return the string representation of an array.\n\n    Parameters\n    ----------\n    arr : ndarray\n        Input array.\n    max_line_width : int, optional\n        The maximum number of columns the string should span. Newline\n        characters split the string appropriately after array elements.\n    precision : int, optional\n        Floating point precision. Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent very small numbers as zero, default is False. Very small\n        is defined by `precision`, if the precision is 8 then\n        numbers smaller than 5e-9 are represented as zero.\n\n    Returns\n    -------\n    string : str\n      The string representation of an array.\n\n    See Also\n    --------\n    array_str, array2string, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_repr(np.array([1,2]))\n    'array([1, 2])'\n    >>> np.array_repr(np.ma.array([0.]))\n    'MaskedArray([ 0.])'\n    >>> np.array_repr(np.array([], np.int32))\n    'array([], dtype=int32)'\n\n    >>> x = np.array([1e-6, 4e-7, 2, 3])\n    >>> np.array_repr(x, precision=6, suppress_small=True)\n    'array([ 0.000001,  0.      ,  2.      ,  3.      ])'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_45array_repr = {"array_repr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_45array_repr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_44array_repr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_45array_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_max_line_width = 0;
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress_small = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_repr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_max_line_width,&__pyx_n_s_precision,&__pyx_n_s_suppress_small,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_max_line_width);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_precision);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_suppress_small);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_repr") < 0)) __PYX_ERR(0, 1027, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_max_line_width = values[1];
    __pyx_v_precision = values[2];
    __pyx_v_suppress_small = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_repr", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1027, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_44array_repr(__pyx_self, __pyx_v_arr, __pyx_v_max_line_width, __pyx_v_precision, __pyx_v_suppress_small);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_44array_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_repr", 0);

  /* "ga4py/gain/notimplemented.pyx":1068
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1068, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1027
 * 
 * 
 * def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return the string representation of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1071
 * 
 * 
 * def array_split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal or near-equal size.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_47array_split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_46array_split[] = "Split an array into multiple sub-arrays of equal or near-equal size.\n\n    Please refer to the ``split`` documentation.  The only difference\n    between these functions is that ``array_split`` allows\n    `indices_or_sections` to be an integer that does *not* equally\n    divide the axis.\n\n    See Also\n    --------\n    split : Split array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(8.0)\n    >>> np.array_split(x, 3)\n        [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_47array_split = {"array_split", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_47array_split, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_46array_split};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_47array_split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_split (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ary,&__pyx_n_s_indices_or_sections,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("array_split", 0, 2, 3, 1); __PYX_ERR(0, 1071, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_split") < 0)) __PYX_ERR(0, 1071, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_split", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1071, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_46array_split(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_46array_split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_split", 0);

  /* "ga4py/gain/notimplemented.pyx":1090
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1090, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1071
 * 
 * 
 * def array_split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal or near-equal size.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1093
 * 
 * 
 * def array_str(a, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return a string representation of the data in an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_49array_str(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_48array_str[] = "Return a string representation of the data in an array.\n\n    The data in the array is returned as a single string.  This function is\n    similar to `array_repr`, the difference being that `array_repr` also\n    returns information on the kind of array and its data type.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    max_line_width : int, optional\n        Inserts newlines if text is longer than `max_line_width`.  The\n        default is, indirectly, 75.\n    precision : int, optional\n        Floating point precision.  Default is the current printing precision\n        (usually 8), which can be altered using `set_printoptions`.\n    suppress_small : bool, optional\n        Represent numbers \"very close\" to zero as zero; default is False.\n        Very close is defined by precision: if the precision is 8, e.g.,\n        numbers smaller (in absolute value) than 5e-9 are represented as\n        zero.\n\n    See Also\n    --------\n    array2string, array_repr, set_printoptions\n\n    Examples\n    --------\n    >>> np.array_str(np.arange(3))\n    '[0 1 2]'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_49array_str = {"array_str", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_49array_str, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_48array_str};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_49array_str(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_max_line_width = 0;
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress_small = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_str (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_max_line_width,&__pyx_n_s_precision,&__pyx_n_s_suppress_small,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_max_line_width);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_precision);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_suppress_small);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_str") < 0)) __PYX_ERR(0, 1093, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_max_line_width = values[1];
    __pyx_v_precision = values[2];
    __pyx_v_suppress_small = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_str", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1093, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_48array_str(__pyx_self, __pyx_v_a, __pyx_v_max_line_width, __pyx_v_precision, __pyx_v_suppress_small);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_48array_str(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_max_line_width, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_suppress_small) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_str", 0);

  /* "ga4py/gain/notimplemented.pyx":1126
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1126, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1093
 * 
 * 
 * def array_str(a, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return a string representation of the data in an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.array_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1129
 * 
 * 
 * def asanyarray(a, dtype=None, order=None):             # <<<<<<<<<<<<<<
 *     """Convert the input to an ndarray, but pass ndarray subclasses through.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_51asanyarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_50asanyarray[] = "Convert the input to an ndarray, but pass ndarray subclasses through.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes scalars, lists, lists of tuples, tuples, tuples of tuples,\n        tuples of lists, and ndarrays.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('F') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray or an ndarray subclass\n        Array interpretation of `a`.  If `a` is an ndarray or a subclass\n        of ndarray, it is returned as-is and no copy is performed.\n\n    See Also\n    --------\n    asarray : Similar function which always returns ndarrays.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    asarray_chkfinite : Similar function which checks input for NaNs and\n                        Infs.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array:\n\n    >>> a = [1, 2]\n    >>> np.asanyarray(a)\n    array([1, 2])\n\n    Instances of `ndarray` subclasses are passed through as-is:\n\n    >>> a = np.matrix([1, 2])\n    >>> np.asanyarray(a) is a\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_51asanyarray = {"asanyarray", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_51asanyarray, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_50asanyarray};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_51asanyarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asanyarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_dtype,&__pyx_n_s_order,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asanyarray") < 0)) __PYX_ERR(0, 1129, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_order = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asanyarray", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1129, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asanyarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_50asanyarray(__pyx_self, __pyx_v_a, __pyx_v_dtype, __pyx_v_order);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_50asanyarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asanyarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1178
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1178, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1129
 * 
 * 
 * def asanyarray(a, dtype=None, order=None):             # <<<<<<<<<<<<<<
 *     """Convert the input to an ndarray, but pass ndarray subclasses through.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asanyarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1181
 * 
 * 
 * def asarray_chkfinite(a):             # <<<<<<<<<<<<<<
 *     """Convert the input to an array, checking for NaNs or Infs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_53asarray_chkfinite(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_52asarray_chkfinite[] = "Convert the input to an array, checking for NaNs or Infs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to an array.  This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists and ndarrays.  Success requires no NaNs or Infs.\n    dtype : data-type, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Defaults to 'C'.\n\n    Returns\n    -------\n    out : ndarray\n        Array interpretation of `a`.  No copy is performed if the input\n        is already an ndarray.  If `a` is a subclass of ndarray, a base\n        class ndarray is returned.\n\n    Raises\n    ------\n    ValueError\n        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\n    See Also\n    --------\n    asarray : Create and array.\n    asanyarray : Similar function which passes through subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfarray : Convert input to a floating point ndarray.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    fromiter : Create an array from an iterator.\n    fromfunction : Construct an array by executing a function on grid\n                   positions.\n\n    Examples\n    --------\n    Convert a list into an array.  If all elements are finite\n    ``asarray_chkfinite`` is identical to ``asarray``.\n\n    >>> a = [1, 2]\n    >>> np.asarray_chkfinite(a)\n    array([1, 2])\n\n    Raises ValueError if array_like contains Nans or Infs.\n\n    >>> a = [1, 2, np.inf]\n    >>> try:\n    ...     np.asarray_chkfinite(a)\n    ... except ValueError:\n    ...     print 'ValueError'\n    ...\n    ValueError\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_53asarray_chkfinite = {"asarray_chkfinite", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_53asarray_chkfinite, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_52asarray_chkfinite};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_53asarray_chkfinite(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asarray_chkfinite (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_52asarray_chkfinite(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_52asarray_chkfinite(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asarray_chkfinite", 0);

  /* "ga4py/gain/notimplemented.pyx":1240
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1240, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1181
 * 
 * 
 * def asarray_chkfinite(a):             # <<<<<<<<<<<<<<
 *     """Convert the input to an array, checking for NaNs or Infs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asarray_chkfinite", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1243
 * 
 * 
 * def ascontiguousarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return a contiguous array in memory (C order).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_55ascontiguousarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_54ascontiguousarray[] = "Return a contiguous array in memory (C order).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        Data-type of returned array.\n\n    Returns\n    -------\n    out : ndarray\n        Contiguous array of same shape and content as `a`, with type `dtype`\n        if specified.\n\n    See Also\n    --------\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> np.ascontiguousarray(x, dtype=np.float32)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.]], dtype=float32)\n    >>> x.flags['C_CONTIGUOUS']\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_55ascontiguousarray = {"ascontiguousarray", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_55ascontiguousarray, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_54ascontiguousarray};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_55ascontiguousarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ascontiguousarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ascontiguousarray") < 0)) __PYX_ERR(0, 1243, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ascontiguousarray", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1243, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ascontiguousarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_54ascontiguousarray(__pyx_self, __pyx_v_a, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_54ascontiguousarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ascontiguousarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1276
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1276, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1243
 * 
 * 
 * def ascontiguousarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return a contiguous array in memory (C order).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ascontiguousarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1279
 * 
 * 
 * def asfarray(a, dtype=np.float64):             # <<<<<<<<<<<<<<
 *     """Return an array converted to a float type.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_57asfarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_56asfarray[] = "Return an array converted to a float type.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    dtype : str or dtype object, optional\n        Float type code to coerce input array `a`.  If `dtype` is one of the\n        'int' dtypes, it is replaced with float64.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` as a float ndarray.\n\n    Examples\n    --------\n    >>> np.asfarray([2, 3])\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='float')\n    array([ 2.,  3.])\n    >>> np.asfarray([2, 3], dtype='int8')\n    array([ 2.,  3.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_57asfarray = {"asfarray", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_57asfarray, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_56asfarray};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_57asfarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asfarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k__4;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asfarray") < 0)) __PYX_ERR(0, 1279, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asfarray", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1279, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_56asfarray(__pyx_self, __pyx_v_a, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_56asfarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asfarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1305
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1305, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1279
 * 
 * 
 * def asfarray(a, dtype=np.float64):             # <<<<<<<<<<<<<<
 *     """Return an array converted to a float type.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1308
 * 
 * 
 * def asfortranarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return an array laid out in Fortran order in memory.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_59asfortranarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_58asfortranarray[] = "Return an array laid out in Fortran order in memory.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    dtype : str or dtype object, optional\n        By default, the data-type is inferred from the input data.\n\n    Returns\n    -------\n    out : ndarray\n        The input `a` in Fortran, or column-major, order.\n\n    See Also\n    --------\n    ascontiguousarray : Convert input to a contiguous (C order) array.\n    asanyarray : Convert input to an ndarray with either row or\n        column-major memory order.\n    require : Return an ndarray that satisfies requirements.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> y = np.asfortranarray(x)\n    >>> x.flags['F_CONTIGUOUS']\n    False\n    >>> y.flags['F_CONTIGUOUS']\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_59asfortranarray = {"asfortranarray", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_59asfortranarray, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_58asfortranarray};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_59asfortranarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asfortranarray (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asfortranarray") < 0)) __PYX_ERR(0, 1308, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asfortranarray", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1308, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfortranarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_58asfortranarray(__pyx_self, __pyx_v_a, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_58asfortranarray(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asfortranarray", 0);

  /* "ga4py/gain/notimplemented.pyx":1341
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1341, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1308
 * 
 * 
 * def asfortranarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return an array laid out in Fortran order in memory.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asfortranarray", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1344
 * 
 * 
 * def asmatrix(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_61asmatrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_60asmatrix[] = "Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_61asmatrix = {"asmatrix", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_61asmatrix, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_60asmatrix};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_61asmatrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_data = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asmatrix (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "asmatrix") < 0)) __PYX_ERR(0, 1344, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("asmatrix", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1344, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asmatrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_60asmatrix(__pyx_self, __pyx_v_data, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_60asmatrix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asmatrix", 0);

  /* "ga4py/gain/notimplemented.pyx":1373
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1373, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1344
 * 
 * 
 * def asmatrix(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asmatrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1376
 * 
 * 
 * def asscalar(a):             # <<<<<<<<<<<<<<
 *     """Convert an array of size 1 to its scalar equivalent.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_63asscalar(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_62asscalar[] = "Convert an array of size 1 to its scalar equivalent.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array of size 1.\n\n    Returns\n    -------\n    out : scalar\n        Scalar representation of `a`. The input data type is preserved.\n\n    Examples\n    --------\n    >>> np.asscalar(np.array([24]))\n    24\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_63asscalar = {"asscalar", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_63asscalar, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_62asscalar};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_63asscalar(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asscalar (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_62asscalar(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_62asscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("asscalar", 0);

  /* "ga4py/gain/notimplemented.pyx":1395
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1395, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1376
 * 
 * 
 * def asscalar(a):             # <<<<<<<<<<<<<<
 *     """Convert an array of size 1 to its scalar equivalent.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.asscalar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1398
 * 
 * 
 * def atleast_1d():             # <<<<<<<<<<<<<<
 *     """Convert inputs to arrays with at least one dimension.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_65atleast_1d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_64atleast_1d[] = "Convert inputs to arrays with at least one dimension.\n\n    Scalar inputs are converted to 1-dimensional arrays, whilst\n    higher-dimensional inputs are preserved.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more input arrays.\n\n    Returns\n    -------\n    ret : ndarray\n        An array, or sequence of arrays, each with ``a.ndim >= 1``.\n        Copies are made only if necessary.\n\n    See Also\n    --------\n    atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_1d(1.0)\n    array([ 1.])\n\n    >>> x = np.arange(9.0).reshape(3,3)\n    >>> np.atleast_1d(x)\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4.,  5.],\n           [ 6.,  7.,  8.]])\n    >>> np.atleast_1d(x) is x\n    True\n\n    >>> np.atleast_1d(1, [3, 4])\n    [array([1]), array([3, 4])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_65atleast_1d = {"atleast_1d", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_65atleast_1d, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_64atleast_1d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_65atleast_1d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_1d (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_64atleast_1d(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_64atleast_1d(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_1d", 0);

  /* "ga4py/gain/notimplemented.pyx":1436
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1436, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1398
 * 
 * 
 * def atleast_1d():             # <<<<<<<<<<<<<<
 *     """Convert inputs to arrays with at least one dimension.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.atleast_1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1439
 * 
 * 
 * def atleast_2d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least two dimensions.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_67atleast_2d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_66atleast_2d[] = "View inputs as arrays with at least two dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted\n        to arrays.  Arrays that already have two or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 2``.\n        Copies are avoided where possible, and views with two or more\n        dimensions are returned.\n\n    See Also\n    --------\n    atleast_1d, atleast_3d\n\n    Examples\n    --------\n    >>> np.atleast_2d(3.0)\n    array([[ 3.]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_2d(x)\n    array([[ 0.,  1.,  2.]])\n    >>> np.atleast_2d(x).base is x\n    True\n\n    >>> np.atleast_2d(1, [1, 2], [[1, 2]])\n    [array([[1]]), array([[1, 2]]), array([[1, 2]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_67atleast_2d = {"atleast_2d", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_67atleast_2d, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_66atleast_2d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_67atleast_2d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_2d (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_66atleast_2d(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_66atleast_2d(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_2d", 0);

  /* "ga4py/gain/notimplemented.pyx":1475
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1475, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1439
 * 
 * 
 * def atleast_2d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least two dimensions.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.atleast_2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1478
 * 
 * 
 * def atleast_3d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least three dimensions.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_69atleast_3d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_68atleast_3d[] = "View inputs as arrays with at least three dimensions.\n\n    Parameters\n    ----------\n    array1, array2, ... : array_like\n        One or more array-like sequences.  Non-array inputs are converted to\n        arrays.  Arrays that already have three or more dimensions are\n        preserved.\n\n    Returns\n    -------\n    res1, res2, ... : ndarray\n        An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are\n        avoided where possible, and views with three or more dimensions are\n        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view\n        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\n        view of shape ``(M, N, 1)``.\n\n    See Also\n    --------\n    atleast_1d, atleast_2d\n\n    Examples\n    --------\n    >>> np.atleast_3d(3.0)\n    array([[[ 3.]]])\n\n    >>> x = np.arange(3.0)\n    >>> np.atleast_3d(x).shape\n    (1, 3, 1)\n\n    >>> x = np.arange(12.0).reshape(4,3)\n    >>> np.atleast_3d(x).shape\n    (4, 3, 1)\n    >>> np.atleast_3d(x).base is x\n    True\n\n    >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n    ...     print arr, arr.shape\n    ...\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1]\n      [2]]] (1, 2, 1)\n    [[[1 2]]] (1, 1, 2)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_69atleast_3d = {"atleast_3d", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_69atleast_3d, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_68atleast_3d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_69atleast_3d(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_3d (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_68atleast_3d(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_68atleast_3d(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("atleast_3d", 0);

  /* "ga4py/gain/notimplemented.pyx":1526
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1526, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1478
 * 
 * 
 * def atleast_3d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least three dimensions.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.atleast_3d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1529
 * 
 * 
 * def average(a, axis=None, weights=None, returned=False):             # <<<<<<<<<<<<<<
 *     """Compute the weighted average along the specified axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_71average(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_70average[] = "Compute the weighted average along the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing data to be averaged. If `a` is not an array, a\n        conversion is attempted.\n    axis : int, optional\n        Axis along which to average `a`. If `None`, averaging is done over\n        the flattened array.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The weights array can either be 1-D (in which case its length must be\n        the size of `a` along the given axis) or of the same shape as `a`.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n    returned : bool, optional\n        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)\n        is returned, otherwise only the average is returned.\n        If `weights=None`, `sum_of_weights` is equivalent to the number of\n        elements over which the average is taken.\n\n\n    Returns\n    -------\n    average, [sum_of_weights] : {array_type, double}\n        Return the average along the specified axis. When returned is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. The return type is `Float`\n        if `a` is of integer type, otherwise it is of the same type as `a`.\n        `sum_of_weights` is of the same type as `average`.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When the length of 1D `weights` is not the same as the shape of `a`\n        along axis.\n\n    See Also\n    --------\n    mean\n\n    ma.average : average for masked arrays\n\n    Examples\n    --------\n    >>> data = range(1,5)\n    >>> data\n    [1, 2, 3, 4""]\n    >>> np.average(data)\n    2.5\n    >>> np.average(range(1,11), weights=range(10,0,-1))\n    4.0\n\n    >>> data = np.arange(6).reshape((3,2))\n    >>> data\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> np.average(data, axis=1, weights=[1./4, 3./4])\n    array([ 0.75,  2.75,  4.75])\n    >>> np.average(data, weights=[1./4, 3./4])\n    Traceback (most recent call last):\n    ...\n    TypeError: Axis must be specified when shapes of a and weights differ.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_71average = {"average", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_71average, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_70average};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_71average(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  CYTHON_UNUSED PyObject *__pyx_v_returned = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("average (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_weights,&__pyx_n_s_returned,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weights);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_returned);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "average") < 0)) __PYX_ERR(0, 1529, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_weights = values[2];
    __pyx_v_returned = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("average", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1529, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.average", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_70average(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_weights, __pyx_v_returned);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_70average(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_returned) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("average", 0);

  /* "ga4py/gain/notimplemented.pyx":1601
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1601, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1529
 * 
 * 
 * def average(a, axis=None, weights=None, returned=False):             # <<<<<<<<<<<<<<
 *     """Compute the weighted average along the specified axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.average", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1604
 * 
 * 
 * def bartlett(M):             # <<<<<<<<<<<<<<
 *     """Return the Bartlett window.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_73bartlett(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_72bartlett[] = "Return the Bartlett window.\n\n    The Bartlett window is very similar to a triangular window, except\n    that the end points are at zero.  It is often used in signal\n    processing for tapering a signal, without generating too much\n    ripple in the frequency domain.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : array\n        The triangular window, normalized to one (the value one\n        appears only if the number of samples is odd), with the first\n        and last samples equal to zero.\n\n    See Also\n    --------\n    blackman, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Bartlett window is defined as\n\n    .. math:: w(n) = \014rac{2}{M-1} \\left(\n              \014rac{M-1}{2} - \\left|n - \014rac{M-1}{2}\right|\n              \right)\n\n    Most references to the Bartlett window come from the signal\n    processing literature, where it is used as one of many windowing\n    functions for smoothing values.  Note that convolution with this\n    window produces linear interpolation.  It is also known as an\n    apodization (which means\"removing the foot\", i.e. smoothing\n    discontinuities at the beginning and end of the sampled signal) or\n    tapering function. The fourier transform of the Bartlett is the product\n    of two sinc functions.\n    Note the excellent discussion in Kanasewich.\n\n    References\n    ----------\n    .. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n           Biometrika 37, 1-16, 1950.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 109-110.\n    .. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n           Processing\", Prentice-Hall, 1999, pp. 468-471.\n    .. [4] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    "".. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\n\n    Examples\n    --------\n    >>> np.bartlett(12)\n    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,\n            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n            0.18181818,  0.        ])\n\n    Plot the window and its frequency response (requires SciPy and matplotlib):\n\n    >>> from numpy import clip, log10, array, bartlett, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = bartlett(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Bartlett window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_73bartlett = {"bartlett", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_73bartlett, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_72bartlett};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_73bartlett(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bartlett (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_72bartlett(__pyx_self, ((PyObject *)__pyx_v_M));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_72bartlett(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bartlett", 0);

  /* "ga4py/gain/notimplemented.pyx":1705
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1705, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1604
 * 
 * 
 * def bartlett(M):             # <<<<<<<<<<<<<<
 *     """Return the Bartlett window.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bartlett", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1708
 * 
 * 
 * def base_repr(number, base=2, padding=0):             # <<<<<<<<<<<<<<
 *     """Return a string representation of a number in the given base system.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_75base_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_74base_repr[] = "Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Only positive values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_75base_repr = {"base_repr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_75base_repr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_74base_repr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_75base_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_number = 0;
  CYTHON_UNUSED PyObject *__pyx_v_base = 0;
  CYTHON_UNUSED PyObject *__pyx_v_padding = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("base_repr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_number,&__pyx_n_s_base,&__pyx_n_s_padding,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_2);
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_number)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_base);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_padding);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "base_repr") < 0)) __PYX_ERR(0, 1708, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_number = values[0];
    __pyx_v_base = values[1];
    __pyx_v_padding = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("base_repr", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1708, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.base_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_74base_repr(__pyx_self, __pyx_v_number, __pyx_v_base, __pyx_v_padding);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_74base_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_number, CYTHON_UNUSED PyObject *__pyx_v_base, CYTHON_UNUSED PyObject *__pyx_v_padding) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("base_repr", 0);

  /* "ga4py/gain/notimplemented.pyx":1745
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1745, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1708
 * 
 * 
 * def base_repr(number, base=2, padding=0):             # <<<<<<<<<<<<<<
 *     """Return a string representation of a number in the given base system.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.base_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1748
 * 
 * 
 * def binary_repr(num, width=None):             # <<<<<<<<<<<<<<
 *     """Return the binary representation of the input number as a string.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_77binary_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_76binary_repr[] = "Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, the length of\n        the two's complement if `num` is negative.\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        http://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=4)\n    '1101'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_77binary_repr = {"binary_repr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_77binary_repr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_76binary_repr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_77binary_repr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_num = 0;
  CYTHON_UNUSED PyObject *__pyx_v_width = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("binary_repr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_num,&__pyx_n_s_width,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_num)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_width);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "binary_repr") < 0)) __PYX_ERR(0, 1748, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_num = values[0];
    __pyx_v_width = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("binary_repr", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1748, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.binary_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_76binary_repr(__pyx_self, __pyx_v_num, __pyx_v_width);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_76binary_repr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num, CYTHON_UNUSED PyObject *__pyx_v_width) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("binary_repr", 0);

  /* "ga4py/gain/notimplemented.pyx":1805
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1805, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1748
 * 
 * 
 * def binary_repr(num, width=None):             # <<<<<<<<<<<<<<
 *     """Return the binary representation of the input number as a string.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.binary_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1808
 * 
 * 
 * def bincount(x, weights=None, minlength=None):             # <<<<<<<<<<<<<<
 *     """bincount(x, weights=None, minlength=None)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_79bincount(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_78bincount[] = "bincount(x, weights=None, minlength=None)\n\n    Count number of occurrences of each value in array of non-negative ints.\n\n    The number of bins (of size 1) is one larger than the largest value in\n    `x`. If `minlength` is specified, there will be at least this number\n    of bins in the output array (though it will be longer if necessary,\n    depending on the contents of `x`).\n    Each bin gives the number of occurrences of its index value in `x`.\n    If `weights` is specified the input array is weighted by it, i.e. if a\n    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead\n    of ``out[n] += 1``.\n\n    Parameters\n    ----------\n    x : array_like, 1 dimension, nonnegative ints\n        Input array.\n    weights : array_like, optional\n        Weights, array of the same shape as `x`.\n    minlength : int, optional\n        .. versionadded:: 1.6.0\n\n        A minimum number of bins for the output array.\n\n    Returns\n    -------\n    out : ndarray of ints\n        The result of binning the input array.\n        The length of `out` is equal to ``np.amax(x)+1``.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or contains elements with negative\n        values, or if `minlength` is non-positive.\n    TypeError\n        If the type of the input is float or complex.\n\n    See Also\n    --------\n    histogram, digitize, unique\n\n    Examples\n    --------\n    >>> np.bincount(np.arange(5))\n    array([1, 1, 1, 1, 1])\n    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\n    array([1, 3, 1, 1, 0, 0, 0, 1])\n\n    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n    >>> np.bincount(x).size == np.amax(x)+1\n    True\n\n    The input array needs to be of integer dtype, otherwise a\n    TypeError is raised:\n\n    >>> np.bincount(np.arange(5, dtype=np.float))\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: array cannot be safely cast to required type""\n\n    A possible use of ``bincount`` is to perform sums over\n    variable-size chunks of an array, using the ``weights`` keyword.\n\n    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n    >>> x = np.array([0, 1, 1, 2, 2, 2])\n    >>> np.bincount(x,  weights=w)\n    array([ 0.3,  0.7,  1.1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_79bincount = {"bincount", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_79bincount, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_78bincount};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_79bincount(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  CYTHON_UNUSED PyObject *__pyx_v_minlength = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bincount (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_weights,&__pyx_n_s_minlength,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weights);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_minlength);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "bincount") < 0)) __PYX_ERR(0, 1808, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_weights = values[1];
    __pyx_v_minlength = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("bincount", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1808, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bincount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_78bincount(__pyx_self, __pyx_v_x, __pyx_v_weights, __pyx_v_minlength);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_78bincount(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_minlength) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bincount", 0);

  /* "ga4py/gain/notimplemented.pyx":1880
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1880, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1808
 * 
 * 
 * def bincount(x, weights=None, minlength=None):             # <<<<<<<<<<<<<<
 *     """bincount(x, weights=None, minlength=None)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bincount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1883
 * 
 * 
 * def blackman(M):             # <<<<<<<<<<<<<<
 *     """Return the Blackman window.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_81blackman(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_80blackman[] = "Return the Blackman window.\n\n    The Blackman window is a taper formed by using the the first three\n    terms of a summation of cosines. It was designed to have close to the\n    minimal leakage possible.  It is close to optimal, only slightly worse\n    than a Kaiser window.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an empty\n        array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one appears only if the\n        number of samples is odd).\n\n    See Also\n    --------\n    bartlett, hamming, hanning, kaiser\n\n    Notes\n    -----\n    The Blackman window is defined as\n\n    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)\n\n    Most references to the Blackman window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function. It is known as a\n    \"near optimal\" tapering function, almost as good (by some measures)\n    as the kaiser window.\n\n    References\n    ----------\n    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\n    Dover Publications, New York.\n\n    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\n    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\n    Examples\n    --------\n    >>> from numpy import blackman\n    >>> blackman(12)\n    array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,\n             4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n             9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n             1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, lo""g10, array, blackman, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = blackman(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Blackman window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_81blackman = {"blackman", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_81blackman, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_80blackman};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_81blackman(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("blackman (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_80blackman(__pyx_self, ((PyObject *)__pyx_v_M));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_80blackman(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("blackman", 0);

  /* "ga4py/gain/notimplemented.pyx":1976
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 1976, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1883
 * 
 * 
 * def blackman(M):             # <<<<<<<<<<<<<<
 *     """Return the Blackman window.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.blackman", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":1979
 * 
 * 
 * def bmat(obj, ldict=None, gdict=None):             # <<<<<<<<<<<<<<
 *     """Build a matrix object from a string, nested sequence, or array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_83bmat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_82bmat[] = "Build a matrix object from a string, nested sequence, or array.\n\n    Parameters\n    ----------\n    obj : str or array_like\n        Input data.  Names of variables in the current scope may be\n        referenced, even if `obj` is a string.\n\n    Returns\n    -------\n    out : matrix\n        Returns a matrix object, which is a specialized 2-D array.\n\n    See Also\n    --------\n    matrix\n\n    Examples\n    --------\n    >>> A = np.mat('1 1; 1 1')\n    >>> B = np.mat('2 2; 2 2')\n    >>> C = np.mat('3 4; 5 6')\n    >>> D = np.mat('7 8; 9 0')\n\n    All the following expressions construct the same block matrix:\n\n    >>> np.bmat([[A, B], [C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    >>> np.bmat('A,B; C,D')\n    matrix([[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 4, 7, 8],\n            [5, 6, 9, 0]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_83bmat = {"bmat", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_83bmat, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_82bmat};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_83bmat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ldict = 0;
  CYTHON_UNUSED PyObject *__pyx_v_gdict = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bmat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_obj,&__pyx_n_s_ldict,&__pyx_n_s_gdict,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ldict);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_gdict);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "bmat") < 0)) __PYX_ERR(0, 1979, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_obj = values[0];
    __pyx_v_ldict = values[1];
    __pyx_v_gdict = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("bmat", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1979, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bmat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_82bmat(__pyx_self, __pyx_v_obj, __pyx_v_ldict, __pyx_v_gdict);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_82bmat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_ldict, CYTHON_UNUSED PyObject *__pyx_v_gdict) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("bmat", 0);

  /* "ga4py/gain/notimplemented.pyx":2023
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2023, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1979
 * 
 * 
 * def bmat(obj, ldict=None, gdict=None):             # <<<<<<<<<<<<<<
 *     """Build a matrix object from a string, nested sequence, or array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.bmat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2026
 * 
 * 
 * def broadcast_arrays():             # <<<<<<<<<<<<<<
 *     """Broadcast any number of arrays against each other.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_85broadcast_arrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_84broadcast_arrays[] = "Broadcast any number of arrays against each other.\n\n    Parameters\n    ----------\n    `*args` : array_likes\n        The arrays to broadcast.\n\n    Returns\n    -------\n    broadcasted : list of arrays\n        These arrays are views on the original arrays.  They are typically\n        not contiguous.  Furthermore, more than one element of a\n        broadcasted array may refer to a single memory location.  If you\n        need to write to the arrays, make copies first.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> y = np.array([[1],[2],[3]])\n    >>> np.broadcast_arrays(x, y)\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n\n    Here is a useful idiom for getting contiguous copies instead of\n    non-contiguous views.\n\n    >>> map(np.array, np.broadcast_arrays(x, y))\n    [array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]]), array([[1, 1, 1],\n           [2, 2, 2],\n           [3, 3, 3]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_85broadcast_arrays = {"broadcast_arrays", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_85broadcast_arrays, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_84broadcast_arrays};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_85broadcast_arrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("broadcast_arrays (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_84broadcast_arrays(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_84broadcast_arrays(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("broadcast_arrays", 0);

  /* "ga4py/gain/notimplemented.pyx":2064
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2064, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2026
 * 
 * 
 * def broadcast_arrays():             # <<<<<<<<<<<<<<
 *     """Broadcast any number of arrays against each other.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.broadcast_arrays", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2067
 * 
 * 
 * def byte_bounds(a):             # <<<<<<<<<<<<<<
 *     """Returns pointers to the end-points of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_87byte_bounds(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_86byte_bounds[] = "Returns pointers to the end-points of an array.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array. It must conform to the Python-side of the array interface.\n\n    Returns\n    -------\n    (low, high) : tuple of 2 integers\n        The first integer is the first byte of the array, the second integer is\n        just past the last byte of the array.  If `a` is not contiguous it\n        will not use every byte between the (`low`, `high`) values.\n\n    Examples\n    --------\n    >>> I = np.eye(2, dtype='f'); I.dtype\n    dtype('float32')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    >>> I = np.eye(2, dtype='G'); I.dtype\n    dtype('complex192')\n    >>> low, high = np.byte_bounds(I)\n    >>> high - low == I.size*I.itemsize\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_87byte_bounds = {"byte_bounds", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_87byte_bounds, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_86byte_bounds};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_87byte_bounds(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("byte_bounds (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_86byte_bounds(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_86byte_bounds(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("byte_bounds", 0);

  /* "ga4py/gain/notimplemented.pyx":2096
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2096, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2067
 * 
 * 
 * def byte_bounds(a):             # <<<<<<<<<<<<<<
 *     """Returns pointers to the end-points of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.byte_bounds", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2099
 * 
 * 
 * def can_cast():             # <<<<<<<<<<<<<<
 *     """can_cast(from, totype, casting = 'safe')
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_89can_cast(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_88can_cast[] = "can_cast(from, totype, casting = 'safe')\n\n    Returns True if cast between data types can occur according to the\n    casting rule.  If from is a scalar or array scalar, also returns\n    True if the scalar value can be cast without overflow or truncation\n    to an integer.\n\n    Parameters\n    ----------\n    from : dtype, dtype specifier, scalar, or array\n        Data type, scalar, or array to cast from.\n    totype : dtype or dtype specifier\n        Data type to cast to.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n          * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    out : bool\n        True if cast can occur according to the casting rule.\n\n    See also\n    --------\n    dtype, result_type\n\n    Examples\n    --------\n\n    Basic examples\n\n    >>> np.can_cast(np.int32, np.int64)\n    True\n    >>> np.can_cast(np.float64, np.complex)\n    True\n    >>> np.can_cast(np.complex, np.float)\n    False\n\n    >>> np.can_cast('i8', 'f8')\n    True\n    >>> np.can_cast('i8', 'f4')\n    False\n    >>> np.can_cast('i4', 'S4')\n    True\n\n    Casting scalars\n\n    >>> np.can_cast(100, 'i1')\n    True\n    >>> np.can_cast(150, 'i1')\n    False\n    >>> np.can_cast(150, 'u1')\n    True\n\n    >>> np.can_cast(3.5e100, np.float32)\n    False\n    >>> np.can_cast(1000.0, np.float32)\n    True\n\n    Array scalar checks the value, array does not\n\n    >>> np.can_cast(np.array(1000.0), np.float32)\n    True\n    >>> np.can_cast(np.array([1000.0]), np.float32)\n    False\n\n    Using the casting rules\n\n    >>> np.can_c""ast('i8', 'i8', 'no')\n    True\n    >>> np.can_cast('<i8', '>i8', 'no')\n    False\n\n    >>> np.can_cast('<i8', '>i8', 'equiv')\n    True\n    >>> np.can_cast('<i4', '>i8', 'equiv')\n    False\n\n    >>> np.can_cast('<i4', '>i8', 'safe')\n    True\n    >>> np.can_cast('<i8', '>i4', 'safe')\n    False\n\n    >>> np.can_cast('<i8', '>i4', 'same_kind')\n    True\n    >>> np.can_cast('<i8', '>u4', 'same_kind')\n    False\n\n    >>> np.can_cast('<i8', '>u4', 'unsafe')\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_89can_cast = {"can_cast", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_89can_cast, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_88can_cast};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_89can_cast(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("can_cast (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_88can_cast(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_88can_cast(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("can_cast", 0);

  /* "ga4py/gain/notimplemented.pyx":2199
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2199, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2099
 * 
 * 
 * def can_cast():             # <<<<<<<<<<<<<<
 *     """can_cast(from, totype, casting = 'safe')
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.can_cast", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2202
 * 
 * 
 * def choose(a, choices, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Construct an array from an index array and a set of arrays to choose from.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_91choose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_90choose[] = "Construct an array from an index array and a set of arrays to choose from.\n\n    First of all, if confused or uncertain, definitely look at the Examples -\n    in its full generality, this function is less simple than it might\n    seem from the following code description (below ndi =\n    `numpy.lib.index_tricks`):\n\n    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.\n\n    But this omits some subtleties.  Here is a fully general summary:\n\n    Given an \"index\" array (`a`) of integers and a sequence of `n` arrays\n    (`choices`), `a` and each choice array are first broadcast, as necessary,\n    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =\n    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``\n    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as\n    follows:\n\n    * if ``mode=raise`` (the default), then, first of all, each element of\n      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that\n      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position\n      in `Ba` - then the value at the same position in the new array is the\n      value in `Bchoices[i]` at that same position;\n\n    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; modular arithmetic is used to map integers outside the range\n      `[0, n-1]` back into that range; and then the new array is constructed\n      as above;\n\n    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)\n      integer; negative integers are mapped to 0; values greater than `n-1`\n      are mapped to `n-1`; and then the new array is constructed as above.\n\n    Parameters\n    ----------\n    a : int array\n        This array must contain integers in `[0, n-1]`, where `n` is the number\n        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any\n        integers are permissible.\n    choices : sequence of arrays""\n        Choice arrays. `a` and all of the choices must be broadcastable to the\n        same shape.  If `choices` is itself an array (not recommended), then\n        its outermost dimension (i.e., the one corresponding to\n        ``choices.shape[0]``) is taken as defining the \"sequence\".\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise' (default), 'wrap', 'clip'}, optional\n        Specifies how indices outside `[0, n-1]` will be treated:\n\n          * 'raise' : an exception is raised\n          * 'wrap' : value becomes value mod `n`\n          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1\n\n    Returns\n    -------\n    merged_array : array\n        The merged result.\n\n    Raises\n    ------\n    ValueError: shape mismatch\n        If `a` and each choice array are not all broadcastable to the same\n        shape.\n\n    See Also\n    --------\n    ndarray.choose : equivalent method\n\n    Notes\n    -----\n    To reduce the chance of misinterpretation, even though the following\n    \"abuse\" is nominally supported, `choices` should neither be, nor be\n    thought of as, a single array, i.e., the outermost sequence-like container\n    should be either a list or a tuple.\n\n    Examples\n    --------\n\n    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n    ...   [20, 21, 22, 23], [30, 31, 32, 33]]\n    >>> np.choose([2, 3, 1, 0], choices\n    ... # the first element of the result will be the first element of the\n    ... # third (2+1) \"array\" in choices, namely, 20; the second element\n    ... # will be the second element of the fourth (3+1) choice array, i.e.,\n    ... # 31, etc.\n    ... )\n    array([20, 31, 12,  3])\n    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\n    array([20, 31, 12,  3])\n    >>> # because there are 4 choice arrays\n    >>> np.choose([2, 4, 1, 0], choices, m""ode='wrap') # 4 goes to (4 mod 4)\n    array([20,  1, 12,  3])\n    >>> # i.e., 0\n\n    A couple examples illustrating how choose broadcasts:\n\n    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    >>> choices = [-10, 10]\n    >>> np.choose(a, choices)\n    array([[ 10, -10,  10],\n           [-10,  10, -10],\n           [ 10, -10,  10]])\n\n    >>> # With thanks to Anne Archibald\n    >>> a = np.array([0, 1]).reshape((2,1,1))\n    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))\n    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\n    array([[[ 1,  1,  1,  1,  1],\n            [ 2,  2,  2,  2,  2],\n            [ 3,  3,  3,  3,  3]],\n           [[-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5],\n            [-1, -2, -3, -4, -5]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_91choose = {"choose", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_91choose, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_90choose};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_91choose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_choices = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("choose (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_choices,&__pyx_n_s_out,&__pyx_n_s_mode,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_n_s_raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_choices)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("choose", 0, 2, 4, 1); __PYX_ERR(0, 2202, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "choose") < 0)) __PYX_ERR(0, 2202, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_choices = values[1];
    __pyx_v_out = values[2];
    __pyx_v_mode = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("choose", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2202, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.choose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_90choose(__pyx_self, __pyx_v_a, __pyx_v_choices, __pyx_v_out, __pyx_v_mode);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_90choose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_choices, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("choose", 0);

  /* "ga4py/gain/notimplemented.pyx":2320
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2320, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2202
 * 
 * 
 * def choose(a, choices, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Construct an array from an index array and a set of arrays to choose from.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.choose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2323
 * 
 * 
 * def column_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack 1-D arrays as columns into a 2-D array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_93column_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_92column_stack[] = "Stack 1-D arrays as columns into a 2-D array.\n\n    Take a sequence of 1-D arrays and stack them as columns\n    to make a single 2-D array. 2-D arrays are stacked as-is,\n    just like with `hstack`.  1-D arrays are turned into 2-D columns\n    first.\n\n    Parameters\n    ----------\n    tup : sequence of 1-D or 2-D arrays.\n        Arrays to stack. All of them must have the same first dimension.\n\n    Returns\n    -------\n    stacked : 2-D array\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack, vstack, concatenate\n\n    Notes\n    -----\n    This function is equivalent to ``np.vstack(tup).T``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.column_stack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_93column_stack = {"column_stack", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_93column_stack, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_92column_stack};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_93column_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("column_stack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_92column_stack(__pyx_self, ((PyObject *)__pyx_v_tup));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_92column_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("column_stack", 0);

  /* "ga4py/gain/notimplemented.pyx":2359
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2359, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2323
 * 
 * 
 * def column_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack 1-D arrays as columns into a 2-D array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.column_stack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2362
 * 
 * 
 * def common_type():             # <<<<<<<<<<<<<<
 *     """Return a scalar type which is common to the input arrays.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_95common_type(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_94common_type[] = "Return a scalar type which is common to the input arrays.\n\n    The return type will always be an inexact (i.e. floating point) scalar\n    type, even if all the arrays are integer arrays. If one of the inputs is\n    an integer array, the minimum precision type that is returned is a\n    64-bit floating point dtype.\n\n    All input arrays can be safely cast to the returned dtype without loss\n    of information.\n\n    Parameters\n    ----------\n    array1, array2, ... : ndarrays\n        Input arrays.\n\n    Returns\n    -------\n    out : data type code\n        Data type code.\n\n    See Also\n    --------\n    dtype, mintypecode\n\n    Examples\n    --------\n    >>> np.common_type(np.arange(2, dtype=np.float32))\n    <type 'numpy.float32'>\n    >>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n    <type 'numpy.float64'>\n    >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n    <type 'numpy.complex128'>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_95common_type = {"common_type", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_95common_type, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_94common_type};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_95common_type(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("common_type (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_94common_type(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_94common_type(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("common_type", 0);

  /* "ga4py/gain/notimplemented.pyx":2397
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2397, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2362
 * 
 * 
 * def common_type():             # <<<<<<<<<<<<<<
 *     """Return a scalar type which is common to the input arrays.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.common_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2400
 * 
 * 
 * def compare_chararrays():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_97compare_chararrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_96compare_chararrays[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_97compare_chararrays = {"compare_chararrays", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_97compare_chararrays, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_96compare_chararrays};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_97compare_chararrays(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("compare_chararrays (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_96compare_chararrays(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_96compare_chararrays(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("compare_chararrays", 0);

  /* "ga4py/gain/notimplemented.pyx":2405
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2405, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2400
 * 
 * 
 * def compare_chararrays():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.compare_chararrays", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2408
 * 
 * 
 * def compress(condition, a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return selected slices of an array along given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_99compress(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_98compress[] = "Return selected slices of an array along given axis.\n\n    When working along a given axis, a slice along that axis is returned in\n    `output` for each index where `condition` evaluates to True. When\n    working on a 1-D array, `compress` is equivalent to `extract`.\n\n    Parameters\n    ----------\n    condition : 1-D array of bools\n        Array that selects which entries to return. If len(condition)\n        is less than the size of `a` along the given axis, then output is\n        truncated to the length of the condition array.\n    a : array_like\n        Array from which to extract a part.\n    axis : int, optional\n        Axis along which to take slices. If None (default), work on the\n        flattened array.\n    out : ndarray, optional\n        Output array.  Its type is preserved and it must be of the right\n        shape to hold the output.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        A copy of `a` without the slices along axis for which `condition`\n        is false.\n\n    See Also\n    --------\n    take, choose, diag, diagonal, select\n    ndarray.compress : Equivalent method.\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> a\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.compress([0, 1], a, axis=0)\n    array([[3, 4]])\n    >>> np.compress([False, True, True], a, axis=0)\n    array([[3, 4],\n           [5, 6]])\n    >>> np.compress([False, True], a, axis=1)\n    array([[2],\n           [4],\n           [6]])\n\n    Working on the flattened array does not return slices along an axis but\n    selects elements.\n\n    >>> np.compress([False, True], a)\n    array([2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_99compress = {"compress", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_99compress, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_98compress};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_99compress(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_condition = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("compress (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_condition,&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_condition)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("compress", 0, 2, 4, 1); __PYX_ERR(0, 2408, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "compress") < 0)) __PYX_ERR(0, 2408, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_condition = values[0];
    __pyx_v_a = values[1];
    __pyx_v_axis = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("compress", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2408, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_98compress(__pyx_self, __pyx_v_condition, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_98compress(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("compress", 0);

  /* "ga4py/gain/notimplemented.pyx":2466
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2466, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2408
 * 
 * 
 * def compress(condition, a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return selected slices of an array along given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.compress", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2469
 * 
 * 
 * def concatenate():             # <<<<<<<<<<<<<<
 *     """concatenate((a1, a2, ...), axis=0)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_101concatenate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_100concatenate[] = "concatenate((a1, a2, ...), axis=0)\n\n    Join a sequence of arrays together.\n\n    Parameters\n    ----------\n    a1, a2, ... : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined.  Default is 0.\n\n    Returns\n    -------\n    res : ndarray\n        The concatenated array.\n\n    See Also\n    --------\n    ma.concatenate : Concatenate function that preserves input masks.\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.\n    split : Split array into a list of multiple sub-arrays of equal size.\n    hsplit : Split array into multiple sub-arrays horizontally (column wise)\n    vsplit : Split array into multiple sub-arrays vertically (row wise)\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    hstack : Stack arrays in sequence horizontally (column wise)\n    vstack : Stack arrays in sequence vertically (row wise)\n    dstack : Stack arrays in sequence depth wise (along third dimension)\n\n    Notes\n    -----\n    When one or more of the arrays to be concatenated is a MaskedArray,\n    this function will return a MaskedArray object instead of an ndarray,\n    but the input masks are *not* preserved. In cases where a MaskedArray\n    is expected as input, use the ma.concatenate function from the masked\n    array module instead.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1, 2, 5],\n           [3, 4, 6]])\n\n    This function will not preserve masking of MaskedArray inputs.\n\n    >>> a = np.ma.arange(3)\n    >>> a[1] = np.ma.masked\n    >>> b = np.arange(2, 5)\n    >>> a\n    masked_arr""ay(data = [0 -- 2],\n                 mask = [False  True False],\n           fill_value = 999999)\n    >>> b\n    array([2, 3, 4])\n    >>> np.concatenate([a, b])\n    masked_array(data = [0 1 2 2 3 4],\n                 mask = False,\n           fill_value = 999999)\n    >>> np.ma.concatenate([a, b])\n    masked_array(data = [0 -- 2 2 3 4],\n                 mask = [False  True False False False False],\n           fill_value = 999999)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_101concatenate = {"concatenate", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_101concatenate, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_100concatenate};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_101concatenate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("concatenate (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_100concatenate(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_100concatenate(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("concatenate", 0);

  /* "ga4py/gain/notimplemented.pyx":2542
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2542, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2469
 * 
 * 
 * def concatenate():             # <<<<<<<<<<<<<<
 *     """concatenate((a1, a2, ...), axis=0)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.concatenate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2545
 * 
 * 
 * def convolve(a, v, mode='full'):             # <<<<<<<<<<<<<<
 *     """Returns the discrete, linear convolution of two one-dimensional sequences.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_103convolve(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_102convolve[] = "Returns the discrete, linear convolution of two one-dimensional sequences.\n\n    The convolution operator is often seen in signal processing, where it\n    models the effect of a linear time-invariant system on a signal [1]_.  In\n    probability theory, the sum of two independent random variables is\n    distributed according to the convolution of their individual\n    distributions.\n\n    Parameters\n    ----------\n    a : (N,) array_like\n        First one-dimensional input array.\n    v : (M,) array_like\n        Second one-dimensional input array.\n    mode : {'full', 'valid', 'same'}, optional\n        'full':\n          By default, mode is 'full'.  This returns the convolution\n          at each point of overlap, with an output shape of (N+M-1,). At\n          the end-points of the convolution, the signals do not overlap\n          completely, and boundary effects may be seen.\n\n        'same':\n          Mode `same` returns output of length ``max(M, N)``.  Boundary\n          effects are still visible.\n\n        'valid':\n          Mode `valid` returns output of length\n          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given\n          for points where the signals overlap completely.  Values outside\n          the signal boundary have no effect.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete, linear convolution of `a` and `v`.\n\n    See Also\n    --------\n    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier\n                               Transform.\n    scipy.linalg.toeplitz : Used to construct the convolution operator.\n\n    Notes\n    -----\n    The discrete convolution operation is defined as\n\n    .. math:: (f * g)[n] = \\sum_{m = -\\infty}^{\\infty} f[m] g[n - m]\n\n    It can be shown that a convolution :math:`x(t) * y(t)` in time/space\n    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier\n    domain, after appropriate padding (padding is necessary to prevent""\n    circular convolution).  Since multiplication is more efficient (faster)\n    than convolution, the function `scipy.signal.fftconvolve` exploits the\n    FFT to calculate the convolution of large data-sets.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Convolution\", http://en.wikipedia.org/wiki/Convolution.\n\n    Examples\n    --------\n    Note how the convolution operator flips the second array\n    before \"sliding\" the two across one another:\n\n    >>> np.convolve([1, 2, 3], [0, 1, 0.5])\n    array([ 0. ,  1. ,  2.5,  4. ,  1.5])\n\n    Only return the middle values of the convolution.\n    Contains boundary effects, where zeros are taken\n    into account:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'same')\n    array([ 1. ,  2.5,  4. ])\n\n    The two arrays are of the same length, so there\n    is only one position where they completely overlap:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')\n    array([ 2.5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_103convolve = {"convolve", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_103convolve, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_102convolve};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_103convolve(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("convolve (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_v,&__pyx_n_s_mode,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s_full);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("convolve", 0, 2, 3, 1); __PYX_ERR(0, 2545, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "convolve") < 0)) __PYX_ERR(0, 2545, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_v = values[1];
    __pyx_v_mode = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("convolve", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2545, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.convolve", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_102convolve(__pyx_self, __pyx_v_a, __pyx_v_v, __pyx_v_mode);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_102convolve(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("convolve", 0);

  /* "ga4py/gain/notimplemented.pyx":2627
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2627, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2545
 * 
 * 
 * def convolve(a, v, mode='full'):             # <<<<<<<<<<<<<<
 *     """Returns the discrete, linear convolution of two one-dimensional sequences.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.convolve", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2630
 * 
 * 
 * def copy(a):             # <<<<<<<<<<<<<<
 *     """Return an array copy of the given object.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_105copy(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_104copy[] = "Return an array copy of the given object.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    arr : ndarray\n        Array interpretation of `a`.\n\n    Notes\n    -----\n    This is equivalent to\n\n    >>> np.array(a, copy=True)                              #doctest: +SKIP\n\n    Examples\n    --------\n    Create an array x, with a reference y and a copy z:\n\n    >>> x = np.array([1, 2, 3])\n    >>> y = x\n    >>> z = np.copy(x)\n\n    Note that, when we modify x, y changes, but not z:\n\n    >>> x[0] = 10\n    >>> x[0] == y[0]\n    True\n    >>> x[0] == z[0]\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_105copy = {"copy", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_105copy, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_104copy};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_105copy(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("copy (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_104copy(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_104copy(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("copy", 0);

  /* "ga4py/gain/notimplemented.pyx":2666
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2666, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2630
 * 
 * 
 * def copy(a):             # <<<<<<<<<<<<<<
 *     """Return an array copy of the given object.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2669
 * 
 * 
 * def corrcoef(x, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Return correlation coefficients.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_107corrcoef(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_106corrcoef[] = "Return correlation coefficients.\n\n    Please refer to the documentation for `cov` for more detail.  The\n    relationship between the correlation coefficient matrix, `P`, and the\n    covariance matrix, `C`, is\n\n    .. math:: P_{ij} = \014rac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }\n\n    The values of `P` are between -1 and 1, inclusive.\n\n    Parameters\n    ----------\n    x : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        shape as `m`.\n    rowvar : int, optional\n        If `rowvar` is non-zero (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : int, optional\n        Default normalization is by ``(N - 1)``, where ``N`` is the number of\n        observations (unbiased estimate). If `bias` is 1, then\n        normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : {None, int}, optional\n        .. versionadded:: 1.5\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n\n    Returns\n    -------\n    out : ndarray\n        The correlation coefficient matrix of the variables.\n\n    See Also\n    --------\n    cov : Covariance matrix\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_107corrcoef = {"corrcoef", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_107corrcoef, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_106corrcoef};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_107corrcoef(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rowvar = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bias = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("corrcoef (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_rowvar,&__pyx_n_s_bias,&__pyx_n_s_ddof,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_int_1);
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rowvar);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bias);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "corrcoef") < 0)) __PYX_ERR(0, 2669, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
    __pyx_v_rowvar = values[2];
    __pyx_v_bias = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("corrcoef", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2669, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.corrcoef", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_106corrcoef(__pyx_self, __pyx_v_x, __pyx_v_y, __pyx_v_rowvar, __pyx_v_bias, __pyx_v_ddof);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_106corrcoef(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("corrcoef", 0);

  /* "ga4py/gain/notimplemented.pyx":2715
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2715, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2669
 * 
 * 
 * def corrcoef(x, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Return correlation coefficients.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.corrcoef", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2718
 * 
 * 
 * def correlate(a, v, mode='valid', old_behavior=False):             # <<<<<<<<<<<<<<
 *     """Cross-correlation of two 1-dimensional sequences.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_109correlate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_108correlate[] = "Cross-correlation of two 1-dimensional sequences.\n\n    This function computes the correlation as generally defined in signal\n    processing texts::\n\n        z[k] = sum_n a[n] * conj(v[n+k])\n\n    with a and v sequences being zero-padded where necessary and conj being\n    the conjugate.\n\n    Parameters\n    ----------\n    a, v : array_like\n        Input sequences.\n    mode : {'valid', 'same', 'full'}, optional\n        Refer to the `convolve` docstring.  Note that the default\n        is `valid`, unlike `convolve`, which uses `full`.\n    old_behavior : bool\n        If True, uses the old behavior from Numeric, (correlate(a,v) == correlate(v,\n        a), and the conjugate is not taken for complex arrays). If False, uses\n        the conventional signal processing definition (see note).\n\n    See Also\n    --------\n    convolve : Discrete, linear convolution of two one-dimensional sequences.\n\n    Examples\n    --------\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5])\n    array([ 3.5])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\n    array([ 2. ,  3.5,  3. ])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\n    array([ 0.5,  2. ,  3.5,  3. ,  0. ])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_109correlate = {"correlate", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_109correlate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_108correlate};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_109correlate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  CYTHON_UNUSED PyObject *__pyx_v_old_behavior = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("correlate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_v,&__pyx_n_s_mode,&__pyx_n_s_old_behavior,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_s_valid);
    values[3] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("correlate", 0, 2, 4, 1); __PYX_ERR(0, 2718, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_old_behavior);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "correlate") < 0)) __PYX_ERR(0, 2718, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_v = values[1];
    __pyx_v_mode = values[2];
    __pyx_v_old_behavior = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("correlate", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2718, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.correlate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_108correlate(__pyx_self, __pyx_v_a, __pyx_v_v, __pyx_v_mode, __pyx_v_old_behavior);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_108correlate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_old_behavior) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("correlate", 0);

  /* "ga4py/gain/notimplemented.pyx":2755
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2755, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2718
 * 
 * 
 * def correlate(a, v, mode='valid', old_behavior=False):             # <<<<<<<<<<<<<<
 *     """Cross-correlation of two 1-dimensional sequences.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.correlate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2758
 * 
 * 
 * def count_nonzero(a):             # <<<<<<<<<<<<<<
 *     """count_nonzero(a)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_111count_nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_110count_nonzero[] = "count_nonzero(a)\n\n    Counts the number of non-zero values in the array ``a``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n\n    Returns\n    -------\n    count : int\n        Number of non-zero values in the array.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    Examples\n    --------\n    >>> np.count_nonzero(np.eye(4))\n    4\n\n    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n    5\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_111count_nonzero = {"count_nonzero", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_111count_nonzero, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_110count_nonzero};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_111count_nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("count_nonzero (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_110count_nonzero(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_110count_nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("count_nonzero", 0);

  /* "ga4py/gain/notimplemented.pyx":2787
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2787, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2758
 * 
 * 
 * def count_nonzero(a):             # <<<<<<<<<<<<<<
 *     """count_nonzero(a)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.count_nonzero", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2790
 * 
 * 
 * def cov(m, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Estimate a covariance matrix, given data.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_113cov(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_112cov[] = "Estimate a covariance matrix, given data.\n\n    Covariance indicates the level to which two variables vary together.\n    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,\n    then the covariance matrix element :math:`C_{ij}` is the covariance of\n    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance\n    of :math:`x_i`.\n\n    Parameters\n    ----------\n    m : array_like\n        A 1-D or 2-D array containing multiple variables and observations.\n        Each row of `m` represents a variable, and each column a single\n        observation of all those variables. Also see `rowvar` below.\n    y : array_like, optional\n        An additional set of variables and observations. `y` has the same\n        form as that of `m`.\n    rowvar : int, optional\n        If `rowvar` is non-zero (default), then each row represents a\n        variable, with observations in the columns. Otherwise, the relationship\n        is transposed: each column represents a variable, while the rows\n        contain observations.\n    bias : int, optional\n        Default normalization is by ``(N - 1)``, where ``N`` is the number of\n        observations given (unbiased estimate). If `bias` is 1, then\n        normalization is by ``N``. These values can be overridden by using\n        the keyword ``ddof`` in numpy versions >= 1.5.\n    ddof : int, optional\n        .. versionadded:: 1.5\n        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is\n        the number of observations; this overrides the value implied by\n        ``bias``. The default value is ``None``.\n\n    Returns\n    -------\n    out : ndarray\n        The covariance matrix of the variables.\n\n    See Also\n    --------\n    corrcoef : Normalized covariance matrix\n\n    Examples\n    --------\n    Consider two variables, :math:`x_0` and :math:`x_1`, which\n    correlate perfectly, but in opposite directions:\n\n    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T\n   "" >>> x\n    array([[0, 1, 2],\n           [2, 1, 0]])\n\n    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance\n    matrix shows this clearly:\n\n    >>> np.cov(x)\n    array([[ 1., -1.],\n           [-1.,  1.]])\n\n    Note that element :math:`C_{0,1}`, which shows the correlation between\n    :math:`x_0` and :math:`x_1`, is negative.\n\n    Further, note how `x` and `y` are combined:\n\n    >>> x = [-2.1, -1,  4.3]\n    >>> y = [3,  1.1,  0.12]\n    >>> X = np.vstack((x,y))\n    >>> print np.cov(X)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x, y)\n    [[ 11.71        -4.286     ]\n     [ -4.286        2.14413333]]\n    >>> print np.cov(x)\n    11.71\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_113cov = {"cov", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_113cov, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_112cov};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_113cov(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rowvar = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bias = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cov (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_m,&__pyx_n_s_y,&__pyx_n_s_rowvar,&__pyx_n_s_bias,&__pyx_n_s_ddof,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_int_1);
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rowvar);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bias);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cov") < 0)) __PYX_ERR(0, 2790, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_y = values[1];
    __pyx_v_rowvar = values[2];
    __pyx_v_bias = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cov", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2790, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cov", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_112cov(__pyx_self, __pyx_v_m, __pyx_v_y, __pyx_v_rowvar, __pyx_v_bias, __pyx_v_ddof);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_112cov(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_rowvar, CYTHON_UNUSED PyObject *__pyx_v_bias, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cov", 0);

  /* "ga4py/gain/notimplemented.pyx":2868
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2868, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2790
 * 
 * 
 * def cov(m, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Estimate a covariance matrix, given data.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cov", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2871
 * 
 * 
 * def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the cross product of two (arrays of) vectors.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_115cross(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_114cross[] = "Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  By default, the\n        last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    ix_ : Construct index arrays.\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3""])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    -3\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the `right-hand rule`.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_115cross = {"cross", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_115cross, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_114cross};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_115cross(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axisa = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axisb = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axisc = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cross (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,&__pyx_n_s_axisa,&__pyx_n_s_axisb,&__pyx_n_s_axisc,&__pyx_n_s_axis,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_int_neg_1);
    values[4] = ((PyObject *)__pyx_int_neg_1);
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("cross", 0, 2, 6, 1); __PYX_ERR(0, 2871, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axisa);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axisb);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axisc);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cross") < 0)) __PYX_ERR(0, 2871, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
    __pyx_v_axisa = values[2];
    __pyx_v_axisb = values[3];
    __pyx_v_axisc = values[4];
    __pyx_v_axis = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cross", 0, 2, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2871, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cross", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_114cross(__pyx_self, __pyx_v_a, __pyx_v_b, __pyx_v_axisa, __pyx_v_axisb, __pyx_v_axisc, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_114cross(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axisa, CYTHON_UNUSED PyObject *__pyx_v_axisb, CYTHON_UNUSED PyObject *__pyx_v_axisc, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cross", 0);

  /* "ga4py/gain/notimplemented.pyx":2976
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 2976, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2871
 * 
 * 
 * def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the cross product of two (arrays of) vectors.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cross", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":2979
 * 
 * 
 * def cumprod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product of elements along a given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_117cumprod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_116cumprod[] = "Return the cumulative product of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative product is computed.  By default\n        the input is flattened.\n    dtype : dtype, optional\n        Type of the returned array, as well as of the accumulator in which\n        the elements are multiplied.  If *dtype* is not specified, it\n        defaults to the dtype of `a`, unless `a` has an integer dtype with\n        a precision less than that of the default platform integer.  In\n        that case, the default platform integer is used instead.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type of the resulting values will be cast if necessary.\n\n    Returns\n    -------\n    cumprod : ndarray\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to out is returned.\n\n    See Also\n    --------\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([1,2,3])\n    >>> np.cumprod(a) # intermediate results 1, 1*2\n    ...               # total product 1*2*3 = 6\n    array([1, 2, 6])\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> np.cumprod(a, dtype=float) # specify type of output\n    array([   1.,    2.,    6.,   24.,  120.,  720.])\n\n    The cumulative product for each column (i.e., over the rows) of `a`:\n\n    >>> np.cumprod(a, axis=0)\n    array([[ 1,  2,  3],\n           [ 4, 10, 18]])\n\n    The cumulative product for each row (i.e. over the columns) of `a`:\n\n    >>> np.cumprod(a,axis=1)\n    array([[  1,   2,   6],\n           [  4,  20, 120]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_117cumprod = {"cumprod", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_117cumprod, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_116cumprod};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_117cumprod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumprod (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cumprod") < 0)) __PYX_ERR(0, 2979, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cumprod", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2979, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumprod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_116cumprod(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_116cumprod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumprod", 0);

  /* "ga4py/gain/notimplemented.pyx":3038
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3038, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2979
 * 
 * 
 * def cumprod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product of elements along a given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumprod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3041
 * 
 * 
 * def cumproduct(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product over the given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_119cumproduct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_118cumproduct[] = "Return the cumulative product over the given axis.\n\n\n    See Also\n    --------\n    cumprod : equivalent function; see for details.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_119cumproduct = {"cumproduct", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_119cumproduct, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_118cumproduct};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_119cumproduct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumproduct (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cumproduct") < 0)) __PYX_ERR(0, 3041, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cumproduct", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3041, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumproduct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_118cumproduct(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_118cumproduct(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumproduct", 0);

  /* "ga4py/gain/notimplemented.pyx":3050
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3050, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3041
 * 
 * 
 * def cumproduct(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product over the given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumproduct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3053
 * 
 * 
 * def cumsum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative sum of the elements along a given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_121cumsum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_120cumsum[] = "Return the cumulative sum of the elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int, optional\n        Axis along which the cumulative sum is computed. The default\n        (None) is to compute the cumsum over the flattened array.\n    dtype : dtype, optional\n        Type of the returned array and of the accumulator in which the\n        elements are summed.  If `dtype` is not specified, it defaults\n        to the dtype of `a`, unless `a` has an integer dtype with a\n        precision less than that of the default platform integer.  In\n        that case, the default platform integer is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary. See `doc.ufuncs`\n        (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    cumsum_along_axis : ndarray.\n        A new array holding the result is returned unless `out` is\n        specified, in which case a reference to `out` is returned. The\n        result has the same size as `a`, and the same shape as `a` if\n        `axis` is not None or `a` is a 1-d array.\n\n\n    See Also\n    --------\n    sum : Sum array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.cumsum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n\n    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> ""np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_121cumsum = {"cumsum", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_121cumsum, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_120cumsum};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_121cumsum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumsum (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "cumsum") < 0)) __PYX_ERR(0, 3053, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("cumsum", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3053, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumsum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_120cumsum(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_120cumsum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cumsum", 0);

  /* "ga4py/gain/notimplemented.pyx":3114
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3114, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3053
 * 
 * 
 * def cumsum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative sum of the elements along a given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.cumsum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3117
 * 
 * 
 * def datetime_data(dtype):             # <<<<<<<<<<<<<<
 *     """Return (unit, numerator, denominator, events) from a datetime dtype
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_123datetime_data(PyObject *__pyx_self, PyObject *__pyx_v_dtype); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_122datetime_data[] = "Return (unit, numerator, denominator, events) from a datetime dtype\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_123datetime_data = {"datetime_data", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_123datetime_data, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_122datetime_data};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_123datetime_data(PyObject *__pyx_self, PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_data (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_122datetime_data(__pyx_self, ((PyObject *)__pyx_v_dtype));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_122datetime_data(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("datetime_data", 0);

  /* "ga4py/gain/notimplemented.pyx":3121
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3121, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3117
 * 
 * 
 * def datetime_data(dtype):             # <<<<<<<<<<<<<<
 *     """Return (unit, numerator, denominator, events) from a datetime dtype
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.datetime_data", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3124
 * 
 * 
 * def delete(arr, obj, axis=None):             # <<<<<<<<<<<<<<
 *     """Return a new array with sub-arrays along an axis deleted.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_125delete(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_124delete[] = "Return a new array with sub-arrays along an axis deleted.\n\n    Parameters\n    ----------\n    arr : array_like\n      Input array.\n    obj : slice, int or array of ints\n      Indicate which sub-arrays to remove.\n    axis : int, optional\n      The axis along which to delete the subarray defined by `obj`.\n      If `axis` is None, `obj` is applied to the flattened array.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with the elements specified by `obj` removed. Note\n        that `delete` does not occur in-place. If `axis` is None, `out` is\n        a flattened array.\n\n    See Also\n    --------\n    insert : Insert elements into an array.\n    append : Append elements at the end of an array.\n\n    Examples\n    --------\n    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n    >>> arr\n    array([[ 1,  2,  3,  4],\n           [ 5,  6,  7,  8],\n           [ 9, 10, 11, 12]])\n    >>> np.delete(arr, 1, 0)\n    array([[ 1,  2,  3,  4],\n           [ 9, 10, 11, 12]])\n\n    >>> np.delete(arr, np.s_[::2], 1)\n    array([[ 2,  4],\n           [ 6,  8],\n           [10, 12]])\n    >>> np.delete(arr, [1,3,5], None)\n    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_125delete = {"delete", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_125delete, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_124delete};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_125delete(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("delete (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_obj,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("delete", 0, 2, 3, 1); __PYX_ERR(0, 3124, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "delete") < 0)) __PYX_ERR(0, 3124, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_obj = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("delete", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3124, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_124delete(__pyx_self, __pyx_v_arr, __pyx_v_obj, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_124delete(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("delete", 0);

  /* "ga4py/gain/notimplemented.pyx":3168
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3168, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3124
 * 
 * 
 * def delete(arr, obj, axis=None):             # <<<<<<<<<<<<<<
 *     """Return a new array with sub-arrays along an axis deleted.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3171
 * 
 * 
 * def deprecate():             # <<<<<<<<<<<<<<
 *     """Issues a DeprecationWarning, adds warning to `old_name`'s
 *     docstring, rebinds ``old_name.__name__`` and returns the new
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_127deprecate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_126deprecate[] = "Issues a DeprecationWarning, adds warning to `old_name`'s\n    docstring, rebinds ``old_name.__name__`` and returns the new\n    function object.\n\n    This function may also be used as a decorator.\n\n    Parameters\n    ----------\n    func : function\n        The function to be deprecated.\n    old_name : str, optional\n        The name of the function to be deprecated. Default is None, in which\n        case the name of `func` is used.\n    new_name : str, optional\n        The new name for the function. Default is None, in which case\n        the deprecation message is that `old_name` is deprecated. If given,\n        the deprecation message is that `old_name` is deprecated and `new_name`\n        should be used instead.\n    message : str, optional\n        Additional explanation of the deprecation.  Displayed in the docstring\n        after the warning.\n\n    Returns\n    -------\n    old_func : function\n        The deprecated function.\n\n    Examples\n    --------\n    Note that ``olduint`` returns a value after printing Deprecation Warning:\n\n    >>> olduint = np.deprecate(np.uint)\n    >>> olduint(6)\n    /usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:\n    DeprecationWarning: uint32 is deprecated\n      warnings.warn(str1, DeprecationWarning)\n    6\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_127deprecate = {"deprecate", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_127deprecate, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_126deprecate};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_127deprecate(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deprecate (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_126deprecate(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_126deprecate(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deprecate", 0);

  /* "ga4py/gain/notimplemented.pyx":3211
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3211, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3171
 * 
 * 
 * def deprecate():             # <<<<<<<<<<<<<<
 *     """Issues a DeprecationWarning, adds warning to `old_name`'s
 *     docstring, rebinds ``old_name.__name__`` and returns the new
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.deprecate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3214
 * 
 * 
 * def deprecate_with_doc(msg):             # <<<<<<<<<<<<<<
 *     """message
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_129deprecate_with_doc(PyObject *__pyx_self, PyObject *__pyx_v_msg); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_128deprecate_with_doc[] = "message\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_129deprecate_with_doc = {"deprecate_with_doc", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_129deprecate_with_doc, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_128deprecate_with_doc};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_129deprecate_with_doc(PyObject *__pyx_self, PyObject *__pyx_v_msg) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deprecate_with_doc (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_128deprecate_with_doc(__pyx_self, ((PyObject *)__pyx_v_msg));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_128deprecate_with_doc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_msg) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("deprecate_with_doc", 0);

  /* "ga4py/gain/notimplemented.pyx":3218
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3218, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3214
 * 
 * 
 * def deprecate_with_doc(msg):             # <<<<<<<<<<<<<<
 *     """message
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.deprecate_with_doc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3221
 * 
 * 
 * def diag_indices(n, ndim=2):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_131diag_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_130diag_indices[] = "Return the indices to access the main diagonal of an array.\n\n    This returns a tuple of indices that can be used to access the main\n    diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape\n    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for\n    ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``\n    for ``i = [0..n-1]``.\n\n    Parameters\n    ----------\n    n : int\n      The size, along each dimension, of the arrays for which the returned\n      indices can be used.\n\n    ndim : int, optional\n      The number of dimensions.\n\n    See also\n    --------\n    diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Create a set of indices to access the diagonal of a (4, 4) array:\n\n    >>> di = np.diag_indices(4)\n    >>> di\n    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> a[di] = 100\n    >>> a\n    array([[100,   1,   2,   3],\n           [  4, 100,   6,   7],\n           [  8,   9, 100,  11],\n           [ 12,  13,  14, 100]])\n\n    Now, we create indices to manipulate a 3-D array:\n\n    >>> d3 = np.diag_indices(2, 3)\n    >>> d3\n    (array([0, 1]), array([0, 1]), array([0, 1]))\n\n    And use it to set the diagonal of an array of zeros to 1:\n\n    >>> a = np.zeros((2, 2, 2), dtype=np.int)\n    >>> a[d3] = 1\n    >>> a\n    array([[[1, 0],\n            [0, 0]],\n           [[0, 0],\n            [0, 1]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_131diag_indices = {"diag_indices", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_131diag_indices, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_130diag_indices};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_131diag_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ndim = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diag_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n,&__pyx_n_s_ndim,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_2);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ndim);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "diag_indices") < 0)) __PYX_ERR(0, 3221, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_ndim = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("diag_indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3221, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diag_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_130diag_indices(__pyx_self, __pyx_v_n, __pyx_v_ndim);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_130diag_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_ndim) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diag_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":3284
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3284, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3221
 * 
 * 
 * def diag_indices(n, ndim=2):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diag_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3287
 * 
 * 
 * def diag_indices_from(arr):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an n-dimensional array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_133diag_indices_from(PyObject *__pyx_self, PyObject *__pyx_v_arr); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_132diag_indices_from[] = "Return the indices to access the main diagonal of an n-dimensional array.\n\n    See `diag_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array, at least 2-D\n\n    See Also\n    --------\n    diag_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_133diag_indices_from = {"diag_indices_from", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_133diag_indices_from, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_132diag_indices_from};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_133diag_indices_from(PyObject *__pyx_self, PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diag_indices_from (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_132diag_indices_from(__pyx_self, ((PyObject *)__pyx_v_arr));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_132diag_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diag_indices_from", 0);

  /* "ga4py/gain/notimplemented.pyx":3305
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3305, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3287
 * 
 * 
 * def diag_indices_from(arr):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an n-dimensional array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diag_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3308
 * 
 * 
 * def diagflat(v, k=0):             # <<<<<<<<<<<<<<
 *     """Create a two-dimensional array with the flattened input as a diagonal.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_135diagflat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_134diagflat[] = "Create a two-dimensional array with the flattened input as a diagonal.\n\n    Parameters\n    ----------\n    v : array_like\n        Input data, which is flattened and set as the `k`-th\n        diagonal of the output.\n    k : int, optional\n        Diagonal to set; 0, the default, corresponds to the \"main\" diagonal,\n        a positive (negative) `k` giving the number of the diagonal above\n        (below) the main.\n\n    Returns\n    -------\n    out : ndarray\n        The 2-D output array.\n\n    See Also\n    --------\n    diag : MATLAB work-alike for 1-D and 2-D arrays.\n    diagonal : Return specified diagonals.\n    trace : Sum along diagonals.\n\n    Examples\n    --------\n    >>> np.diagflat([[1,2], [3,4]])\n    array([[1, 0, 0, 0],\n           [0, 2, 0, 0],\n           [0, 0, 3, 0],\n           [0, 0, 0, 4]])\n\n    >>> np.diagflat([1,2], 1)\n    array([[0, 1, 0],\n           [0, 0, 2],\n           [0, 0, 0]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_135diagflat = {"diagflat", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_135diagflat, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_134diagflat};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_135diagflat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diagflat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_v,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_v)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "diagflat") < 0)) __PYX_ERR(0, 3308, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_v = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("diagflat", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3308, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diagflat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_134diagflat(__pyx_self, __pyx_v_v, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_134diagflat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diagflat", 0);

  /* "ga4py/gain/notimplemented.pyx":3346
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3346, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3308
 * 
 * 
 * def diagflat(v, k=0):             # <<<<<<<<<<<<<<
 *     """Create a two-dimensional array with the flattened input as a diagonal.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diagflat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3349
 * 
 * 
 * def diff(a, n=1, axis=-1):             # <<<<<<<<<<<<<<
 *     """Calculate the n-th order discrete difference along given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_137diff(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_136diff[] = "Calculate the n-th order discrete difference along given axis.\n\n    The first order difference is given by ``out[n] = a[n+1] - a[n]`` along\n    the given axis, higher order differences are calculated by using `diff`\n    recursively.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n    n : int, optional\n        The number of times values are differenced.\n    axis : int, optional\n        The axis along which the difference is taken, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        The `n` order differences. The shape of the output is the same as `a`\n        except along `axis` where the dimension is smaller by `n`.\n\n    See Also\n    --------\n    gradient, ediff1d\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.diff(x)\n    array([ 1,  2,  3, -7])\n    >>> np.diff(x, n=2)\n    array([  1,   1, -10])\n\n    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n    >>> np.diff(x)\n    array([[2, 3, 4],\n           [5, 1, 2]])\n    >>> np.diff(x, axis=0)\n    array([[-1,  2,  0, -2]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_137diff = {"diff", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_137diff, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_136diff};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_137diff(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diff (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_n,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    values[2] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "diff") < 0)) __PYX_ERR(0, 3349, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_n = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("diff", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3349, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_136diff(__pyx_self, __pyx_v_a, __pyx_v_n, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_136diff(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("diff", 0);

  /* "ga4py/gain/notimplemented.pyx":3391
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3391, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3349
 * 
 * 
 * def diff(a, n=1, axis=-1):             # <<<<<<<<<<<<<<
 *     """Calculate the n-th order discrete difference along given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.diff", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3394
 * 
 * 
 * def digitize(x, bins):             # <<<<<<<<<<<<<<
 *     """digitize(x, bins)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_139digitize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_138digitize[] = "digitize(x, bins)\n\n    Return the indices of the bins to which each value in input array belongs.\n\n    Each index ``i`` returned is such that ``bins[i-1] <= x < bins[i]`` if\n    `bins` is monotonically increasing, or ``bins[i-1] > x >= bins[i]`` if\n    `bins` is monotonically decreasing. If values in `x` are beyond the\n    bounds of `bins`, 0 or ``len(bins)`` is returned as appropriate.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array to be binned. It has to be 1-dimensional.\n    bins : array_like\n        Array of bins. It has to be 1-dimensional and monotonic.\n\n    Returns\n    -------\n    out : ndarray of ints\n        Output array of indices, of same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If the input is not 1-dimensional, or if `bins` is not monotonic.\n    TypeError\n        If the type of the input is complex.\n\n    See Also\n    --------\n    bincount, histogram, unique\n\n    Notes\n    -----\n    If values in `x` are such that they fall outside the bin range,\n    attempting to index `bins` with the indices that `digitize` returns\n    will result in an IndexError.\n\n    Examples\n    --------\n    >>> x = np.array([0.2, 6.4, 3.0, 1.6])\n    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n    >>> inds = np.digitize(x, bins)\n    >>> inds\n    array([1, 4, 3, 2])\n    >>> for n in range(x.size):\n    ...   print bins[inds[n]-1], \"<=\", x[n], \"<\", bins[inds[n]]\n    ...\n    0.0 <= 0.2 < 1.0\n    4.0 <= 6.4 < 10.0\n    2.5 <= 3.0 < 4.0\n    1.0 <= 1.6 < 2.5\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_139digitize = {"digitize", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_139digitize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_138digitize};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_139digitize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("digitize (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_bins,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bins)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("digitize", 1, 2, 2, 1); __PYX_ERR(0, 3394, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "digitize") < 0)) __PYX_ERR(0, 3394, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_x = values[0];
    __pyx_v_bins = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("digitize", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3394, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.digitize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_138digitize(__pyx_self, __pyx_v_x, __pyx_v_bins);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_138digitize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_bins) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("digitize", 0);

  /* "ga4py/gain/notimplemented.pyx":3450
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3450, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3394
 * 
 * 
 * def digitize(x, bins):             # <<<<<<<<<<<<<<
 *     """digitize(x, bins)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.digitize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3453
 * 
 * 
 * def disp(mesg, device=None, linefeed=True):             # <<<<<<<<<<<<<<
 *     """Display a message on a device.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_141disp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_140disp[] = "Display a message on a device.\n\n    Parameters\n    ----------\n    mesg : str\n        Message to display.\n    device : object\n        Device to write message. If None, defaults to ``sys.stdout`` which is\n        very similar to ``print``. `device` needs to have ``write()`` and\n        ``flush()`` methods.\n    linefeed : bool, optional\n        Option whether to print a line feed or not. Defaults to True.\n\n    Raises\n    ------\n    AttributeError\n        If `device` does not have a ``write()`` or ``flush()`` method.\n\n    Examples\n    --------\n    Besides ``sys.stdout``, a file-like object can also be used as it has\n    both required methods:\n\n    >>> from StringIO import StringIO\n    >>> buf = StringIO()\n    >>> np.disp('\"Display\" in a file', device=buf)\n    >>> buf.getvalue()\n    '\"Display\" in a file\n'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_141disp = {"disp", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_141disp, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_140disp};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_141disp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_mesg = 0;
  CYTHON_UNUSED PyObject *__pyx_v_device = 0;
  CYTHON_UNUSED PyObject *__pyx_v_linefeed = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("disp (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_mesg,&__pyx_n_s_device,&__pyx_n_s_linefeed,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mesg)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_device);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_linefeed);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "disp") < 0)) __PYX_ERR(0, 3453, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_mesg = values[0];
    __pyx_v_device = values[1];
    __pyx_v_linefeed = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("disp", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3453, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.disp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_140disp(__pyx_self, __pyx_v_mesg, __pyx_v_device, __pyx_v_linefeed);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_140disp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_mesg, CYTHON_UNUSED PyObject *__pyx_v_device, CYTHON_UNUSED PyObject *__pyx_v_linefeed) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("disp", 0);

  /* "ga4py/gain/notimplemented.pyx":3484
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3484, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3453
 * 
 * 
 * def disp(mesg, device=None, linefeed=True):             # <<<<<<<<<<<<<<
 *     """Display a message on a device.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.disp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3487
 * 
 * 
 * def dsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split array into multiple sub-arrays along the 3rd axis (depth).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_143dsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_142dsplit[] = "Split array into multiple sub-arrays along the 3rd axis (depth).\n\n    Please refer to the `split` documentation.  `dsplit` is equivalent\n    to `split` with ``axis=2``, the array is always split along the third\n    axis provided the array dimension is greater than or equal to 3.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(2, 2, 4)\n    >>> x\n    array([[[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.]],\n           [[  8.,   9.,  10.,  11.],\n            [ 12.,  13.,  14.,  15.]]])\n    >>> np.dsplit(x, 2)\n    [array([[[  0.,   1.],\n            [  4.,   5.]],\n           [[  8.,   9.],\n            [ 12.,  13.]]]),\n     array([[[  2.,   3.],\n            [  6.,   7.]],\n           [[ 10.,  11.],\n            [ 14.,  15.]]])]\n    >>> np.dsplit(x, np.array([3, 6]))\n    [array([[[  0.,   1.,   2.],\n            [  4.,   5.,   6.]],\n           [[  8.,   9.,  10.],\n            [ 12.,  13.,  14.]]]),\n     array([[[  3.],\n            [  7.]],\n           [[ 11.],\n            [ 15.]]]),\n     array([], dtype=float64)]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_143dsplit = {"dsplit", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_143dsplit, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_142dsplit};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_143dsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dsplit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ary,&__pyx_n_s_indices_or_sections,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("dsplit", 1, 2, 2, 1); __PYX_ERR(0, 3487, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "dsplit") < 0)) __PYX_ERR(0, 3487, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("dsplit", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3487, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.dsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_142dsplit(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_142dsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dsplit", 0);

  /* "ga4py/gain/notimplemented.pyx":3527
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3527, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3487
 * 
 * 
 * def dsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split array into multiple sub-arrays along the 3rd axis (depth).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.dsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3530
 * 
 * 
 * def dstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence depth wise (along third axis).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_145dstack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_144dstack[] = "Stack arrays in sequence depth wise (along third axis).\n\n    Takes a sequence of arrays and stack them along the third axis\n    to make a single array. Rebuilds arrays divided by `dsplit`.\n    This is a simple way to stack 2D arrays (images) into a single\n    3D array for processing.\n\n    Parameters\n    ----------\n    tup : sequence of arrays\n        Arrays to stack. All of them must have the same shape along all\n        but the third axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack along first axis.\n    hstack : Stack along second axis.\n    concatenate : Join arrays.\n    dsplit : Split array along third axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=2)``.\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.dstack((a,b))\n    array([[[1, 2],\n            [2, 3],\n            [3, 4]]])\n\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.dstack((a,b))\n    array([[[1, 2]],\n           [[2, 3]],\n           [[3, 4]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_145dstack = {"dstack", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_145dstack, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_144dstack};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_145dstack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dstack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_144dstack(__pyx_self, ((PyObject *)__pyx_v_tup));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_144dstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dstack", 0);

  /* "ga4py/gain/notimplemented.pyx":3577
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3577, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3530
 * 
 * 
 * def dstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence depth wise (along third axis).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.dstack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3580
 * 
 * 
 * def ediff1d(ary, to_end=None, to_begin=None):             # <<<<<<<<<<<<<<
 *     """The differences between consecutive elements of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_147ediff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_146ediff1d[] = "The differences between consecutive elements of an array.\n\n    Parameters\n    ----------\n    ary : array_like\n        If necessary, will be flattened before the differences are taken.\n    to_end : array_like, optional\n        Number(s) to append at the end of the returned differences.\n    to_begin : array_like, optional\n        Number(s) to prepend at the beginning of the returned differences.\n\n    Returns\n    -------\n    ed : ndarray\n        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.\n\n    See Also\n    --------\n    diff, gradient\n\n    Notes\n    -----\n    When applied to masked arrays, this function drops the mask information\n    if the `to_begin` and/or `to_end` parameters are used.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 0])\n    >>> np.ediff1d(x)\n    array([ 1,  2,  3, -7])\n\n    >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\n    array([-99,   1,   2,   3,  -7,  88,  99])\n\n    The returned array is always 1D.\n\n    >>> y = [[1, 2, 4], [1, 6, 24]]\n    >>> np.ediff1d(y)\n    array([ 1,  2, -3,  5, 18])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_147ediff1d = {"ediff1d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_147ediff1d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_146ediff1d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_147ediff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_to_end = 0;
  CYTHON_UNUSED PyObject *__pyx_v_to_begin = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ediff1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ary,&__pyx_n_s_to_end,&__pyx_n_s_to_begin,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_to_end);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_to_begin);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ediff1d") < 0)) __PYX_ERR(0, 3580, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ary = values[0];
    __pyx_v_to_end = values[1];
    __pyx_v_to_begin = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ediff1d", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3580, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ediff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_146ediff1d(__pyx_self, __pyx_v_ary, __pyx_v_to_end, __pyx_v_to_begin);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_146ediff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_to_end, CYTHON_UNUSED PyObject *__pyx_v_to_begin) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ediff1d", 0);

  /* "ga4py/gain/notimplemented.pyx":3622
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3622, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3580
 * 
 * 
 * def ediff1d(ary, to_end=None, to_begin=None):             # <<<<<<<<<<<<<<
 *     """The differences between consecutive elements of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ediff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3625
 * 
 * 
 * def einsum():             # <<<<<<<<<<<<<<
 *     """einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_149einsum(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_148einsum[] = "einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')\n\n    Evaluates the Einstein summation convention on the operands.\n\n    Using the Einstein summation convention, many common multi-dimensional\n    array operations can be represented in a simple fashion.  This function\n    provides a way compute such summations. The best way to understand this\n    function is to try the examples below, which show how many common NumPy\n    functions can be implemented as calls to `einsum`.\n\n    Parameters\n    ----------\n    subscripts : str\n        Specifies the subscripts for summation.\n    operands : list of array_like\n        These are the arrays for the operation.\n    out : ndarray, optional\n        If provided, the calculation is done into this array.\n    dtype : data-type, optional\n        If provided, forces the calculation to use the data type specified.\n        Note that you may have to also give a more liberal `casting`\n        parameter to allow the conversions.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Controls the memory layout of the output. 'C' means it should\n        be C contiguous. 'F' means it should be Fortran contiguous,\n        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.\n        'K' means it should be as close to the layout as the inputs as\n        is possible, including arbitrarily permuted axes.\n        Default is 'K'.\n    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n        Controls what kind of data casting may occur.  Setting this to\n        'unsafe' is not recommended, as it can adversely affect accumulations.\n\n          * 'no' means the data types should not be cast at all.\n          * 'equiv' means only byte-order changes are allowed.\n          * 'safe' means only casts which can preserve values are allowed.\n          * 'same_kind' means only safe casts or casts within a kind,\n            like float64 to float32, are allowed.\n      ""    * 'unsafe' means any data conversions may be done.\n\n    Returns\n    -------\n    output : ndarray\n        The calculation based on the Einstein summation convention.\n\n    See Also\n    --------\n    dot, inner, outer, tensordot\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The subscripts string is a comma-separated list of subscript labels,\n    where each label refers to a dimension of the corresponding operand.\n    Repeated subscripts labels in one operand take the diagonal.  For example,\n    ``np.einsum('ii', a)`` is equivalent to ``np.trace(a)``.\n\n    Whenever a label is repeated, it is summed, so ``np.einsum('i,i', a, b)``\n    is equivalent to ``np.inner(a,b)``.  If a label appears only once,\n    it is not summed, so ``np.einsum('i', a)`` produces a view of ``a``\n    with no changes.\n\n    The order of labels in the output is by default alphabetical.  This\n    means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while\n    ``np.einsum('ji', a)`` takes its transpose.\n\n    The output can be controlled by specifying output subscript labels\n    as well.  This specifies the label order, and allows summing to\n    be disallowed or forced when desired.  The call ``np.einsum('i->', a)``\n    is like ``np.sum(a, axis=-1)``, and ``np.einsum('ii->i', a)``\n    is like ``np.diag(a)``.  The difference is that `einsum` does not\n    allow broadcasting by default.\n\n    To enable and control broadcasting, use an ellipsis.  Default\n    NumPy-style broadcasting is done by adding an ellipsis\n    to the left of each term, like ``np.einsum('...ii->...i', a)``.\n    To take the trace along the first and last axes,\n    you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix\n    product with the left-most indices instead of rightmost, you can do\n    ``np.einsum('ij...,jk...->ik...', a, b)``.\n\n    When there is only one operand, no axes are summed, and no output\n    parameter is provided, a view into the operand is returned i""nstead\n    of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``\n    produces a view.\n\n    An alternative way to provide the subscripts and operands is as\n    ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``. The examples\n    below have corresponding `einsum` calls with the two parameter methods.\n\n    Examples\n    --------\n    >>> a = np.arange(25).reshape(5,5)\n    >>> b = np.arange(5)\n    >>> c = np.arange(6).reshape(2,3)\n\n    >>> np.einsum('ii', a)\n    60\n    >>> np.einsum(a, [0,0])\n    60\n    >>> np.trace(a)\n    60\n\n    >>> np.einsum('ii->i', a)\n    array([ 0,  6, 12, 18, 24])\n    >>> np.einsum(a, [0,0], [0])\n    array([ 0,  6, 12, 18, 24])\n    >>> np.diag(a)\n    array([ 0,  6, 12, 18, 24])\n\n    >>> np.einsum('ij,j', a, b)\n    array([ 30,  80, 130, 180, 230])\n    >>> np.einsum(a, [0,1], b, [1])\n    array([ 30,  80, 130, 180, 230])\n    >>> np.dot(a, b)\n    array([ 30,  80, 130, 180, 230])\n\n    >>> np.einsum('ji', c)\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> np.einsum(c, [1,0])\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n    >>> c.T\n    array([[0, 3],\n           [1, 4],\n           [2, 5]])\n\n    >>> np.einsum('..., ...', 3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.einsum(3, [Ellipsis], c, [Ellipsis])\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n    >>> np.multiply(3, c)\n    array([[ 0,  3,  6],\n           [ 9, 12, 15]])\n\n    >>> np.einsum('i,i', b, b)\n    30\n    >>> np.einsum(b, [0], b, [0])\n    30\n    >>> np.inner(b,b)\n    30\n\n    >>> np.einsum('i,j', np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.einsum(np.arange(2)+1, [0], b, [1])\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n    >>> np.outer(np.arange(2)+1, b)\n    array([[0, 1, 2, 3, 4],\n           [0, 2, 4, 6, 8]])\n\n    >>> np.einsum('i...->...', a)\n    array([50, 55, 60, 65, 70])\n    >>> n""p.einsum(a, [0,Ellipsis], [Ellipsis])\n    array([50, 55, 60, 65, 70])\n    >>> np.sum(a, axis=0)\n    array([50, 55, 60, 65, 70])\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> np.einsum('ijk,jil->kl', a, b)\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> np.tensordot(a,b, axes=([1,0],[0,1]))\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_149einsum = {"einsum", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_149einsum, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_148einsum};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_149einsum(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("einsum (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_148einsum(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_148einsum(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("einsum", 0);

  /* "ga4py/gain/notimplemented.pyx":3814
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3814, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3625
 * 
 * 
 * def einsum():             # <<<<<<<<<<<<<<
 *     """einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.einsum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3817
 * 
 * 
 * def expand_dims(a, axis):             # <<<<<<<<<<<<<<
 *     """Expand the shape of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_151expand_dims(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_150expand_dims[] = "Expand the shape of an array.\n\n    Insert a new axis, corresponding to a given position in the array shape.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis : int\n        Position (amongst axes) where new axis is to be inserted.\n\n    Returns\n    -------\n    res : ndarray\n        Output array. The number of dimensions is one greater than that of\n        the input array.\n\n    See Also\n    --------\n    doc.indexing, atleast_1d, atleast_2d, atleast_3d\n\n    Examples\n    --------\n    >>> x = np.array([1,2])\n    >>> x.shape\n    (2,)\n\n    The following is equivalent to ``x[np.newaxis,:]`` or ``x[np.newaxis]``:\n\n    >>> y = np.expand_dims(x, axis=0)\n    >>> y\n    array([[1, 2]])\n    >>> y.shape\n    (1, 2)\n\n    >>> y = np.expand_dims(x, axis=1)  # Equivalent to x[:,newaxis]\n    >>> y\n    array([[1],\n           [2]])\n    >>> y.shape\n    (2, 1)\n\n    Note that some examples may use ``None`` instead of ``np.newaxis``.  These\n    are the same objects:\n\n    >>> np.newaxis is None\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_151expand_dims = {"expand_dims", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_151expand_dims, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_150expand_dims};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_151expand_dims(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("expand_dims (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("expand_dims", 1, 2, 2, 1); __PYX_ERR(0, 3817, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "expand_dims") < 0)) __PYX_ERR(0, 3817, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("expand_dims", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3817, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.expand_dims", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_150expand_dims(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_150expand_dims(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("expand_dims", 0);

  /* "ga4py/gain/notimplemented.pyx":3867
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3867, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3817
 * 
 * 
 * def expand_dims(a, axis):             # <<<<<<<<<<<<<<
 *     """Expand the shape of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.expand_dims", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3870
 * 
 * 
 * def extract(condition, arr):             # <<<<<<<<<<<<<<
 *     """Return the elements of an array that satisfy some condition.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_153extract(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_152extract[] = "Return the elements of an array that satisfy some condition.\n\n    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If\n    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.\n\n    Parameters\n    ----------\n    condition : array_like\n        An array whose nonzero or True entries indicate the elements of `arr`\n        to extract.\n    arr : array_like\n        Input array of the same size as `condition`.\n\n    See Also\n    --------\n    take, put, putmask, compress\n\n    Examples\n    --------\n    >>> arr = np.arange(12).reshape((3, 4))\n    >>> arr\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n    >>> condition = np.mod(arr, 3)==0\n    >>> condition\n    array([[ True, False, False,  True],\n           [False, False,  True, False],\n           [False,  True, False, False]], dtype=bool)\n    >>> np.extract(condition, arr)\n    array([0, 3, 6, 9])\n\n\n    If `condition` is boolean:\n\n    >>> arr[condition]\n    array([0, 3, 6, 9])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_153extract = {"extract", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_153extract, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_152extract};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_153extract(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_condition = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("extract (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_condition,&__pyx_n_s_arr,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_condition)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("extract", 1, 2, 2, 1); __PYX_ERR(0, 3870, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "extract") < 0)) __PYX_ERR(0, 3870, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_condition = values[0];
    __pyx_v_arr = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("extract", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3870, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.extract", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_152extract(__pyx_self, __pyx_v_condition, __pyx_v_arr);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_152extract(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condition, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("extract", 0);

  /* "ga4py/gain/notimplemented.pyx":3910
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3910, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3870
 * 
 * 
 * def extract(condition, arr):             # <<<<<<<<<<<<<<
 *     """Return the elements of an array that satisfy some condition.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.extract", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3913
 * 
 * 
 * def _fastCopyAndTranspose(a):             # <<<<<<<<<<<<<<
 *     """_fastCopyAndTranspose(a)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose[] = "_fastCopyAndTranspose(a)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose = {"_fastCopyAndTranspose", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_fastCopyAndTranspose (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_154_fastCopyAndTranspose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_fastCopyAndTranspose", 0);

  /* "ga4py/gain/notimplemented.pyx":3918
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3918, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3913
 * 
 * 
 * def _fastCopyAndTranspose(a):             # <<<<<<<<<<<<<<
 *     """_fastCopyAndTranspose(a)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented._fastCopyAndTranspose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3921
 * 
 * 
 * def fill_diagonal(a, val):             # <<<<<<<<<<<<<<
 *     """Fill the main diagonal of the given array of any dimensionality.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_157fill_diagonal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_156fill_diagonal[] = "Fill the main diagonal of the given array of any dimensionality.\n\n    For an array `a` with ``a.ndim > 2``, the diagonal is the list of\n    locations with indices ``a[i, i, ..., i]`` all identical. This function\n    modifies the input array in-place, it does not return a value.\n\n    Parameters\n    ----------\n    a : array, at least 2-D.\n      Array whose diagonal is to be filled, it gets modified in-place.\n\n    val : scalar\n      Value to be written on the diagonal, its type must be compatible with\n      that of the array a.\n\n    See also\n    --------\n    diag_indices, diag_indices_from\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    This functionality can be obtained via `diag_indices`, but internally\n    this version uses a much faster implementation that never constructs the\n    indices and uses simple slicing.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 3), int)\n    >>> np.fill_diagonal(a, 5)\n    >>> a\n    array([[5, 0, 0],\n           [0, 5, 0],\n           [0, 0, 5]])\n\n    The same function can operate on a 4-D array:\n\n    >>> a = np.zeros((3, 3, 3, 3), int)\n    >>> np.fill_diagonal(a, 4)\n\n    We only show a few blocks for clarity:\n\n    >>> a[0, 0]\n    array([[4, 0, 0],\n           [0, 0, 0],\n           [0, 0, 0]])\n    >>> a[1, 1]\n    array([[0, 0, 0],\n           [0, 4, 0],\n           [0, 0, 0]])\n    >>> a[2, 2]\n    array([[0, 0, 0],\n           [0, 0, 0],\n           [0, 0, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_157fill_diagonal = {"fill_diagonal", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_157fill_diagonal, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_156fill_diagonal};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_157fill_diagonal(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_val = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fill_diagonal (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_val,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_val)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fill_diagonal", 1, 2, 2, 1); __PYX_ERR(0, 3921, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fill_diagonal") < 0)) __PYX_ERR(0, 3921, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_val = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fill_diagonal", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3921, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fill_diagonal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_156fill_diagonal(__pyx_self, __pyx_v_a, __pyx_v_val);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_156fill_diagonal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fill_diagonal", 0);

  /* "ga4py/gain/notimplemented.pyx":3979
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 3979, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3921
 * 
 * 
 * def fill_diagonal(a, val):             # <<<<<<<<<<<<<<
 *     """Fill the main diagonal of the given array of any dimensionality.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fill_diagonal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":3982
 * 
 * 
 * def find_common_type(array_types, scalar_types):             # <<<<<<<<<<<<<<
 *     """Determine common type following standard coercion rules.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_159find_common_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_158find_common_type[] = "Determine common type following standard coercion rules.\n\n    Parameters\n    ----------\n    array_types : sequence\n        A list of dtypes or dtype convertible objects representing arrays.\n    scalar_types : sequence\n        A list of dtypes or dtype convertible objects representing scalars.\n\n    Returns\n    -------\n    datatype : dtype\n        The common data type, which is the maximum of `array_types` ignoring\n        `scalar_types`, unless the maximum of `scalar_types` is of a\n        different kind (`dtype.kind`). If the kind is not understood, then\n        None is returned.\n\n    See Also\n    --------\n    dtype, common_type, can_cast, mintypecode\n\n    Examples\n    --------\n    >>> np.find_common_type([], [np.int64, np.float32, np.complex])\n    dtype('complex128')\n    >>> np.find_common_type([np.int64, np.float32], [])\n    dtype('float64')\n\n    The standard casting rules ensure that a scalar cannot up-cast an\n    array unless the scalar is of a fundamentally different kind of data\n    (i.e. under a different hierarchy in the data type hierarchy) then\n    the array:\n\n    >>> np.find_common_type([np.float32], [np.int64, np.float64])\n    dtype('float32')\n\n    Complex is of a different type, so it up-casts the float in the\n    `array_types` argument:\n\n    >>> np.find_common_type([np.float32], [np.complex])\n    dtype('complex128')\n\n    Type specifier strings are convertible to dtypes and can therefore\n    be used instead of dtypes:\n\n    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\n    dtype('complex128')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_159find_common_type = {"find_common_type", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_159find_common_type, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_158find_common_type};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_159find_common_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_array_types = 0;
  CYTHON_UNUSED PyObject *__pyx_v_scalar_types = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("find_common_type (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_array_types,&__pyx_n_s_scalar_types,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_array_types)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_scalar_types)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("find_common_type", 1, 2, 2, 1); __PYX_ERR(0, 3982, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "find_common_type") < 0)) __PYX_ERR(0, 3982, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_array_types = values[0];
    __pyx_v_scalar_types = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("find_common_type", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3982, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.find_common_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_158find_common_type(__pyx_self, __pyx_v_array_types, __pyx_v_scalar_types);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_158find_common_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_array_types, CYTHON_UNUSED PyObject *__pyx_v_scalar_types) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("find_common_type", 0);

  /* "ga4py/gain/notimplemented.pyx":4032
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4032, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3982
 * 
 * 
 * def find_common_type(array_types, scalar_types):             # <<<<<<<<<<<<<<
 *     """Determine common type following standard coercion rules.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.find_common_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4035
 * 
 * 
 * def fix(x, y=None):             # <<<<<<<<<<<<<<
 *     """Round to nearest integer towards zero.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_161fix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_160fix[] = "Round to nearest integer towards zero.\n\n    Round an array of floats element-wise to nearest integer towards zero.\n    The rounded values are returned as floats.\n\n    Parameters\n    ----------\n    x : array_like\n        An array of floats to be rounded\n    y : ndarray, optional\n        Output array\n\n    Returns\n    -------\n    out : ndarray of floats\n        The array of rounded numbers\n\n    See Also\n    --------\n    trunc, floor, ceil\n    around : Round to given number of decimals\n\n    Examples\n    --------\n    >>> np.fix(3.14)\n    3.0\n    >>> np.fix(3)\n    3.0\n    >>> np.fix([2.1, 2.9, -2.1, -2.9])\n    array([ 2.,  2., -2., -2.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_161fix = {"fix", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_161fix, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_160fix};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_161fix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fix (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fix") < 0)) __PYX_ERR(0, 4035, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fix", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4035, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_160fix(__pyx_self, __pyx_v_x, __pyx_v_y);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_160fix(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fix", 0);

  /* "ga4py/gain/notimplemented.pyx":4068
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4068, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4035
 * 
 * 
 * def fix(x, y=None):             # <<<<<<<<<<<<<<
 *     """Round to nearest integer towards zero.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4071
 * 
 * 
 * def flatnonzero(a):             # <<<<<<<<<<<<<<
 *     """Return indices that are non-zero in the flattened version of a.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_163flatnonzero(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_162flatnonzero[] = "Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to a.ravel().nonzero()[0].\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of `a.ravel()`\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_163flatnonzero = {"flatnonzero", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_163flatnonzero, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_162flatnonzero};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_163flatnonzero(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flatnonzero (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_162flatnonzero(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_162flatnonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flatnonzero", 0);

  /* "ga4py/gain/notimplemented.pyx":4107
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4107, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4071
 * 
 * 
 * def flatnonzero(a):             # <<<<<<<<<<<<<<
 *     """Return indices that are non-zero in the flattened version of a.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.flatnonzero", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4110
 * 
 * 
 * def fliplr(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the left/right direction.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_165fliplr(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_164fliplr[] = "Flip array in the left/right direction.\n\n    Flip the entries in each row in the left/right direction.\n    Columns are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    f : ndarray\n        A view of `m` with the columns reversed.  Since a view\n        is returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    flipud : Flip array in the up/down direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to A[:,::-1]. Does not require the array to be\n    two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.,2.,3.])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.fliplr(A)\n    array([[ 0.,  0.,  1.],\n           [ 0.,  2.,  0.],\n           [ 3.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.fliplr(A)==A[:,::-1,...])\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_165fliplr = {"fliplr", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_165fliplr, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_164fliplr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_165fliplr(PyObject *__pyx_self, PyObject *__pyx_v_m) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fliplr (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_164fliplr(__pyx_self, ((PyObject *)__pyx_v_m));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_164fliplr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fliplr", 0);

  /* "ga4py/gain/notimplemented.pyx":4154
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4154, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4110
 * 
 * 
 * def fliplr(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the left/right direction.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fliplr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4157
 * 
 * 
 * def flipud(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the up/down direction.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_167flipud(PyObject *__pyx_self, PyObject *__pyx_v_m); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_166flipud[] = "Flip array in the up/down direction.\n\n    Flip the entries in each column in the up/down direction.\n    Rows are preserved, but appear in a different order than before.\n\n    Parameters\n    ----------\n    m : array_like\n        Input array.\n\n    Returns\n    -------\n    out : array_like\n        A view of `m` with the rows reversed.  Since a view is\n        returned, this operation is :math:`\\mathcal O(1)`.\n\n    See Also\n    --------\n    fliplr : Flip array in the left/right direction.\n    rot90 : Rotate array counterclockwise.\n\n    Notes\n    -----\n    Equivalent to ``A[::-1,...]``.\n    Does not require the array to be two-dimensional.\n\n    Examples\n    --------\n    >>> A = np.diag([1.0, 2, 3])\n    >>> A\n    array([[ 1.,  0.,  0.],\n           [ 0.,  2.,  0.],\n           [ 0.,  0.,  3.]])\n    >>> np.flipud(A)\n    array([[ 0.,  0.,  3.],\n           [ 0.,  2.,  0.],\n           [ 1.,  0.,  0.]])\n\n    >>> A = np.random.randn(2,3,5)\n    >>> np.all(np.flipud(A)==A[::-1,...])\n    True\n\n    >>> np.flipud([1,2])\n    array([2, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_167flipud = {"flipud", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_167flipud, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_166flipud};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_167flipud(PyObject *__pyx_self, PyObject *__pyx_v_m) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flipud (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_166flipud(__pyx_self, ((PyObject *)__pyx_v_m));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_166flipud(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("flipud", 0);

  /* "ga4py/gain/notimplemented.pyx":4204
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4204, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4157
 * 
 * 
 * def flipud(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the up/down direction.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.flipud", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4207
 * 
 * 
 * def frombuffer(buffer, dtype=float, count=-1, offset=0):             # <<<<<<<<<<<<<<
 *     """frombuffer(buffer, dtype=float, count=-1, offset=0)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_169frombuffer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_168frombuffer[] = "frombuffer(buffer, dtype=float, count=-1, offset=0)\n\n    Interpret a buffer as a 1-dimensional array.\n\n    Parameters\n    ----------\n    buffer : buffer_like\n        An object that exposes the buffer interface.\n    dtype : data-type, optional\n        Data-type of the returned array; default: float.\n    count : int, optional\n        Number of items to read. ``-1`` means all data in the buffer.\n    offset : int, optional\n        Start reading the buffer from this offset; default: 0.\n\n    Notes\n    -----\n    If the buffer has data that is not in machine byte-order, this should\n    be specified as part of the data-type, e.g.::\n\n      >>> dt = np.dtype(int)\n      >>> dt = dt.newbyteorder('>')\n      >>> np.frombuffer(buf, dtype=dt)\n\n    The data of the resulting array will not be byteswapped, but will be\n    interpreted correctly.\n\n    Examples\n    --------\n    >>> s = 'hello world'\n    >>> np.frombuffer(s, dtype='S1', count=5, offset=6)\n    array(['w', 'o', 'r', 'l', 'd'],\n          dtype='|S1')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_169frombuffer = {"frombuffer", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_169frombuffer, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_168frombuffer};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_169frombuffer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_buffer = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  CYTHON_UNUSED PyObject *__pyx_v_offset = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("frombuffer (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_buffer,&__pyx_n_s_dtype,&__pyx_n_s_count,&__pyx_n_s_offset,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = __pyx_k__5;
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_buffer)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_count);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_offset);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "frombuffer") < 0)) __PYX_ERR(0, 4207, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_buffer = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
    __pyx_v_offset = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("frombuffer", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4207, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frombuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_168frombuffer(__pyx_self, __pyx_v_buffer, __pyx_v_dtype, __pyx_v_count, __pyx_v_offset);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_168frombuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_buffer, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_offset) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("frombuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":4244
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4244, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4207
 * 
 * 
 * def frombuffer(buffer, dtype=float, count=-1, offset=0):             # <<<<<<<<<<<<<<
 *     """frombuffer(buffer, dtype=float, count=-1, offset=0)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frombuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4247
 * 
 * 
 * def fromfile(file, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromfile(file, dtype=float, count=-1, sep='')
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_171fromfile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_170fromfile[] = "fromfile(file, dtype=float, count=-1, sep='')\n\n    Construct an array from data in a text or binary file.\n\n    A highly efficient way of reading binary data with a known data-type,\n    as well as parsing simply formatted text files.  Data written using the\n    `tofile` method can be read using this function.\n\n    Parameters\n    ----------\n    file : file or str\n        Open file object or filename.\n    dtype : data-type\n        Data type of the returned array.\n        For binary files, it is used to determine the size and byte-order\n        of the items in the file.\n    count : int\n        Number of items to read. ``-1`` means all items (i.e., the complete\n        file).\n    sep : str\n        Separator between items if file is a text file.\n        Empty (\"\") separator means the file should be treated as binary.\n        Spaces (\" \") in the separator match zero or more whitespace characters.\n        A separator consisting only of spaces must match at least one\n        whitespace.\n\n    See also\n    --------\n    load, save\n    ndarray.tofile\n    loadtxt : More flexible way of loading data from a text file.\n\n    Notes\n    -----\n    Do not rely on the combination of `tofile` and `fromfile` for\n    data storage, as the binary files generated are are not platform\n    independent.  In particular, no byte-order or data-type information is\n    saved.  Data can be stored in the platform independent ``.npy`` format\n    using `save` and `load` instead.\n\n    Examples\n    --------\n    Construct an ndarray:\n\n    >>> dt = np.dtype([('time', [('min', int), ('sec', int)]),\n    ...                ('temp', float)])\n    >>> x = np.zeros((1,), dtype=dt)\n    >>> x['time']['min'] = 10; x['temp'] = 98.25\n    >>> x\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    Save the raw data to disk:\n\n    >>> import os\n    >>> fname = os.tmpnam()\n    >>> x.tofile(fname)\n\n    Read"" the raw data from disk:\n\n    >>> np.fromfile(fname, dtype=dt)\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n\n    The recommended way to store and load data:\n\n    >>> np.save(fname, x)\n    >>> np.load(fname + '.npy')\n    array([((10, 0), 98.25)],\n          dtype=[('time', [('min', '<i4'), ('sec', '<i4')]), ('temp', '<f8')])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_171fromfile = {"fromfile", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_171fromfile, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_170fromfile};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_171fromfile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  CYTHON_UNUSED PyObject *__pyx_v_sep = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromfile (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_file,&__pyx_n_s_dtype,&__pyx_n_s_count,&__pyx_n_s_sep,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = __pyx_k__6;
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_kp_s__2);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_count);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sep);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromfile") < 0)) __PYX_ERR(0, 4247, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_file = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
    __pyx_v_sep = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromfile", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4247, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromfile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_170fromfile(__pyx_self, __pyx_v_file, __pyx_v_dtype, __pyx_v_count, __pyx_v_sep);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_170fromfile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromfile", 0);

  /* "ga4py/gain/notimplemented.pyx":4321
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4321, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4247
 * 
 * 
 * def fromfile(file, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromfile(file, dtype=float, count=-1, sep='')
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromfile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4324
 * 
 * 
 * def fromiter(iterable, dtype, count=-1):             # <<<<<<<<<<<<<<
 *     """fromiter(iterable, dtype, count=-1)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_173fromiter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_172fromiter[] = "fromiter(iterable, dtype, count=-1)\n\n    Create a new 1-dimensional array from an iterable object.\n\n    Parameters\n    ----------\n    iterable : iterable object\n        An iterable object providing data for the array.\n    dtype : data-type\n        The data-type of the returned array.\n    count : int, optional\n        The number of items to read from *iterable*.  The default is -1,\n        which means all data is read.\n\n    Returns\n    -------\n    out : ndarray\n        The output array.\n\n    Notes\n    -----\n    Specify `count` to improve performance.  It allows ``fromiter`` to\n    pre-allocate the output array, instead of resizing it on demand.\n\n    Examples\n    --------\n    >>> iterable = (x*x for x in range(5))\n    >>> np.fromiter(iterable, np.float)\n    array([  0.,   1.,   4.,   9.,  16.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_173fromiter = {"fromiter", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_173fromiter, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_172fromiter};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_173fromiter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_iterable = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromiter (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_iterable,&__pyx_n_s_dtype,&__pyx_n_s_count,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_iterable)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fromiter", 0, 2, 3, 1); __PYX_ERR(0, 4324, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_count);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromiter") < 0)) __PYX_ERR(0, 4324, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_iterable = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromiter", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4324, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromiter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_172fromiter(__pyx_self, __pyx_v_iterable, __pyx_v_dtype, __pyx_v_count);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_172fromiter(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_iterable, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromiter", 0);

  /* "ga4py/gain/notimplemented.pyx":4357
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4357, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4324
 * 
 * 
 * def fromiter(iterable, dtype, count=-1):             # <<<<<<<<<<<<<<
 *     """fromiter(iterable, dtype, count=-1)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromiter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4360
 * 
 * 
 * def frompyfunc(func, nin, nout):             # <<<<<<<<<<<<<<
 *     """frompyfunc(func, nin, nout)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_175frompyfunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_174frompyfunc[] = "frompyfunc(func, nin, nout)\n\n    Takes an arbitrary Python function and returns a Numpy ufunc.\n\n    Can be used, for example, to add broadcasting to a built-in Python\n    function (see Examples section).\n\n    Parameters\n    ----------\n    func : Python function object\n        An arbitrary Python function.\n    nin : int\n        The number of input arguments.\n    nout : int\n        The number of objects returned by `func`.\n\n    Returns\n    -------\n    out : ufunc\n        Returns a Numpy universal function (``ufunc``) object.\n\n    Notes\n    -----\n    The returned ufunc always returns PyObject arrays.\n\n    Examples\n    --------\n    Use frompyfunc to add broadcasting to the Python function ``oct``:\n\n    >>> oct_array = np.frompyfunc(oct, 1, 1)\n    >>> oct_array(np.array((10, 30, 100)))\n    array([012, 036, 0144], dtype=object)\n    >>> np.array((oct(10), oct(30), oct(100))) # for comparison\n    array(['012', '036', '0144'],\n          dtype='|S4')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_175frompyfunc = {"frompyfunc", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_175frompyfunc, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_174frompyfunc};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_175frompyfunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_func = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nin = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nout = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("frompyfunc (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func,&__pyx_n_s_nin,&__pyx_n_s_nout,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nin)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("frompyfunc", 1, 3, 3, 1); __PYX_ERR(0, 4360, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nout)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("frompyfunc", 1, 3, 3, 2); __PYX_ERR(0, 4360, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "frompyfunc") < 0)) __PYX_ERR(0, 4360, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_func = values[0];
    __pyx_v_nin = values[1];
    __pyx_v_nout = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("frompyfunc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4360, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frompyfunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_174frompyfunc(__pyx_self, __pyx_v_func, __pyx_v_nin, __pyx_v_nout);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_174frompyfunc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func, CYTHON_UNUSED PyObject *__pyx_v_nin, CYTHON_UNUSED PyObject *__pyx_v_nout) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("frompyfunc", 0);

  /* "ga4py/gain/notimplemented.pyx":4399
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4399, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4360
 * 
 * 
 * def frompyfunc(func, nin, nout):             # <<<<<<<<<<<<<<
 *     """frompyfunc(func, nin, nout)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.frompyfunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4402
 * 
 * 
 * def fromregex(file, regexp, dtype):             # <<<<<<<<<<<<<<
 *     """Construct an array from a text file, using regular expression parsing.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_177fromregex(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_176fromregex[] = "Construct an array from a text file, using regular expression parsing.\n\n    The returned array is always a structured array, and is constructed from\n    all matches of the regular expression in the file. Groups in the regular\n    expression are converted to fields of the structured array.\n\n    Parameters\n    ----------\n    file : str or file\n        File name or file object to read.\n    regexp : str or regexp\n        Regular expression used to parse the file.\n        Groups in the regular expression correspond to fields in the dtype.\n    dtype : dtype or list of dtypes\n        Dtype for the structured array.\n\n    Returns\n    -------\n    output : ndarray\n        The output array, containing the part of the content of `file` that\n        was matched by `regexp`. `output` is always a structured array.\n\n    Raises\n    ------\n    TypeError\n        When `dtype` is not a valid dtype for a structured array.\n\n    See Also\n    --------\n    fromstring, loadtxt\n\n    Notes\n    -----\n    Dtypes for structured arrays can be specified in several forms, but all\n    forms specify at least the data type and field name. For details see\n    `doc.structured_arrays`.\n\n    Examples\n    --------\n    >>> f = open('test.dat', 'w')\n    >>> f.write(\"1312 foo\n1534  bar\n444   qux\")\n    >>> f.close()\n\n    >>> regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n    >>> output = np.fromregex('test.dat', regexp,\n    ...                       [('num', np.int64), ('key', 'S3')])\n    >>> output\n    array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],\n          dtype=[('num', '<i8'), ('key', '|S3')])\n    >>> output['num']\n    array([1312, 1534,  444], dtype=int64)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_177fromregex = {"fromregex", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_177fromregex, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_176fromregex};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_177fromregex(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_regexp = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromregex (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_file,&__pyx_n_s_regexp,&__pyx_n_s_dtype,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_regexp)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fromregex", 1, 3, 3, 1); __PYX_ERR(0, 4402, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fromregex", 1, 3, 3, 2); __PYX_ERR(0, 4402, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromregex") < 0)) __PYX_ERR(0, 4402, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_file = values[0];
    __pyx_v_regexp = values[1];
    __pyx_v_dtype = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromregex", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4402, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromregex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_176fromregex(__pyx_self, __pyx_v_file, __pyx_v_regexp, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_176fromregex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_regexp, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromregex", 0);

  /* "ga4py/gain/notimplemented.pyx":4456
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4456, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4402
 * 
 * 
 * def fromregex(file, regexp, dtype):             # <<<<<<<<<<<<<<
 *     """Construct an array from a text file, using regular expression parsing.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromregex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4459
 * 
 * 
 * def fromstring(string, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromstring(string, dtype=float, count=-1, sep='')
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_179fromstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_178fromstring[] = "fromstring(string, dtype=float, count=-1, sep='')\n\n    A new 1-D array initialized from raw binary or text data in a string.\n\n    Parameters\n    ----------\n    string : str\n        A string containing the data.\n    dtype : data-type, optional\n        The data type of the array; default: float.  For binary input data,\n        the data must be in exactly this format.\n    count : int, optional\n        Read this number of `dtype` elements from the data.  If this is\n        negative (the default), the count will be determined from the\n        length of the data.\n    sep : str, optional\n        If not provided or, equivalently, the empty string, the data will\n        be interpreted as binary data; otherwise, as ASCII text with\n        decimal numbers.  Also in this latter case, this argument is\n        interpreted as the string separating numbers in the data; extra\n        whitespace between elements is also ignored.\n\n    Returns\n    -------\n    arr : ndarray\n        The constructed array.\n\n    Raises\n    ------\n    ValueError\n        If the string is not the correct size to satisfy the requested\n        `dtype` and `count`.\n\n    See Also\n    --------\n    frombuffer, fromfile, fromiter\n\n    Examples\n    --------\n    >>> np.fromstring('\001\002', dtype=np.uint8)\n    array([1, 2], dtype=uint8)\n    >>> np.fromstring('1 2', dtype=int, sep=' ')\n    array([1, 2])\n    >>> np.fromstring('1, 2', dtype=int, sep=',')\n    array([1, 2])\n    >>> np.fromstring('\001\002\003\004\005', dtype=np.uint8, count=3)\n    array([1, 2, 3], dtype=uint8)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_179fromstring = {"fromstring", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_179fromstring, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_178fromstring};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_179fromstring(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_string = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_count = 0;
  CYTHON_UNUSED PyObject *__pyx_v_sep = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromstring (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_string,&__pyx_n_s_dtype,&__pyx_n_s_count,&__pyx_n_s_sep,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = __pyx_k__7;
    values[2] = ((PyObject *)__pyx_int_neg_1);
    values[3] = ((PyObject *)__pyx_kp_s__2);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_string)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_count);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sep);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fromstring") < 0)) __PYX_ERR(0, 4459, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_string = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_count = values[2];
    __pyx_v_sep = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fromstring", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4459, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_178fromstring(__pyx_self, __pyx_v_string, __pyx_v_dtype, __pyx_v_count, __pyx_v_sep);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_178fromstring(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_string, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_count, CYTHON_UNUSED PyObject *__pyx_v_sep) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fromstring", 0);

  /* "ga4py/gain/notimplemented.pyx":4510
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4510, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4459
 * 
 * 
 * def fromstring(string, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromstring(string, dtype=float, count=-1, sep='')
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fromstring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4513
 * 
 * 
 * def fv(rate, nper, pmt, pv, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the future value.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_181fv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_180fv[] = "Compute the future value.\n\n    Given:\n     * a present value, `pv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value at the end of the `nper` periods\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pmt : scalar or array_like of shape(M, )\n        Payment\n    pv : scalar or array_like of shape(M, )\n        Present value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Future values.  If all input is scalar, returns a scalar float.  If\n        any input is array_like, returns future values for each input element.\n        If multiple inputs are array_like, they all must have the same shape.\n\n    Notes\n    -----\n    The future value is computed by solving the equation::\n\n     fv +\n     pv*(1+rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n     fv + pv + pmt * nper == 0\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Example""s\n    --------\n    What is the future value after 10 years of saving $100 now, with\n    an additional monthly savings of $100.  Assume the interest rate is\n    5% (annually) compounded monthly?\n\n    >>> np.fv(0.05/12, 10*12, -100, -100)\n    15692.928894335748\n\n    By convention, the negative sign represents cash flow out (i.e. money not\n    available today).  Thus, saving $100 a month at 5% annual interest leads\n    to $15,692.93 available to spend in 10 years.\n\n    If any input is array_like, returns an array of equal shape.  Let's\n    compare different interest rates from the example above.\n\n    >>> a = np.array((0.05, 0.06, 0.07))/12\n    >>> np.fv(a, 10*12, -100, -100)\n    array([ 15692.92889434,  16569.87435405,  17509.44688102])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_181fv = {"fv", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_181fv, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_180fv};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_181fv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rate,&__pyx_n_s_nper,&__pyx_n_s_pmt,&__pyx_n_s_pv,&__pyx_n_s_when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_n_s_end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, 1); __PYX_ERR(0, 4513, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, 2); __PYX_ERR(0, 4513, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, 3); __PYX_ERR(0, 4513, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fv") < 0)) __PYX_ERR(0, 4513, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_nper = values[1];
    __pyx_v_pmt = values[2];
    __pyx_v_pv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fv", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4513, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_180fv(__pyx_self, __pyx_v_rate, __pyx_v_nper, __pyx_v_pmt, __pyx_v_pv, __pyx_v_when);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_180fv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fv", 0);

  /* "ga4py/gain/notimplemented.pyx":4593
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4593, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4513
 * 
 * 
 * def fv(rate, nper, pmt, pv, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the future value.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.fv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4596
 * 
 * 
 * def genfromtxt(fname, dtype=float, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True):             # <<<<<<<<<<<<<<
 *     """Load data from a text file, with missing values handled as specified.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_183genfromtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_182genfromtxt[] = "Load data from a text file, with missing values handled as specified.\n\n    Each line past the first `skip_header` lines is split at the `delimiter`\n    character, and characters following the `comments` character are discarded.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        `.gz` or `.bz2`, the file is first decompressed. Note that\n        generators must return byte strings in Python 3k.\n    dtype : dtype, optional\n        Data type of the resulting array.\n        If None, the dtypes will be determined by the contents of each\n        column, individually.\n    comments : str, optional\n        The character used to indicate the start of a comment.\n        All the characters occurring on a line after a comment are discarded\n    delimiter : str, int, or sequence, optional\n        The string used to separate values.  By default, any consecutive\n        whitespaces act as delimiter.  An integer or sequence of integers\n        can also be provided as width(s) of each field.\n    skip_header : int, optional\n        The numbers of lines to skip at the beginning of the file.\n    skip_footer : int, optional\n        The numbers of lines to skip at the end of the file\n    converters : variable, optional\n        The set of functions that convert the data of a column to a value.\n        The converters can also be used to provide a default value\n        for missing data: ``converters = {3: lambda s: float(s or 0)}``.\n    missing_values : variable, optional\n        The set of strings corresponding to missing data.\n    filling_values : variable, optional\n        The set of values to be used as default when the data are missing.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.\n    names : {None, True, str, sequence}, optional\n     ""   If `names` is True, the field names are read from the first valid line\n        after the first `skip_header` lines.\n        If `names` is a sequence or a single-string of comma-separated names,\n        the names will be used to define the field names in a structured dtype.\n        If `names` is None, the names of the dtype fields will be used, if any.\n    excludelist : sequence, optional\n        A list of names to exclude. This list is appended to the default list\n        ['return','file','print']. Excluded names are appended an underscore:\n        for example, `file` would become `file_`.\n    deletechars : str, optional\n        A string combining invalid characters that must be deleted from the\n        names.\n    defaultfmt : str, optional\n        A format used to define default field names, such as \"f%i\" or \"f_%02i\".\n    autostrip : bool, optional\n        Whether to automatically strip white spaces from the variables.\n    replace_space : char, optional\n        Character(s) used in replacement of white spaces in the variables names.\n        By default, use a '_'.\n    case_sensitive : {True, False, 'upper', 'lower'}, optional\n        If True, field names are case sensitive.\n        If False or 'upper', field names are converted to upper case.\n        If 'lower', field names are converted to lower case.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``\n    usemask : bool, optional\n        If True, return a masked array.\n        If False, return a regular array.\n    invalid_raise : bool, optional\n        If True, an exception is raised if an inconsistency is detected in the\n        number of columns.\n        If False, a warning is emitted and the offending lines are skipped.\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file. If `usemask` is True, this is a\n        masked array.\n\n    See Als""o\n    --------\n    numpy.loadtxt : equivalent function when no data is missing.\n\n    Notes\n    -----\n    * When spaces are used as delimiters, or when no delimiter has been given\n      as input, there should not be any missing data between two fields.\n    * When the variables are named (either by a flexible dtype or with `names`,\n      there must not be any header in the file (else a ValueError\n      exception is raised).\n    * Individual values are not stripped of spaces by default.\n      When using a custom converter, make sure the function does remove spaces.\n\n    Examples\n    ---------\n    >>> from StringIO import StringIO\n    >>> import numpy as np\n\n    Comma delimited file with mixed dtype\n\n    >>> s = StringIO(\"1,1.3,abcde\")\n    >>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n    ... ('mystring','S5')], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Using dtype = None\n\n    >>> s.seek(0) # needed for StringIO example only\n    >>> data = np.genfromtxt(s, dtype=None,\n    ... names = ['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    Specifying dtype and names\n\n    >>> s.seek(0)\n    >>> data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n    ... names=['myint','myfloat','mystring'], delimiter=\",\")\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '|S5')])\n\n    An example with fixed-width columns\n\n    >>> s = StringIO(\"11.3abcde\")\n    >>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n    ...     delimiter=[1,3,5])\n    >>> data\n    array((1, 1.3, 'abcde'),\n          dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '|S5')])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_183genfromtxt = {"genfromtxt", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_183genfromtxt, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_182genfromtxt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_183genfromtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_fname = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_comments = 0;
  CYTHON_UNUSED PyObject *__pyx_v_delimiter = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skiprows = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skip_header = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skip_footer = 0;
  CYTHON_UNUSED PyObject *__pyx_v_converters = 0;
  CYTHON_UNUSED PyObject *__pyx_v_missing = 0;
  CYTHON_UNUSED PyObject *__pyx_v_missing_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_filling_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_usecols = 0;
  CYTHON_UNUSED PyObject *__pyx_v_names = 0;
  CYTHON_UNUSED PyObject *__pyx_v_excludelist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_deletechars = 0;
  CYTHON_UNUSED PyObject *__pyx_v_replace_space = 0;
  CYTHON_UNUSED PyObject *__pyx_v_autostrip = 0;
  CYTHON_UNUSED PyObject *__pyx_v_case_sensitive = 0;
  CYTHON_UNUSED PyObject *__pyx_v_defaultfmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_unpack = 0;
  CYTHON_UNUSED PyObject *__pyx_v_usemask = 0;
  CYTHON_UNUSED PyObject *__pyx_v_loose = 0;
  CYTHON_UNUSED PyObject *__pyx_v_invalid_raise = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genfromtxt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_fname,&__pyx_n_s_dtype,&__pyx_n_s_comments,&__pyx_n_s_delimiter,&__pyx_n_s_skiprows,&__pyx_n_s_skip_header,&__pyx_n_s_skip_footer,&__pyx_n_s_converters,&__pyx_n_s_missing,&__pyx_n_s_missing_values,&__pyx_n_s_filling_values,&__pyx_n_s_usecols,&__pyx_n_s_names,&__pyx_n_s_excludelist,&__pyx_n_s_deletechars,&__pyx_n_s_replace_space,&__pyx_n_s_autostrip,&__pyx_n_s_case_sensitive,&__pyx_n_s_defaultfmt,&__pyx_n_s_unpack,&__pyx_n_s_usemask,&__pyx_n_s_loose,&__pyx_n_s_invalid_raise,0};
    PyObject* values[23] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    values[1] = __pyx_k__8;
    values[2] = ((PyObject *)__pyx_kp_s__9);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_int_0);
    values[5] = ((PyObject *)__pyx_int_0);
    values[6] = ((PyObject *)__pyx_int_0);
    values[7] = ((PyObject *)Py_None);
    values[8] = ((PyObject *)__pyx_kp_s__2);
    values[9] = ((PyObject *)Py_None);
    values[10] = ((PyObject *)Py_None);
    values[11] = ((PyObject *)Py_None);
    values[12] = ((PyObject *)Py_None);
    values[13] = ((PyObject *)Py_None);
    values[14] = ((PyObject *)Py_None);
    values[15] = ((PyObject *)__pyx_n_s__10);
    values[16] = ((PyObject *)Py_False);
    values[17] = ((PyObject *)Py_True);
    values[18] = ((PyObject *)__pyx_kp_s_f_i);
    values[19] = ((PyObject *)Py_None);
    values[20] = ((PyObject *)Py_False);
    values[21] = ((PyObject *)Py_True);
    values[22] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 23: values[22] = PyTuple_GET_ITEM(__pyx_args, 22);
        CYTHON_FALLTHROUGH;
        case 22: values[21] = PyTuple_GET_ITEM(__pyx_args, 21);
        CYTHON_FALLTHROUGH;
        case 21: values[20] = PyTuple_GET_ITEM(__pyx_args, 20);
        CYTHON_FALLTHROUGH;
        case 20: values[19] = PyTuple_GET_ITEM(__pyx_args, 19);
        CYTHON_FALLTHROUGH;
        case 19: values[18] = PyTuple_GET_ITEM(__pyx_args, 18);
        CYTHON_FALLTHROUGH;
        case 18: values[17] = PyTuple_GET_ITEM(__pyx_args, 17);
        CYTHON_FALLTHROUGH;
        case 17: values[16] = PyTuple_GET_ITEM(__pyx_args, 16);
        CYTHON_FALLTHROUGH;
        case 16: values[15] = PyTuple_GET_ITEM(__pyx_args, 15);
        CYTHON_FALLTHROUGH;
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        CYTHON_FALLTHROUGH;
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        CYTHON_FALLTHROUGH;
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        CYTHON_FALLTHROUGH;
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        CYTHON_FALLTHROUGH;
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        CYTHON_FALLTHROUGH;
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fname)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_comments);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_delimiter);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_skiprows);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_skip_header);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_skip_footer);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_converters);
          if (value) { values[7] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  8:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_missing);
          if (value) { values[8] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  9:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_missing_values);
          if (value) { values[9] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 10:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_filling_values);
          if (value) { values[10] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 11:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_usecols);
          if (value) { values[11] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 12:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_names);
          if (value) { values[12] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 13:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_excludelist);
          if (value) { values[13] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 14:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deletechars);
          if (value) { values[14] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 15:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_replace_space);
          if (value) { values[15] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 16:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_autostrip);
          if (value) { values[16] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 17:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_case_sensitive);
          if (value) { values[17] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 18:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_defaultfmt);
          if (value) { values[18] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 19:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_unpack);
          if (value) { values[19] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 20:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_usemask);
          if (value) { values[20] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 21:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_loose);
          if (value) { values[21] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 22:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_invalid_raise);
          if (value) { values[22] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "genfromtxt") < 0)) __PYX_ERR(0, 4596, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 23: values[22] = PyTuple_GET_ITEM(__pyx_args, 22);
        CYTHON_FALLTHROUGH;
        case 22: values[21] = PyTuple_GET_ITEM(__pyx_args, 21);
        CYTHON_FALLTHROUGH;
        case 21: values[20] = PyTuple_GET_ITEM(__pyx_args, 20);
        CYTHON_FALLTHROUGH;
        case 20: values[19] = PyTuple_GET_ITEM(__pyx_args, 19);
        CYTHON_FALLTHROUGH;
        case 19: values[18] = PyTuple_GET_ITEM(__pyx_args, 18);
        CYTHON_FALLTHROUGH;
        case 18: values[17] = PyTuple_GET_ITEM(__pyx_args, 17);
        CYTHON_FALLTHROUGH;
        case 17: values[16] = PyTuple_GET_ITEM(__pyx_args, 16);
        CYTHON_FALLTHROUGH;
        case 16: values[15] = PyTuple_GET_ITEM(__pyx_args, 15);
        CYTHON_FALLTHROUGH;
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        CYTHON_FALLTHROUGH;
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        CYTHON_FALLTHROUGH;
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        CYTHON_FALLTHROUGH;
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        CYTHON_FALLTHROUGH;
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        CYTHON_FALLTHROUGH;
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_fname = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_comments = values[2];
    __pyx_v_delimiter = values[3];
    __pyx_v_skiprows = values[4];
    __pyx_v_skip_header = values[5];
    __pyx_v_skip_footer = values[6];
    __pyx_v_converters = values[7];
    __pyx_v_missing = values[8];
    __pyx_v_missing_values = values[9];
    __pyx_v_filling_values = values[10];
    __pyx_v_usecols = values[11];
    __pyx_v_names = values[12];
    __pyx_v_excludelist = values[13];
    __pyx_v_deletechars = values[14];
    __pyx_v_replace_space = values[15];
    __pyx_v_autostrip = values[16];
    __pyx_v_case_sensitive = values[17];
    __pyx_v_defaultfmt = values[18];
    __pyx_v_unpack = values[19];
    __pyx_v_usemask = values[20];
    __pyx_v_loose = values[21];
    __pyx_v_invalid_raise = values[22];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("genfromtxt", 0, 1, 23, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4596, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.genfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_182genfromtxt(__pyx_self, __pyx_v_fname, __pyx_v_dtype, __pyx_v_comments, __pyx_v_delimiter, __pyx_v_skiprows, __pyx_v_skip_header, __pyx_v_skip_footer, __pyx_v_converters, __pyx_v_missing, __pyx_v_missing_values, __pyx_v_filling_values, __pyx_v_usecols, __pyx_v_names, __pyx_v_excludelist, __pyx_v_deletechars, __pyx_v_replace_space, __pyx_v_autostrip, __pyx_v_case_sensitive, __pyx_v_defaultfmt, __pyx_v_unpack, __pyx_v_usemask, __pyx_v_loose, __pyx_v_invalid_raise);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_182genfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_skip_header, CYTHON_UNUSED PyObject *__pyx_v_skip_footer, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_missing, CYTHON_UNUSED PyObject *__pyx_v_missing_values, CYTHON_UNUSED PyObject *__pyx_v_filling_values, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_names, CYTHON_UNUSED PyObject *__pyx_v_excludelist, CYTHON_UNUSED PyObject *__pyx_v_deletechars, CYTHON_UNUSED PyObject *__pyx_v_replace_space, CYTHON_UNUSED PyObject *__pyx_v_autostrip, CYTHON_UNUSED PyObject *__pyx_v_case_sensitive, CYTHON_UNUSED PyObject *__pyx_v_defaultfmt, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_usemask, CYTHON_UNUSED PyObject *__pyx_v_loose, CYTHON_UNUSED PyObject *__pyx_v_invalid_raise) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genfromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":4731
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4731, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4596
 * 
 * 
 * def genfromtxt(fname, dtype=float, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True):             # <<<<<<<<<<<<<<
 *     """Load data from a text file, with missing values handled as specified.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.genfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4734
 * 
 * 
 * def get_array_wrap():             # <<<<<<<<<<<<<<
 *     """Find the wrapper for the array with the highest priority.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_185get_array_wrap(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_184get_array_wrap[] = "Find the wrapper for the array with the highest priority.\n\n    In case of ties, leftmost wins. If no wrapper is found, return None\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_185get_array_wrap = {"get_array_wrap", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_185get_array_wrap, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_184get_array_wrap};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_185get_array_wrap(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_array_wrap (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_184get_array_wrap(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_184get_array_wrap(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_array_wrap", 0);

  /* "ga4py/gain/notimplemented.pyx":4740
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4740, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4734
 * 
 * 
 * def get_array_wrap():             # <<<<<<<<<<<<<<
 *     """Find the wrapper for the array with the highest priority.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_array_wrap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4743
 * 
 * 
 * def get_include():             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the NumPy \*.h header files.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_187get_include(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_186get_include[] = "Return the directory that contains the NumPy \\*.h header files.\n\n    Extension modules that need to compile against NumPy should use this\n    function to locate the appropriate include directory.\n\n    Notes\n    -----\n    When using ``distutils``, for example in ``setup.py``.\n    ::\n\n        import numpy as np\n        ...\n        Extension('extension_name', ...\n                include_dirs=[np.get_include()])\n        ...\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_187get_include = {"get_include", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_187get_include, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_186get_include};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_187get_include(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_include (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_186get_include(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_186get_include(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_include", 0);

  /* "ga4py/gain/notimplemented.pyx":4761
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4761, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4743
 * 
 * 
 * def get_include():             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the NumPy \*.h header files.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_include", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4764
 * 
 * 
 * def get_numarray_include(type=None):             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the numarray \*.h header files.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_189get_numarray_include(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_188get_numarray_include[] = "Return the directory that contains the numarray \\*.h header files.\n\n    Extension modules that need to compile against numarray should use this\n    function to locate the appropriate include directory.\n\n    Parameters\n    ----------\n    type : any, optional\n        If `type` is not None, the location of the NumPy headers is returned\n        as well.\n\n    Returns\n    -------\n    dirs : str or list of str\n        If `type` is None, `dirs` is a string containing the path to the\n        numarray headers.\n        If `type` is not None, `dirs` is a list of strings with first the\n        path(s) to the numarray headers, followed by the path to the NumPy\n        headers.\n\n    Notes\n    -----\n    Useful when using ``distutils``, for example in ``setup.py``.\n    ::\n\n        import numpy as np\n        ...\n        Extension('extension_name', ...\n                include_dirs=[np.get_numarray_include()])\n        ...\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_189get_numarray_include = {"get_numarray_include", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_189get_numarray_include, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_188get_numarray_include};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_189get_numarray_include(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_type = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_numarray_include (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_type,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_type);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_numarray_include") < 0)) __PYX_ERR(0, 4764, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_type = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_numarray_include", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4764, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_numarray_include", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_188get_numarray_include(__pyx_self, __pyx_v_type);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_188get_numarray_include(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_numarray_include", 0);

  /* "ga4py/gain/notimplemented.pyx":4797
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4797, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4764
 * 
 * 
 * def get_numarray_include(type=None):             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the numarray \*.h header files.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_numarray_include", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4800
 * 
 * 
 * def get_printoptions():             # <<<<<<<<<<<<<<
 *     """Return the current print options.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_191get_printoptions(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_190get_printoptions[] = "Return the current print options.\n\n    Returns\n    -------\n    print_opts : dict\n        Dictionary of current print options with keys\n\n          - precision : int\n          - threshold : int\n          - edgeitems : int\n          - linewidth : int\n          - suppress : bool\n          - nanstr : str\n          - infstr : str\n\n        For a full description of these options, see `set_printoptions`.\n\n    See Also\n    --------\n    set_printoptions, set_string_function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_191get_printoptions = {"get_printoptions", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_191get_printoptions, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_190get_printoptions};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_191get_printoptions(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_printoptions (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_190get_printoptions(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_190get_printoptions(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_printoptions", 0);

  /* "ga4py/gain/notimplemented.pyx":4823
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4823, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4800
 * 
 * 
 * def get_printoptions():             # <<<<<<<<<<<<<<
 *     """Return the current print options.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.get_printoptions", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4826
 * 
 * 
 * def getbuffer():             # <<<<<<<<<<<<<<
 *     """getbuffer(obj [,offset[, size]])
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_193getbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_192getbuffer[] = "getbuffer(obj [,offset[, size]])\n\n    Create a buffer object from the given object referencing a slice of\n    length size starting at offset.\n\n    Default is the entire buffer. A read-write buffer is attempted followed\n    by a read-only buffer.\n\n    Parameters\n    ----------\n    obj : object\n\n    offset : int, optional\n\n    size : int, optional\n\n    Returns\n    -------\n    buffer_obj : buffer\n\n    Examples\n    --------\n    >>> buf = np.getbuffer(np.ones(5), 1, 3)\n    >>> len(buf)\n    3\n    >>> buf[0]\n    '\000'\n    >>> buf\n    <read-write buffer for 0x8af1e70, size 3, offset 1 at 0x8ba4ec0>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_193getbuffer = {"getbuffer", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_193getbuffer, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_192getbuffer};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_193getbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getbuffer (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_192getbuffer(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_192getbuffer(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getbuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":4859
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4859, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4826
 * 
 * 
 * def getbuffer():             # <<<<<<<<<<<<<<
 *     """getbuffer(obj [,offset[, size]])
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.getbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4862
 * 
 * 
 * def getbufsize():             # <<<<<<<<<<<<<<
 *     """Return the size of the buffer used in ufuncs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_195getbufsize(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_194getbufsize[] = "Return the size of the buffer used in ufuncs.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_195getbufsize = {"getbufsize", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_195getbufsize, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_194getbufsize};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_195getbufsize(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getbufsize (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_194getbufsize(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_194getbufsize(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getbufsize", 0);

  /* "ga4py/gain/notimplemented.pyx":4866
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4866, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4862
 * 
 * 
 * def getbufsize():             # <<<<<<<<<<<<<<
 *     """Return the size of the buffer used in ufuncs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.getbufsize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4869
 * 
 * 
 * def geterr():             # <<<<<<<<<<<<<<
 *     """Get the current way of handling floating-point errors.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_197geterr(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_196geterr[] = "Get the current way of handling floating-point errors.\n\n    Returns\n    -------\n    res : dict\n        A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n        whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n        \"raise\", and \"call\". The keys represent possible floating-point\n        exceptions, and the values define how these exceptions are handled.\n\n    See Also\n    --------\n    geterrcall, seterr, seterrcall\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'warn', 'invalid': 'warn',\n    'under': 'ignore'}\n    >>> np.arange(3.) / np.arange(3.)\n    array([ NaN,   1.,   1.])\n\n    >>> oldsettings = np.seterr(all='warn', over='raise')\n    >>> np.geterr()\n    {'over': 'raise', 'divide': 'warn', 'invalid': 'warn', 'under': 'warn'}\n    >>> np.arange(3.) / np.arange(3.)\n    __main__:1: RuntimeWarning: invalid value encountered in divide\n    array([ NaN,   1.,   1.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_197geterr = {"geterr", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_197geterr, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_196geterr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_197geterr(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterr (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_196geterr(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_196geterr(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterr", 0);

  /* "ga4py/gain/notimplemented.pyx":4905
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4905, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4869
 * 
 * 
 * def geterr():             # <<<<<<<<<<<<<<
 *     """Get the current way of handling floating-point errors.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.geterr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4908
 * 
 * 
 * def geterrcall():             # <<<<<<<<<<<<<<
 *     """Return the current callback function used on floating-point errors.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_199geterrcall(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_198geterrcall[] = "Return the current callback function used on floating-point errors.\n\n    When the error handling for a floating-point error (one of \"divide\",\n    \"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\n    that is called or the log instance that is written to is returned by\n    `geterrcall`. This function or log instance has been set with\n    `seterrcall`.\n\n    Returns\n    -------\n    errobj : callable, log instance or None\n        The current error handler. If no handler was set through `seterrcall`,\n        ``None`` is returned.\n\n    See Also\n    --------\n    seterrcall, seterr, geterr\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrcall()  # we did not yet set a handler, returns None\n\n    >>> oldsettings = np.seterr(all='call')\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    >>> oldhandler = np.seterrcall(err_handler)\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> cur_handler = np.geterrcall()\n    >>> cur_handler is err_handler\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_199geterrcall = {"geterrcall", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_199geterrcall, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_198geterrcall};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_199geterrcall(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterrcall (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_198geterrcall(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_198geterrcall(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterrcall", 0);

  /* "ga4py/gain/notimplemented.pyx":4949
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 4949, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4908
 * 
 * 
 * def geterrcall():             # <<<<<<<<<<<<<<
 *     """Return the current callback function used on floating-point errors.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.geterrcall", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":4952
 * 
 * 
 * def geterrobj():             # <<<<<<<<<<<<<<
 *     """geterrobj()
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_201geterrobj(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_200geterrobj[] = "geterrobj()\n\n    Return the current object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `geterrobj` is used internally by the other\n    functions that get and set error handling behavior (`geterr`, `seterr`,\n    `geterrcall`, `seterrcall`).\n\n    Returns\n    -------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    seterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrobj()  # first get the defaults\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> old_bufsize = np.setbufsize(20000)\n    >>> old_err = np.seterr(divide='raise')\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.geterrobj()\n    [20000, 2, <function err_handler at 0x91dcaac>]\n\n    >>> old_err = np.seterr(all='ignore')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    '0'\n    >>> old_err = np.seterr(divide='warn', over='log', under='call',\n                            invalid='print')\n    >>> np.b""ase_repr(np.geterrobj()[1], 8)\n    '4351'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_201geterrobj = {"geterrobj", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_201geterrobj, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_200geterrobj};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_201geterrobj(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterrobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_200geterrobj(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_200geterrobj(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("geterrobj", 0);

  /* "ga4py/gain/notimplemented.pyx":5015
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5015, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4952
 * 
 * 
 * def geterrobj():             # <<<<<<<<<<<<<<
 *     """geterrobj()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.geterrobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5018
 * 
 * 
 * def gradient(f):             # <<<<<<<<<<<<<<
 *     """Return the gradient of an N-dimensional array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_203gradient(PyObject *__pyx_self, PyObject *__pyx_v_f); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_202gradient[] = "Return the gradient of an N-dimensional array.\n\n    The gradient is computed using central differences in the interior\n    and first differences at the boundaries. The returned gradient hence has\n    the same shape as the input array.\n\n    Parameters\n    ----------\n    f : array_like\n      An N-dimensional array containing samples of a scalar function.\n    `*varargs` : scalars\n      0, 1, or N scalars specifying the sample distances in each direction,\n      that is: `dx`, `dy`, `dz`, ... The default distance is 1.\n\n\n    Returns\n    -------\n    g : ndarray\n      N arrays of the same shape as `f` giving the derivative of `f` with\n      respect to each dimension.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)\n    >>> np.gradient(x)\n    array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n    >>> np.gradient(x, 2)\n    array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float))\n    [array([[ 2.,  2., -1.],\n           [ 2.,  2., -1.]]),\n    array([[ 1. ,  2.5,  4. ],\n           [ 1. ,  1. ,  1. ]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_203gradient = {"gradient", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_203gradient, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_202gradient};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_203gradient(PyObject *__pyx_self, PyObject *__pyx_v_f) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("gradient (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_202gradient(__pyx_self, ((PyObject *)__pyx_v_f));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_202gradient(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("gradient", 0);

  /* "ga4py/gain/notimplemented.pyx":5055
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5055, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5018
 * 
 * 
 * def gradient(f):             # <<<<<<<<<<<<<<
 *     """Return the gradient of an N-dimensional array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.gradient", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5058
 * 
 * 
 * def hamming(M):             # <<<<<<<<<<<<<<
 *     """Return the Hamming window.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_205hamming(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_204hamming[] = "Return the Hamming window.\n\n    The Hamming window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hanning, kaiser\n\n    Notes\n    -----\n    The Hamming window is defined as\n\n    .. math::  w(n) = 0.54 + 0.46cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and\n    is described in Blackman and Tukey. It was recommended for smoothing the\n    truncated autocovariance function in the time domain.\n    Most references to the Hamming window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 109-110.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> np.hamming(12)\n    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,\n            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n         ""   0.15302337,  0.08      ])\n\n    Plot the window and the frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hamming(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = np.abs(fftshift(A))\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> response = 20 * np.log10(mag)\n    >>> response = np.clip(response, -100, 100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Hamming window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_205hamming = {"hamming", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_205hamming, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_204hamming};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_205hamming(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hamming (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_204hamming(__pyx_self, ((PyObject *)__pyx_v_M));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_204hamming(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hamming", 0);

  /* "ga4py/gain/notimplemented.pyx":5149
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5149, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5058
 * 
 * 
 * def hamming(M):             # <<<<<<<<<<<<<<
 *     """Return the Hamming window.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hamming", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5152
 * 
 * 
 * def hanning(M):             # <<<<<<<<<<<<<<
 *     """Return the Hanning window.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_207hanning(PyObject *__pyx_self, PyObject *__pyx_v_M); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_206hanning[] = "Return the Hanning window.\n\n    The Hanning window is a taper formed by using a weighted cosine.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n\n    Returns\n    -------\n    out : ndarray, shape(M,)\n        The window, normalized to one (the value one\n        appears only if `M` is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, kaiser\n\n    Notes\n    -----\n    The Hanning window is defined as\n\n    .. math::  w(n) = 0.5 - 0.5cos\\left(\014rac{2\\pi{n}}{M-1}\right)\n               \\qquad 0 \\leq n \\leq M-1\n\n    The Hanning was named for Julius van Hann, an Austrian meterologist. It is\n    also known as the Cosine Bell. Some authors prefer that it be called a\n    Hann window, to help avoid confusion with the very similar Hamming window.\n\n    Most references to the Hanning window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n           spectra, Dover Publications, New York.\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n           The University of Alberta Press, 1975, pp. 106-108.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n           \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\n    Examples\n    --------\n    >>> from numpy import hanning\n    >>> hanning(12)\n    array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,\n            0.97974649,  0.97974649,  0.""82743037,  0.57115742,  0.29229249,\n            0.07937323,  0.        ])\n\n    Plot the window and its frequency response:\n\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = np.hanning(51)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = np.linspace(-0.5,0.5,len(A))\n    >>> response = 20*np.log10(mag)\n    >>> response = np.clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of the Hann window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_207hanning = {"hanning", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_207hanning, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_206hanning};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_207hanning(PyObject *__pyx_self, PyObject *__pyx_v_M) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hanning (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_206hanning(__pyx_self, ((PyObject *)__pyx_v_M));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_206hanning(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hanning", 0);

  /* "ga4py/gain/notimplemented.pyx":5245
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5245, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5152
 * 
 * 
 * def hanning(M):             # <<<<<<<<<<<<<<
 *     """Return the Hanning window.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hanning", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5248
 * 
 * 
 * def histogram(a, bins=10, range=None, normed=False, weights=None, density=None):             # <<<<<<<<<<<<<<
 *     """Compute the histogram of a set of data.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_209histogram(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_208histogram[] = "Compute the histogram of a set of data.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data. The histogram is computed over the flattened array.\n    bins : int or sequence of scalars, optional\n        If `bins` is an int, it defines the number of equal-width\n        bins in the given range (10, by default). If `bins` is a sequence,\n        it defines the bin edges, including the rightmost edge, allowing\n        for non-uniform bin widths.\n    range : (float, float), optional\n        The lower and upper range of the bins.  If not provided, range\n        is simply ``(a.min(), a.max())``.  Values outside the range are\n        ignored.\n    normed : bool, optional\n        This keyword is deprecated in Numpy 1.6 due to confusing/buggy\n        behavior. It will be removed in Numpy 2.0. Use the density keyword\n        instead.\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that this latter behavior is\n        known to be buggy with unequal bin widths; use `density` instead.\n    weights : array_like, optional\n        An array of weights, of the same shape as `a`.  Each value in `a`\n        only contributes its associated weight towards the bin count\n        (instead of 1).  If `normed` is True, the weights are normalized,\n        so that the integral of the density over the range remains 1\n    density : bool, optional\n        If False, the result will contain the number of samples\n        in each bin.  If True, the result is the value of the\n        probability *density* function at the bin, normalized such that\n        the *integral* over the range is 1. Note that the sum of the\n        histogram values will not be equal to 1 unless bins of unity\n        width are chosen; it is not a probability *mass* function.\n        Overr""ides the `normed` keyword if given.\n\n    Returns\n    -------\n    hist : array\n        The values of the histogram. See `normed` and `weights` for a\n        description of the possible semantics.\n    bin_edges : array of dtype float\n        Return the bin edges ``(length(hist)+1)``.\n\n\n    See Also\n    --------\n    histogramdd, bincount, searchsorted, digitize\n\n    Notes\n    -----\n    All but the last (righthand-most) bin is half-open.  In other words, if\n    `bins` is::\n\n      [1, 2, 3, 4]\n\n    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and the\n    second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which *includes*\n    4.\n\n    Examples\n    --------\n    >>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n    (array([0, 2, 1]), array([0, 1, 2, 3]))\n    >>> np.histogram(np.arange(4), bins=np.arange(5), density=True)\n    (array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))\n    >>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n    (array([1, 4, 1]), array([0, 1, 2, 3]))\n\n    >>> a = np.arange(5)\n    >>> hist, bin_edges = np.histogram(a, density=True)\n    >>> hist\n    array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])\n    >>> hist.sum()\n    2.4999999999999996\n    >>> np.sum(hist*np.diff(bin_edges))\n    1.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_209histogram = {"histogram", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_209histogram, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_208histogram};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_209histogram(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  CYTHON_UNUSED PyObject *__pyx_v_range = 0;
  CYTHON_UNUSED PyObject *__pyx_v_normed = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  CYTHON_UNUSED PyObject *__pyx_v_density = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogram (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_bins,&__pyx_n_s_range,&__pyx_n_s_normed,&__pyx_n_s_weights,&__pyx_n_s_density,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_10);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_False);
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bins);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_range);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_normed);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weights);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_density);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "histogram") < 0)) __PYX_ERR(0, 5248, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_bins = values[1];
    __pyx_v_range = values[2];
    __pyx_v_normed = values[3];
    __pyx_v_weights = values[4];
    __pyx_v_density = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("histogram", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5248, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_208histogram(__pyx_self, __pyx_v_a, __pyx_v_bins, __pyx_v_range, __pyx_v_normed, __pyx_v_weights, __pyx_v_density);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_208histogram(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights, CYTHON_UNUSED PyObject *__pyx_v_density) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogram", 0);

  /* "ga4py/gain/notimplemented.pyx":5330
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5330, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5248
 * 
 * 
 * def histogram(a, bins=10, range=None, normed=False, weights=None, density=None):             # <<<<<<<<<<<<<<
 *     """Compute the histogram of a set of data.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5333
 * 
 * 
 * def histogram2d(x, y, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the bi-dimensional histogram of two data samples.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_211histogram2d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_210histogram2d[] = "Compute the bi-dimensional histogram of two data samples.\n\n    Parameters\n    ----------\n    x : array_like, shape(N,)\n        A sequence of values to be histogrammed along the first dimension.\n    y : array_like, shape(M,)\n        A sequence of values to be histogrammed along the second dimension.\n    bins : int or [int, int] or array_like or [array, array], optional\n        The bin specification:\n\n          * If int, the number of bins for the two dimensions (nx=ny=bins).\n          * If [int, int], the number of bins in each dimension (nx, ny = bins).\n          * If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).\n          * If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).\n\n    range : array_like, shape(2,2), optional\n        The leftmost and rightmost edges of the bins along each dimension\n        (if not specified explicitly in the `bins` parameters):\n        ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range\n        will be considered outliers and not tallied in the histogram.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, i.e. the bin count divided by the bin area.\n    weights : array_like, shape(N,), optional\n        An array of values ``w_i`` weighing each sample ``(x_i, y_i)``. Weights\n        are normalized to 1 if `normed` is True. If `normed` is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray, shape(nx, ny)\n        The bi-dimensional histogram of samples `x` and `y`. Values in `x`\n        are histogrammed along the first dimension and values in `y` are\n        histogrammed along the second dimension.\n    xedges : ndarray, shape(nx,)\n        The bin edges along the first dimension.\n    yedges : ndarray, shape(ny,)\n        The bin e""dges along the second dimension.\n\n    See Also\n    --------\n    histogram: 1D histogram\n    histogramdd: Multidimensional histogram\n\n    Notes\n    -----\n    When `normed` is True, then the returned histogram is the sample density,\n    defined such that:\n\n    .. math::\n      \\sum_{i=0}^{nx-1} \\sum_{j=0}^{ny-1} H_{i,j} \\Delta x_i \\Delta y_j = 1\n\n    where `H` is the histogram array and :math:`\\Delta x_i \\Delta y_i`\n    the area of bin `{i,j}`.\n\n    Please note that the histogram does not follow the Cartesian convention\n    where `x` values are on the abcissa and `y` values on the ordinate axis.\n    Rather, `x` is histogrammed along the first dimension of the array\n    (vertical), and `y` along the second dimension of the array (horizontal).\n    This ensures compatibility with `histogramdd`.\n\n    Examples\n    --------\n    >>> x, y = np.random.randn(2, 100)\n    >>> H, xedges, yedges = np.histogram2d(x, y, bins=(5, 8))\n    >>> H.shape, xedges.shape, yedges.shape\n    ((5, 8), (6,), (9,))\n\n    We can now use the Matplotlib to visualize this 2-dimensional histogram:\n\n    >>> extent = [yedges[0], yedges[-1], xedges[-1], xedges[0]]\n    >>> import matplotlib.pyplot as plt\n    >>> plt.imshow(H, extent=extent, interpolation='nearest')\n    <matplotlib.image.AxesImage object at ...>\n    >>> plt.colorbar()\n    <matplotlib.colorbar.Colorbar instance at ...>\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_211histogram2d = {"histogram2d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_211histogram2d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_210histogram2d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_211histogram2d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  CYTHON_UNUSED PyObject *__pyx_v_range = 0;
  CYTHON_UNUSED PyObject *__pyx_v_normed = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogram2d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_bins,&__pyx_n_s_range,&__pyx_n_s_normed,&__pyx_n_s_weights,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[2] = ((PyObject *)__pyx_int_10);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_False);
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("histogram2d", 0, 2, 6, 1); __PYX_ERR(0, 5333, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bins);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_range);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_normed);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weights);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "histogram2d") < 0)) __PYX_ERR(0, 5333, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
    __pyx_v_bins = values[2];
    __pyx_v_range = values[3];
    __pyx_v_normed = values[4];
    __pyx_v_weights = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("histogram2d", 0, 2, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5333, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_210histogram2d(__pyx_self, __pyx_v_x, __pyx_v_y, __pyx_v_bins, __pyx_v_range, __pyx_v_normed, __pyx_v_weights);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_210histogram2d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogram2d", 0);

  /* "ga4py/gain/notimplemented.pyx":5415
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5415, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5333
 * 
 * 
 * def histogram2d(x, y, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the bi-dimensional histogram of two data samples.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogram2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5418
 * 
 * 
 * def histogramdd(sample, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the multidimensional histogram of some data.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_213histogramdd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_212histogramdd[] = "Compute the multidimensional histogram of some data.\n\n    Parameters\n    ----------\n    sample : array_like\n        The data to be histogrammed. It must be an (N,D) array or data\n        that can be converted to such. The rows of the resulting array\n        are the coordinates of points in a D dimensional polytope.\n    bins : sequence or int, optional\n        The bin specification:\n\n        * A sequence of arrays describing the bin edges along each dimension.\n        * The number of bins for each dimension (nx, ny, ... =bins)\n        * The number of bins for all dimensions (nx=ny=...=bins).\n\n    range : sequence, optional\n        A sequence of lower and upper bin edges to be used if the edges are\n        not given explicitely in `bins`. Defaults to the minimum and maximum\n        values along each dimension.\n    normed : bool, optional\n        If False, returns the number of samples in each bin. If True, returns\n        the bin density, ie, the bin count divided by the bin hypervolume.\n    weights : array_like (N,), optional\n        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.\n        Weights are normalized to 1 if normed is True. If normed is False, the\n        values of the returned histogram are equal to the sum of the weights\n        belonging to the samples falling into each bin.\n\n    Returns\n    -------\n    H : ndarray\n        The multidimensional histogram of sample x. See normed and weights for\n        the different possible semantics.\n    edges : list\n        A list of D arrays describing the bin edges for each dimension.\n\n    See Also\n    --------\n    histogram: 1-D histogram\n    histogram2d: 2-D histogram\n\n    Examples\n    --------\n    >>> r = np.random.randn(100,3)\n    >>> H, edges = np.histogramdd(r, bins = (5, 8, 4))\n    >>> H.shape, edges[0].size, edges[1].size, edges[2].size\n    ((5, 8, 4), 6, 9, 5)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_213histogramdd = {"histogramdd", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_213histogramdd, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_212histogramdd};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_213histogramdd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_sample = 0;
  CYTHON_UNUSED PyObject *__pyx_v_bins = 0;
  CYTHON_UNUSED PyObject *__pyx_v_range = 0;
  CYTHON_UNUSED PyObject *__pyx_v_normed = 0;
  CYTHON_UNUSED PyObject *__pyx_v_weights = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogramdd (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_sample,&__pyx_n_s_bins,&__pyx_n_s_range,&__pyx_n_s_normed,&__pyx_n_s_weights,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_10);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_False);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sample)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_bins);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_range);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_normed);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weights);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "histogramdd") < 0)) __PYX_ERR(0, 5418, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_sample = values[0];
    __pyx_v_bins = values[1];
    __pyx_v_range = values[2];
    __pyx_v_normed = values[3];
    __pyx_v_weights = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("histogramdd", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5418, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogramdd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_212histogramdd(__pyx_self, __pyx_v_sample, __pyx_v_bins, __pyx_v_range, __pyx_v_normed, __pyx_v_weights);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_212histogramdd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sample, CYTHON_UNUSED PyObject *__pyx_v_bins, CYTHON_UNUSED PyObject *__pyx_v_range, CYTHON_UNUSED PyObject *__pyx_v_normed, CYTHON_UNUSED PyObject *__pyx_v_weights) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("histogramdd", 0);

  /* "ga4py/gain/notimplemented.pyx":5468
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5468, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5418
 * 
 * 
 * def histogramdd(sample, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the multidimensional histogram of some data.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.histogramdd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5471
 * 
 * 
 * def hsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays horizontally (column-wise).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_215hsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_214hsplit[] = "Split an array into multiple sub-arrays horizontally (column-wise).\n\n    Please refer to the `split` documentation.  `hsplit` is equivalent\n    to `split` with ``axis=1``, the array is always split along the second\n    axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.hsplit(x, 2)\n    [array([[  0.,   1.],\n           [  4.,   5.],\n           [  8.,   9.],\n           [ 12.,  13.]]),\n     array([[  2.,   3.],\n           [  6.,   7.],\n           [ 10.,  11.],\n           [ 14.,  15.]])]\n    >>> np.hsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.],\n           [  4.,   5.,   6.],\n           [  8.,   9.,  10.],\n           [ 12.,  13.,  14.]]),\n     array([[  3.],\n           [  7.],\n           [ 11.],\n           [ 15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the second axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.hsplit(x, 2)\n    [array([[[ 0.,  1.]],\n           [[ 4.,  5.]]]),\n     array([[[ 2.,  3.]],\n           [[ 6.,  7.]]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_215hsplit = {"hsplit", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_215hsplit, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_214hsplit};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_215hsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hsplit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ary,&__pyx_n_s_indices_or_sections,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("hsplit", 1, 2, 2, 1); __PYX_ERR(0, 5471, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "hsplit") < 0)) __PYX_ERR(0, 5471, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("hsplit", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5471, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_214hsplit(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_214hsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hsplit", 0);

  /* "ga4py/gain/notimplemented.pyx":5525
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5525, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5471
 * 
 * 
 * def hsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays horizontally (column-wise).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5528
 * 
 * 
 * def hstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence horizontally (column wise).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_217hstack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_216hstack[] = "Stack arrays in sequence horizontally (column wise).\n\n    Take a sequence of arrays and stack them horizontally to make\n    a single array. Rebuild arrays divided by `hsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        All arrays must have the same shape along all but the second axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third axis).\n    concatenate : Join a sequence of arrays together.\n    hsplit : Split array along second axis.\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=1)``\n\n    Examples\n    --------\n    >>> a = np.array((1,2,3))\n    >>> b = np.array((2,3,4))\n    >>> np.hstack((a,b))\n    array([1, 2, 3, 2, 3, 4])\n    >>> a = np.array([[1],[2],[3]])\n    >>> b = np.array([[2],[3],[4]])\n    >>> np.hstack((a,b))\n    array([[1, 2],\n           [2, 3],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_217hstack = {"hstack", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_217hstack, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_216hstack};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_217hstack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hstack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_216hstack(__pyx_self, ((PyObject *)__pyx_v_tup));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_216hstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hstack", 0);

  /* "ga4py/gain/notimplemented.pyx":5569
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5569, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5528
 * 
 * 
 * def hstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence horizontally (column wise).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.hstack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5572
 * 
 * 
 * def i0(x):             # <<<<<<<<<<<<<<
 *     """Modified Bessel function of the first kind, order 0.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_219i0(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_218i0[] = "Modified Bessel function of the first kind, order 0.\n\n    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*\n    \"up-cast\" int dtype arguments unless accompanied by at least one float or\n    complex dtype argument (see Raises below).\n\n    Parameters\n    ----------\n    x : array_like, dtype float or complex\n        Argument of the Bessel function.\n\n    Returns\n    -------\n    out : ndarray, shape = x.shape, dtype = x.dtype\n        The modified Bessel function evaluated at each of the elements of `x`.\n\n    Raises\n    ------\n    TypeError: array cannot be safely cast to required type\n        If argument consists exclusively of int dtypes.\n\n    See Also\n    --------\n    scipy.special.iv, scipy.special.ive\n\n    Notes\n    -----\n    We use the algorithm published by Clenshaw [1]_ and referenced by\n    Abramowitz and Stegun [2]_, for which the function domain is partitioned\n    into the two intervals [0,8] and (8,inf), and Chebyshev polynomial\n    expansions are employed in each interval. Relative error on the domain\n    [0,30] using IEEE arithmetic is documented [3]_ as having a peak of 5.8e-16\n    with an rms of 1.4e-16 (n = 30000).\n\n    References\n    ----------\n    .. [1] C. W. Clenshaw, \"Chebyshev series for mathematical functions,\" in\n           *National Physical Laboratory Mathematical Tables*, vol. 5, London:\n           Her Majesty's Stationery Office, 1962.\n    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical\n           Functions*, 10th printing, New York: Dover, 1964, pp. 379.\n           http://www.math.sfu.ca/~cbm/aands/page_379.htm\n    .. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html\n\n    Examples\n    --------\n    >>> np.i0([0.])\n    array(1.0)\n    >>> np.i0([0., 1. + 2j])\n    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_219i0 = {"i0", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_219i0, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_218i0};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_219i0(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("i0 (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_218i0(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_218i0(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("i0", 0);

  /* "ga4py/gain/notimplemented.pyx":5625
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5625, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5572
 * 
 * 
 * def i0(x):             # <<<<<<<<<<<<<<
 *     """Modified Bessel function of the first kind, order 0.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.i0", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5628
 * 
 * 
 * def imag(val):             # <<<<<<<<<<<<<<
 *     """Return the imaginary part of the elements of the array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_221imag(PyObject *__pyx_self, PyObject *__pyx_v_val); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_220imag[] = "Return the imaginary part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, angle, real_if_close\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.imag\n    array([ 2.,  4.,  6.])\n    >>> a.imag = np.array([8, 10, 12])\n    >>> a\n    array([ 1. +8.j,  3.+10.j,  5.+12.j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_221imag = {"imag", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_221imag, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_220imag};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_221imag(PyObject *__pyx_self, PyObject *__pyx_v_val) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("imag (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_220imag(__pyx_self, ((PyObject *)__pyx_v_val));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_220imag(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("imag", 0);

  /* "ga4py/gain/notimplemented.pyx":5656
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5656, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5628
 * 
 * 
 * def imag(val):             # <<<<<<<<<<<<<<
 *     """Return the imaginary part of the elements of the array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.imag", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5659
 * 
 * 
 * def in1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Test whether each element of a 1D array is also present in a second array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_223in1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_222in1d[] = "Test whether each element of a 1D array is also present in a second array.\n\n    Returns a boolean array the same length as `ar1` that is True\n    where an element of `ar1` is in `ar2` and False otherwise.\n\n    Parameters\n    ----------\n    ar1 : array_like, shape (M,)\n        Input array.\n    ar2 : array_like\n        The values against which to test each value of `ar1`.\n    assume_unique : bool, optional\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    mask : ndarray of bools, shape(M,)\n        The values `ar1[mask]` are in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Notes\n    -----\n    `in1d` can be considered as an element-wise function version of the\n    python keyword `in`, for 1D sequences. ``in1d(a, b)`` is roughly\n    equivalent to ``np.array([item in b for item in a])``.\n\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> test = np.array([0, 1, 2, 5, 0])\n    >>> states = [0, 2]\n    >>> mask = np.in1d(test, states)\n    >>> mask\n    array([ True, False,  True, False,  True], dtype=bool)\n    >>> test[mask]\n    array([0, 2, 0])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_223in1d = {"in1d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_223in1d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_222in1d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_223in1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("in1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ar1,&__pyx_n_s_ar2,&__pyx_n_s_assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("in1d", 0, 2, 3, 1); __PYX_ERR(0, 5659, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "in1d") < 0)) __PYX_ERR(0, 5659, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("in1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5659, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.in1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_222in1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_222in1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("in1d", 0);

  /* "ga4py/gain/notimplemented.pyx":5704
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5704, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5659
 * 
 * 
 * def in1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Test whether each element of a 1D array is also present in a second array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.in1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5707
 * 
 * 
 * def indices(dimensions, dtype=int):             # <<<<<<<<<<<<<<
 *     """Return an array representing the indices of a grid.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_225indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_224indices[] = "Return an array representing the indices of a grid.\n\n    Compute an array where the subarrays contain index values 0,1,...\n    varying only along the corresponding axis.\n\n    Parameters\n    ----------\n    dimensions : sequence of ints\n        The shape of the grid.\n    dtype : dtype, optional\n        Data type of the result.\n\n    Returns\n    -------\n    grid : ndarray\n        The array of grid indices,\n        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n\n    See Also\n    --------\n    mgrid, meshgrid\n\n    Notes\n    -----\n    The output shape is obtained by prepending the number of dimensions\n    in front of the tuple of dimensions, i.e. if `dimensions` is a tuple\n    ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n    ``(N,r0,...,rN-1)``.\n\n    The subarrays ``grid[k]`` contains the N-D array of indices along the\n    ``k-th`` axis. Explicitly::\n\n        grid[k,i0,i1,...,iN-1] = ik\n\n    Examples\n    --------\n    >>> grid = np.indices((2, 3))\n    >>> grid.shape\n    (2, 2, 3)\n    >>> grid[0]        # row indices\n    array([[0, 0, 0],\n           [1, 1, 1]])\n    >>> grid[1]        # column indices\n    array([[0, 1, 2],\n           [0, 1, 2]])\n\n    The indices can be used as an index into an array.\n\n    >>> x = np.arange(20).reshape(5, 4)\n    >>> row, col = np.indices((2, 3))\n    >>> x[row, col]\n    array([[0, 1, 2],\n           [4, 5, 6]])\n\n    Note that it would be more straightforward in the above example to\n    extract the required elements directly with ``x[:2, :3]``.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_225indices = {"indices", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_225indices, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_224indices};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_225indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_dimensions = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_dimensions,&__pyx_n_s_dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k__11;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dimensions)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "indices") < 0)) __PYX_ERR(0, 5707, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_dimensions = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5707, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_224indices(__pyx_self, __pyx_v_dimensions, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_224indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_dimensions, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("indices", 0);

  /* "ga4py/gain/notimplemented.pyx":5766
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5766, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5707
 * 
 * 
 * def indices(dimensions, dtype=int):             # <<<<<<<<<<<<<<
 *     """Return an array representing the indices of a grid.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5769
 * 
 * 
 * def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):             # <<<<<<<<<<<<<<
 *     """Get help information for a function, class, or module.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_227info(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_226info[] = "Get help information for a function, class, or module.\n\n    Parameters\n    ----------\n    object : object or str, optional\n        Input object or name to get information about. If `object` is a\n        numpy object, its docstring is given. If it is a string, available\n        modules are searched for matching objects.\n        If None, information about `info` itself is returned.\n    maxwidth : int, optional\n        Printing width.\n    output : file like object, optional\n        File like object that the output is written to, default is ``stdout``.\n        The object has to be opened in 'w' or 'a' mode.\n    toplevel : str, optional\n        Start search at this level.\n\n    See Also\n    --------\n    source, lookfor\n\n    Notes\n    -----\n    When used interactively with an object, ``np.info(obj)`` is equivalent to\n    ``help(obj)`` on the Python prompt or ``obj?`` on the IPython prompt.\n\n    Examples\n    --------\n    >>> np.info(np.polyval) # doctest: +SKIP\n       polyval(p, x)\n         Evaluate the polynomial p at x.\n         ...\n\n    When using a string for `object` it is possible to get multiple results.\n\n    >>> np.info('fft') # doctest: +SKIP\n         *** Found in numpy ***\n    Core FFT routines\n    ...\n         *** Found in numpy.fft ***\n     fft(a, n=None, axis=-1)\n    ...\n         *** Repeat reference found in numpy.fft.fftpack ***\n         *** Total of 3 references found. ***\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_227info = {"info", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_227info, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_226info};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_227info(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_object = 0;
  CYTHON_UNUSED PyObject *__pyx_v_maxwidth = 0;
  CYTHON_UNUSED PyObject *__pyx_v_output = 0;
  CYTHON_UNUSED PyObject *__pyx_v_toplevel = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("info (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_object,&__pyx_n_s_maxwidth,&__pyx_n_s_output,&__pyx_n_s_toplevel,0};
    PyObject* values[4] = {0,0,0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)__pyx_int_76);
    values[2] = __pyx_k__12;
    values[3] = ((PyObject *)__pyx_n_s_numpy);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_object);
          if (value) { values[0] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_maxwidth);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_toplevel);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "info") < 0)) __PYX_ERR(0, 5769, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_object = values[0];
    __pyx_v_maxwidth = values[1];
    __pyx_v_output = values[2];
    __pyx_v_toplevel = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("info", 0, 0, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5769, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.info", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_226info(__pyx_self, __pyx_v_object, __pyx_v_maxwidth, __pyx_v_output, __pyx_v_toplevel);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_226info(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_maxwidth, CYTHON_UNUSED PyObject *__pyx_v_output, CYTHON_UNUSED PyObject *__pyx_v_toplevel) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("info", 0);

  /* "ga4py/gain/notimplemented.pyx":5816
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5816, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5769
 * 
 * 
 * def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):             # <<<<<<<<<<<<<<
 *     """Get help information for a function, class, or module.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.info", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5819
 * 
 * 
 * def inner(a, b):             # <<<<<<<<<<<<<<
 *     """inner(a, b)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_229inner(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_228inner[] = "inner(a, b)\n\n    Inner product of two arrays.\n\n    Ordinary inner product of vectors for 1-D arrays (without complex\n    conjugation), in higher dimensions a sum product over the last axes.\n\n    Parameters\n    ----------\n    a, b : array_like\n        If `a` and `b` are nonscalar, their last dimensions of must match.\n\n    Returns\n    -------\n    out : ndarray\n        `out.shape = a.shape[:-1] + b.shape[:-1]`\n\n    Raises\n    ------\n    ValueError\n        If the last dimension of `a` and `b` has different size.\n\n    See Also\n    --------\n    tensordot : Sum products over arbitrary axes.\n    dot : Generalised matrix product, using second last dimension of `b`.\n    einsum : Einstein summation convention.\n\n    Notes\n    -----\n    For vectors (1-D arrays) it computes the ordinary inner-product::\n\n        np.inner(a, b) = sum(a[:]*b[:])\n\n    More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::\n\n        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n    or explicitly::\n\n        np.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n             = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n    In addition `a` or `b` may be scalars, in which case::\n\n       np.inner(a,b) = a*b\n\n    Examples\n    --------\n    Ordinary inner product for vectors:\n\n    >>> a = np.array([1,2,3])\n    >>> b = np.array([0,1,0])\n    >>> np.inner(a, b)\n    2\n\n    A multidimensional example:\n\n    >>> a = np.arange(24).reshape((2,3,4))\n    >>> b = np.arange(4)\n    >>> np.inner(a, b)\n    array([[ 14,  38,  62],\n           [ 86, 110, 134]])\n\n    An example where `b` is a scalar:\n\n    >>> np.inner(np.eye(2), 7)\n    array([[ 7.,  0.],\n           [ 0.,  7.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_229inner = {"inner", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_229inner, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_228inner};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_229inner(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("inner (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("inner", 1, 2, 2, 1); __PYX_ERR(0, 5819, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "inner") < 0)) __PYX_ERR(0, 5819, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("inner", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5819, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.inner", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_228inner(__pyx_self, __pyx_v_a, __pyx_v_b);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_228inner(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("inner", 0);

  /* "ga4py/gain/notimplemented.pyx":5892
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5892, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5819
 * 
 * 
 * def inner(a, b):             # <<<<<<<<<<<<<<
 *     """inner(a, b)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.inner", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5895
 * 
 * 
 * def insert(arr, obj, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Insert values along the given axis before the given indices.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_231insert(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_230insert[] = "Insert values along the given axis before the given indices.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input array.\n    obj : int, slice or sequence of ints\n        Object that defines the index or indices before which `values` is\n        inserted.\n    values : array_like\n        Values to insert into `arr`. If the type of `values` is different\n        from that of `arr`, `values` is converted to the type of `arr`.\n    axis : int, optional\n        Axis along which to insert `values`.  If `axis` is None then `arr`\n        is flattened first.\n\n    Returns\n    -------\n    out : ndarray\n        A copy of `arr` with `values` inserted.  Note that `insert`\n        does not occur in-place: a new array is returned. If\n        `axis` is None, `out` is a flattened array.\n\n    See Also\n    --------\n    append : Append elements at the end of an array.\n    delete : Delete elements from an array.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 1], [2, 2], [3, 3]])\n    >>> a\n    array([[1, 1],\n           [2, 2],\n           [3, 3]])\n    >>> np.insert(a, 1, 5)\n    array([1, 5, 1, 2, 2, 3, 3])\n    >>> np.insert(a, 1, 5, axis=1)\n    array([[1, 5, 1],\n           [2, 5, 2],\n           [3, 5, 3]])\n\n    >>> b = a.flatten()\n    >>> b\n    array([1, 1, 2, 2, 3, 3])\n    >>> np.insert(b, [2, 2], [5, 6])\n    array([1, 1, 5, 6, 2, 2, 3, 3])\n\n    >>> np.insert(b, slice(2, 4), [5, 6])\n    array([1, 1, 5, 2, 6, 2, 3, 3])\n\n    >>> np.insert(b, [2, 2], [7.13, False]) # type casting\n    array([1, 1, 7, 0, 2, 2, 3, 3])\n\n    >>> x = np.arange(8).reshape(2, 4)\n    >>> idx = (1, 3)\n    >>> np.insert(x, idx, 999, axis=1)\n    array([[  0, 999,   1,   2, 999,   3],\n           [  4, 999,   5,   6, 999,   7]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_231insert = {"insert", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_231insert, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_230insert};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_231insert(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_obj = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("insert (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_obj,&__pyx_n_s_values,&__pyx_n_s_axis,0};
    PyObject* values[4] = {0,0,0,0};
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("insert", 0, 3, 4, 1); __PYX_ERR(0, 5895, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("insert", 0, 3, 4, 2); __PYX_ERR(0, 5895, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "insert") < 0)) __PYX_ERR(0, 5895, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_obj = values[1];
    __pyx_v_values = values[2];
    __pyx_v_axis = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("insert", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5895, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.insert", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_230insert(__pyx_self, __pyx_v_arr, __pyx_v_obj, __pyx_v_values, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_230insert(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_obj, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("insert", 0);

  /* "ga4py/gain/notimplemented.pyx":5957
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5957, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5895
 * 
 * 
 * def insert(arr, obj, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Insert values along the given axis before the given indices.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.insert", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5960
 * 
 * 
 * def int_asbuffer():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_233int_asbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_232int_asbuffer[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_233int_asbuffer = {"int_asbuffer", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_233int_asbuffer, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_232int_asbuffer};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_233int_asbuffer(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("int_asbuffer (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_232int_asbuffer(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_232int_asbuffer(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("int_asbuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":5965
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 5965, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5960
 * 
 * 
 * def int_asbuffer():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.int_asbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":5968
 * 
 * 
 * def interp(x, xp, fp, left=None, right=None):             # <<<<<<<<<<<<<<
 *     """One-dimensional linear interpolation.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_235interp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_234interp[] = "One-dimensional linear interpolation.\n\n    Returns the one-dimensional piecewise linear interpolant to a function\n    with given values at discrete data-points.\n\n    Parameters\n    ----------\n    x : array_like\n        The x-coordinates of the interpolated values.\n\n    xp : 1-D sequence of floats\n        The x-coordinates of the data points, must be increasing.\n\n    fp : 1-D sequence of floats\n        The y-coordinates of the data points, same length as `xp`.\n\n    left : float, optional\n        Value to return for `x < xp[0]`, default is `fp[0]`.\n\n    right : float, optional\n        Value to return for `x > xp[-1]`, defaults is `fp[-1]`.\n\n    Returns\n    -------\n    y : {float, ndarray}\n        The interpolated values, same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `xp` and `fp` have different length\n\n    Notes\n    -----\n    Does not check that the x-coordinate sequence `xp` is increasing.\n    If `xp` is not increasing, the results are nonsense.\n    A simple check for increasingness is::\n\n        np.all(np.diff(xp) > 0)\n\n\n    Examples\n    --------\n    >>> xp = [1, 2, 3]\n    >>> fp = [3, 2, 0]\n    >>> np.interp(2.5, xp, fp)\n    1.0\n    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\n    array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])\n    >>> UNDEF = -99.0\n    >>> np.interp(3.14, xp, fp, right=UNDEF)\n    -99.0\n\n    Plot an interpolant to the sine function:\n\n    >>> x = np.linspace(0, 2*np.pi, 10)\n    >>> y = np.sin(x)\n    >>> xvals = np.linspace(0, 2*np.pi, 50)\n    >>> yinterp = np.interp(xvals, x, y)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, y, 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(xvals, yinterp, '-x')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_235interp = {"interp", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_235interp, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_234interp};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_235interp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_xp = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fp = 0;
  CYTHON_UNUSED PyObject *__pyx_v_left = 0;
  CYTHON_UNUSED PyObject *__pyx_v_right = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("interp (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_xp,&__pyx_n_s_fp,&__pyx_n_s_left,&__pyx_n_s_right,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_xp)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("interp", 0, 3, 5, 1); __PYX_ERR(0, 5968, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fp)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("interp", 0, 3, 5, 2); __PYX_ERR(0, 5968, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_left);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_right);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "interp") < 0)) __PYX_ERR(0, 5968, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_xp = values[1];
    __pyx_v_fp = values[2];
    __pyx_v_left = values[3];
    __pyx_v_right = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("interp", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5968, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.interp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_234interp(__pyx_self, __pyx_v_x, __pyx_v_xp, __pyx_v_fp, __pyx_v_left, __pyx_v_right);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_234interp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_xp, CYTHON_UNUSED PyObject *__pyx_v_fp, CYTHON_UNUSED PyObject *__pyx_v_left, CYTHON_UNUSED PyObject *__pyx_v_right) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("interp", 0);

  /* "ga4py/gain/notimplemented.pyx":6036
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6036, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5968
 * 
 * 
 * def interp(x, xp, fp, left=None, right=None):             # <<<<<<<<<<<<<<
 *     """One-dimensional linear interpolation.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.interp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6039
 * 
 * 
 * def intersect1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the intersection of two arrays.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_237intersect1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_236intersect1d[] = "Find the intersection of two arrays.\n\n    Return the sorted, unique values that are in both of the input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    out : ndarray\n        Sorted 1D array of common and unique elements.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\n    array([1, 3])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_237intersect1d = {"intersect1d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_237intersect1d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_236intersect1d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_237intersect1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("intersect1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ar1,&__pyx_n_s_ar2,&__pyx_n_s_assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("intersect1d", 0, 2, 3, 1); __PYX_ERR(0, 6039, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "intersect1d") < 0)) __PYX_ERR(0, 6039, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("intersect1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6039, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.intersect1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_236intersect1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_236intersect1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("intersect1d", 0);

  /* "ga4py/gain/notimplemented.pyx":6068
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6068, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6039
 * 
 * 
 * def intersect1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the intersection of two arrays.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.intersect1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6071
 * 
 * 
 * def ipmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment portion for loan interest.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_239ipmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_238ipmt[] = "Not implemented. Compute the payment portion for loan interest.\n\n    Parameters\n    ----------\n    rate : scalar or array_like of shape(M, )\n        Rate of interest as decimal (not per cent) per period\n    per : scalar or array_like of shape(M, )\n        Interest paid against the loan changes during the life or the loan.\n        The `per` is the payment period to calculate the interest amount.\n    nper : scalar or array_like of shape(M, )\n        Number of compounding periods\n    pv : scalar or array_like of shape(M, )\n        Present value\n    fv : scalar or array_like of shape(M, ), optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0)).\n        Defaults to {'end', 0}.\n\n    Returns\n    -------\n    out : ndarray\n        Interest portion of payment.  If all input is scalar, returns a scalar\n        float.  If any input is array_like, returns interest payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    See Also\n    --------\n    ppmt, pmt, pv\n\n    Notes\n    -----\n    The total payment is made up of payment against principal plus interest.\n\n    ``pmt = ppmt + ipmt``\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_239ipmt = {"ipmt", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_239ipmt, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_238ipmt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_239ipmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_per = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ipmt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rate,&__pyx_n_s_per,&__pyx_n_s_nper,&__pyx_n_s_pv,&__pyx_n_s_fv,&__pyx_n_s_when,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_float_0_0);
    values[5] = ((PyObject *)__pyx_n_s_end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_per)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, 1); __PYX_ERR(0, 6071, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, 2); __PYX_ERR(0, 6071, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, 3); __PYX_ERR(0, 6071, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fv);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_when);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ipmt") < 0)) __PYX_ERR(0, 6071, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_per = values[1];
    __pyx_v_nper = values[2];
    __pyx_v_pv = values[3];
    __pyx_v_fv = values[4];
    __pyx_v_when = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ipmt", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6071, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ipmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_238ipmt(__pyx_self, __pyx_v_rate, __pyx_v_per, __pyx_v_nper, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_238ipmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ipmt", 0);

  /* "ga4py/gain/notimplemented.pyx":6110
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6110, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6071
 * 
 * 
 * def ipmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment portion for loan interest.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ipmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6113
 * 
 * 
 * def irr(values):             # <<<<<<<<<<<<<<
 *     """Return the Internal Rate of Return (IRR).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_241irr(PyObject *__pyx_self, PyObject *__pyx_v_values); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_240irr[] = "Return the Internal Rate of Return (IRR).\n\n    This is the \"average\" periodically compounded rate of return\n    that gives a net present value of 0.0; for a more complete explanation,\n    see Notes below.\n\n    Parameters\n    ----------\n    values : array_like, shape(N,)\n        Input cash flows per time period.  By convention, net \"deposits\"\n        are negative and net \"withdrawals\" are positive.  Thus, for example,\n        at least the first element of `values`, which represents the initial\n        investment, will typically be negative.\n\n    Returns\n    -------\n    out : float\n        Internal Rate of Return for periodic input values.\n\n    Notes\n    -----\n    The IRR is perhaps best understood through an example (illustrated\n    using np.irr in the Examples section below).  Suppose one invests\n    100 units and then makes the following withdrawals at regular\n    (fixed) intervals: 39, 59, 55, 20.  Assuming the ending value is 0,\n    one's 100 unit investment yields 173 units; however, due to the\n    combination of compounding and the periodic withdrawals, the\n    \"average\" rate of return is neither simply 0.73/4 nor (1.73)^0.25-1.\n    Rather, it is the solution (for :math:`r`) of the equation:\n\n    .. math:: -100 + \014rac{39}{1+r} + \014rac{59}{(1+r)^2}\n     + \014rac{55}{(1+r)^3} + \014rac{20}{(1+r)^4} = 0\n\n    In general, for `values` :math:`= [v_0, v_1, ... v_M]`,\n    irr is the solution of the equation: [G]_\n\n    .. math:: \\sum_{t=0}^M{\014rac{v_t}{(1+irr)^{t}}} = 0\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 348.\n\n    Examples\n    --------\n    >>> np.irr([-100, 39, 59, 55, 20])\n    0.2809484211599611\n\n    (Compare with the Example given for numpy.lib.financial.npv)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_241irr = {"irr", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_241irr, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_240irr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_241irr(PyObject *__pyx_self, PyObject *__pyx_v_values) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("irr (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_240irr(__pyx_self, ((PyObject *)__pyx_v_values));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_240irr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("irr", 0);

  /* "ga4py/gain/notimplemented.pyx":6165
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6165, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6113
 * 
 * 
 * def irr(values):             # <<<<<<<<<<<<<<
 *     """Return the Internal Rate of Return (IRR).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.irr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6168
 * 
 * 
 * def iscomplex(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is complex.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_243iscomplex(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_242iscomplex[] = "Returns a bool array, where True if input element is complex.\n\n    What is tested is whether the input has a non-zero imaginary part, not if\n    the input type is complex.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray of bools\n        Output array.\n\n    See Also\n    --------\n    isreal\n    iscomplexobj : Return True if x is a complex type or an array of complex\n                   numbers.\n\n    Examples\n    --------\n    >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([ True, False, False, False, False,  True], dtype=bool)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_243iscomplex = {"iscomplex", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_243iscomplex, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_242iscomplex};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_243iscomplex(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iscomplex (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_242iscomplex(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_242iscomplex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iscomplex", 0);

  /* "ga4py/gain/notimplemented.pyx":6196
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6196, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6168
 * 
 * 
 * def iscomplex(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is complex.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.iscomplex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6199
 * 
 * 
 * def iscomplexobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a complex type or an array of complex numbers.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_245iscomplexobj(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_244iscomplexobj[] = "Return True if x is a complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `iscomplexobj` evaluates to True\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, True if `x` is of a complex type.\n\n    See Also\n    --------\n    isrealobj, iscomplex\n\n    Examples\n    --------\n    >>> np.iscomplexobj(1)\n    False\n    >>> np.iscomplexobj(1+0j)\n    True\n    >>> np.iscomplexobj([3, 1+0j, True])\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_245iscomplexobj = {"iscomplexobj", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_245iscomplexobj, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_244iscomplexobj};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_245iscomplexobj(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iscomplexobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_244iscomplexobj(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_244iscomplexobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iscomplexobj", 0);

  /* "ga4py/gain/notimplemented.pyx":6230
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6230, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6199
 * 
 * 
 * def iscomplexobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a complex type or an array of complex numbers.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.iscomplexobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6233
 * 
 * 
 * def isfortran(a):             # <<<<<<<<<<<<<<
 *     """Returns True if array is arranged in Fortran-order in memory
 *     and dimension > 1.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_247isfortran(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_246isfortran[] = "Returns True if array is arranged in Fortran-order in memory\n    and dimension > 1.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n\n    Examples\n    --------\n\n    np.array allows to specify whether the array is written in C-contiguous\n    order (last index varies the fastest), or FORTRAN-contiguous order in\n    memory (first index varies the fastest).\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')\n    >>> b\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(b)\n    True\n\n\n    The transpose of a C-ordered array is a FORTRAN-ordered array.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n    >>> b = a.T\n    >>> b\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.isfortran(b)\n    True\n\n    1-D arrays always evaluate as False.\n\n    >>> np.isfortran(np.array([1, 2], order='FORTRAN'))\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_247isfortran = {"isfortran", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_247isfortran, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_246isfortran};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_247isfortran(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isfortran (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_246isfortran(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_246isfortran(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isfortran", 0);

  /* "ga4py/gain/notimplemented.pyx":6287
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6287, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6233
 * 
 * 
 * def isfortran(a):             # <<<<<<<<<<<<<<
 *     """Returns True if array is arranged in Fortran-order in memory
 *     and dimension > 1.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isfortran", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6290
 * 
 * 
 * def isneginf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for negative infinity, return result as bool array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_249isneginf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_248isneginf[] = "Test element-wise for negative infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape and type as `x` to store the\n        result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a numpy boolean array is\n        returned with values True where the corresponding element of the\n        input is negative infinity and values False where the element of\n        the input is not negative infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as\n        zeros and ones, if the type is boolean then as False and True. The\n        return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isposinf, isnan, isfinite\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when x is a scalar\n    input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isneginf(np.NINF)\n    array(True, dtype=bool)\n    >>> np.isneginf(np.inf)\n    array(False, dtype=bool)\n    >>> np.isneginf(np.PINF)\n    array(False, dtype=bool)\n    >>> np.isneginf([-np.inf, 0., np.inf])\n    array([ True, False, False], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isneginf(x, y)\n    array([1, 0, 0])\n    >>> y\n    array([1, 0, 0])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_249isneginf = {"isneginf", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_249isneginf, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_248isneginf};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_249isneginf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isneginf (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isneginf") < 0)) __PYX_ERR(0, 6290, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isneginf", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6290, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isneginf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_248isneginf(__pyx_self, __pyx_v_x, __pyx_v_y);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_248isneginf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isneginf", 0);

  /* "ga4py/gain/notimplemented.pyx":6346
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6346, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6290
 * 
 * 
 * def isneginf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for negative infinity, return result as bool array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isneginf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6349
 * 
 * 
 * def isposinf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for positive infinity, return result as bool array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_251isposinf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_250isposinf[] = "Test element-wise for positive infinity, return result as bool array.\n\n    Parameters\n    ----------\n    x : array_like\n        The input array.\n    y : array_like, optional\n        A boolean array with the same shape as `x` to store the result.\n\n    Returns\n    -------\n    y : ndarray\n        A boolean array with the same dimensions as the input.\n        If second argument is not supplied then a boolean array is returned\n        with values True where the corresponding element of the input is\n        positive infinity and values False where the element of the input is\n        not positive infinity.\n\n        If a second argument is supplied the result is stored there. If the\n        type of that array is a numeric type the result is represented as zeros\n        and ones, if the type is boolean then as False and True.\n        The return value `y` is then a reference to that array.\n\n    See Also\n    --------\n    isinf, isneginf, isfinite, isnan\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754).\n\n    Errors result if the second argument is also supplied when `x` is a\n    scalar input, or if first and second arguments have different shapes.\n\n    Examples\n    --------\n    >>> np.isposinf(np.PINF)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.inf)\n    array(True, dtype=bool)\n    >>> np.isposinf(np.NINF)\n    array(False, dtype=bool)\n    >>> np.isposinf([-np.inf, 0., np.inf])\n    array([False, False,  True], dtype=bool)\n\n    >>> x = np.array([-np.inf, 0., np.inf])\n    >>> y = np.array([2, 2, 2])\n    >>> np.isposinf(x, y)\n    array([0, 0, 1])\n    >>> y\n    array([0, 0, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_251isposinf = {"isposinf", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_251isposinf, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_250isposinf};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_251isposinf(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isposinf (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "isposinf") < 0)) __PYX_ERR(0, 6349, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("isposinf", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6349, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isposinf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_250isposinf(__pyx_self, __pyx_v_x, __pyx_v_y);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_250isposinf(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isposinf", 0);

  /* "ga4py/gain/notimplemented.pyx":6404
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6404, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6349
 * 
 * 
 * def isposinf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for positive infinity, return result as bool array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isposinf", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6407
 * 
 * 
 * def isreal(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is real.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_253isreal(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_252isreal[] = "Returns a bool array, where True if input element is real.\n\n    If element has complex type with zero complex part, the return value\n    for that element is True.\n\n    Parameters\n    ----------\n    x : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray, bool\n        Boolean array of same shape as `x`.\n\n    See Also\n    --------\n    iscomplex\n    isrealobj : Return True if x is not a complex type.\n\n    Examples\n    --------\n    >>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\n    array([False,  True,  True,  True,  True, False], dtype=bool)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_253isreal = {"isreal", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_253isreal, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_252isreal};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_253isreal(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isreal (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_252isreal(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_252isreal(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isreal", 0);

  /* "ga4py/gain/notimplemented.pyx":6434
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6434, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6407
 * 
 * 
 * def isreal(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is real.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isreal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6437
 * 
 * 
 * def isrealobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a not complex type or an array of complex numbers.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_255isrealobj(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_254isrealobj[] = "Return True if x is a not complex type or an array of complex numbers.\n\n    The type of the input is checked, not the value. So even if the input\n    has an imaginary part equal to zero, `isrealobj` evaluates to False\n    if the data type is complex.\n\n    Parameters\n    ----------\n    x : any\n        The input can be of any type and shape.\n\n    Returns\n    -------\n    y : bool\n        The return value, False if `x` is of a complex type.\n\n    See Also\n    --------\n    iscomplexobj, isreal\n\n    Examples\n    --------\n    >>> np.isrealobj(1)\n    True\n    >>> np.isrealobj(1+0j)\n    False\n    >>> np.isrealobj([3, 1+0j, True])\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_255isrealobj = {"isrealobj", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_255isrealobj, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_254isrealobj};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_255isrealobj(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isrealobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_254isrealobj(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_254isrealobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isrealobj", 0);

  /* "ga4py/gain/notimplemented.pyx":6468
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6468, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6437
 * 
 * 
 * def isrealobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a not complex type or an array of complex numbers.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isrealobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6471
 * 
 * 
 * def isscalar(num):             # <<<<<<<<<<<<<<
 *     """Returns True if the type of `num` is a scalar type.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_257isscalar(PyObject *__pyx_self, PyObject *__pyx_v_num); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_256isscalar[] = "Returns True if the type of `num` is a scalar type.\n\n    Parameters\n    ----------\n    num : any\n        Input argument, can be of any type and shape.\n\n    Returns\n    -------\n    val : bool\n        True if `num` is a scalar type, False if it is not.\n\n    Examples\n    --------\n    >>> np.isscalar(3.1)\n    True\n    >>> np.isscalar([3.1])\n    False\n    >>> np.isscalar(False)\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_257isscalar = {"isscalar", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_257isscalar, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_256isscalar};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_257isscalar(PyObject *__pyx_self, PyObject *__pyx_v_num) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isscalar (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_256isscalar(__pyx_self, ((PyObject *)__pyx_v_num));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_256isscalar(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_num) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isscalar", 0);

  /* "ga4py/gain/notimplemented.pyx":6494
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6494, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6471
 * 
 * 
 * def isscalar(num):             # <<<<<<<<<<<<<<
 *     """Returns True if the type of `num` is a scalar type.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.isscalar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6497
 * 
 * 
 * def issctype(rep):             # <<<<<<<<<<<<<<
 *     """Determines whether the given object represents a scalar data-type.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_259issctype(PyObject *__pyx_self, PyObject *__pyx_v_rep); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_258issctype[] = "Determines whether the given object represents a scalar data-type.\n\n    Parameters\n    ----------\n    rep : any\n        If `rep` is an instance of a scalar dtype, True is returned. If not,\n        False is returned.\n\n    Returns\n    -------\n    out : bool\n        Boolean result of check whether `rep` is a scalar dtype.\n\n    See Also\n    --------\n    issubsctype, issubdtype, obj2sctype, sctype2char\n\n    Examples\n    --------\n    >>> np.issctype(np.int32)\n    True\n    >>> np.issctype(list)\n    False\n    >>> np.issctype(1.1)\n    False\n\n    Strings are also a scalar type:\n\n    >>> np.issctype(np.dtype('str'))\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_259issctype = {"issctype", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_259issctype, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_258issctype};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_259issctype(PyObject *__pyx_self, PyObject *__pyx_v_rep) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issctype (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_258issctype(__pyx_self, ((PyObject *)__pyx_v_rep));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_258issctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issctype", 0);

  /* "ga4py/gain/notimplemented.pyx":6530
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6530, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6497
 * 
 * 
 * def issctype(rep):             # <<<<<<<<<<<<<<
 *     """Determines whether the given object represents a scalar data-type.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6533
 * 
 * 
 * def issubclass_(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if a class is a subclass of a second class.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_261issubclass_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_260issubclass_[] = "Determine if a class is a subclass of a second class.\n\n    `issubclass_` is equivalent to the Python built-in ``issubclass``,\n    except that it returns False instead of raising a TypeError is one\n    of the arguments is not a class.\n\n    Parameters\n    ----------\n    arg1 : class\n        Input class. True is returned if `arg1` is a subclass of `arg2`.\n    arg2 : class or tuple of classes.\n        Input class. If a tuple of classes, True is returned if `arg1` is a\n        subclass of any of the tuple elements.\n\n    Returns\n    -------\n    out : bool\n        Whether `arg1` is a subclass of `arg2` or not.\n\n    See Also\n    --------\n    issubsctype, issubdtype, issctype\n\n    Examples\n    --------\n    >>> np.issubclass_(np.int32, np.int)\n    True\n    >>> np.issubclass_(np.int32, np.float)\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_261issubclass_ = {"issubclass_", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_261issubclass_, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_260issubclass_};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_261issubclass_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arg1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arg2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubclass_ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arg1,&__pyx_n_s_arg2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arg1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arg2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("issubclass_", 1, 2, 2, 1); __PYX_ERR(0, 6533, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "issubclass_") < 0)) __PYX_ERR(0, 6533, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_arg1 = values[0];
    __pyx_v_arg2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("issubclass_", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6533, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubclass_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_260issubclass_(__pyx_self, __pyx_v_arg1, __pyx_v_arg2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_260issubclass_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubclass_", 0);

  /* "ga4py/gain/notimplemented.pyx":6565
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6565, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6533
 * 
 * 
 * def issubclass_(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if a class is a subclass of a second class.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubclass_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6568
 * 
 * 
 * def issubdtype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Returns True if first argument is a typecode lower/equal in type hierarchy.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_263issubdtype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_262issubdtype[] = "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype_like\n        dtype or string representing a typecode.\n\n    Returns\n    -------\n    out : bool\n\n    See Also\n    --------\n    issubsctype, issubclass_\n    numpy.core.numerictypes : Overview of numpy type hierarchy.\n\n    Examples\n    --------\n    >>> np.issubdtype('S1', str)\n    True\n    >>> np.issubdtype(np.float64, np.float32)\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_263issubdtype = {"issubdtype", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_263issubdtype, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_262issubdtype};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_263issubdtype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arg1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arg2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubdtype (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arg1,&__pyx_n_s_arg2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arg1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arg2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("issubdtype", 1, 2, 2, 1); __PYX_ERR(0, 6568, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "issubdtype") < 0)) __PYX_ERR(0, 6568, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_arg1 = values[0];
    __pyx_v_arg2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("issubdtype", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6568, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubdtype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_262issubdtype(__pyx_self, __pyx_v_arg1, __pyx_v_arg2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_262issubdtype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubdtype", 0);

  /* "ga4py/gain/notimplemented.pyx":6593
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6593, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6568
 * 
 * 
 * def issubdtype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Returns True if first argument is a typecode lower/equal in type hierarchy.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubdtype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6596
 * 
 * 
 * def issubsctype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if the first argument is a subclass of the second argument.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_265issubsctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_264issubsctype[] = "Determine if the first argument is a subclass of the second argument.\n\n    Parameters\n    ----------\n    arg1, arg2 : dtype or dtype specifier\n        Data-types.\n\n    Returns\n    -------\n    out : bool\n        The result.\n\n    See Also\n    --------\n    issctype, issubdtype,obj2sctype\n\n    Examples\n    --------\n    >>> np.issubsctype('S8', str)\n    True\n    >>> np.issubsctype(np.array([1]), np.int)\n    True\n    >>> np.issubsctype(np.array([1]), np.float)\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_265issubsctype = {"issubsctype", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_265issubsctype, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_264issubsctype};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_265issubsctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arg1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arg2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubsctype (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arg1,&__pyx_n_s_arg2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arg1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arg2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("issubsctype", 1, 2, 2, 1); __PYX_ERR(0, 6596, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "issubsctype") < 0)) __PYX_ERR(0, 6596, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_arg1 = values[0];
    __pyx_v_arg2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("issubsctype", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6596, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubsctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_264issubsctype(__pyx_self, __pyx_v_arg1, __pyx_v_arg2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_264issubsctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arg1, CYTHON_UNUSED PyObject *__pyx_v_arg2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("issubsctype", 0);

  /* "ga4py/gain/notimplemented.pyx":6623
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6623, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6596
 * 
 * 
 * def issubsctype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if the first argument is a subclass of the second argument.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.issubsctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6626
 * 
 * 
 * def iterable(y):             # <<<<<<<<<<<<<<
 *     """Check whether or not an object can be iterated over.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_267iterable(PyObject *__pyx_self, PyObject *__pyx_v_y); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_266iterable[] = "Check whether or not an object can be iterated over.\n\n    Parameters\n    ----------\n    y : object\n      Input object.\n\n    Returns\n    -------\n    b : {0, 1}\n      Return 1 if the object has an iterator method or is a sequence,\n      and 0 otherwise.\n\n\n    Examples\n    --------\n    >>> np.iterable([1, 2, 3])\n    1\n    >>> np.iterable(2)\n    0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_267iterable = {"iterable", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_267iterable, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_266iterable};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_267iterable(PyObject *__pyx_self, PyObject *__pyx_v_y) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iterable (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_266iterable(__pyx_self, ((PyObject *)__pyx_v_y));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_266iterable(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("iterable", 0);

  /* "ga4py/gain/notimplemented.pyx":6649
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6649, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6626
 * 
 * 
 * def iterable(y):             # <<<<<<<<<<<<<<
 *     """Check whether or not an object can be iterated over.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.iterable", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6652
 * 
 * 
 * def ix_():             # <<<<<<<<<<<<<<
 *     """Construct an open mesh from multiple sequences.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_269ix_(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_268ix_[] = "Construct an open mesh from multiple sequences.\n\n    This function takes N 1-D sequences and returns N outputs with N\n    dimensions each, such that the shape is 1 in all but one dimension\n    and the dimension with the non-unit shape value cycles through all\n    N dimensions.\n\n    Using `ix_` one can quickly construct index arrays that will index\n    the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array\n    ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.\n\n    Parameters\n    ----------\n    args : 1-D sequences\n\n    Returns\n    -------\n    out : tuple of ndarrays\n        N arrays with N dimensions each, with N the number of input\n        sequences. Together these arrays form an open mesh.\n\n    See Also\n    --------\n    ogrid, mgrid, meshgrid\n\n    Examples\n    --------\n    >>> a = np.arange(10).reshape(2, 5)\n    >>> a\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> ixgrid = np.ix_([0,1], [2,4])\n    >>> ixgrid\n    (array([[0],\n           [1]]), array([[2, 4]]))\n    >>> ixgrid[0].shape, ixgrid[1].shape\n    ((2, 1), (1, 2))\n    >>> a[ixgrid]\n    array([[2, 4],\n           [7, 9]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_269ix_ = {"ix_", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_269ix_, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_268ix_};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_269ix_(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ix_ (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_268ix_(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_268ix_(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ix_", 0);

  /* "ga4py/gain/notimplemented.pyx":6695
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6695, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6652
 * 
 * 
 * def ix_():             # <<<<<<<<<<<<<<
 *     """Construct an open mesh from multiple sequences.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ix_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6698
 * 
 * 
 * def kaiser(M, beta):             # <<<<<<<<<<<<<<
 *     """Return the Kaiser window.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_271kaiser(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_270kaiser[] = "Return the Kaiser window.\n\n    The Kaiser window is a taper formed by using a Bessel function.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an\n        empty array is returned.\n    beta : float\n        Shape parameter for window.\n\n    Returns\n    -------\n    out : array\n        The window, normalized to one (the value one\n        appears only if the number of samples is odd).\n\n    See Also\n    --------\n    bartlett, blackman, hamming, hanning\n\n    Notes\n    -----\n    The Kaiser window is defined as\n\n    .. math::  w(n) = I_0\\left( \010eta \\sqrt{1-\014rac{4n^2}{(M-1)^2}}\n               \right)/I_0(\010eta)\n\n    with\n\n    .. math:: \\quad -\014rac{M-1}{2} \\leq n \\leq \014rac{M-1}{2},\n\n    where :math:`I_0` is the modified zeroth-order Bessel function.\n\n    The Kaiser was named for Jim Kaiser, who discovered a simple approximation\n    to the DPSS window based on Bessel functions.\n    The Kaiser window is a very good approximation to the Digital Prolate\n    Spheroidal Sequence, or Slepian window, which is the transform which\n    maximizes the energy in the main lobe of the window relative to total\n    energy.\n\n    The Kaiser can approximate many other windows by varying the beta\n    parameter.\n\n    ====  =======================\n    beta  Window shape\n    ====  =======================\n    0     Rectangular\n    5     Similar to a Hamming\n    6     Similar to a Hanning\n    8.6   Similar to a Blackman\n    ====  =======================\n\n    A beta value of 14 is probably a good starting point. Note that as beta\n    gets large, the window narrows, and so the number of samples needs to be\n    large enough to sample the increasingly narrow spike, otherwise nans will\n    get returned.\n\n\n    Most references to the Kaiser window come from the signal processing\n    literature, where it is used as one of many windowing functions for\n    smoothing values.  It"" is also known as an apodization (which means\n    \"removing the foot\", i.e. smoothing discontinuities at the beginning\n    and end of the sampled signal) or tapering function.\n\n    References\n    ----------\n    .. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n           digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n           John Wiley and Sons, New York, (1966).\n    .. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n           University of Alberta Press, 1975, pp. 177-178.\n    .. [3] Wikipedia, \"Window function\",\n           http://en.wikipedia.org/wiki/Window_function\n\n    Examples\n    --------\n    >>> from numpy import kaiser\n    >>> kaiser(12, 14)\n    array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,\n             2.29737120e-01,   5.99885316e-01,   9.45674898e-01,\n             9.45674898e-01,   5.99885316e-01,   2.29737120e-01,\n             4.65200189e-02,   3.46009194e-03,   7.72686684e-06])\n\n\n    Plot the window and the frequency response:\n\n    >>> from numpy import clip, log10, array, kaiser, linspace\n    >>> from numpy.fft import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = kaiser(51, 14)\n    >>> plt.plot(window)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Kaiser window\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Sample\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    >>> plt.figure()\n    <matplotlib.figure.Figure object at 0x...>\n    >>> A = fft(window, 2048) / 25.5\n    >>> mag = abs(fftshift(A))\n    >>> freq = linspace(-0.5,0.5,len(A))\n    >>> response = 20*log10(mag)\n    >>> response = clip(response,-100,100)\n    >>> plt.plot(freq, response)\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Frequency response of Kaiser window\")\n    <matplot""lib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Magnitude [dB]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.axis('tight')\n    (-0.5, 0.5, -100.0, ...)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_271kaiser = {"kaiser", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_271kaiser, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_270kaiser};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_271kaiser(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_M = 0;
  CYTHON_UNUSED PyObject *__pyx_v_beta = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("kaiser (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_M,&__pyx_n_s_beta,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_M)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_beta)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("kaiser", 1, 2, 2, 1); __PYX_ERR(0, 6698, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "kaiser") < 0)) __PYX_ERR(0, 6698, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_M = values[0];
    __pyx_v_beta = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("kaiser", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6698, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kaiser", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_270kaiser(__pyx_self, __pyx_v_M, __pyx_v_beta);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_270kaiser(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_beta) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("kaiser", 0);

  /* "ga4py/gain/notimplemented.pyx":6822
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6822, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6698
 * 
 * 
 * def kaiser(M, beta):             # <<<<<<<<<<<<<<
 *     """Return the Kaiser window.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kaiser", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6825
 * 
 * 
 * def kron(a, b):             # <<<<<<<<<<<<<<
 *     """Kronecker product of two arrays.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_273kron(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_272kron[] = "Kronecker product of two arrays.\n\n    Computes the Kronecker product, a composite array made of blocks of the\n    second array scaled by the first.\n\n    Parameters\n    ----------\n    a, b : array_like\n\n    Returns\n    -------\n    out : ndarray\n\n    See Also\n    --------\n\n    outer : The outer product\n\n    Notes\n    -----\n\n    The function assumes that the number of dimenensions of `a` and `b`\n    are the same, if necessary prepending the smallest with ones.\n    If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,\n    the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.\n    The elements are products of elements from `a` and `b`, organized\n    explicitly by::\n\n        kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n    where::\n\n        kt = it * st + jt,  t = 0,...,N\n\n    In the common 2-D case (N=1), the block structure can be visualized::\n\n        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n         [  ...                              ...   ],\n         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\n    Examples\n    --------\n    >>> np.kron([1,10,100], [5,6,7])\n    array([  5,   6,   7,  50,  60,  70, 500, 600, 700])\n    >>> np.kron([5,6,7], [1,10,100])\n    array([  5,  50, 500,   6,  60, 600,   7,  70, 700])\n\n    >>> np.kron(np.eye(2), np.ones((2,2)))\n    array([[ 1.,  1.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.],\n           [ 0.,  0.,  1.,  1.],\n           [ 0.,  0.,  1.,  1.]])\n\n    >>> a = np.arange(100).reshape((2,5,2,5))\n    >>> b = np.arange(24).reshape((2,3,4))\n    >>> c = np.kron(a,b)\n    >>> c.shape\n    (2, 10, 6, 20)\n    >>> I = (1,3,0,2)\n    >>> J = (0,2,1)\n    >>> J1 = (0,) + J             # extend to ndim=4\n    >>> S1 = (1,) + b.shape\n    >>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n    >>> c[K] == a[I]*b[J]\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_273kron = {"kron", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_273kron, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_272kron};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_273kron(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("kron (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("kron", 1, 2, 2, 1); __PYX_ERR(0, 6825, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "kron") < 0)) __PYX_ERR(0, 6825, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("kron", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6825, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kron", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_272kron(__pyx_self, __pyx_v_a, __pyx_v_b);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_272kron(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("kron", 0);

  /* "ga4py/gain/notimplemented.pyx":6894
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6894, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6825
 * 
 * 
 * def kron(a, b):             # <<<<<<<<<<<<<<
 *     """Kronecker product of two arrays.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.kron", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6897
 * 
 * 
 * def lexsort(keys, axis=-1):             # <<<<<<<<<<<<<<
 *     """lexsort(keys, axis=-1)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_275lexsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_274lexsort[] = "lexsort(keys, axis=-1)\n\n    Perform an indirect sort using a sequence of keys.\n\n    Given multiple sorting keys, which can be interpreted as columns in a\n    spreadsheet, lexsort returns an array of integer indices that describes\n    the sort order by multiple columns. The last key in the sequence is used\n    for the primary sort order, the second-to-last key for the secondary sort\n    order, and so on. The keys argument must be a sequence of objects that\n    can be converted to arrays of the same shape. If a 2D array is provided\n    for the keys argument, it's rows are interpreted as the sorting keys and\n    sorting is according to the last row, second last row etc.\n\n    Parameters\n    ----------\n    keys : (k,N) array or tuple containing k (N,)-shaped sequences\n        The `k` different \"columns\" to be sorted.  The last column (or row if\n        `keys` is a 2D array) is the primary sort key.\n    axis : int, optional\n        Axis to be indirectly sorted.  By default, sort over the last axis.\n\n    Returns\n    -------\n    indices : (N,) ndarray of ints\n        Array of indices that sort the keys along the specified axis.\n\n    See Also\n    --------\n    argsort : Indirect sort.\n    ndarray.sort : In-place sort.\n    sort : Return a sorted copy of an array.\n\n    Examples\n    --------\n    Sort names: first by surname, then by name.\n\n    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')\n    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')\n    >>> ind = np.lexsort((first_names, surnames))\n    >>> ind\n    array([1, 2, 0])\n\n    >>> [surnames[i] + \", \" + first_names[i] for i in ind]\n    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n    Sort two columns of numbers:\n\n    >>> a = [1,5,1,4,3,4,4] # First column\n    >>> b = [9,4,0,4,0,2,1] # Second column\n    >>> ind = np.lexsort((b,a)) # Sort by a, then by b\n    >>> print ind\n    [2 0 4 6 5 3 1]\n\n    >>> [(a[i],b[i]) for i in ind]\n    [(1, 0), (1, 9), (3, 0)"", (4, 1), (4, 2), (4, 4), (5, 4)]\n\n    Note that sorting is first according to the elements of ``a``.\n    Secondary sorting is according to the elements of ``b``.\n\n    A normal ``argsort`` would have yielded:\n\n    >>> [(a[i],b[i]) for i in np.argsort(a)]\n    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n\n    Structured arrays are sorted lexically by ``argsort``:\n\n    >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n    ...              dtype=np.dtype([('x', int), ('y', int)]))\n\n    >>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))\n    array([2, 0, 4, 6, 5, 3, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_275lexsort = {"lexsort", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_275lexsort, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_274lexsort};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_275lexsort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_keys = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lexsort (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_keys,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_keys)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lexsort") < 0)) __PYX_ERR(0, 6897, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_keys = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("lexsort", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6897, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lexsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_274lexsort(__pyx_self, __pyx_v_keys, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_274lexsort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_keys, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lexsort", 0);

  /* "ga4py/gain/notimplemented.pyx":6972
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 6972, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6897
 * 
 * 
 * def lexsort(keys, axis=-1):             # <<<<<<<<<<<<<<
 *     """lexsort(keys, axis=-1)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lexsort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":6975
 * 
 * 
 * def load(file, mmap_mode=None):             # <<<<<<<<<<<<<<
 *     """Load a pickled, ``.npy``, or ``.npz`` binary file.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_277load(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_276load[] = "Load a pickled, ``.npy``, or ``.npz`` binary file.\n\n    Parameters\n    ----------\n    file : file-like object or string\n        The file to read.  It must support ``seek()`` and ``read()`` methods.\n        If the filename extension is ``.gz``, the file is first decompressed.\n    mmap_mode: {None, 'r+', 'r', 'w+', 'c'}, optional\n        If not None, then memory-map the file, using the given mode\n        (see `numpy.memmap`).  The mode has no effect for pickled or\n        zipped files.\n        A memory-mapped array is stored on disk, and not directly loaded\n        into memory.  However, it can be accessed and sliced like any\n        ndarray.  Memory mapping is especially useful for accessing\n        small fragments of large files without reading the entire file\n        into memory.\n\n    Returns\n    -------\n    result : array, tuple, dict, etc.\n        Data stored in the file.\n\n    Raises\n    ------\n    IOError\n        If the input file does not exist or cannot be read.\n\n    See Also\n    --------\n    save, savez, loadtxt\n    memmap : Create a memory-map to an array stored in a file on disk.\n\n    Notes\n    -----\n    - If the file contains pickle data, then whatever is stored in the\n      pickle is returned.\n    - If the file is a ``.npy`` file, then an array is returned.\n    - If the file is a ``.npz`` file, then a dictionary-like object is\n      returned, containing ``{filename: array}`` key-value pairs, one for\n      each file in the archive.\n\n    Examples\n    --------\n    Store data to disk, and load it again:\n\n    >>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n    >>> np.load('/tmp/123.npy')\n    array([[1, 2, 3],\n           [4, 5, 6]])\n\n    Mem-map the stored array, and then access the second row\n    directly from disk:\n\n    >>> X = np.load('/tmp/123.npy', mmap_mode='r')\n    >>> X[1, :]\n    memmap([4, 5, 6])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_277load = {"load", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_277load, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_276load};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_277load(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mmap_mode = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("load (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_file,&__pyx_n_s_mmap_mode,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mmap_mode);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "load") < 0)) __PYX_ERR(0, 6975, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_file = values[0];
    __pyx_v_mmap_mode = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("load", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6975, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.load", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_276load(__pyx_self, __pyx_v_file, __pyx_v_mmap_mode);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_276load(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_mmap_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("load", 0);

  /* "ga4py/gain/notimplemented.pyx":7034
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7034, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6975
 * 
 * 
 * def load(file, mmap_mode=None):             # <<<<<<<<<<<<<<
 *     """Load a pickled, ``.npy``, or ``.npz`` binary file.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.load", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7037
 * 
 * 
 * def loads():             # <<<<<<<<<<<<<<
 *     """loads(string) -- Load a pickle from the given string
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_279loads(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_278loads[] = "loads(string) -- Load a pickle from the given string\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_279loads = {"loads", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_279loads, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_278loads};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_279loads(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("loads (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_278loads(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_278loads(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("loads", 0);

  /* "ga4py/gain/notimplemented.pyx":7042
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7042, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7037
 * 
 * 
 * def loads():             # <<<<<<<<<<<<<<
 *     """loads(string) -- Load a pickle from the given string
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.loads", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7045
 * 
 * 
 * def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """Load data from a text file.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_281loadtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_280loadtxt[] = "Load data from a text file.\n\n    Each row in the text file must have the same number of values.\n\n    Parameters\n    ----------\n    fname : file or str\n        File, filename, or generator to read.  If the filename extension is\n        ``.gz`` or ``.bz2``, the file is first decompressed. Note that\n        generators should return byte strings for Python 3k.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this is a\n        record data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type.\n    comments : str, optional\n        The character used to indicate the start of a comment;\n        default: '#'.\n    delimiter : str, optional\n        The string used to separate values.  By default, this is any\n        whitespace.\n    converters : dict, optional\n        A dictionary mapping column number to a function that will convert\n        that column to a float.  E.g., if column 0 is a date string:\n        ``converters = {0: datestr2num}``.  Converters can also be used to\n        provide a default value for missing data (but see also `genfromtxt`):\n        ``converters = {3: lambda s: float(s.strip() or 0)}``.  Default: None.\n    skiprows : int, optional\n        Skip the first `skiprows` lines; default: 0.\n    usecols : sequence, optional\n        Which columns to read, with 0 being the first.  For example,\n        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using ``x, y, z = loadtxt(...)``.  When used with a record\n        data-type, arrays are returned for each field.  Default is False.\n    ndmin : int, optional\n        The ""returned array will have at least `ndmin` dimensions.\n        Otherwise mono-dimensional axes will be squeezed. \n        Legal values: 0 (default), 1 or 2.\n        .. versionadded:: 1.6.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file.\n\n    See Also\n    --------\n    load, fromstring, fromregex\n    genfromtxt : Load data with missing values handled as specified.\n    scipy.io.loadmat : reads MATLAB data files\n\n    Notes\n    -----\n    This function aims to be a fast reader for simply formatted files.  The\n    `genfromtxt` function provides more sophisticated handling of, e.g.,\n    lines with missing values.\n\n    Examples\n    --------\n    >>> from StringIO import StringIO   # StringIO behaves like a file object\n    >>> c = StringIO(\"0 1\n2 3\")\n    >>> np.loadtxt(c)\n    array([[ 0.,  1.],\n           [ 2.,  3.]])\n\n    >>> d = StringIO(\"M 21 72\nF 35 58\")\n    >>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n    ...                      'formats': ('S1', 'i4', 'f4')})\n    array([('M', 21, 72.0), ('F', 35, 58.0)],\n          dtype=[('gender', '|S1'), ('age', '<i4'), ('weight', '<f4')])\n\n    >>> c = StringIO(\"1,0,2\n3,0,4\")\n    >>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n    >>> x\n    array([ 1.,  3.])\n    >>> y\n    array([ 2.,  4.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_281loadtxt = {"loadtxt", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_281loadtxt, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_280loadtxt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_281loadtxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_fname = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_comments = 0;
  CYTHON_UNUSED PyObject *__pyx_v_delimiter = 0;
  CYTHON_UNUSED PyObject *__pyx_v_converters = 0;
  CYTHON_UNUSED PyObject *__pyx_v_skiprows = 0;
  CYTHON_UNUSED PyObject *__pyx_v_usecols = 0;
  CYTHON_UNUSED PyObject *__pyx_v_unpack = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ndmin = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("loadtxt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_fname,&__pyx_n_s_dtype,&__pyx_n_s_comments,&__pyx_n_s_delimiter,&__pyx_n_s_converters,&__pyx_n_s_skiprows,&__pyx_n_s_usecols,&__pyx_n_s_unpack,&__pyx_n_s_ndmin,0};
    PyObject* values[9] = {0,0,0,0,0,0,0,0,0};
    values[1] = __pyx_k__13;
    values[2] = ((PyObject *)__pyx_kp_s__9);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)__pyx_int_0);
    values[6] = ((PyObject *)Py_None);
    values[7] = ((PyObject *)Py_False);
    values[8] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fname)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_comments);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_delimiter);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_converters);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_skiprows);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_usecols);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_unpack);
          if (value) { values[7] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  8:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ndmin);
          if (value) { values[8] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "loadtxt") < 0)) __PYX_ERR(0, 7045, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_fname = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_comments = values[2];
    __pyx_v_delimiter = values[3];
    __pyx_v_converters = values[4];
    __pyx_v_skiprows = values[5];
    __pyx_v_usecols = values[6];
    __pyx_v_unpack = values[7];
    __pyx_v_ndmin = values[8];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("loadtxt", 0, 1, 9, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7045, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.loadtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_280loadtxt(__pyx_self, __pyx_v_fname, __pyx_v_dtype, __pyx_v_comments, __pyx_v_delimiter, __pyx_v_converters, __pyx_v_skiprows, __pyx_v_usecols, __pyx_v_unpack, __pyx_v_ndmin);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_280loadtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_comments, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_converters, CYTHON_UNUSED PyObject *__pyx_v_skiprows, CYTHON_UNUSED PyObject *__pyx_v_usecols, CYTHON_UNUSED PyObject *__pyx_v_unpack, CYTHON_UNUSED PyObject *__pyx_v_ndmin) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("loadtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":7129
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7129, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7045
 * 
 * 
 * def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """Load data from a text file.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.loadtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7132
 * 
 * 
 * def lookfor(what, module=None, import_modules=True, regenerate=False, output=None):             # <<<<<<<<<<<<<<
 *     """Do a keyword search on docstrings.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_283lookfor(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_282lookfor[] = "Do a keyword search on docstrings.\n\n    A list of of objects that matched the search is displayed,\n    sorted by relevance. All given keywords need to be found in the\n    docstring for it to be returned as a result, but the order does\n    not matter.\n\n    Parameters\n    ----------\n    what : str\n        String containing words to look for.\n    module : str or list, optional\n        Name of module(s) whose docstrings to go through.\n    import_modules : bool, optional\n        Whether to import sub-modules in packages. Default is True.\n    regenerate : bool, optional\n        Whether to re-generate the docstring cache. Default is False.\n    output : file-like, optional\n        File-like object to write the output to. If omitted, use a pager.\n\n    See Also\n    --------\n    source, info\n\n    Notes\n    -----\n    Relevance is determined only roughly, by checking if the keywords occur\n    in the function name, at the start of a docstring, etc.\n\n    Examples\n    --------\n    >>> np.lookfor('binary representation')\n    Search results for 'binary representation'\n    ------------------------------------------\n    numpy.binary_repr\n        Return the binary representation of the input number as a string.\n    numpy.core.setup_common.long_double_representation\n        Given a binary dump as given by GNU od -b, look for long double\n    numpy.base_repr\n        Return a string representation of a number in the given base system.\n    ...\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_283lookfor = {"lookfor", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_283lookfor, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_282lookfor};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_283lookfor(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_what = 0;
  CYTHON_UNUSED PyObject *__pyx_v_module = 0;
  CYTHON_UNUSED PyObject *__pyx_v_import_modules = 0;
  CYTHON_UNUSED PyObject *__pyx_v_regenerate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_output = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lookfor (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_what,&__pyx_n_s_module,&__pyx_n_s_import_modules,&__pyx_n_s_regenerate,&__pyx_n_s_output,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_True);
    values[3] = ((PyObject *)Py_False);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_what)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_module);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_import_modules);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_regenerate);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lookfor") < 0)) __PYX_ERR(0, 7132, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_what = values[0];
    __pyx_v_module = values[1];
    __pyx_v_import_modules = values[2];
    __pyx_v_regenerate = values[3];
    __pyx_v_output = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("lookfor", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7132, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lookfor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_282lookfor(__pyx_self, __pyx_v_what, __pyx_v_module, __pyx_v_import_modules, __pyx_v_regenerate, __pyx_v_output);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_282lookfor(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_what, CYTHON_UNUSED PyObject *__pyx_v_module, CYTHON_UNUSED PyObject *__pyx_v_import_modules, CYTHON_UNUSED PyObject *__pyx_v_regenerate, CYTHON_UNUSED PyObject *__pyx_v_output) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lookfor", 0);

  /* "ga4py/gain/notimplemented.pyx":7176
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7176, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7132
 * 
 * 
 * def lookfor(what, module=None, import_modules=True, regenerate=False, output=None):             # <<<<<<<<<<<<<<
 *     """Do a keyword search on docstrings.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.lookfor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7179
 * 
 * 
 * def mafromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a text file and return a masked array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_285mafromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_284mafromtxt[] = "Load ASCII data stored in a text file and return a masked array.\n\n    For a complete description of all the input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function to load ASCII data.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_285mafromtxt = {"mafromtxt", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_285mafromtxt, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_284mafromtxt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_285mafromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mafromtxt (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_284mafromtxt(__pyx_self, ((PyObject *)__pyx_v_fname));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_284mafromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mafromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":7189
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7189, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7179
 * 
 * 
 * def mafromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a text file and return a masked array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mafromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7192
 * 
 * 
 * def mask_indices(n, mask_func, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices to access (n, n) arrays, given a masking function.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_287mask_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_286mask_indices[] = "Return the indices to access (n, n) arrays, given a masking function.\n\n    Assume `mask_func` is a function that, for a square array a of size\n    ``(n, n)`` with a possible offset argument `k`, when called as\n    ``mask_func(a, k)`` returns a new array with zeros in certain locations\n    (functions like `triu` or `tril` do precisely this). Then this function\n    returns the indices where the non-zero values would be located.\n\n    Parameters\n    ----------\n    n : int\n        The returned indices will be valid to access arrays of shape (n, n).\n    mask_func : callable\n        A function whose call signature is similar to that of `triu`, `tril`.\n        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n        `k` is an optional argument to the function.\n    k : scalar\n        An optional argument which is passed through to `mask_func`. Functions\n        like `triu`, `tril` take a second argument that is interpreted as an\n        offset.\n\n    Returns\n    -------\n    indices : tuple of arrays.\n        The `n` arrays of indices corresponding to the locations where\n        ``mask_func(np.ones((n, n)), k)`` is True.\n\n    See Also\n    --------\n    triu, tril, triu_indices, tril_indices\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    These are the indices that would allow you to access the upper triangular\n    part of any 3x3 array:\n\n    >>> iu = np.mask_indices(3, np.triu)\n\n    For example, if `a` is a 3x3 array:\n\n    >>> a = np.arange(9).reshape(3, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n    >>> a[iu]\n    array([0, 1, 2, 4, 5, 8])\n\n    An offset can be passed also to the masking function.  This gets us the\n    indices starting on the first diagonal right of the main one:\n\n    >>> iu1 = np.mask_indices(3, np.triu, 1)\n\n    with which we now extract only three elements:\n\n    >>> a[iu1]\n    array([1, 2, 5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_287mask_indices = {"mask_indices", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_287mask_indices, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_286mask_indices};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_287mask_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mask_func = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mask_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n,&__pyx_n_s_mask_func,&__pyx_n_s_k,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mask_func)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("mask_indices", 0, 2, 3, 1); __PYX_ERR(0, 7192, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mask_indices") < 0)) __PYX_ERR(0, 7192, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_mask_func = values[1];
    __pyx_v_k = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mask_indices", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7192, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mask_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_286mask_indices(__pyx_self, __pyx_v_n, __pyx_v_mask_func, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_286mask_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_mask_func, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mask_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":7256
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7256, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7192
 * 
 * 
 * def mask_indices(n, mask_func, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices to access (n, n) arrays, given a masking function.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mask_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7259
 * 
 * 
 * def mat(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_289mat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_288mat[] = "Interpret the input as a matrix.\n\n    Unlike `matrix`, `asmatrix` does not make a copy if the input is already\n    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\n    Parameters\n    ----------\n    data : array_like\n        Input data.\n\n    Returns\n    -------\n    mat : matrix\n        `data` interpreted as a matrix.\n\n    Examples\n    --------\n    >>> x = np.array([[1, 2], [3, 4]])\n\n    >>> m = np.asmatrix(x)\n\n    >>> x[0,0] = 5\n\n    >>> m\n    matrix([[5, 2],\n            [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_289mat = {"mat", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_289mat, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_288mat};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_289mat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_data = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_dtype,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mat") < 0)) __PYX_ERR(0, 7259, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_dtype = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mat", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7259, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_288mat(__pyx_self, __pyx_v_data, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_288mat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_data, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mat", 0);

  /* "ga4py/gain/notimplemented.pyx":7288
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7288, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7259
 * 
 * 
 * def mat(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7291
 * 
 * 
 * def max(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_291max(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_290max[] = "Return the maximum of an array or maximum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  Must be of\n        the same shape and buffer length as the expected output.  See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amax : ndarray or scalar\n        Maximum of `a`. If `axis` is None, the result is a scalar value.\n        If `axis` is given, the result is an array of dimension\n        ``a.ndim - 1``.\n\n    See Also\n    --------\n    nanmax : NaN values are ignored instead of being propagated.\n    fmax : same behavior as the C99 fmax function.\n    argmax : indices of the maximum values.\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is NaN, the\n    corresponding max value will be NaN as well.  To ignore NaN values\n    (MATLAB behavior), please use nanmax.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amax(a)\n    3\n    >>> np.amax(a, axis=0)\n    array([2, 3])\n    >>> np.amax(a, axis=1)\n    array([1, 3])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amax(b)\n    nan\n    >>> np.nanmax(b)\n    4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_291max = {"max", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_291max, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_290max};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_291max(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("max (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "max") < 0)) __PYX_ERR(0, 7291, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("max", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7291, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.max", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_290max(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_290max(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("max", 0);

  /* "ga4py/gain/notimplemented.pyx":7345
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7345, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7291
 * 
 * 
 * def max(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.max", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7348
 * 
 * 
 * def maximum_sctype(t):             # <<<<<<<<<<<<<<
 *     """Return the scalar type of highest precision of the same kind as the input.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_293maximum_sctype(PyObject *__pyx_self, PyObject *__pyx_v_t); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_292maximum_sctype[] = "Return the scalar type of highest precision of the same kind as the input.\n\n    Parameters\n    ----------\n    t : dtype or dtype specifier\n        The input data type. This can be a `dtype` object or an object that\n        is convertible to a `dtype`.\n\n    Returns\n    -------\n    out : dtype\n        The highest precision data type of the same kind (`dtype.kind`) as `t`.\n\n    See Also\n    --------\n    obj2sctype, mintypecode, sctype2char\n    dtype\n\n    Examples\n    --------\n    >>> np.maximum_sctype(np.int)\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype(np.uint8)\n    <type 'numpy.uint64'>\n    >>> np.maximum_sctype(np.complex)\n    <type 'numpy.complex192'>\n\n    >>> np.maximum_sctype(str)\n    <type 'numpy.string_'>\n\n    >>> np.maximum_sctype('i2')\n    <type 'numpy.int64'>\n    >>> np.maximum_sctype('f4')\n    <type 'numpy.float96'>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_293maximum_sctype = {"maximum_sctype", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_293maximum_sctype, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_292maximum_sctype};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_293maximum_sctype(PyObject *__pyx_self, PyObject *__pyx_v_t) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("maximum_sctype (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_292maximum_sctype(__pyx_self, ((PyObject *)__pyx_v_t));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_292maximum_sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_t) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("maximum_sctype", 0);

  /* "ga4py/gain/notimplemented.pyx":7385
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7385, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7348
 * 
 * 
 * def maximum_sctype(t):             # <<<<<<<<<<<<<<
 *     """Return the scalar type of highest precision of the same kind as the input.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.maximum_sctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7388
 * 
 * 
 * def may_share_memory(a, b):             # <<<<<<<<<<<<<<
 *     """Determine if two arrays can share memory
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_295may_share_memory(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_294may_share_memory[] = "Determine if two arrays can share memory\n\n    The memory-bounds of a and b are computed.  If they overlap then\n    this function returns True.  Otherwise, it returns False.\n\n    A return of True does not necessarily mean that the two arrays\n    share any element.  It just means that they *might*.\n\n    Parameters\n    ----------\n    a, b : ndarray\n\n    Returns\n    -------\n    out : bool\n\n    Examples\n    --------\n    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\n    False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_295may_share_memory = {"may_share_memory", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_295may_share_memory, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_294may_share_memory};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_295may_share_memory(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("may_share_memory (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("may_share_memory", 1, 2, 2, 1); __PYX_ERR(0, 7388, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "may_share_memory") < 0)) __PYX_ERR(0, 7388, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("may_share_memory", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7388, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.may_share_memory", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_294may_share_memory(__pyx_self, __pyx_v_a, __pyx_v_b);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_294may_share_memory(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("may_share_memory", 0);

  /* "ga4py/gain/notimplemented.pyx":7411
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7411, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7388
 * 
 * 
 * def may_share_memory(a, b):             # <<<<<<<<<<<<<<
 *     """Determine if two arrays can share memory
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.may_share_memory", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7414
 * 
 * 
 * def mean(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Compute the arithmetic mean along the specified axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_297mean(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_296mean[] = "Compute the arithmetic mean along the specified axis.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the means are computed. The default is to compute\n        the mean of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.\n        See `doc.ufuncs` for details.\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n        If `out=None`, returns a new array containing the mean values,\n        otherwise a reference to the output array is returned.\n\n    See Also\n    --------\n    average : Weighted average\n\n    Notes\n    -----\n    The arithmetic mean is the sum of the elements along the axis divided\n    by the number of elements.\n\n    Note that for floating-point input, the mean is computed using the\n    same precision the input has.  Depending on the input data, this can\n    cause the results to be inaccurate, especially for `float32` (see\n    example below).  Specifying a higher-precision accumulator using the\n    `dtype` keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.mean(a)\n    2.5\n    >>> np.mean(a, axis=0)\n    array([ 2.,  3.])\n    >>> np.mean(a, axis=1)\n    ""array([ 1.5,  3.5])\n\n    In single precision, `mean` can be inaccurate:\n\n    >>> a = np.zeros((2, 512*512), dtype=np.float32)\n    >>> a[0, :] = 1.0\n    >>> a[1, :] = 0.1\n    >>> np.mean(a)\n    0.546875\n\n    Computing the mean in float64 is more accurate:\n\n    >>> np.mean(a, dtype=np.float64)\n    0.55000000074505806\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_297mean = {"mean", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_297mean, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_296mean};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_297mean(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mean (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mean") < 0)) __PYX_ERR(0, 7414, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mean", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7414, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mean", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_296mean(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_296mean(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mean", 0);

  /* "ga4py/gain/notimplemented.pyx":7484
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7484, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7414
 * 
 * 
 * def mean(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Compute the arithmetic mean along the specified axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mean", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7487
 * 
 * 
 * def median(a, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the median along the specified axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_299median(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_298median[] = "Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : {None, int}, optional\n        Axis along which the medians are computed. The default (axis=None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : {False, True}, optional\n       If True, then allow use of memory of input array (a) for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted. Default is\n       False. Note that, if `overwrite_input` is True and the input\n       is not already an ndarray, an error will be raised.\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, percentile\n\n    Notes\n    -----\n    Given a vector V of length N, the median of V is the middle value of\n    a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is\n    odd.  When N is even, it is the average of the two middle values of\n    ``V_sorted``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])""\n    >>> np.median(a)\n    3.5\n    >>> np.median(a, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.median(a, axis=1)\n    array([ 7.,  2.])\n    >>> m = np.median(a, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.median(a, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n    >>> b = a.copy()\n    >>> np.median(b, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.median(b, axis=None, overwrite_input=True)\n    3.5\n    >>> assert not np.all(a==b)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_299median = {"median", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_299median, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_298median};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_299median(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_overwrite_input = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("median (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,&__pyx_n_s_overwrite_input,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_overwrite_input);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "median") < 0)) __PYX_ERR(0, 7487, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
    __pyx_v_overwrite_input = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("median", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7487, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.median", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_298median(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out, __pyx_v_overwrite_input);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_298median(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("median", 0);

  /* "ga4py/gain/notimplemented.pyx":7560
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7560, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7487
 * 
 * 
 * def median(a, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the median along the specified axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.median", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7563
 * 
 * 
 * def meshgrid(x, y):             # <<<<<<<<<<<<<<
 *     """Return coordinate matrices from two coordinate vectors.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_301meshgrid(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_300meshgrid[] = "Return coordinate matrices from two coordinate vectors.\n\n    Parameters\n    ----------\n    x, y : ndarray\n        Two 1-D arrays representing the x and y coordinates of a grid.\n\n    Returns\n    -------\n    X, Y : ndarray\n        For vectors `x`, `y` with lengths ``Nx=len(x)`` and ``Ny=len(y)``,\n        return `X`, `Y` where `X` and `Y` are ``(Ny, Nx)`` shaped arrays\n        with the elements of `x` and y repeated to fill the matrix along\n        the first dimension for `x`, the second for `y`.\n\n    See Also\n    --------\n    index_tricks.mgrid : Construct a multi-dimensional \"meshgrid\"\n                         using indexing notation.\n    index_tricks.ogrid : Construct an open multi-dimensional \"meshgrid\"\n                         using indexing notation.\n\n    Examples\n    --------\n    >>> X, Y = np.meshgrid([1,2,3], [4,5,6,7])\n    >>> X\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\n    >>> Y\n    array([[4, 4, 4],\n           [5, 5, 5],\n           [6, 6, 6],\n           [7, 7, 7]])\n\n    `meshgrid` is very useful to evaluate functions on a grid.\n\n    >>> x = np.arange(-5, 5, 0.1)\n    >>> y = np.arange(-5, 5, 0.1)\n    >>> xx, yy = np.meshgrid(x, y)\n    >>> z = np.sin(xx**2+yy**2)/(xx**2+yy**2)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_301meshgrid = {"meshgrid", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_301meshgrid, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_300meshgrid};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_301meshgrid(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("meshgrid (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("meshgrid", 1, 2, 2, 1); __PYX_ERR(0, 7563, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "meshgrid") < 0)) __PYX_ERR(0, 7563, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("meshgrid", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7563, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.meshgrid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_300meshgrid(__pyx_self, __pyx_v_x, __pyx_v_y);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_300meshgrid(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("meshgrid", 0);

  /* "ga4py/gain/notimplemented.pyx":7608
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7608, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7563
 * 
 * 
 * def meshgrid(x, y):             # <<<<<<<<<<<<<<
 *     """Return coordinate matrices from two coordinate vectors.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.meshgrid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7611
 * 
 * 
 * def min(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_303min(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_302min[] = "Return the minimum of an array or minimum along an axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default a flattened input is used.\n    out : ndarray, optional\n        Alternative output array in which to place the result.  Must\n        be of the same shape and buffer length as the expected output.\n        See `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    amin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    nanmin: nan values are ignored instead of being propagated\n    fmin: same behavior as the C99 fmin function\n    argmin: Return the indices of the minimum values.\n\n    amax, nanmax, fmax\n\n    Notes\n    -----\n    NaN values are propagated, that is if at least one item is nan, the\n    corresponding min value will be nan as well. To ignore NaN values (matlab\n    behavior), please use nanmin.\n\n    Examples\n    --------\n    >>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> np.amin(a)           # Minimum of the flattened array\n    0\n    >>> np.amin(a, axis=0)         # Minima along the first axis\n    array([0, 1])\n    >>> np.amin(a, axis=1)         # Minima along the second axis\n    array([0, 2])\n\n    >>> b = np.arange(5, dtype=np.float)\n    >>> b[2] = np.NaN\n    >>> np.amin(b)\n    nan\n    >>> np.nanmin(b)\n    0.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_303min = {"min", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_303min, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_302min};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_303min(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("min (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "min") < 0)) __PYX_ERR(0, 7611, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("min", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7611, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.min", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_302min(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_302min(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("min", 0);

  /* "ga4py/gain/notimplemented.pyx":7665
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7665, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7611
 * 
 * 
 * def min(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.min", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7668
 * 
 * 
 * def min_scalar_type(a):             # <<<<<<<<<<<<<<
 *     """min_scalar_type(a)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_305min_scalar_type(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_304min_scalar_type[] = "min_scalar_type(a)\n\n    For scalar ``a``, returns the data type with the smallest size\n    and smallest scalar kind which can hold its value.  For non-scalar\n    array ``a``, returns the vector's dtype unmodified.\n\n    Floating point values are not demoted to integers,\n    and complex values are not demoted to floats.\n\n    Parameters\n    ----------\n    a : scalar or array_like\n        The value whose minimal data type is to be found.\n\n    Returns\n    -------\n    out : dtype\n        The minimal data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, promote_types, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.min_scalar_type(10)\n    dtype('uint8')\n\n    >>> np.min_scalar_type(-260)\n    dtype('int16')\n\n    >>> np.min_scalar_type(3.1)\n    dtype('float16')\n\n    >>> np.min_scalar_type(1e50)\n    dtype('float64')\n\n    >>> np.min_scalar_type(np.arange(4,dtype='f8'))\n    dtype('float64')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_305min_scalar_type = {"min_scalar_type", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_305min_scalar_type, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_304min_scalar_type};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_305min_scalar_type(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("min_scalar_type (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_304min_scalar_type(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_304min_scalar_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("min_scalar_type", 0);

  /* "ga4py/gain/notimplemented.pyx":7715
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7715, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7668
 * 
 * 
 * def min_scalar_type(a):             # <<<<<<<<<<<<<<
 *     """min_scalar_type(a)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.min_scalar_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7718
 * 
 * 
 * def mintypecode(typechars, typeset='GDFgdf', default='d'):             # <<<<<<<<<<<<<<
 *     """Return the character for the minimum-size type to which given types can
 *     be safely cast.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_307mintypecode(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_306mintypecode[] = "Return the character for the minimum-size type to which given types can\n    be safely cast.\n\n    The returned type character must represent the smallest size dtype such\n    that an array of the returned type can handle the data from an array of\n    all types in `typechars` (or if `typechars` is an array, then its\n    dtype.char).\n\n    Parameters\n    ----------\n    typechars : list of str or array_like\n        If a list of strings, each string should represent a dtype.\n        If array_like, the character representation of the array dtype is used.\n    typeset : str or list of str, optional\n        The set of characters that the returned character is chosen from.\n        The default set is 'GDFgdf'.\n    default : str, optional\n        The default character, this is returned if none of the characters in\n        `typechars` matches a character in `typeset`.\n\n    Returns\n    -------\n    typechar : str\n        The character representing the minimum-size type that was found.\n\n    See Also\n    --------\n    dtype, sctype2char, maximum_sctype\n\n    Examples\n    --------\n    >>> np.mintypecode(['d', 'f', 'S'])\n    'd'\n    >>> x = np.array([1.1, 2-3.j])\n    >>> np.mintypecode(x)\n    'D'\n\n    >>> np.mintypecode('abceh', default='G')\n    'G'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_307mintypecode = {"mintypecode", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_307mintypecode, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_306mintypecode};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_307mintypecode(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_typechars = 0;
  CYTHON_UNUSED PyObject *__pyx_v_typeset = 0;
  CYTHON_UNUSED PyObject *__pyx_v_default = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mintypecode (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_typechars,&__pyx_n_s_typeset,&__pyx_n_s_default,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_n_s_GDFgdf);
    values[2] = ((PyObject *)__pyx_n_s_d);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_typechars)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_typeset);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_default);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mintypecode") < 0)) __PYX_ERR(0, 7718, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_typechars = values[0];
    __pyx_v_typeset = values[1];
    __pyx_v_default = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mintypecode", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7718, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mintypecode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_306mintypecode(__pyx_self, __pyx_v_typechars, __pyx_v_typeset, __pyx_v_default);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_306mintypecode(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_typechars, CYTHON_UNUSED PyObject *__pyx_v_typeset, CYTHON_UNUSED PyObject *__pyx_v_default) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mintypecode", 0);

  /* "ga4py/gain/notimplemented.pyx":7760
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7760, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7718
 * 
 * 
 * def mintypecode(typechars, typeset='GDFgdf', default='d'):             # <<<<<<<<<<<<<<
 *     """Return the character for the minimum-size type to which given types can
 *     be safely cast.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mintypecode", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7763
 * 
 * 
 * def mirr(values, finance_rate, reinvest_rate):             # <<<<<<<<<<<<<<
 *     """Modified internal rate of return.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_309mirr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_308mirr[] = "Modified internal rate of return.\n\n    Parameters\n    ----------\n    values : array_like\n        Cash flows (must contain at least one positive and one negative value)\n        or nan is returned.  The first value is considered a sunk cost at time zero.\n    finance_rate : scalar\n        Interest rate paid on the cash flows\n    reinvest_rate : scalar\n        Interest rate received on the cash flows upon reinvestment\n\n    Returns\n    -------\n    out : float\n        Modified internal rate of return\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_309mirr = {"mirr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_309mirr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_308mirr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_309mirr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  CYTHON_UNUSED PyObject *__pyx_v_finance_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_reinvest_rate = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mirr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_values,&__pyx_n_s_finance_rate,&__pyx_n_s_reinvest_rate,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_values)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_finance_rate)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("mirr", 1, 3, 3, 1); __PYX_ERR(0, 7763, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_reinvest_rate)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("mirr", 1, 3, 3, 2); __PYX_ERR(0, 7763, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "mirr") < 0)) __PYX_ERR(0, 7763, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_values = values[0];
    __pyx_v_finance_rate = values[1];
    __pyx_v_reinvest_rate = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("mirr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7763, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mirr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_308mirr(__pyx_self, __pyx_v_values, __pyx_v_finance_rate, __pyx_v_reinvest_rate);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_308mirr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED PyObject *__pyx_v_finance_rate, CYTHON_UNUSED PyObject *__pyx_v_reinvest_rate) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mirr", 0);

  /* "ga4py/gain/notimplemented.pyx":7782
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7782, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7763
 * 
 * 
 * def mirr(values, finance_rate, reinvest_rate):             # <<<<<<<<<<<<<<
 *     """Modified internal rate of return.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.mirr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7785
 * 
 * 
 * def msort(a):             # <<<<<<<<<<<<<<
 *     """Return a copy of an array sorted along the first axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_311msort(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_310msort[] = "Return a copy of an array sorted along the first axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    sort\n\n    Notes\n    -----\n    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_311msort = {"msort", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_311msort, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_310msort};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_311msort(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("msort (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_310msort(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_310msort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("msort", 0);

  /* "ga4py/gain/notimplemented.pyx":7807
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7807, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7785
 * 
 * 
 * def msort(a):             # <<<<<<<<<<<<<<
 *     """Return a copy of an array sorted along the first axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.msort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7810
 * 
 * 
 * def nan_to_num(x):             # <<<<<<<<<<<<<<
 *     """Replace nan with zero and inf with finite numbers.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_313nan_to_num(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_312nan_to_num[] = "Replace nan with zero and inf with finite numbers.\n\n    Returns an array or scalar replacing Not a Number (NaN) with zero,\n    (positive) infinity with a very large number and negative infinity\n    with a very small (or negative) number.\n\n    Parameters\n    ----------\n    x : array_like\n        Input data.\n\n    Returns\n    -------\n    out : ndarray, float\n        Array with the same shape as `x` and dtype of the element in `x`  with\n        the greatest precision. NaN is replaced by zero, and infinity\n        (-infinity) is replaced by the largest (smallest or most negative)\n        floating point value that fits in the output dtype. All finite numbers\n        are upcast to the output dtype (default float64).\n\n    See Also\n    --------\n    isinf : Shows which elements are negative or negative infinity.\n    isneginf : Shows which elements are negative infinity.\n    isposinf : Shows which elements are positive infinity.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite : Shows which elements are finite (not NaN, not infinity)\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n\n    Examples\n    --------\n    >>> np.set_printoptions(precision=8)\n    >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n    >>> np.nan_to_num(x)\n    array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,\n            -1.28000000e+002,   1.28000000e+002])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_313nan_to_num = {"nan_to_num", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_313nan_to_num, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_312nan_to_num};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_313nan_to_num(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nan_to_num (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_312nan_to_num(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_312nan_to_num(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nan_to_num", 0);

  /* "ga4py/gain/notimplemented.pyx":7854
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7854, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7810
 * 
 * 
 * def nan_to_num(x):             # <<<<<<<<<<<<<<
 *     """Replace nan with zero and inf with finite numbers.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nan_to_num", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7857
 * 
 * 
 * def nanargmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the maximum values over an axis, ignoring NaNs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_315nanargmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_314nanargmax[] = "Return indices of the maximum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmax, nanargmin\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmax(a)\n    0\n    >>> np.nanargmax(a)\n    1\n    >>> np.nanargmax(a, axis=0)\n    array([1, 0])\n    >>> np.nanargmax(a, axis=1)\n    array([1, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_315nanargmax = {"nanargmax", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_315nanargmax, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_314nanargmax};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_315nanargmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanargmax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanargmax") < 0)) __PYX_ERR(0, 7857, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanargmax", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7857, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_314nanargmax(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_314nanargmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanargmax", 0);

  /* "ga4py/gain/notimplemented.pyx":7889
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7889, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7857
 * 
 * 
 * def nanargmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the maximum values over an axis, ignoring NaNs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7892
 * 
 * 
 * def nanargmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the minimum values over an axis, ignoring NaNs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_317nanargmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_316nanargmin[] = "Return indices of the minimum values over an axis, ignoring NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which to operate.  By default flattened input is used.\n\n    Returns\n    -------\n    index_array : ndarray\n        An array of indices or a single index value.\n\n    See Also\n    --------\n    argmin, nanargmax\n\n    Examples\n    --------\n    >>> a = np.array([[np.nan, 4], [2, 3]])\n    >>> np.argmin(a)\n    0\n    >>> np.nanargmin(a)\n    2\n    >>> np.nanargmin(a, axis=0)\n    array([1, 1])\n    >>> np.nanargmin(a, axis=1)\n    array([1, 0])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_317nanargmin = {"nanargmin", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_317nanargmin, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_316nanargmin};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_317nanargmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanargmin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanargmin") < 0)) __PYX_ERR(0, 7892, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanargmin", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7892, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_316nanargmin(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_316nanargmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanargmin", 0);

  /* "ga4py/gain/notimplemented.pyx":7924
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7924, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7892
 * 
 * 
 * def nanargmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the minimum values over an axis, ignoring NaNs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanargmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7927
 * 
 * 
 * def nanmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis ignoring any NaNs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_319nanmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_318nanmax[] = "Return the maximum of an array or maximum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose maximum is desired. If `a` is not\n        an array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the maximum is computed. The default is to compute\n        the maximum of the flattened array.\n\n    Returns\n    -------\n    nanmax : ndarray\n        An array with the same shape as `a`, with the specified axis removed.\n        If `a` is a 0-d array, or if axis is None, a ndarray scalar is\n        returned.  The the same dtype as `a` is returned.\n\n    See Also\n    --------\n    numpy.amax : Maximum across array including any Not a Numbers.\n    numpy.nanmin : Minimum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.max.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmax(a)\n    3.0\n    >>> np.nanmax(a, axis=0)\n    array([ 3.,  2.])\n    >>> np.nanmax(a, axis=1)\n    array([ 2.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmax([1, 2, np.nan, np.NINF])\n    2.0\n    >>> np.nanmax([1, 2, np.nan, np.inf])\n    inf\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_319nanmax = {"nanmax", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_319nanmax, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_318nanmax};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_319nanmax(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanmax (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanmax") < 0)) __PYX_ERR(0, 7927, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanmax", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7927, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_318nanmax(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_318nanmax(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanmax", 0);

  /* "ga4py/gain/notimplemented.pyx":7981
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 7981, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7927
 * 
 * 
 * def nanmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis ignoring any NaNs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmax", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":7984
 * 
 * 
 * def nanmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis ignoring any NaNs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_321nanmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_320nanmin[] = "Return the minimum of an array or minimum along an axis ignoring any NaNs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose minimum is desired.\n    axis : int, optional\n        Axis along which the minimum is computed.The default is to compute\n        the minimum of the flattened array.\n\n    Returns\n    -------\n    nanmin : ndarray\n        A new array or a scalar array with the result.\n\n    See Also\n    --------\n    numpy.amin : Minimum across array including any Not a Numbers.\n    numpy.nanmax : Maximum across array ignoring any Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Positive infinity is treated as a very large number and negative infinity\n    is treated as a very small (i.e. negative) number.\n\n    If the input has a integer type the function is equivalent to np.min.\n\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, np.nan]])\n    >>> np.nanmin(a)\n    1.0\n    >>> np.nanmin(a, axis=0)\n    array([ 1.,  2.])\n    >>> np.nanmin(a, axis=1)\n    array([ 1.,  3.])\n\n    When positive infinity and negative infinity are present:\n\n    >>> np.nanmin([1, 2, np.nan, np.inf])\n    1.0\n    >>> np.nanmin([1, 2, np.nan, np.NINF])\n    -inf\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_321nanmin = {"nanmin", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_321nanmin, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_320nanmin};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_321nanmin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanmin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nanmin") < 0)) __PYX_ERR(0, 7984, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nanmin", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7984, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_320nanmin(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_320nanmin(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nanmin", 0);

  /* "ga4py/gain/notimplemented.pyx":8036
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8036, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7984
 * 
 * 
 * def nanmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis ignoring any NaNs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nanmin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8039
 * 
 * 
 * def nansum(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the sum of array elements over a given axis treating
 *     Not a Numbers (NaNs) as zero.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_323nansum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_322nansum[] = "Return the sum of array elements over a given axis treating\n    Not a Numbers (NaNs) as zero.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose sum is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the sum is computed. The default is to compute\n        the sum of the flattened array.\n\n    Returns\n    -------\n    y : ndarray\n        An array with the same shape as a, with the specified axis removed.\n        If a is a 0-d array, or if axis is None, a scalar is returned with\n        the same dtype as `a`.\n\n    See Also\n    --------\n    numpy.sum : Sum across array including Not a Numbers.\n    isnan : Shows which elements are Not a Number (NaN).\n    isfinite: Shows which elements are not: Not a Number, positive and\n             negative infinity\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    If positive or negative infinity are present the result is positive or\n    negative infinity. But if both positive and negative infinity are present,\n    the result is Not A Number (NaN).\n\n    Arithmetic is modular when using integer types (all elements of `a` must\n    be finite i.e. no elements that are NaNs, positive infinity and negative\n    infinity because NaNs are floating point types), and no error is raised\n    on overflow.\n\n\n    Examples\n    --------\n    >>> np.nansum(1)\n    1\n    >>> np.nansum([1])\n    1\n    >>> np.nansum([1, np.nan])\n    1.0\n    >>> a = np.array([[1, 1], [1, np.nan]])\n    >>> np.nansum(a)\n    3.0\n    >>> np.nansum(a, axis=0)\n    array([ 2.,  1.])\n\n    When positive infinity and negative infinity are present\n\n    >>> np.nansum([1, np.nan, np.inf])\n    inf\n    >>> np.nansum([1, np.nan, np.NINF])\n    -inf\n    >>> np.nansum([1, np.nan, np.inf, np.NINF])\n    nan\n   "" \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_323nansum = {"nansum", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_323nansum, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_322nansum};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_323nansum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nansum (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nansum") < 0)) __PYX_ERR(0, 8039, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nansum", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8039, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nansum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_322nansum(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_322nansum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nansum", 0);

  /* "ga4py/gain/notimplemented.pyx":8104
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8104, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8039
 * 
 * 
 * def nansum(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the sum of array elements over a given axis treating
 *     Not a Numbers (NaNs) as zero.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nansum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8107
 * 
 * 
 * def ndfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a file and return it as a single array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_325ndfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_324ndfromtxt[] = "Load ASCII data stored in a file and return it as a single array.\n\n    Complete description of all the optional input parameters is available in\n    the docstring of the `genfromtxt` function.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_325ndfromtxt = {"ndfromtxt", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_325ndfromtxt, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_324ndfromtxt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_325ndfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ndfromtxt (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_324ndfromtxt(__pyx_self, ((PyObject *)__pyx_v_fname));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_324ndfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ndfromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":8118
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8118, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8107
 * 
 * 
 * def ndfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a file and return it as a single array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ndfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8121
 * 
 * 
 * def ndim(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_327ndim(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_326ndim[] = "Return the number of dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  If it is not already an ndarray, a conversion is\n        attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in `a`.  Scalars are zero-dimensional.\n\n    See Also\n    --------\n    ndarray.ndim : equivalent method\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Examples\n    --------\n    >>> np.ndim([[1,2,3],[4,5,6]])\n    2\n    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.ndim(1)\n    0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_327ndim = {"ndim", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_327ndim, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_326ndim};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_327ndim(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ndim (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_326ndim(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_326ndim(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ndim", 0);

  /* "ga4py/gain/notimplemented.pyx":8151
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8151, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8121
 * 
 * 
 * def ndim(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ndim", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8154
 * 
 * 
 * def nested_iters():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_329nested_iters(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_328nested_iters[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_329nested_iters = {"nested_iters", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_329nested_iters, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_328nested_iters};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_329nested_iters(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nested_iters (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_328nested_iters(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_328nested_iters(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nested_iters", 0);

  /* "ga4py/gain/notimplemented.pyx":8159
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8159, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8154
 * 
 * 
 * def nested_iters():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nested_iters", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8162
 * 
 * 
 * def newbuffer(size):             # <<<<<<<<<<<<<<
 *     """newbuffer(size)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_331newbuffer(PyObject *__pyx_self, PyObject *__pyx_v_size); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_330newbuffer[] = "newbuffer(size)\n\n    Return a new uninitialized buffer object of size bytes\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_331newbuffer = {"newbuffer", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_331newbuffer, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_330newbuffer};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_331newbuffer(PyObject *__pyx_self, PyObject *__pyx_v_size) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("newbuffer (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_330newbuffer(__pyx_self, ((PyObject *)__pyx_v_size));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_330newbuffer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("newbuffer", 0);

  /* "ga4py/gain/notimplemented.pyx":8169
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8169, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8162
 * 
 * 
 * def newbuffer(size):             # <<<<<<<<<<<<<<
 *     """newbuffer(size)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.newbuffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8172
 * 
 * 
 * def nonzero(a):             # <<<<<<<<<<<<<<
 *     """Return the indices of the elements that are non-zero.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_333nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_332nonzero[] = "Return the indices of the elements that are non-zero.\n\n    Returns a tuple of arrays, one for each dimension of `a`, containing\n    the indices of the non-zero elements in that dimension. The\n    corresponding non-zero values can be obtained with::\n\n        a[nonzero(a)]\n\n    To group the indices by element, rather than dimension, use::\n\n        transpose(nonzero(a))\n\n    The result of this is always a 2-D array, with a row for\n    each non-zero element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n\n    Returns\n    -------\n    tuple_of_arrays : tuple\n        Indices of elements that are non-zero.\n\n    See Also\n    --------\n    flatnonzero :\n        Return indices that are non-zero in the flattened version of the input\n        array.\n    ndarray.nonzero :\n        Equivalent ndarray method.\n    count_nonzero :\n        Counts the number of non-zero elements in the input array.\n\n    Examples\n    --------\n    >>> x = np.eye(3)\n    >>> x\n    array([[ 1.,  0.,  0.],\n           [ 0.,  1.,  0.],\n           [ 0.,  0.,  1.]])\n    >>> np.nonzero(x)\n    (array([0, 1, 2]), array([0, 1, 2]))\n\n    >>> x[np.nonzero(x)]\n    array([ 1.,  1.,  1.])\n    >>> np.transpose(np.nonzero(x))\n    array([[0, 0],\n           [1, 1],\n           [2, 2]])\n\n    A common use for ``nonzero`` is to find the indices of an array, where\n    a condition is True.  Given an array `a`, the condition `a` > 3 is a\n    boolean array and since False is interpreted as 0, np.nonzero(a > 3)\n    yields the indices of the `a` where the condition is true.\n\n    >>> a = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    >>> a > 3\n    array([[False, False, False],\n           [ True,  True,  True],\n           [ True,  True,  True]], dtype=bool)\n    >>> np.nonzero(a > 3)\n    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n    The ``nonzero`` method of the boolean array can also be called.\n\n    >>> (a > 3).nonzero()\n    (array([1, 1, 1, ""2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_333nonzero = {"nonzero", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_333nonzero, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_332nonzero};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_333nonzero(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nonzero (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_332nonzero(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_332nonzero(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nonzero", 0);

  /* "ga4py/gain/notimplemented.pyx":8244
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8244, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8172
 * 
 * 
 * def nonzero(a):             # <<<<<<<<<<<<<<
 *     """Return the indices of the elements that are non-zero.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nonzero", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8247
 * 
 * 
 * def nper(rate, pmt, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the number of periodic payments.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_335nper(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_334nper[] = "Compute the number of periodic payments.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Notes\n    -----\n    The number of periods ``nper`` is computed by solving the equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0\n\n    but if ``rate = 0`` then::\n\n     fv + pv + pmt*nper = 0\n\n    Examples\n    --------\n    If you only had $150/month to pay towards the loan, how long would it take\n    to pay-off a loan of $8,000 at 7% annual interest?\n\n    >>> np.nper(0.07/12, -150, 8000)\n    64.073348770661852\n\n    So, over 64 months would be required to pay off the loan.\n\n    The same analysis could be done with several different interest rates\n    and/or payments and/or total amounts to produce an entire table.\n\n    >>> np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n    ...                    -150   : -99     : 50    ,\n    ...                    8000   : 9001    : 1000]))\n    array([[[  64.07334877,   74.06368256],\n            [ 108.07548412,  127.99022654]],\n           [[  66.12443902,   76.87897353],\n            [ 114.70165583,  137.90124779]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_335nper = {"nper", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_335nper, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_334nper};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_335nper(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nper (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rate,&__pyx_n_s_pmt,&__pyx_n_s_pv,&__pyx_n_s_fv,&__pyx_n_s_when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)__pyx_n_s_end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("nper", 0, 3, 5, 1); __PYX_ERR(0, 8247, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("nper", 0, 3, 5, 2); __PYX_ERR(0, 8247, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fv);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "nper") < 0)) __PYX_ERR(0, 8247, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_pmt = values[1];
    __pyx_v_pv = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("nper", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8247, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nper", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_334nper(__pyx_self, __pyx_v_rate, __pyx_v_pmt, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_334nper(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nper", 0);

  /* "ga4py/gain/notimplemented.pyx":8295
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8295, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8247
 * 
 * 
 * def nper(rate, pmt, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the number of periodic payments.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.nper", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8298
 * 
 * 
 * def npv(rate, values):             # <<<<<<<<<<<<<<
 *     """Returns the NPV (Net Present Value) of a cash flow series.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_337npv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_336npv[] = "Returns the NPV (Net Present Value) of a cash flow series.\n\n    Parameters\n    ----------\n    rate : scalar\n        The discount rate.\n    values : array_like, shape(M, )\n        The values of the time series of cash flows.  The (fixed) time\n        interval between cash flow \"events\" must be the same as that\n        for which `rate` is given (i.e., if `rate` is per year, then\n        precisely a year is understood to elapse between each cash flow\n        event).  By convention, investments or \"deposits\" are negative,\n        income or \"withdrawals\" are positive; `values` must begin with\n        the initial investment, thus `values[0]` will typically be\n        negative.\n\n    Returns\n    -------\n    out : float\n        The NPV of the input cash flow series `values` at the discount `rate`.\n\n    Notes\n    -----\n    Returns the result of: [G]_\n\n    .. math :: \\sum_{t=0}^M{\014rac{values_t}{(1+rate)^{t}}}\n\n    References\n    ----------\n    .. [G] L. J. Gitman, \"Principles of Managerial Finance, Brief,\" 3rd ed.,\n       Addison-Wesley, 2003, pg. 346.\n\n    Examples\n    --------\n    >>> np.npv(0.281,[-100, 39, 59, 55, 20])\n    -0.0066187288356340801\n\n    (Compare with the Example given for numpy.lib.financial.irr)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_337npv = {"npv", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_337npv, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_336npv};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_337npv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("npv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rate,&__pyx_n_s_values,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("npv", 1, 2, 2, 1); __PYX_ERR(0, 8298, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "npv") < 0)) __PYX_ERR(0, 8298, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_rate = values[0];
    __pyx_v_values = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("npv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8298, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.npv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_336npv(__pyx_self, __pyx_v_rate, __pyx_v_values);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_336npv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_values) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("npv", 0);

  /* "ga4py/gain/notimplemented.pyx":8339
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8339, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8298
 * 
 * 
 * def npv(rate, values):             # <<<<<<<<<<<<<<
 *     """Returns the NPV (Net Present Value) of a cash flow series.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.npv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8342
 * 
 * 
 * def obj2sctype(rep, default=None):             # <<<<<<<<<<<<<<
 *     """Return the scalar dtype or NumPy equivalent of Python type of an object.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_339obj2sctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_338obj2sctype[] = "Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Parameters\n    ----------\n    rep : any\n        The object of which the type is returned.\n    default : any, optional\n        If given, this is returned for objects whose types can not be\n        determined. If not given, None is returned for those objects.\n\n    Returns\n    -------\n    dtype : dtype or Python type\n        The data type of `rep`.\n\n    See Also\n    --------\n    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype\n\n    Examples\n    --------\n    >>> np.obj2sctype(np.int32)\n    <type 'numpy.int32'>\n    >>> np.obj2sctype(np.array([1., 2.]))\n    <type 'numpy.float64'>\n    >>> np.obj2sctype(np.array([1.j]))\n    <type 'numpy.complex128'>\n\n    >>> np.obj2sctype(dict)\n    <type 'numpy.object_'>\n    >>> np.obj2sctype('string')\n    <type 'numpy.string_'>\n\n    >>> np.obj2sctype(1, default=list)\n    <type 'list'>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_339obj2sctype = {"obj2sctype", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_339obj2sctype, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_338obj2sctype};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_339obj2sctype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rep = 0;
  CYTHON_UNUSED PyObject *__pyx_v_default = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("obj2sctype (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rep,&__pyx_n_s_default,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rep)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_default);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "obj2sctype") < 0)) __PYX_ERR(0, 8342, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rep = values[0];
    __pyx_v_default = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("obj2sctype", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8342, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.obj2sctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_338obj2sctype(__pyx_self, __pyx_v_rep, __pyx_v_default);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_338obj2sctype(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rep, CYTHON_UNUSED PyObject *__pyx_v_default) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("obj2sctype", 0);

  /* "ga4py/gain/notimplemented.pyx":8380
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8380, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8342
 * 
 * 
 * def obj2sctype(rep, default=None):             # <<<<<<<<<<<<<<
 *     """Return the scalar dtype or NumPy equivalent of Python type of an object.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.obj2sctype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8383
 * 
 * 
 * def outer(a, b):             # <<<<<<<<<<<<<<
 *     """Compute the outer product of two vectors.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_341outer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_340outer[] = "Compute the outer product of two vectors.\n\n    Given two vectors, ``a = [a0, a1, ..., aM]`` and\n    ``b = [b0, b1, ..., bN]``,\n    the outer product [1]_ is::\n\n      [[a0*b0  a0*b1 ... a0*bN ]\n       [a1*b0    .\n       [ ...          .\n       [aM*b0            aM*bN ]]\n\n    Parameters\n    ----------\n    a, b : array_like, shape (M,), (N,)\n        First and second input vectors.  Inputs are flattened if they\n        are not already 1-dimensional.\n\n    Returns\n    -------\n    out : ndarray, shape (M, N)\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner, einsum\n\n    References\n    ----------\n    .. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd\n             ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n             pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.]])\n    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n    >>> im\n    array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],\n           [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],\n           [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n           [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],\n           [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])\n    >>> grid = rl + im\n    >>> grid\n    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n    An example using a \"vector\" of letters:\n\n    >>> x = np.array(['a', 'b', 'c'], dtype=object)\n    >>> np.""outer(x, [1, 2, 3])\n    array([[a, aa, aaa],\n           [b, bb, bbb],\n           [c, cc, ccc]], dtype=object)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_341outer = {"outer", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_341outer, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_340outer};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_341outer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("outer (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("outer", 1, 2, 2, 1); __PYX_ERR(0, 8383, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "outer") < 0)) __PYX_ERR(0, 8383, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("outer", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8383, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.outer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_340outer(__pyx_self, __pyx_v_a, __pyx_v_b);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_340outer(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("outer", 0);

  /* "ga4py/gain/notimplemented.pyx":8451
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8451, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8383
 * 
 * 
 * def outer(a, b):             # <<<<<<<<<<<<<<
 *     """Compute the outer product of two vectors.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.outer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8454
 * 
 * 
 * def packbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """packbits(myarray, axis=None)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_343packbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_342packbits[] = "packbits(myarray, axis=None)\n\n    Packs the elements of a binary-valued array into bits in a uint8 array.\n\n    The result is padded to full bytes by inserting zero bits at the end.\n\n    Parameters\n    ----------\n    myarray : array_like\n        An integer type array whose elements should be packed to bits.\n    axis : int, optional\n        The dimension over which bit-packing is done.\n        ``None`` implies packing the flattened array.\n\n    Returns\n    -------\n    packed : ndarray\n        Array of type uint8 whose elements represent bits corresponding to the\n        logical (0 or nonzero) value of the input elements. The shape of\n        `packed` has the same number of dimensions as the input (unless `axis`\n        is None, in which case the output is 1-D).\n\n    See Also\n    --------\n    unpackbits: Unpacks elements of a uint8 array into a binary-valued output\n                array.\n\n    Examples\n    --------\n    >>> a = np.array([[[1,0,1],\n    ...                [0,1,0]],\n    ...               [[1,1,0],\n    ...                [0,0,1]]])\n    >>> b = np.packbits(a, axis=-1)\n    >>> b\n    array([[[160],[64]],[[192],[32]]], dtype=uint8)\n\n    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\n    and 32 = 0010 0000.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_343packbits = {"packbits", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_343packbits, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_342packbits};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_343packbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_myarray = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("packbits (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_myarray,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_myarray)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "packbits") < 0)) __PYX_ERR(0, 8454, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_myarray = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("packbits", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8454, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.packbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_342packbits(__pyx_self, __pyx_v_myarray, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_342packbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("packbits", 0);

  /* "ga4py/gain/notimplemented.pyx":8497
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8497, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8454
 * 
 * 
 * def packbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """packbits(myarray, axis=None)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.packbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8500
 * 
 * 
 * def percentile(a, q, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the qth percentile of the data along the specified axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_345percentile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_344percentile[] = "Compute the qth percentile of the data along the specified axis.\n\n    Returns the qth percentile of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    q : float in range of [0,100] (or sequence of floats)\n        Percentile to compute which must be between 0 and 100 inclusive.\n    axis : int, optional\n        Axis along which the percentiles are computed. The default (None)\n        is to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type (of the output) will be cast if necessary.\n    overwrite_input : bool, optional\n       If True, then allow use of memory of input array `a` for\n       calculations. The input array will be modified by the call to\n       median. This will save memory when you do not need to preserve\n       the contents of the input array. Treat the input as undefined,\n       but it will probably be fully or partially sorted.\n       Default is False. Note that, if `overwrite_input` is True and the\n       input is not already an array, an error will be raised.\n\n    Returns\n    -------\n    pcntile : ndarray\n        A new array holding the result (unless `out` is specified, in\n        which case that array is returned instead).  If the input contains\n        integers, or floats of smaller precision than 64, then the output\n        data-type is float64.  Otherwise, the output data-type is the same\n        as that of the input.\n\n    See Also\n    --------\n    mean, median\n\n    Notes\n    -----\n    Given a vector V of length N, the qth percentile of V is the qth ranked\n    value in a sorted copy of V.  A weighted average of the two nearest\n    neighbors is used if the normalized ranking does not match q exactly.\n    The same as the med""ian if ``q=0.5``, the same as the minimum if ``q=0``\n    and the same as the maximum if ``q=1``.\n\n    Examples\n    --------\n    >>> a = np.array([[10, 7, 4], [3, 2, 1]])\n    >>> a\n    array([[10,  7,  4],\n           [ 3,  2,  1]])\n    >>> np.percentile(a, 50)\n    3.5\n    >>> np.percentile(a, 0.5, axis=0)\n    array([ 6.5,  4.5,  2.5])\n    >>> np.percentile(a, 50, axis=1)\n    array([ 7.,  2.])\n\n    >>> m = np.percentile(a, 50, axis=0)\n    >>> out = np.zeros_like(m)\n    >>> np.percentile(a, 50, axis=0, out=m)\n    array([ 6.5,  4.5,  2.5])\n    >>> m\n    array([ 6.5,  4.5,  2.5])\n\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=1, overwrite_input=True)\n    array([ 7.,  2.])\n    >>> assert not np.all(a==b)\n    >>> b = a.copy()\n    >>> np.percentile(b, 50, axis=None, overwrite_input=True)\n    3.5\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_345percentile = {"percentile", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_345percentile, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_344percentile};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_345percentile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_q = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_overwrite_input = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("percentile (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_q,&__pyx_n_s_axis,&__pyx_n_s_out,&__pyx_n_s_overwrite_input,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_q)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("percentile", 0, 2, 5, 1); __PYX_ERR(0, 8500, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_overwrite_input);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "percentile") < 0)) __PYX_ERR(0, 8500, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_q = values[1];
    __pyx_v_axis = values[2];
    __pyx_v_out = values[3];
    __pyx_v_overwrite_input = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("percentile", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8500, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.percentile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_344percentile(__pyx_self, __pyx_v_a, __pyx_v_q, __pyx_v_axis, __pyx_v_out, __pyx_v_overwrite_input);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_344percentile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_q, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_overwrite_input) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("percentile", 0);

  /* "ga4py/gain/notimplemented.pyx":8577
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8577, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8500
 * 
 * 
 * def percentile(a, q, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the qth percentile of the data along the specified axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.percentile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8580
 * 
 * 
 * def piecewise(x, condlist, funclist):             # <<<<<<<<<<<<<<
 *     """Evaluate a piecewise-defined function.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_347piecewise(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_346piecewise[] = "Evaluate a piecewise-defined function.\n\n    Given a set of conditions and corresponding functions, evaluate each\n    function on the input data wherever its condition is true.\n\n    Parameters\n    ----------\n    x : ndarray\n        The input domain.\n    condlist : list of bool arrays\n        Each boolean array corresponds to a function in `funclist`.  Wherever\n        `condlist[i]` is True, `funclist[i](x)` is used as the output value.\n\n        Each boolean array in `condlist` selects a piece of `x`,\n        and should therefore be of the same shape as `x`.\n\n        The length of `condlist` must correspond to that of `funclist`.\n        If one extra function is given, i.e. if\n        ``len(funclist) - len(condlist) == 1``, then that extra function\n        is the default value, used wherever all conditions are false.\n    funclist : list of callables, f(x,*args,**kw), or scalars\n        Each function is evaluated over `x` wherever its corresponding\n        condition is True.  It should take an array as input and give an array\n        or a scalar value as output.  If, instead of a callable,\n        a scalar is provided then a constant function (``lambda x: scalar``) is\n        assumed.\n    args : tuple, optional\n        Any further arguments given to `piecewise` are passed to the functions\n        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then\n        each function is called as ``f(x, 1, 'a')``.\n    kw : dict, optional\n        Keyword arguments used in calling `piecewise` are passed to the\n        functions upon execution, i.e., if called\n        ``piecewise(..., ..., lambda=1)``, then each function is called as\n        ``f(x, lambda=1)``.\n\n    Returns\n    -------\n    out : ndarray\n        The output is the same shape and type as x and is found by\n        calling the functions in `funclist` on the appropriate portions of `x`,\n        as defined by the boolean arrays in `condlist`.  Portions not covered\n   ""     by any condition have undefined values.\n\n\n    See Also\n    --------\n    choose, select, where\n\n    Notes\n    -----\n    This is similar to choose or select, except that functions are\n    evaluated on elements of `x` that satisfy the corresponding condition from\n    `condlist`.\n\n    The result is::\n\n            |--\n            |funclist[0](x[condlist[0]])\n      out = |funclist[1](x[condlist[1]])\n            |...\n            |funclist[n2](x[condlist[n2]])\n            |--\n\n    Examples\n    --------\n    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.\n\n    >>> x = np.arange(6) - 2.5\n    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])\n    array([-1., -1., -1.,  1.,  1.,  1.])\n\n    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for\n    ``x >= 0``.\n\n    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])\n    array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_347piecewise = {"piecewise", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_347piecewise, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_346piecewise};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_347piecewise(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_condlist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_funclist = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("piecewise (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_condlist,&__pyx_n_s_funclist,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_condlist)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("piecewise", 1, 3, 3, 1); __PYX_ERR(0, 8580, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_funclist)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("piecewise", 1, 3, 3, 2); __PYX_ERR(0, 8580, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "piecewise") < 0)) __PYX_ERR(0, 8580, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_x = values[0];
    __pyx_v_condlist = values[1];
    __pyx_v_funclist = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("piecewise", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8580, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.piecewise", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_346piecewise(__pyx_self, __pyx_v_x, __pyx_v_condlist, __pyx_v_funclist);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_346piecewise(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_funclist) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("piecewise", 0);

  /* "ga4py/gain/notimplemented.pyx":8660
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8660, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8580
 * 
 * 
 * def piecewise(x, condlist, funclist):             # <<<<<<<<<<<<<<
 *     """Evaluate a piecewise-defined function.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.piecewise", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8663
 * 
 * 
 * def pkgload():             # <<<<<<<<<<<<<<
 *     """Load one or more packages into parent package top-level namespace.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_349pkgload(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_348pkgload[] = "Load one or more packages into parent package top-level namespace.\n\n       This function is intended to shorten the need to import many\n       subpackages, say of scipy, constantly with statements such as\n\n         import scipy.linalg, scipy.fftpack, scipy.etc...\n\n       Instead, you can say:\n\n         import scipy\n         scipy.pkgload('linalg','fftpack',...)\n\n       or\n\n         scipy.pkgload()\n\n       to load all of them in one call.\n\n       If a name which doesn't exist in scipy's namespace is\n       given, a warning is shown.\n\n       Parameters\n       ----------\n        *packages : arg-tuple\n             the names (one or more strings) of all the modules one\n             wishes to load into the top-level namespace.\n        verbose= : integer\n             verbosity level [default: -1].\n             verbose=-1 will suspend also warnings.\n        force= : bool\n             when True, force reloading loaded packages [default: False].\n        postpone= : bool\n             when True, don't load packages [default: False]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_349pkgload = {"pkgload", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_349pkgload, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_348pkgload};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_349pkgload(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pkgload (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_348pkgload(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_348pkgload(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pkgload", 0);

  /* "ga4py/gain/notimplemented.pyx":8699
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8699, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8663
 * 
 * 
 * def pkgload():             # <<<<<<<<<<<<<<
 *     """Load one or more packages into parent package top-level namespace.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pkgload", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8702
 * 
 * 
 * def place(arr, mask, vals):             # <<<<<<<<<<<<<<
 *     """Change elements of an array based on conditional and input values.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_351place(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_350place[] = "Change elements of an array based on conditional and input values.\n\n    Similar to ``np.putmask(arr, mask, vals)``, the difference is that `place`\n    uses the first N elements of `vals`, where N is the number of True values\n    in `mask`, while `putmask` uses the elements where `mask` is True.\n\n    Note that `extract` does the exact opposite of `place`.\n\n    Parameters\n    ----------\n    arr : array_like\n        Array to put data into.\n    mask : array_like\n        Boolean mask array. Must have the same size as `a`.\n    vals : 1-D sequence\n        Values to put into `a`. Only the first N elements are used, where\n        N is the number of True values in `mask`. If `vals` is smaller\n        than N it will be repeated.\n\n    See Also\n    --------\n    putmask, put, take, extract\n\n    Examples\n    --------\n    >>> arr = np.arange(6).reshape(2, 3)\n    >>> np.place(arr, arr>2, [44, 55])\n    >>> arr\n    array([[ 0,  1,  2],\n           [44, 55, 44]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_351place = {"place", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_351place, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_350place};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_351place(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mask = 0;
  CYTHON_UNUSED PyObject *__pyx_v_vals = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("place (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_mask,&__pyx_n_s_vals,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mask)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("place", 1, 3, 3, 1); __PYX_ERR(0, 8702, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_vals)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("place", 1, 3, 3, 2); __PYX_ERR(0, 8702, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "place") < 0)) __PYX_ERR(0, 8702, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_arr = values[0];
    __pyx_v_mask = values[1];
    __pyx_v_vals = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("place", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8702, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.place", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_350place(__pyx_self, __pyx_v_arr, __pyx_v_mask, __pyx_v_vals);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_350place(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_vals) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("place", 0);

  /* "ga4py/gain/notimplemented.pyx":8735
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8735, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8702
 * 
 * 
 * def place(arr, mask, vals):             # <<<<<<<<<<<<<<
 *     """Change elements of an array based on conditional and input values.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.place", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8738
 * 
 * 
 * def pmt(rate, nper, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the payment against loan principal plus interest.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_353pmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_352pmt[] = "Compute the payment against loan principal plus interest.\n\n    Given:\n     * a present value, `pv` (e.g., an amount borrowed)\n     * a future value, `fv` (e.g., 0)\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * and (optional) specification of whether payment is made\n       at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the (fixed) periodic payment.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like (optional)\n        Future value (default = 0)\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray\n        Payment against loan plus interest.  If all input is scalar, returns a\n        scalar float.  If any input is array_like, returns payment for each\n        input element. If multiple inputs are array_like, they all must have\n        the same shape.\n\n    Notes\n    -----\n    The payment is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n    or, when ``rate == 0``::\n\n      fv + pv + pmt * nper == 0\n\n    for ``pmt``.\n\n    Note that computing a monthly mortgage payment is only\n    one use for this function.  For example, pmt returns the\n    periodic deposit one must make to achieve a specified\n    future balance given an initial deposit, a fixed,\n    periodically compounded interest rate, and the total\n    number of periods.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) F""ormat - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php\n       ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the monthly payment needed to pay off a $200,000 loan in 15\n    years at an annual interest rate of 7.5%?\n\n    >>> np.pmt(0.075/12, 12*15, 200000)\n    -1854.0247200054619\n\n    In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained\n    today, a monthly payment of $1,854.02 would be required.  Note that this\n    example illustrates usage of `fv` having a default value of 0.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_353pmt = {"pmt", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_353pmt, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_352pmt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_353pmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pmt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rate,&__pyx_n_s_nper,&__pyx_n_s_pv,&__pyx_n_s_fv,&__pyx_n_s_when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)__pyx_int_0);
    values[4] = ((PyObject *)__pyx_n_s_end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pmt", 0, 3, 5, 1); __PYX_ERR(0, 8738, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pmt", 0, 3, 5, 2); __PYX_ERR(0, 8738, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fv);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "pmt") < 0)) __PYX_ERR(0, 8738, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_nper = values[1];
    __pyx_v_pv = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("pmt", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8738, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_352pmt(__pyx_self, __pyx_v_rate, __pyx_v_nper, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_352pmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pmt", 0);

  /* "ga4py/gain/notimplemented.pyx":8820
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8820, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8738
 * 
 * 
 * def pmt(rate, nper, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the payment against loan principal plus interest.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8823
 * 
 * 
 * def poly(seq_of_zeros):             # <<<<<<<<<<<<<<
 *     """Find the coefficients of a polynomial with the given sequence of roots.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_355poly(PyObject *__pyx_self, PyObject *__pyx_v_seq_of_zeros); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_354poly[] = "Find the coefficients of a polynomial with the given sequence of roots.\n\n    Returns the coefficients of the polynomial whose leading coefficient\n    is one for the given sequence of zeros (multiple roots must be included\n    in the sequence as many times as their multiplicity; see Examples).\n    A square matrix (or array, which will be treated as a matrix) can also\n    be given, in which case the coefficients of the characteristic polynomial\n    of the matrix are returned.\n\n    Parameters\n    ----------\n    seq_of_zeros : array_like, shape (N,) or (N, N)\n        A sequence of polynomial roots, or a square array or matrix object.\n\n    Returns\n    -------\n    c : ndarray\n        1D array of polynomial coefficients from highest to lowest degree:\n\n        ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``\n        where c[0] always equals 1.\n\n    Raises\n    ------\n    ValueError\n        If input is the wrong shape (the input must be a 1-D or square\n        2-D array).\n\n    See Also\n    --------\n    polyval : Evaluate a polynomial at a point.\n    roots : Return the roots of a polynomial.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    Specifying the roots of a polynomial still leaves one degree of\n    freedom, typically represented by an undetermined leading\n    coefficient. [1]_ In the case of this function, that coefficient -\n    the first one in the returned array - is always taken as one. (If\n    for some reason you have one other point, the only automatic way\n    presently to leverage that information is to use ``polyfit``.)\n\n    The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`\n    matrix **A** is given by\n\n        :math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`,\n\n    where **I** is the `n`-by-`n` identity matrix. [2]_\n\n    References\n    ----------\n    .. [1] M. Sullivan and M. Sullivan, III, \"Algebra a""nd Trignometry,\n       Enhanced With Graphing Utilities,\" Prentice-Hall, pg. 318, 1996.\n\n    .. [2] G. Strang, \"Linear Algebra and Its Applications, 2nd Edition,\"\n       Academic Press, pg. 182, 1980.\n\n    Examples\n    --------\n    Given a sequence of a polynomial's zeros:\n\n    >>> np.poly((0, 0, 0)) # Multiple root example\n    array([1, 0, 0, 0])\n    \n    The line above represents z**3 + 0*z**2 + 0*z + 0.\n\n    >>> np.poly((-1./2, 0, 1./2))\n    array([ 1.  ,  0.  , -0.25,  0.  ])\n    \n    The line above represents z**3 - z/4\n\n    >>> np.poly((np.random.random(1.)[0], 0, np.random.random(1.)[0]))\n    array([ 1.        , -0.77086955,  0.08618131,  0.        ]) #random\n\n    Given a square array object:\n\n    >>> P = np.array([[0, 1./3], [-1./2, 0]])\n    >>> np.poly(P)\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Or a square matrix object:\n\n    >>> np.poly(np.matrix(P))\n    array([ 1.        ,  0.        ,  0.16666667])\n\n    Note how in all cases the leading coefficient is always 1.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_355poly = {"poly", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_355poly, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_354poly};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_355poly(PyObject *__pyx_self, PyObject *__pyx_v_seq_of_zeros) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("poly (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_354poly(__pyx_self, ((PyObject *)__pyx_v_seq_of_zeros));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_354poly(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_seq_of_zeros) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("poly", 0);

  /* "ga4py/gain/notimplemented.pyx":8914
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8914, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8823
 * 
 * 
 * def poly(seq_of_zeros):             # <<<<<<<<<<<<<<
 *     """Find the coefficients of a polynomial with the given sequence of roots.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.poly", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8917
 * 
 * 
 * def polyadd(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the sum of two polynomials.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_357polyadd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_356polyadd[] = "Find the sum of two polynomials.\n\n    Returns the polynomial resulting from the sum of two input polynomials.\n    Each input must be either a poly1d object or a 1D sequence of polynomial\n    coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The sum of the inputs. If either input is a poly1d object, then the\n        output is also a poly1d object. Otherwise, it is a 1D array of\n        polynomial coefficients from highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\n    Examples\n    --------\n    >>> np.polyadd([1, 2], [9, 5, 4])\n    array([9, 6, 6])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2])\n    >>> p2 = np.poly1d([9, 5, 4])\n    >>> print p1\n    1 x + 2\n    >>> print p2\n       2\n    9 x + 5 x + 4\n    >>> print np.polyadd(p1, p2)\n       2\n    9 x + 6 x + 6\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_357polyadd = {"polyadd", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_357polyadd, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_356polyadd};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_357polyadd(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyadd (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a1,&__pyx_n_s_a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyadd", 1, 2, 2, 1); __PYX_ERR(0, 8917, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyadd") < 0)) __PYX_ERR(0, 8917, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyadd", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8917, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyadd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_356polyadd(__pyx_self, __pyx_v_a1, __pyx_v_a2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_356polyadd(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyadd", 0);

  /* "ga4py/gain/notimplemented.pyx":8960
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 8960, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8917
 * 
 * 
 * def polyadd(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the sum of two polynomials.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyadd", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":8963
 * 
 * 
 * def polyder(p, m=1):             # <<<<<<<<<<<<<<
 *     """Return the derivative of the specified order of a polynomial.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_359polyder(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_358polyder[] = "Return the derivative of the specified order of a polynomial.\n\n    Parameters\n    ----------\n    p : poly1d or sequence\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of differentiation (default: 1)\n\n    Returns\n    -------\n    der : poly1d\n        A new polynomial representing the derivative.\n\n    See Also\n    --------\n    polyint : Anti-derivative of a polynomial.\n    poly1d : Class for one-dimensional polynomials.\n\n    Examples\n    --------\n    The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:\n\n    >>> p = np.poly1d([1,1,1,1])\n    >>> p2 = np.polyder(p)\n    >>> p2\n    poly1d([3, 2, 1])\n\n    which evaluates to:\n\n    >>> p2(2.)\n    17.0\n\n    We can verify this, approximating the derivative with\n    ``(f(x + h) - f(x))/h``:\n\n    >>> (p(2. + 0.001) - p(2.)) / 0.001\n    17.007000999997857\n\n    The fourth-order derivative of a 3rd-order polynomial is zero:\n\n    >>> np.polyder(p, 2)\n    poly1d([6, 2])\n    >>> np.polyder(p, 3)\n    poly1d([6])\n    >>> np.polyder(p, 4)\n    poly1d([ 0.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_359polyder = {"polyder", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_359polyder, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_358polyder};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_359polyder(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyder (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_p,&__pyx_n_s_m,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_m);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyder") < 0)) __PYX_ERR(0, 8963, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_p = values[0];
    __pyx_v_m = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyder", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 8963, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyder", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_358polyder(__pyx_self, __pyx_v_p, __pyx_v_m);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_358polyder(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyder", 0);

  /* "ga4py/gain/notimplemented.pyx":9014
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9014, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8963
 * 
 * 
 * def polyder(p, m=1):             # <<<<<<<<<<<<<<
 *     """Return the derivative of the specified order of a polynomial.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyder", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9017
 * 
 * 
 * def polydiv(u, v):             # <<<<<<<<<<<<<<
 *     """Returns the quotient and remainder of polynomial division.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_361polydiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_360polydiv[] = "Returns the quotient and remainder of polynomial division.\n\n    The input arrays are the coefficients (including any coefficients\n    equal to zero) of the \"numerator\" (dividend) and \"denominator\"\n    (divisor) polynomials, respectively.\n\n    Parameters\n    ----------\n    u : array_like or poly1d\n        Dividend polynomial's coefficients.\n\n    v : array_like or poly1d\n        Divisor polynomial's coefficients.\n\n    Returns\n    -------\n    q : ndarray\n        Coefficients, including those equal to zero, of the quotient.\n    r : ndarray\n        Coefficients, including those equal to zero, of the remainder.\n\n    See Also\n    --------\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,\n    polyval\n\n    Notes\n    -----\n    Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need\n    not equal `v.ndim`. In other words, all four possible combinations -\n    ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,\n    ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.\n\n    Examples\n    --------\n    .. math:: \014rac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\n\n    >>> x = np.array([3.0, 5.0, 2.0])\n    >>> y = np.array([2.0, 1.0])\n    >>> np.polydiv(x, y)\n    (array([ 1.5 ,  1.75]), array([ 0.25]))\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_361polydiv = {"polydiv", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_361polydiv, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_360polydiv};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_361polydiv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_u = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polydiv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_u,&__pyx_n_s_v,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_u)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polydiv", 1, 2, 2, 1); __PYX_ERR(0, 9017, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polydiv") < 0)) __PYX_ERR(0, 9017, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_u = values[0];
    __pyx_v_v = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polydiv", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9017, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polydiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_360polydiv(__pyx_self, __pyx_v_u, __pyx_v_v);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_360polydiv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_u, CYTHON_UNUSED PyObject *__pyx_v_v) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polydiv", 0);

  /* "ga4py/gain/notimplemented.pyx":9061
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9061, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9017
 * 
 * 
 * def polydiv(u, v):             # <<<<<<<<<<<<<<
 *     """Returns the quotient and remainder of polynomial division.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polydiv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9064
 * 
 * 
 * def polyfit(x, y, deg, rcond=None, full=False):             # <<<<<<<<<<<<<<
 *     """Least squares polynomial fit.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_363polyfit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_362polyfit[] = "Least squares polynomial fit.\n\n    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`\n    to points `(x, y)`. Returns a vector of coefficients `p` that minimises\n    the squared error.\n\n    Parameters\n    ----------\n    x : array_like, shape (M,)\n        x-coordinates of the M sample points ``(x[i], y[i])``.\n    y : array_like, shape (M,) or (M, K)\n        y-coordinates of the sample points. Several data sets of sample\n        points sharing the same x-coordinates can be fitted at once by\n        passing in a 2D-array that contains one dataset per column.\n    deg : int\n        Degree of the fitting polynomial\n    rcond : float, optional\n        Relative condition number of the fit. Singular values smaller than this\n        relative to the largest singular value will be ignored. The default\n        value is len(x)*eps, where eps is the relative precision of the float\n        type, about 2e-16 in most cases.\n    full : bool, optional\n        Switch determining nature of return value. When it is\n        False (the default) just the coefficients are returned, when True\n        diagnostic information from the singular value decomposition is also\n        returned.\n\n    Returns\n    -------\n    p : ndarray, shape (M,) or (M, K)\n        Polynomial coefficients, highest power first.\n        If `y` was 2-D, the coefficients for `k`-th data set are in ``p[:,k]``.\n\n    residuals, rank, singular_values, rcond : present only if `full` = True\n        Residuals of the least-squares fit, the effective rank of the scaled\n        Vandermonde coefficient matrix, its singular values, and the specified\n        value of `rcond`. For more details, see `linalg.lstsq`.\n\n    Warns\n    -----\n    RankWarning\n        The rank of the coefficient matrix in the least-squares fit is\n        deficient. The warning is only raised if `full` = False.\n\n        The warnings can be turned off by\n\n        >>> import warnings\n        >>> war""nings.simplefilter('ignore', np.RankWarning)\n\n    See Also\n    --------\n    polyval : Computes polynomial values.\n    linalg.lstsq : Computes a least-squares fit.\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\n\n    Notes\n    -----\n    The solution minimizes the squared error\n\n    .. math ::\n        E = \\sum_{j=0}^k |p(x_j) - y_j|^2\n\n    in the equations::\n\n        x[0]**n * p[n] + ... + x[0] * p[1] + p[0] = y[0]\n        x[1]**n * p[n] + ... + x[1] * p[1] + p[0] = y[1]\n        ...\n        x[k]**n * p[n] + ... + x[k] * p[1] + p[0] = y[k]\n\n    The coefficient matrix of the coefficients `p` is a Vandermonde matrix.\n\n    `polyfit` issues a `RankWarning` when the least-squares fit is badly\n    conditioned. This implies that the best fit is not well-defined due\n    to numerical error. The results may be improved by lowering the polynomial\n    degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter\n    can also be set to a value smaller than its default, but the resulting\n    fit may be spurious: including contributions from the small singular\n    values can add numerical noise to the result.\n\n    Note that fitting polynomial coefficients is inherently badly conditioned\n    when the degree of the polynomial is large or the interval of sample points\n    is badly centered. The quality of the fit should always be checked in these\n    cases. When polynomial fits are not satisfactory, splines may be a good\n    alternative.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Curve fitting\",\n           http://en.wikipedia.org/wiki/Curve_fitting\n    .. [2] Wikipedia, \"Polynomial interpolation\",\n           http://en.wikipedia.org/wiki/Polynomial_interpolation\n\n    Examples\n    --------\n    >>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n    >>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n    >>> z = np.polyfit(x, y, 3)\n    >>> z\n    array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]"")\n\n    It is convenient to use `poly1d` objects for dealing with polynomials:\n\n    >>> p = np.poly1d(z)\n    >>> p(0.5)\n    0.6143849206349179\n    >>> p(3.5)\n    -0.34732142857143039\n    >>> p(10)\n    22.579365079365115\n\n    High-order polynomials may oscillate wildly:\n\n    >>> p30 = np.poly1d(np.polyfit(x, y, 30))\n    /... RankWarning: Polyfit may be poorly conditioned...\n    >>> p30(4)\n    -0.80000000000000204\n    >>> p30(5)\n    -0.99999999999999445\n    >>> p30(4.5)\n    -0.10547061179440398\n\n    Illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> xp = np.linspace(-2, 6, 100)\n    >>> plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n    [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim(-2,2)\n    (-2, 2)\n    >>> plt.show()\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_363polyfit = {"polyfit", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_363polyfit, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_362polyfit};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_363polyfit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_deg = 0;
  CYTHON_UNUSED PyObject *__pyx_v_rcond = 0;
  CYTHON_UNUSED PyObject *__pyx_v_full = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyfit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_deg,&__pyx_n_s_rcond,&__pyx_n_s_full,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyfit", 0, 3, 5, 1); __PYX_ERR(0, 9064, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deg)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyfit", 0, 3, 5, 2); __PYX_ERR(0, 9064, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rcond);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_full);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyfit") < 0)) __PYX_ERR(0, 9064, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
    __pyx_v_deg = values[2];
    __pyx_v_rcond = values[3];
    __pyx_v_full = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyfit", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9064, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyfit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_362polyfit(__pyx_self, __pyx_v_x, __pyx_v_y, __pyx_v_deg, __pyx_v_rcond, __pyx_v_full);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_362polyfit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_deg, CYTHON_UNUSED PyObject *__pyx_v_rcond, CYTHON_UNUSED PyObject *__pyx_v_full) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyfit", 0);

  /* "ga4py/gain/notimplemented.pyx":9197
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9197, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9064
 * 
 * 
 * def polyfit(x, y, deg, rcond=None, full=False):             # <<<<<<<<<<<<<<
 *     """Least squares polynomial fit.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyfit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9200
 * 
 * 
 * def polyint(p, m=1, k=None):             # <<<<<<<<<<<<<<
 *     """Return an antiderivative (indefinite integral) of a polynomial.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_365polyint(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_364polyint[] = "Return an antiderivative (indefinite integral) of a polynomial.\n\n    The returned order `m` antiderivative `P` of polynomial `p` satisfies\n    :math:`\014rac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`\n    integration constants `k`. The constants determine the low-order\n    polynomial part\n\n    .. math:: \014rac{k_{m-1}}{0!} x^0 + \\ldots + \014rac{k_0}{(m-1)!}x^{m-1}\n\n    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.\n\n    Parameters\n    ----------\n    p : {array_like, poly1d}\n        Polynomial to differentiate.\n        A sequence is interpreted as polynomial coefficients, see `poly1d`.\n    m : int, optional\n        Order of the antiderivative. (Default: 1)\n    k : {None, list of `m` scalars, scalar}, optional\n        Integration constants. They are given in the order of integration:\n        those corresponding to highest-order terms come first.\n\n        If ``None`` (default), all constants are assumed to be zero.\n        If `m = 1`, a single scalar can be given instead of a list.\n\n    See Also\n    --------\n    polyder : derivative of a polynomial\n    poly1d.integ : equivalent method\n\n    Examples\n    --------\n    The defining property of the antiderivative:\n\n    >>> p = np.poly1d([1,1,1])\n    >>> P = np.polyint(p)\n    >>> P\n    poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])\n    >>> np.polyder(P) == p\n    True\n\n    The integration constants default to zero, but can be specified:\n\n    >>> P = np.polyint(p, 3)\n    >>> P(0)\n    0.0\n    >>> np.polyder(P)(0)\n    0.0\n    >>> np.polyder(P, 2)(0)\n    0.0\n    >>> P = np.polyint(p, 3, k=[6,5,3])\n    >>> P\n    poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ])\n\n    Note that 3 = 6 / 2!, and that the constants are given in the order of\n    integrations. Constant of the highest-order polynomial term comes first:\n\n    >>> np.polyder(P, 2)(0)\n    6.0\n    >>> np.polyder(P, 1)(0)\n    5.0\n    >>> P(0)\n    3.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_365polyint = {"polyint", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_365polyint, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_364polyint};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_365polyint(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyint (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_p,&__pyx_n_s_m,&__pyx_n_s_k,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_m);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyint") < 0)) __PYX_ERR(0, 9200, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_p = values[0];
    __pyx_v_m = values[1];
    __pyx_v_k = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyint", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9200, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_364polyint(__pyx_self, __pyx_v_p, __pyx_v_m, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_364polyint(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyint", 0);

  /* "ga4py/gain/notimplemented.pyx":9266
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9266, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9200
 * 
 * 
 * def polyint(p, m=1, k=None):             # <<<<<<<<<<<<<<
 *     """Return an antiderivative (indefinite integral) of a polynomial.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyint", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9269
 * 
 * 
 * def polymul(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the product of two polynomials.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_367polymul(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_366polymul[] = "Find the product of two polynomials.\n\n    Finds the polynomial resulting from the multiplication of the two input\n    polynomials. Each input must be either a poly1d object or a 1D sequence\n    of polynomial coefficients, from highest to lowest degree.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d object\n        Input polynomials.\n\n    Returns\n    -------\n    out : ndarray or poly1d object\n        The polynomial resulting from the multiplication of the inputs. If\n        either inputs is a poly1d object, then the output is also a poly1d\n        object. Otherwise, it is a 1D array of polynomial coefficients from\n        highest to lowest degree.\n\n    See Also\n    --------\n    poly1d : A one-dimensional polynomial class.\n    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,\n    polyval\n\n    Examples\n    --------\n    >>> np.polymul([1, 2, 3], [9, 5, 1])\n    array([ 9, 23, 38, 17,  3])\n\n    Using poly1d objects:\n\n    >>> p1 = np.poly1d([1, 2, 3])\n    >>> p2 = np.poly1d([9, 5, 1])\n    >>> print p1\n       2\n    1 x + 2 x + 3\n    >>> print p2\n       2\n    9 x + 5 x + 1\n    >>> print np.polymul(p1, p2)\n       4      3      2\n    9 x + 23 x + 38 x + 17 x + 3\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_367polymul = {"polymul", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_367polymul, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_366polymul};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_367polymul(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polymul (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a1,&__pyx_n_s_a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polymul", 1, 2, 2, 1); __PYX_ERR(0, 9269, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polymul") < 0)) __PYX_ERR(0, 9269, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polymul", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9269, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polymul", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_366polymul(__pyx_self, __pyx_v_a1, __pyx_v_a2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_366polymul(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polymul", 0);

  /* "ga4py/gain/notimplemented.pyx":9315
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9315, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9269
 * 
 * 
 * def polymul(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the product of two polynomials.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polymul", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9318
 * 
 * 
 * def polysub(a1, a2):             # <<<<<<<<<<<<<<
 *     """Difference (subtraction) of two polynomials.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_369polysub(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_368polysub[] = "Difference (subtraction) of two polynomials.\n\n    Given two polynomials `a1` and `a2`, returns ``a1 - a2``.\n    `a1` and `a2` can be either array_like sequences of the polynomials'\n    coefficients (including coefficients equal to zero), or `poly1d` objects.\n\n    Parameters\n    ----------\n    a1, a2 : array_like or poly1d\n        Minuend and subtrahend polynomials, respectively.\n\n    Returns\n    -------\n    out : ndarray or poly1d\n        Array or `poly1d` object of the difference polynomial's coefficients.\n\n    See Also\n    --------\n    polyval, polydiv, polymul, polyadd\n\n    Examples\n    --------\n    .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\n\n    >>> np.polysub([2, 10, -2], [3, 10, -4])\n    array([-1,  0,  2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_369polysub = {"polysub", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_369polysub, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_368polysub};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_369polysub(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_a2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polysub (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a1,&__pyx_n_s_a2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polysub", 1, 2, 2, 1); __PYX_ERR(0, 9318, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polysub") < 0)) __PYX_ERR(0, 9318, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a1 = values[0];
    __pyx_v_a2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polysub", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9318, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polysub", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_368polysub(__pyx_self, __pyx_v_a1, __pyx_v_a2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_368polysub(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a1, CYTHON_UNUSED PyObject *__pyx_v_a2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polysub", 0);

  /* "ga4py/gain/notimplemented.pyx":9347
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9347, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9318
 * 
 * 
 * def polysub(a1, a2):             # <<<<<<<<<<<<<<
 *     """Difference (subtraction) of two polynomials.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polysub", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9350
 * 
 * 
 * def polyval(p, x):             # <<<<<<<<<<<<<<
 *     """Evaluate a polynomial at specific values.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_371polyval(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_370polyval[] = "Evaluate a polynomial at specific values.\n\n    If `p` is of length N, this function returns the value:\n\n        ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``\n\n    If `x` is a sequence, then `p(x)` is returned for each element of `x`.\n    If `x` is another polynomial then the composite polynomial `p(x(t))`\n    is returned.\n\n    Parameters\n    ----------\n    p : array_like or poly1d object\n       1D array of polynomial coefficients (including coefficients equal\n       to zero) from highest degree to the constant term, or an\n       instance of poly1d.\n    x : array_like or poly1d object\n       A number, a 1D array of numbers, or an instance of poly1d, \"at\"\n       which to evaluate `p`.\n\n    Returns\n    -------\n    values : ndarray or poly1d\n       If `x` is a poly1d instance, the result is the composition of the two\n       polynomials, i.e., `x` is \"substituted\" in `p` and the simplified\n       result is returned. In addition, the type of `x` - array_like or\n       poly1d - governs the type of the output: `x` array_like => `values`\n       array_like, `x` a poly1d object => `values` is also.\n\n    See Also\n    --------\n    poly1d: A polynomial class.\n\n    Notes\n    -----\n    Horner's scheme [1]_ is used to evaluate the polynomial. Even so,\n    for polynomials of high degree the values may be inaccurate due to\n    rounding errors. Use carefully.\n\n    References\n    ----------\n    .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.\n       trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand\n       Reinhold Co., 1985, pg. 720.\n\n    Examples\n    --------\n    >>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n    76\n    >>> np.polyval([3,0,1], np.poly1d(5))\n    poly1d([ 76.])\n    >>> np.polyval(np.poly1d([3,0,1]), 5)\n    76\n    >>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\n    poly1d([ 76.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_371polyval = {"polyval", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_371polyval, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_370polyval};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_371polyval(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyval (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_p,&__pyx_n_s_x,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("polyval", 1, 2, 2, 1); __PYX_ERR(0, 9350, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "polyval") < 0)) __PYX_ERR(0, 9350, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_p = values[0];
    __pyx_v_x = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("polyval", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9350, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_370polyval(__pyx_self, __pyx_v_p, __pyx_v_x);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_370polyval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("polyval", 0);

  /* "ga4py/gain/notimplemented.pyx":9408
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9408, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9350
 * 
 * 
 * def polyval(p, x):             # <<<<<<<<<<<<<<
 *     """Evaluate a polynomial at specific values.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.polyval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9411
 * 
 * 
 * def ppmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment against loan principal.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_373ppmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_372ppmt[] = "Not implemented. Compute the payment against loan principal.\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    per : array_like, int\n        Amount paid against the loan changes.  The `per` is the period of\n        interest.\n    nper : array_like\n        Number of compounding periods\n    pv : array_like\n        Present value\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}\n        When payments are due ('begin' (1) or 'end' (0))\n\n    See Also\n    --------\n    pmt, pv, ipmt\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_373ppmt = {"ppmt", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_373ppmt, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_372ppmt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_373ppmt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_per = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ppmt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rate,&__pyx_n_s_per,&__pyx_n_s_nper,&__pyx_n_s_pv,&__pyx_n_s_fv,&__pyx_n_s_when,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_float_0_0);
    values[5] = ((PyObject *)__pyx_n_s_end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_per)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, 1); __PYX_ERR(0, 9411, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, 2); __PYX_ERR(0, 9411, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, 3); __PYX_ERR(0, 9411, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fv);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_when);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ppmt") < 0)) __PYX_ERR(0, 9411, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_per = values[1];
    __pyx_v_nper = values[2];
    __pyx_v_pv = values[3];
    __pyx_v_fv = values[4];
    __pyx_v_when = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ppmt", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9411, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ppmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_372ppmt(__pyx_self, __pyx_v_rate, __pyx_v_per, __pyx_v_nper, __pyx_v_pv, __pyx_v_fv, __pyx_v_when);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_372ppmt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_per, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ppmt", 0);

  /* "ga4py/gain/notimplemented.pyx":9435
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9435, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9411
 * 
 * 
 * def ppmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment against loan principal.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ppmt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9438
 * 
 * 
 * def prod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_375prod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_374prod[] = "Return the product of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis over which the product is taken.  By default, the product\n        of all elements is calculated.\n    dtype : data-type, optional\n        The data-type of the returned array, as well as of the accumulator\n        in which the elements are multiplied.  By default, if `a` is of\n        integer type, `dtype` is the default platform integer. (Note: if\n        the type of `a` is unsigned, then so is `dtype`.)  Otherwise,\n        the dtype is the same as that of `a`.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output, but the type of the\n        output values will be cast if necessary.\n\n    Returns\n    -------\n    product_along_axis : ndarray, see `dtype` parameter above.\n        An array shaped as `a` but with the specified axis removed.\n        Returns a reference to `out` if specified.\n\n    See Also\n    --------\n    ndarray.prod : equivalent method\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.  That means that, on a 32-bit platform:\n\n    >>> x = np.array([536870910, 536870910, 536870910, 536870910])\n    >>> np.prod(x) #random\n    16\n\n    Examples\n    --------\n    By default, calculate the product of all elements:\n\n    >>> np.prod([1.,2.])\n    2.0\n\n    Even when the input array is two-dimensional:\n\n    >>> np.prod([[1.,2.],[3.,4.]])\n    24.0\n\n    But we can also specify the axis over which to multiply:\n\n    >>> np.prod([[1.,2.],[3.,4.]], axis=1)\n    array([  2.,  12.])\n\n    If the type of `x` is unsigned, then the output type is\n    the unsigned platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.uint8)\n    >>> np.prod(x).dtype ""== np.uint\n    True\n\n    If `x` is of a signed integer type, then the output type\n    is the default platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.int8)\n    >>> np.prod(x).dtype == np.int\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_375prod = {"prod", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_375prod, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_374prod};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_375prod(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("prod (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "prod") < 0)) __PYX_ERR(0, 9438, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("prod", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9438, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.prod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_374prod(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_374prod(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("prod", 0);

  /* "ga4py/gain/notimplemented.pyx":9511
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9511, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9438
 * 
 * 
 * def prod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.prod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9514
 * 
 * 
 * def product(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_377product(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_376product[] = "Return the product of array elements over a given axis.\n\n    See Also\n    --------\n    prod : equivalent function; see for details.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_377product = {"product", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_377product, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_376product};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_377product(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("product (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "product") < 0)) __PYX_ERR(0, 9514, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("product", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9514, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.product", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_376product(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_376product(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("product", 0);

  /* "ga4py/gain/notimplemented.pyx":9522
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9522, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9514
 * 
 * 
 * def product(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.product", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9525
 * 
 * 
 * def promote_types(type1, type2):             # <<<<<<<<<<<<<<
 *     """promote_types(type1, type2)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_379promote_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_378promote_types[] = "promote_types(type1, type2)\n\n    Returns the data type with the smallest size and smallest scalar\n    kind to which both ``type1`` and ``type2`` may be safely cast.\n    The returned data type is always in native byte order.\n\n    This function is symmetric and associative.\n\n    Parameters\n    ----------\n    type1 : dtype or dtype specifier\n        First data type.\n    type2 : dtype or dtype specifier\n        Second data type.\n\n    Returns\n    -------\n    out : dtype\n        The promoted data type.\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    See Also\n    --------\n    result_type, dtype, can_cast\n\n    Examples\n    --------\n    >>> np.promote_types('f4', 'f8')\n    dtype('float64')\n\n    >>> np.promote_types('i8', 'f4')\n    dtype('float64')\n\n    >>> np.promote_types('>i8', '<c8')\n    dtype('complex128')\n\n    >>> np.promote_types('i1', 'S8')\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: invalid type promotion\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_379promote_types = {"promote_types", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_379promote_types, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_378promote_types};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_379promote_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_type1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_type2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("promote_types (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_type1,&__pyx_n_s_type2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_type1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_type2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("promote_types", 1, 2, 2, 1); __PYX_ERR(0, 9525, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "promote_types") < 0)) __PYX_ERR(0, 9525, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_type1 = values[0];
    __pyx_v_type2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("promote_types", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9525, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.promote_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_378promote_types(__pyx_self, __pyx_v_type1, __pyx_v_type2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_378promote_types(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_type1, CYTHON_UNUSED PyObject *__pyx_v_type2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("promote_types", 0);

  /* "ga4py/gain/notimplemented.pyx":9572
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9572, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9525
 * 
 * 
 * def promote_types(type1, type2):             # <<<<<<<<<<<<<<
 *     """promote_types(type1, type2)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.promote_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9575
 * 
 * 
 * def ptp(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Range of values (maximum - minimum) along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_381ptp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_380ptp[] = "Range of values (maximum - minimum) along an axis.\n\n    The name of the function comes from the acronym for 'peak to peak'.\n\n    Parameters\n    ----------\n    a : array_like\n        Input values.\n    axis : int, optional\n        Axis along which to find the peaks.  By default, flatten the\n        array.\n    out : array_like\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output,\n        but the type of the output values will be cast if necessary.\n\n    Returns\n    -------\n    ptp : ndarray\n        A new array holding the result, unless `out` was\n        specified, in which case a reference to `out` is returned.\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.ptp(x, axis=0)\n    array([2, 2])\n\n    >>> np.ptp(x, axis=1)\n    array([1, 1])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_381ptp = {"ptp", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_381ptp, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_380ptp};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_381ptp(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ptp (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ptp") < 0)) __PYX_ERR(0, 9575, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ptp", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9575, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ptp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_380ptp(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_380ptp(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ptp", 0);

  /* "ga4py/gain/notimplemented.pyx":9612
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9612, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9575
 * 
 * 
 * def ptp(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Range of values (maximum - minimum) along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ptp", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9615
 * 
 * 
 * def put(a, ind, v, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Replaces specified elements of an array with given values.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_383put(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_382put[] = "Replaces specified elements of an array with given values.\n\n    The indexing works on the flattened target array. `put` is roughly\n    equivalent to:\n\n    ::\n\n        a.flat[ind] = v\n\n    Parameters\n    ----------\n    a : ndarray\n        Target array.\n    ind : array_like\n        Target indices, interpreted as integers.\n    v : array_like\n        Values to place in `a` at target indices. If `v` is shorter than\n        `ind` it will be repeated as necessary.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    See Also\n    --------\n    putmask, place\n\n    Examples\n    --------\n    >>> a = np.arange(5)\n    >>> np.put(a, [0, 2], [-44, -55])\n    >>> a\n    array([-44,   1, -55,   3,   4])\n\n    >>> a = np.arange(5)\n    >>> np.put(a, 22, -5, mode='clip')\n    >>> a\n    array([ 0,  1,  2,  3, -5])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_383put = {"put", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_383put, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_382put};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_383put(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ind = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("put (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_ind,&__pyx_n_s_v,&__pyx_n_s_mode,0};
    PyObject* values[4] = {0,0,0,0};
    values[3] = ((PyObject *)__pyx_n_s_raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ind)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("put", 0, 3, 4, 1); __PYX_ERR(0, 9615, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("put", 0, 3, 4, 2); __PYX_ERR(0, 9615, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "put") < 0)) __PYX_ERR(0, 9615, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_ind = values[1];
    __pyx_v_v = values[2];
    __pyx_v_mode = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("put", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9615, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.put", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_382put(__pyx_self, __pyx_v_a, __pyx_v_ind, __pyx_v_v, __pyx_v_mode);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_382put(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_ind, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("put", 0);

  /* "ga4py/gain/notimplemented.pyx":9662
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9662, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9615
 * 
 * 
 * def put(a, ind, v, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Replaces specified elements of an array with given values.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.put", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9665
 * 
 * 
 * def putmask(a, mask, values):             # <<<<<<<<<<<<<<
 *     """putmask(a, mask, values)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_385putmask(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_384putmask[] = "putmask(a, mask, values)\n\n    Changes elements of an array based on conditional and input values.\n\n    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.\n\n    If `values` is not the same size as `a` and `mask` then it will repeat.\n    This gives behavior different from ``a[mask] = values``.\n\n    Parameters\n    ----------\n    a : array_like\n        Target array.\n    mask : array_like\n        Boolean mask array. It has to be the same shape as `a`.\n    values : array_like\n        Values to put into `a` where `mask` is True. If `values` is smaller\n        than `a` it will be repeated.\n\n    See Also\n    --------\n    place, put, take\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2, 3)\n    >>> np.putmask(x, x>2, x**2)\n    >>> x\n    array([[ 0,  1,  2],\n           [ 9, 16, 25]])\n\n    If `values` is smaller than `a` it is repeated:\n\n    >>> x = np.arange(5)\n    >>> np.putmask(x, x>1, [-33, -44])\n    >>> x\n    array([  0,   1, -33, -44, -33])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_385putmask = {"putmask", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_385putmask, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_384putmask};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_385putmask(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mask = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("putmask (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_mask,&__pyx_n_s_values,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mask)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("putmask", 1, 3, 3, 1); __PYX_ERR(0, 9665, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("putmask", 1, 3, 3, 2); __PYX_ERR(0, 9665, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "putmask") < 0)) __PYX_ERR(0, 9665, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_a = values[0];
    __pyx_v_mask = values[1];
    __pyx_v_values = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("putmask", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9665, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.putmask", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_384putmask(__pyx_self, __pyx_v_a, __pyx_v_mask, __pyx_v_values);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_384putmask(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_mask, CYTHON_UNUSED PyObject *__pyx_v_values) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("putmask", 0);

  /* "ga4py/gain/notimplemented.pyx":9706
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9706, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9665
 * 
 * 
 * def putmask(a, mask, values):             # <<<<<<<<<<<<<<
 *     """putmask(a, mask, values)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.putmask", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9709
 * 
 * 
 * def pv(rate, nper, pmt, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the present value.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_387pv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_386pv[] = "Compute the present value.\n\n    Given:\n     * a future value, `fv`\n     * an interest `rate` compounded once per period, of which\n       there are\n     * `nper` total\n     * a (fixed) payment, `pmt`, paid either\n     * at the beginning (`when` = {'begin', 1}) or the end\n       (`when` = {'end', 0}) of each period\n\n    Return:\n       the value now\n\n    Parameters\n    ----------\n    rate : array_like\n        Rate of interest (per period)\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    fv : array_like, optional\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n\n    Returns\n    -------\n    out : ndarray, float\n        Present value of a series of payments or investments.\n\n    Notes\n    -----\n    The present value is computed by solving the equation::\n\n     fv +\n     pv*(1 + rate)**nper +\n     pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0\n\n    or, when ``rate = 0``::\n\n     fv + pv + pmt * nper = 0\n\n    for `pv`, which is then returned.\n\n    References\n    ----------\n    .. [WRW] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\n       Open Document Format for Office Applications (OpenDocument)v1.2,\n       Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\n       Pre-Draft 12. Organization for the Advancement of Structured Information\n       Standards (OASIS). Billerica, MA, USA. [ODT Document].\n       Available:\n       http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n       OpenDocument-formula-20090508.odt\n\n    Examples\n    --------\n    What is the present value (e.g., the initial investment)\n    of an investment that needs to total $15692.93\n    after 10 years of saving $100 every month?  Assume the\n    interest rate is 5% (annually) compounded monthly.\n\n    >>> np.pv(0.05/12, 10*12, -100, 15692.93)\n   "" -100.00067131625819\n\n    By convention, the negative sign represents cash flow out\n    (i.e., money not available today).  Thus, to end up with\n    $15,692.93 in 10 years saving $100 a month at 5% annual\n    interest, one's initial deposit should also be $100.\n\n    If any input is array_like, ``pv`` returns an array of equal shape.\n    Let's compare different interest rates in the example above:\n\n    >>> a = np.array((0.05, 0.04, 0.03))/12\n    >>> np.pv(a, 10*12, -100, 15692.93)\n    array([ -100.00067132,  -649.26771385, -1273.78633713])\n\n    So, to end up with the same $15692.93 under the same $100 per month\n    \"savings plan,\" for annual interest rates of 4% and 3%, one would\n    need initial investments of $649.27 and $1273.79, respectively.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_387pv = {"pv", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_387pv, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_386pv};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_387pv(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_rate = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pv (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_rate,&__pyx_n_s_nper,&__pyx_n_s_pmt,&__pyx_n_s_fv,&__pyx_n_s_when,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)__pyx_float_0_0);
    values[4] = ((PyObject *)__pyx_n_s_end);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nper)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pv", 0, 3, 5, 1); __PYX_ERR(0, 9709, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("pv", 0, 3, 5, 2); __PYX_ERR(0, 9709, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fv);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_when);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "pv") < 0)) __PYX_ERR(0, 9709, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_rate = values[0];
    __pyx_v_nper = values[1];
    __pyx_v_pmt = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("pv", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9709, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_386pv(__pyx_self, __pyx_v_rate, __pyx_v_nper, __pyx_v_pmt, __pyx_v_fv, __pyx_v_when);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_386pv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_rate, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pv", 0);

  /* "ga4py/gain/notimplemented.pyx":9794
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9794, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9709
 * 
 * 
 * def pv(rate, nper, pmt, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the present value.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.pv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9797
 * 
 * 
 * def rank(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_389rank(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_388rank[] = "Return the number of dimensions of an array.\n\n    If `a` is not already an array, a conversion is attempted.\n    Scalars are zero dimensional.\n\n    Parameters\n    ----------\n    a : array_like\n        Array whose number of dimensions is desired. If `a` is not an array,\n        a conversion is attempted.\n\n    Returns\n    -------\n    number_of_dimensions : int\n        The number of dimensions in the array.\n\n    See Also\n    --------\n    ndim : equivalent function\n    ndarray.ndim : equivalent property\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n\n    Notes\n    -----\n    In the old Numeric package, `rank` was the term used for the number of\n    dimensions, but in Numpy `ndim` is used instead.\n\n    Examples\n    --------\n    >>> np.rank([1,2,3])\n    1\n    >>> np.rank(np.array([[1,2,3],[4,5,6]]))\n    2\n    >>> np.rank(1)\n    0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_389rank = {"rank", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_389rank, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_388rank};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_389rank(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rank (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_388rank(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_388rank(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rank", 0);

  /* "ga4py/gain/notimplemented.pyx":9836
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9836, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9797
 * 
 * 
 * def rank(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rank", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9839
 * 
 * 
 * def rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100):             # <<<<<<<<<<<<<<
 *     """Compute the rate of interest per period.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_391rate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_390rate[] = "Compute the rate of interest per period.\n\n    Parameters\n    ----------\n    nper : array_like\n        Number of compounding periods\n    pmt : array_like\n        Payment\n    pv : array_like\n        Present value\n    fv : array_like\n        Future value\n    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional\n        When payments are due ('begin' (1) or 'end' (0))\n    guess : float, optional\n        Starting guess for solving the rate of interest\n    tol : float, optional\n        Required tolerance for the solution\n    maxiter : int, optional\n        Maximum iterations in finding the solution\n\n    Notes\n    -----\n    The rate of interest is computed by iteratively solving the\n    (non-linear) equation::\n\n     fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0\n\n    for ``rate``.\n\n    References\n    ----------\n    Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document\n    Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated\n    Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12.\n    Organization for the Advancement of Structured Information Standards\n    (OASIS). Billerica, MA, USA. [ODT Document]. Available:\n    http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\n    OpenDocument-formula-20090508.odt\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_391rate = {"rate", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_391rate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_390rate};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_391rate(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_nper = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_pv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fv = 0;
  CYTHON_UNUSED PyObject *__pyx_v_when = 0;
  CYTHON_UNUSED PyObject *__pyx_v_guess = 0;
  CYTHON_UNUSED PyObject *__pyx_v_tol = 0;
  CYTHON_UNUSED PyObject *__pyx_v_maxiter = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_nper,&__pyx_n_s_pmt,&__pyx_n_s_pv,&__pyx_n_s_fv,&__pyx_n_s_when,&__pyx_n_s_guess,&__pyx_n_s_tol,&__pyx_n_s_maxiter,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    values[4] = ((PyObject *)__pyx_n_s_end);
    values[5] = ((PyObject *)__pyx_float_0_1);
    values[6] = ((PyObject *)__pyx_float_1eneg_06);
    values[7] = ((PyObject *)__pyx_int_100);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nper)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pmt)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, 1); __PYX_ERR(0, 9839, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, 2); __PYX_ERR(0, 9839, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fv)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, 3); __PYX_ERR(0, 9839, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_when);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_guess);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_tol);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_maxiter);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rate") < 0)) __PYX_ERR(0, 9839, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_nper = values[0];
    __pyx_v_pmt = values[1];
    __pyx_v_pv = values[2];
    __pyx_v_fv = values[3];
    __pyx_v_when = values[4];
    __pyx_v_guess = values[5];
    __pyx_v_tol = values[6];
    __pyx_v_maxiter = values[7];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rate", 0, 4, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9839, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_390rate(__pyx_self, __pyx_v_nper, __pyx_v_pmt, __pyx_v_pv, __pyx_v_fv, __pyx_v_when, __pyx_v_guess, __pyx_v_tol, __pyx_v_maxiter);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_390rate(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_nper, CYTHON_UNUSED PyObject *__pyx_v_pmt, CYTHON_UNUSED PyObject *__pyx_v_pv, CYTHON_UNUSED PyObject *__pyx_v_fv, CYTHON_UNUSED PyObject *__pyx_v_when, CYTHON_UNUSED PyObject *__pyx_v_guess, CYTHON_UNUSED PyObject *__pyx_v_tol, CYTHON_UNUSED PyObject *__pyx_v_maxiter) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rate", 0);

  /* "ga4py/gain/notimplemented.pyx":9881
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9881, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9839
 * 
 * 
 * def rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100):             # <<<<<<<<<<<<<<
 *     """Compute the rate of interest per period.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9884
 * 
 * 
 * def ravel(a, order='C'):             # <<<<<<<<<<<<<<
 *     """Return a flattened array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_393ravel(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_392ravel[] = "Return a flattened array.\n\n    A 1-D array, containing the elements of the input, is returned.  A copy is\n    made only if needed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.  The elements in ``a`` are read in the order specified by\n        `order`, and packed as a 1-D array.\n    order : {'C','F', 'A', 'K'}, optional\n        The elements of ``a`` are read in this order. 'C' means to view\n        the elements in C (row-major) order. 'F' means to view the elements\n        in Fortran (column-major) order. 'A' means to view the elements\n        in 'F' order if a is Fortran contiguous, 'C' order otherwise.\n        'K' means to view the elements in the order they occur in memory,\n        except for reversing the data when strides are negative.\n        By default, 'C' order is used.\n\n    Returns\n    -------\n    1d_array : ndarray\n        Output of the same dtype as `a`, and of shape ``(a.size(),)``.\n\n    See Also\n    --------\n    ndarray.flat : 1-D iterator over an array.\n    ndarray.flatten : 1-D array copy of the elements of an array\n                      in row-major order.\n\n    Notes\n    -----\n    In row-major order, the row index varies the slowest, and the column\n    index the quickest.  This can be generalized to multiple dimensions,\n    where row-major order implies that the index along the first axis\n    varies slowest, and the index along the last quickest.  The opposite holds\n    for Fortran-, or column-major, mode.\n\n    Examples\n    --------\n    It is equivalent to ``reshape(-1, order=order)``.\n\n    >>> x = np.array([[1, 2, 3], [4, 5, 6]])\n    >>> print np.ravel(x)\n    [1 2 3 4 5 6]\n\n    >>> print x.reshape(-1)\n    [1 2 3 4 5 6]\n\n    >>> print np.ravel(x, order='F')\n    [1 4 2 5 3 6]\n\n    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:\n\n    >>> print np.ravel(x.T)\n    [1 4 2 5 3 6]\n    >>> print np.ravel(x.T, order='A')\n    [1 2 3 4 5 6]\n\n    When ``or""der`` is 'K', it will preserve orderings that are neither 'C'\n    nor 'F', but won't reverse axes:\n\n    >>> a = np.arange(3)[::-1]; a\n    array([2, 1, 0])\n    >>> a.ravel(order='C')\n    array([2, 1, 0])\n    >>> a.ravel(order='K')\n    array([2, 1, 0])\n\n    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\n    array([[[ 0,  2,  4],\n            [ 1,  3,  5]],\n           [[ 6,  8, 10],\n            [ 7,  9, 11]]])\n    >>> a.ravel(order='C')\n    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n    >>> a.ravel(order='K')\n    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_393ravel = {"ravel", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_393ravel, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_392ravel};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_393ravel(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ravel (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_order,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_s_C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ravel") < 0)) __PYX_ERR(0, 9884, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_order = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ravel", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9884, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_392ravel(__pyx_self, __pyx_v_a, __pyx_v_order);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_392ravel(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ravel", 0);

  /* "ga4py/gain/notimplemented.pyx":9965
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 9965, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9884
 * 
 * 
 * def ravel(a, order='C'):             # <<<<<<<<<<<<<<
 *     """Return a flattened array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":9968
 * 
 * 
 * def ravel_multi_index(multi_index, dims, mode='raise', order='C'):             # <<<<<<<<<<<<<<
 *     """ravel_multi_index(multi_index, dims, mode='raise', order='C')
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_395ravel_multi_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_394ravel_multi_index[] = "ravel_multi_index(multi_index, dims, mode='raise', order='C')\n\n    Converts a tuple of index arrays into an array of flat\n    indices, applying boundary modes to the multi-index.\n\n    Parameters\n    ----------\n    multi_index : tuple of array_like\n        A tuple of integer arrays, one array for each dimension.\n    dims : tuple of ints\n        The shape of array into which the indices from ``multi_index`` apply.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices are handled.  Can specify\n        either one mode or a tuple of modes, one mode per index.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        In 'clip' mode, a negative index which would normally\n        wrap will clip to 0 instead.\n    order : {'C', 'F'}, optional\n        Determines whether the multi-index should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    raveled_indices : ndarray\n        An array of indices into the flattened version of an array\n        of dimensions ``dims``.\n\n    See Also\n    --------\n    unravel_index\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    Examples\n    --------\n    >>> arr = np.array([[3,6,6],[4,5,1]])\n    >>> np.ravel_multi_index(arr, (7,6))\n    array([22, 41, 37])\n    >>> np.ravel_multi_index(arr, (7,6), order='F')\n    array([31, 41, 13])\n    >>> np.ravel_multi_index(arr, (4,6), mode='clip')\n    array([22, 23, 19])\n    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\n    array([12, 13, 13])\n\n    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n    1621\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_395ravel_multi_index = {"ravel_multi_index", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_395ravel_multi_index, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_394ravel_multi_index};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_395ravel_multi_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_multi_index = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dims = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ravel_multi_index (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_multi_index,&__pyx_n_s_dims,&__pyx_n_s_mode,&__pyx_n_s_order,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_s_raise);
    values[3] = ((PyObject *)__pyx_n_s_C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_multi_index)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dims)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ravel_multi_index", 0, 2, 4, 1); __PYX_ERR(0, 9968, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ravel_multi_index") < 0)) __PYX_ERR(0, 9968, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_multi_index = values[0];
    __pyx_v_dims = values[1];
    __pyx_v_mode = values[2];
    __pyx_v_order = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ravel_multi_index", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 9968, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel_multi_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_394ravel_multi_index(__pyx_self, __pyx_v_multi_index, __pyx_v_dims, __pyx_v_mode, __pyx_v_order);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_394ravel_multi_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_multi_index, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_mode, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ravel_multi_index", 0);

  /* "ga4py/gain/notimplemented.pyx":10025
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10025, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9968
 * 
 * 
 * def ravel_multi_index(multi_index, dims, mode='raise', order='C'):             # <<<<<<<<<<<<<<
 *     """ravel_multi_index(multi_index, dims, mode='raise', order='C')
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.ravel_multi_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10028
 * 
 * 
 * def real(val):             # <<<<<<<<<<<<<<
 *     """Return the real part of the elements of the array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_397real(PyObject *__pyx_self, PyObject *__pyx_v_val); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_396real[] = "Return the real part of the elements of the array.\n\n    Parameters\n    ----------\n    val : array_like\n        Input array.\n\n    Returns\n    -------\n    out : ndarray\n        Output array. If `val` is real, the type of `val` is used for the\n        output.  If `val` has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real_if_close, imag, angle\n\n    Examples\n    --------\n    >>> a = np.array([1+2j, 3+4j, 5+6j])\n    >>> a.real\n    array([ 1.,  3.,  5.])\n    >>> a.real = 9\n    >>> a\n    array([ 9.+2.j,  9.+4.j,  9.+6.j])\n    >>> a.real = np.array([9, 8, 7])\n    >>> a\n    array([ 9.+2.j,  8.+4.j,  7.+6.j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_397real = {"real", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_397real, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_396real};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_397real(PyObject *__pyx_self, PyObject *__pyx_v_val) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("real (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_396real(__pyx_self, ((PyObject *)__pyx_v_val));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_396real(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_val) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("real", 0);

  /* "ga4py/gain/notimplemented.pyx":10059
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10059, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10028
 * 
 * 
 * def real(val):             # <<<<<<<<<<<<<<
 *     """Return the real part of the elements of the array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.real", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10062
 * 
 * 
 * def real_if_close(a, tol=100):             # <<<<<<<<<<<<<<
 *     """If complex input returns a real array if complex parts are close to zero.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_399real_if_close(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_398real_if_close[] = "If complex input returns a real array if complex parts are close to zero.\n\n    \"Close to zero\" is defined as `tol` * (machine epsilon of the type for\n    `a`).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    tol : float\n        Tolerance in machine epsilons for the complex part of the elements\n        in the array.\n\n    Returns\n    -------\n    out : ndarray\n        If `a` is real, the type of `a` is used for the output.  If `a`\n        has complex elements, the returned type is float.\n\n    See Also\n    --------\n    real, imag, angle\n\n    Notes\n    -----\n    Machine epsilon varies from machine to machine and between data types\n    but Python floats on most platforms have a machine epsilon equal to\n    2.2204460492503131e-16.  You can use 'np.finfo(np.float).eps' to print\n    out the machine epsilon for floats.\n\n    Examples\n    --------\n    >>> np.finfo(np.float).eps\n    2.2204460492503131e-16\n\n    >>> np.real_if_close([2.1 + 4e-14j], tol=1000)\n    array([ 2.1])\n    >>> np.real_if_close([2.1 + 4e-13j], tol=1000)\n    array([ 2.1 +4.00000000e-13j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_399real_if_close = {"real_if_close", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_399real_if_close, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_398real_if_close};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_399real_if_close(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_tol = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("real_if_close (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_tol,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_100);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_tol);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "real_if_close") < 0)) __PYX_ERR(0, 10062, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_tol = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("real_if_close", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10062, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.real_if_close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_398real_if_close(__pyx_self, __pyx_v_a, __pyx_v_tol);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_398real_if_close(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_tol) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("real_if_close", 0);

  /* "ga4py/gain/notimplemented.pyx":10104
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10104, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10062
 * 
 * 
 * def real_if_close(a, tol=100):             # <<<<<<<<<<<<<<
 *     """If complex input returns a real array if complex parts are close to zero.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.real_if_close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10107
 * 
 * 
 * def recfromcsv(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a comma-separated file.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_401recfromcsv(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_400recfromcsv[] = "Load ASCII data stored in a comma-separated file.\n\n    The returned array is a record array (if ``usemask=False``, see\n    `recarray`) or a masked record array (if ``usemask=True``,\n    see `ma.mrecords.MaskedRecords`).\n\n    For a complete description of all the input parameters, see `genfromtxt`.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function to load ASCII data.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_401recfromcsv = {"recfromcsv", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_401recfromcsv, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_400recfromcsv};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_401recfromcsv(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recfromcsv (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_400recfromcsv(__pyx_self, ((PyObject *)__pyx_v_fname));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_400recfromcsv(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recfromcsv", 0);

  /* "ga4py/gain/notimplemented.pyx":10121
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10121, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10107
 * 
 * 
 * def recfromcsv(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a comma-separated file.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.recfromcsv", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10124
 * 
 * 
 * def recfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data from a file and return it in a record array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_403recfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_402recfromtxt[] = "Load ASCII data from a file and return it in a record array.\n\n    If ``usemask=False`` a standard `recarray` is returned,\n    if ``usemask=True`` a MaskedRecords array is returned.\n\n    Complete description of all the optional input parameters is available in\n    the docstring of the `genfromtxt` function.\n\n    See Also\n    --------\n    numpy.genfromtxt : generic function\n\n    Notes\n    -----\n    By default, `dtype` is None, which means that the data-type of the output\n    array will be determined from the data.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_403recfromtxt = {"recfromtxt", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_403recfromtxt, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_402recfromtxt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_403recfromtxt(PyObject *__pyx_self, PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recfromtxt (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_402recfromtxt(__pyx_self, ((PyObject *)__pyx_v_fname));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_402recfromtxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recfromtxt", 0);

  /* "ga4py/gain/notimplemented.pyx":10143
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10143, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10124
 * 
 * 
 * def recfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data from a file and return it in a record array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.recfromtxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10146
 * 
 * 
 * def repeat(a, repeats, axis=None):             # <<<<<<<<<<<<<<
 *     """Repeat elements of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_405repeat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_404repeat[] = "Repeat elements of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    repeats : {int, array of ints}\n        The number of repetitions for each element.  `repeats` is broadcasted\n        to fit the shape of the given axis.\n    axis : int, optional\n        The axis along which to repeat values.  By default, use the\n        flattened input array, and return a flat output array.\n\n    Returns\n    -------\n    repeated_array : ndarray\n        Output array which has the same shape as `a`, except along\n        the given axis.\n\n    See Also\n    --------\n    tile : Tile an array.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2],[3,4]])\n    >>> np.repeat(x, 2)\n    array([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> np.repeat(x, 3, axis=1)\n    array([[1, 1, 1, 2, 2, 2],\n           [3, 3, 3, 4, 4, 4]])\n    >>> np.repeat(x, [1, 2], axis=0)\n    array([[1, 2],\n           [3, 4],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_405repeat = {"repeat", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_405repeat, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_404repeat};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_405repeat(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_repeats = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("repeat (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_repeats,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_repeats)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("repeat", 0, 2, 3, 1); __PYX_ERR(0, 10146, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "repeat") < 0)) __PYX_ERR(0, 10146, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_repeats = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("repeat", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10146, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.repeat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_404repeat(__pyx_self, __pyx_v_a, __pyx_v_repeats, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_404repeat(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_repeats, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("repeat", 0);

  /* "ga4py/gain/notimplemented.pyx":10184
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10184, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10146
 * 
 * 
 * def repeat(a, repeats, axis=None):             # <<<<<<<<<<<<<<
 *     """Repeat elements of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.repeat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10187
 * 
 * 
 * def require(a, dtype=None, requirements=None):             # <<<<<<<<<<<<<<
 *     """Return an ndarray of the provided type that satisfies requirements.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_407require(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_406require[] = "Return an ndarray of the provided type that satisfies requirements.\n\n    This function is useful to be sure that an array with the correct flags\n    is returned for passing to compiled code (perhaps through ctypes).\n\n    Parameters\n    ----------\n    a : array_like\n       The object to be converted to a type-and-requirement-satisfying array.\n    dtype : data-type\n       The required data-type, the default data-type is float64).\n    requirements : str or list of str\n       The requirements list can be any of the following\n\n       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\n       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\n       * 'ALIGNED' ('A')      - ensure a data-type aligned array\n       * 'WRITEABLE' ('W')    - ensure a writable array\n       * 'OWNDATA' ('O')      - ensure an array that owns its own data\n\n    See Also\n    --------\n    asarray : Convert input to an ndarray.\n    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.\n    ascontiguousarray : Convert input to a contiguous array.\n    asfortranarray : Convert input to an ndarray with column-major\n                     memory order.\n    ndarray.flags : Information about the memory layout of the array.\n\n    Notes\n    -----\n    The returned array will be guaranteed to have the listed requirements\n    by making a copy if needed.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x.flags\n      C_CONTIGUOUS : True\n      F_CONTIGUOUS : False\n      OWNDATA : False\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n\n    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n    >>> y.flags\n      C_CONTIGUOUS : False\n      F_CONTIGUOUS : True\n      OWNDATA : True\n      WRITEABLE : True\n      ALIGNED : True\n      UPDATEIFCOPY : False\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_407require = {"require", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_407require, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_406require};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_407require(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_requirements = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("require (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_dtype,&__pyx_n_s_requirements,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_requirements);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "require") < 0)) __PYX_ERR(0, 10187, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_dtype = values[1];
    __pyx_v_requirements = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("require", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10187, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.require", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_406require(__pyx_self, __pyx_v_a, __pyx_v_dtype, __pyx_v_requirements);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_406require(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_requirements) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("require", 0);

  /* "ga4py/gain/notimplemented.pyx":10243
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10243, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10187
 * 
 * 
 * def require(a, dtype=None, requirements=None):             # <<<<<<<<<<<<<<
 *     """Return an ndarray of the provided type that satisfies requirements.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.require", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10246
 * 
 * 
 * def reshape(a, newshape, order='C'):             # <<<<<<<<<<<<<<
 *     """Gives a new shape to an array without changing its data.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_409reshape(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_408reshape[] = "Gives a new shape to an array without changing its data.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be reshaped.\n    newshape : int or tuple of ints\n        The new shape should be compatible with the original shape. If\n        an integer, then the result will be a 1-D array of that length.\n        One shape dimension can be -1. In this case, the value is inferred\n        from the length of the array and remaining dimensions.\n    order : {'C', 'F', 'A'}, optional\n        Determines whether the array data should be viewed as in C\n        (row-major) order, FORTRAN (column-major) order, or the C/FORTRAN\n        order should be preserved.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        This will be a new view object if possible; otherwise, it will\n        be a copy.\n\n\n    See Also\n    --------\n    ndarray.reshape : Equivalent method.\n\n    Notes\n    -----\n\n    It is not always possible to change the shape of an array without\n    copying the data. If you want an error to be raise if the data is copied,\n    you should assign the new shape to the shape attribute of the array::\n\n     >>> a = np.zeros((10, 2))\n     # A transpose make the array non-contiguous\n     >>> b = a.T\n     # Taking a view makes it possible to modify the shape without modiying the\n     # initial object.\n     >>> c = b.view()\n     >>> c.shape = (20)\n     AttributeError: incompatible shape for a non-contiguous array\n\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1, 2, 3, 4, 5, 6])\n    >>> np.reshape(a, 6, order='F')\n    array([1, 4, 2, 5, 3, 6])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1, 2],\n           [3, 4],\n           [5, 6]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_409reshape = {"reshape", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_409reshape, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_408reshape};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_409reshape(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_newshape = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("reshape (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_newshape,&__pyx_n_s_order,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s_C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_newshape)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("reshape", 0, 2, 3, 1); __PYX_ERR(0, 10246, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "reshape") < 0)) __PYX_ERR(0, 10246, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_newshape = values[1];
    __pyx_v_order = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("reshape", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10246, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.reshape", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_408reshape(__pyx_self, __pyx_v_a, __pyx_v_newshape, __pyx_v_order);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_408reshape(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_newshape, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("reshape", 0);

  /* "ga4py/gain/notimplemented.pyx":10305
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10305, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10246
 * 
 * 
 * def reshape(a, newshape, order='C'):             # <<<<<<<<<<<<<<
 *     """Gives a new shape to an array without changing its data.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.reshape", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10308
 * 
 * 
 * def resize(a, new_shape):             # <<<<<<<<<<<<<<
 *     """Return a new array with the specified shape.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_411resize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_410resize[] = "Return a new array with the specified shape.\n\n    If the new array is larger than the original array, then the new\n    array is filled with repeated copies of `a`.  Note that this behavior\n    is different from a.resize(new_shape) which fills with zeros instead\n    of repeated copies of `a`.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be resized.\n\n    new_shape : int or tuple of int\n        Shape of resized array.\n\n    Returns\n    -------\n    reshaped_array : ndarray\n        The new array is formed from the data in the old array, repeated\n        if necessary to fill out the required number of elements.  The\n        data are repeated in the order that they are stored in memory.\n\n    See Also\n    --------\n    ndarray.resize : resize an array in-place.\n\n    Examples\n    --------\n    >>> a=np.array([[0,1],[2,3]])\n    >>> np.resize(a,(1,4))\n    array([[0, 1, 2, 3]])\n    >>> np.resize(a,(2,4))\n    array([[0, 1, 2, 3],\n           [0, 1, 2, 3]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_411resize = {"resize", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_411resize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_410resize};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_411resize(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_new_shape = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("resize (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_new_shape,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_new_shape)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("resize", 1, 2, 2, 1); __PYX_ERR(0, 10308, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "resize") < 0)) __PYX_ERR(0, 10308, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_a = values[0];
    __pyx_v_new_shape = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("resize", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10308, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.resize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_410resize(__pyx_self, __pyx_v_a, __pyx_v_new_shape);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_410resize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_new_shape) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("resize", 0);

  /* "ga4py/gain/notimplemented.pyx":10345
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10345, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10308
 * 
 * 
 * def resize(a, new_shape):             # <<<<<<<<<<<<<<
 *     """Return a new array with the specified shape.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.resize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10348
 * 
 * 
 * def restoredot():             # <<<<<<<<<<<<<<
 *     """Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
 *     implementations.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_413restoredot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_412restoredot[] = "Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS\n    implementations.\n\n    Typically, the user will only need to call this when troubleshooting and\n    installation problem, reproducing the conditions of a build without an\n    accelerated BLAS, or when being very careful about benchmarking linear\n    algebra operations.\n\n    See Also\n    --------\n    alterdot : `restoredot` undoes the effects of `alterdot`.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_413restoredot = {"restoredot", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_413restoredot, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_412restoredot};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_413restoredot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("restoredot (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_412restoredot(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_412restoredot(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("restoredot", 0);

  /* "ga4py/gain/notimplemented.pyx":10363
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10363, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10348
 * 
 * 
 * def restoredot():             # <<<<<<<<<<<<<<
 *     """Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
 *     implementations.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.restoredot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10366
 * 
 * 
 * def result_type(*arrays_and_dtypes):             # <<<<<<<<<<<<<<
 *     """result_type(*arrays_and_dtypes)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_415result_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_414result_type[] = "result_type(*arrays_and_dtypes)\n\n    Returns the type that results from applying the NumPy\n    type promotion rules to the arguments.\n\n    Type promotion in NumPy works similarly to the rules in languages\n    like C++, with some slight differences.  When both scalars and\n    arrays are used, the array's type takes precedence and the actual value\n    of the scalar is taken into account.\n\n    For example, calculating 3*a, where a is an array of 32-bit floats,\n    intuitively should result in a 32-bit float output.  If the 3 is a\n    32-bit integer, the NumPy rules indicate it can't convert losslessly\n    into a 32-bit float, so a 64-bit float should be the result type.\n    By examining the value of the constant, '3', we see that it fits in\n    an 8-bit integer, which can be cast losslessly into the 32-bit float.\n\n    Parameters\n    ----------\n    arrays_and_dtypes : list of arrays and dtypes\n        The operands of some operation whose result type is needed.\n\n    Returns\n    -------\n    out : dtype\n        The result type.\n\n    See also\n    --------\n    dtype, promote_types, min_scalar_type, can_cast\n\n    Notes\n    -----\n    .. versionadded:: 1.6.0\n\n    The specific algorithm used is as follows.\n\n    Categories are determined by first checking which of boolean,\n    integer (int/uint), or floating point (float/complex) the maximum\n    kind of all the arrays and the scalars are.\n    \n    If there are only scalars or the maximum category of the scalars\n    is higher than the maximum category of the arrays,\n    the data types are combined with :func:`promote_types`\n    to produce the return value.\n\n    Otherwise, `min_scalar_type` is called on each array, and\n    the resulting data types are all combined with :func:`promote_types`\n    to produce the return value.\n\n    The set of int values is not a subset of the uint values for types\n    with the same number of bits, something not reflected in\n    :func:`min_scalar_type`"", but handled as a special case in `result_type`.\n\n    Examples\n    --------\n    >>> np.result_type(3, np.arange(7, dtype='i1'))\n    dtype('int8')\n\n    >>> np.result_type('i4', 'c8')\n    dtype('complex128')\n\n    >>> np.result_type(3.0, -2)\n    dtype('float64')\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_415result_type = {"result_type", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_415result_type, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_414result_type};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_415result_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arrays_and_dtypes = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("result_type (wrapper)", 0);
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "result_type", 0))) return NULL;
  __Pyx_INCREF(__pyx_args);
  __pyx_v_arrays_and_dtypes = __pyx_args;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_414result_type(__pyx_self, __pyx_v_arrays_and_dtypes);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_arrays_and_dtypes);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_414result_type(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arrays_and_dtypes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("result_type", 0);

  /* "ga4py/gain/notimplemented.pyx":10434
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10434, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10366
 * 
 * 
 * def result_type(*arrays_and_dtypes):             # <<<<<<<<<<<<<<
 *     """result_type(*arrays_and_dtypes)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.result_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10437
 * 
 * 
 * def roll(a, shift, axis=None):             # <<<<<<<<<<<<<<
 *     """Roll array elements along a given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_417roll(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_416roll[] = "Roll array elements along a given axis.\n\n    Elements that roll beyond the last position are re-introduced at\n    the first.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    shift : int\n        The number of places by which elements are shifted.\n    axis : int, optional\n        The axis along which elements are shifted.  By default, the array\n        is flattened before shifting, after which the original\n        shape is restored.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, with the same shape as `a`.\n\n    See Also\n    --------\n    rollaxis : Roll the specified axis backwards, until it lies in a\n               given position.\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> np.roll(x, 2)\n    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n\n    >>> x2 = np.reshape(x, (2,5))\n    >>> x2\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> np.roll(x2, 1)\n    array([[9, 0, 1, 2, 3],\n           [4, 5, 6, 7, 8]])\n    >>> np.roll(x2, 1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, 1, axis=1)\n    array([[4, 0, 1, 2, 3],\n           [9, 5, 6, 7, 8]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_417roll = {"roll", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_417roll, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_416roll};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_417roll(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_shift = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("roll (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_shift,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_shift)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("roll", 0, 2, 3, 1); __PYX_ERR(0, 10437, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "roll") < 0)) __PYX_ERR(0, 10437, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_shift = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("roll", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10437, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.roll", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_416roll(__pyx_self, __pyx_v_a, __pyx_v_shift, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_416roll(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_shift, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("roll", 0);

  /* "ga4py/gain/notimplemented.pyx":10485
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10485, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10437
 * 
 * 
 * def roll(a, shift, axis=None):             # <<<<<<<<<<<<<<
 *     """Roll array elements along a given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.roll", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10488
 * 
 * 
 * def rollaxis(a, axis, start=0):             # <<<<<<<<<<<<<<
 *     """Roll the specified axis backwards, until it lies in a given position.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_419rollaxis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_418rollaxis[] = "Roll the specified axis backwards, until it lies in a given position.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    axis : int\n        The axis to roll backwards.  The positions of the other axes do not\n        change relative to one another.\n    start : int, optional\n        The axis is rolled until it lies before this position.  The default,\n        0, results in a \"complete\" roll.\n\n    Returns\n    -------\n    res : ndarray\n        Output array.\n\n    See Also\n    --------\n    roll : Roll the elements of an array by a number of positions along a\n        given axis.\n\n    Examples\n    --------\n    >>> a = np.ones((3,4,5,6))\n    >>> np.rollaxis(a, 3, 1).shape\n    (3, 6, 4, 5)\n    >>> np.rollaxis(a, 2).shape\n    (5, 3, 4, 6)\n    >>> np.rollaxis(a, 1, 4).shape\n    (3, 5, 6, 4)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_419rollaxis = {"rollaxis", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_419rollaxis, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_418rollaxis};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_419rollaxis(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_start = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rollaxis (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_start,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("rollaxis", 0, 2, 3, 1); __PYX_ERR(0, 10488, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_start);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rollaxis") < 0)) __PYX_ERR(0, 10488, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_start = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rollaxis", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10488, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rollaxis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_418rollaxis(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_start);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_418rollaxis(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_start) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rollaxis", 0);

  /* "ga4py/gain/notimplemented.pyx":10523
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10523, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10488
 * 
 * 
 * def rollaxis(a, axis, start=0):             # <<<<<<<<<<<<<<
 *     """Roll the specified axis backwards, until it lies in a given position.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rollaxis", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10526
 * 
 * 
 * def roots(p):             # <<<<<<<<<<<<<<
 *     """Return the roots of a polynomial with coefficients given in p.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_421roots(PyObject *__pyx_self, PyObject *__pyx_v_p); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_420roots[] = "Return the roots of a polynomial with coefficients given in p.\n\n    The values in the rank-1 array `p` are coefficients of a polynomial.\n    If the length of `p` is n+1 then the polynomial is described by::\n\n      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\n    Parameters\n    ----------\n    p : array_like\n        Rank-1 array of polynomial coefficients.\n\n    Returns\n    -------\n    out : ndarray\n        An array containing the complex roots of the polynomial.\n\n    Raises\n    ------\n    ValueError :\n        When `p` cannot be converted to a rank-1 array.\n\n    See also\n    --------\n    poly : Find the coefficients of a polynomial with a given sequence\n           of roots.\n    polyval : Evaluate a polynomial at a point.\n    polyfit : Least squares polynomial fit.\n    poly1d : A one-dimensional polynomial class.\n\n    Notes\n    -----\n    The algorithm relies on computing the eigenvalues of the\n    companion matrix [1]_.\n\n    References\n    ----------\n    .. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:\n        Cambridge University Press, 1999, pp. 146-7.\n\n    Examples\n    --------\n    >>> coeff = [3.2, 2, 1]\n    >>> np.roots(coeff)\n    array([-0.3125+0.46351241j, -0.3125-0.46351241j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_421roots = {"roots", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_421roots, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_420roots};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_421roots(PyObject *__pyx_self, PyObject *__pyx_v_p) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("roots (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_420roots(__pyx_self, ((PyObject *)__pyx_v_p));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_420roots(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("roots", 0);

  /* "ga4py/gain/notimplemented.pyx":10574
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10574, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10526
 * 
 * 
 * def roots(p):             # <<<<<<<<<<<<<<
 *     """Return the roots of a polynomial with coefficients given in p.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.roots", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10577
 * 
 * 
 * def rot90(m, k=1):             # <<<<<<<<<<<<<<
 *     """Rotate an array by 90 degrees in the counter-clockwise direction.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_423rot90(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_422rot90[] = "Rotate an array by 90 degrees in the counter-clockwise direction.\n\n    The first two dimensions are rotated; therefore, the array must be at\n    least 2-D.\n\n    Parameters\n    ----------\n    m : array_like\n        Array of two or more dimensions.\n    k : integer\n        Number of times the array is rotated by 90 degrees.\n\n    Returns\n    -------\n    y : ndarray\n        Rotated array.\n\n    See Also\n    --------\n    fliplr : Flip an array horizontally.\n    flipud : Flip an array vertically.\n\n    Examples\n    --------\n    >>> m = np.array([[1,2],[3,4]], int)\n    >>> m\n    array([[1, 2],\n           [3, 4]])\n    >>> np.rot90(m)\n    array([[2, 4],\n           [1, 3]])\n    >>> np.rot90(m, 2)\n    array([[4, 3],\n           [2, 1]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_423rot90 = {"rot90", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_423rot90, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_422rot90};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_423rot90(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rot90 (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_m,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "rot90") < 0)) __PYX_ERR(0, 10577, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("rot90", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10577, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rot90", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_422rot90(__pyx_self, __pyx_v_m, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_422rot90(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("rot90", 0);

  /* "ga4py/gain/notimplemented.pyx":10614
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10614, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10577
 * 
 * 
 * def rot90(m, k=1):             # <<<<<<<<<<<<<<
 *     """Rotate an array by 90 degrees in the counter-clockwise direction.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.rot90", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10617
 * 
 * 
 * def round(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_425round(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_424round[] = "Round an array to the given number of decimals.\n\n    Refer to `around` for full documentation.\n\n    See Also\n    --------\n    around : equivalent function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_425round = {"round", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_425round, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_424round};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_425round(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_decimals = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("round (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_decimals,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_decimals);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "round") < 0)) __PYX_ERR(0, 10617, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_decimals = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("round", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10617, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_424round(__pyx_self, __pyx_v_a, __pyx_v_decimals, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_424round(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("round", 0);

  /* "ga4py/gain/notimplemented.pyx":10627
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10627, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10617
 * 
 * 
 * def round(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10630
 * 
 * 
 * def round_(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_427round_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_426round_[] = "Round an array to the given number of decimals.\n\n    Refer to `around` for full documentation.\n\n    See Also\n    --------\n    around : equivalent function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_427round_ = {"round_", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_427round_, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_426round_};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_427round_(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_decimals = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("round_ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_decimals,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_decimals);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "round_") < 0)) __PYX_ERR(0, 10630, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_decimals = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("round_", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10630, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_426round_(__pyx_self, __pyx_v_a, __pyx_v_decimals, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_426round_(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_decimals, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("round_", 0);

  /* "ga4py/gain/notimplemented.pyx":10640
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10640, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10630
 * 
 * 
 * def round_(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.round_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10643
 * 
 * 
 * def row_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_429row_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_428row_stack[] = "Stack arrays in sequence vertically (row wise).\n\n    Take a sequence of arrays and stack them vertically to make a single\n    array. Rebuild arrays divided by `vsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        Tuple containing arrays to be stacked. The arrays must have the same\n        shape along all but the first axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays together.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=0)``\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_429row_stack = {"row_stack", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_429row_stack, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_428row_stack};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_429row_stack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("row_stack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_428row_stack(__pyx_self, ((PyObject *)__pyx_v_tup));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_428row_stack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("row_stack", 0);

  /* "ga4py/gain/notimplemented.pyx":10691
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10691, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10643
 * 
 * 
 * def row_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.row_stack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10694
 * 
 * 
 * def safe_eval(source):             # <<<<<<<<<<<<<<
 *     """Protected string evaluation.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_431safe_eval(PyObject *__pyx_self, PyObject *__pyx_v_source); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_430safe_eval[] = "Protected string evaluation.\n\n    Evaluate a string containing a Python literal expression without\n    allowing the execution of arbitrary non-literal code.\n\n    Parameters\n    ----------\n    source : str\n        The string to evaluate.\n\n    Returns\n    -------\n    obj : object\n       The result of evaluating `source`.\n\n    Raises\n    ------\n    SyntaxError\n        If the code has invalid Python syntax, or if it contains non-literal\n        code.\n\n    Examples\n    --------\n    >>> np.safe_eval('1')\n    1\n    >>> np.safe_eval('[1, 2, 3]')\n    [1, 2, 3]\n    >>> np.safe_eval('{\"foo\": (\"bar\", 10.0)}')\n    {'foo': ('bar', 10.0)}\n\n    >>> np.safe_eval('import os')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: invalid syntax\n\n    >>> np.safe_eval('open(\"/home/user/.ssh/id_dsa\").read()')\n    Traceback (most recent call last):\n      ...\n    SyntaxError: Unsupported source construct: compiler.ast.CallFunc\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_431safe_eval = {"safe_eval", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_431safe_eval, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_430safe_eval};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_431safe_eval(PyObject *__pyx_self, PyObject *__pyx_v_source) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("safe_eval (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_430safe_eval(__pyx_self, ((PyObject *)__pyx_v_source));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_430safe_eval(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_source) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("safe_eval", 0);

  /* "ga4py/gain/notimplemented.pyx":10736
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10736, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10694
 * 
 * 
 * def safe_eval(source):             # <<<<<<<<<<<<<<
 *     """Protected string evaluation.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.safe_eval", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10739
 * 
 * 
 * def save(file, arr):             # <<<<<<<<<<<<<<
 *     """Save an array to a binary file in NumPy ``.npy`` format.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_433save(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_432save[] = "Save an array to a binary file in NumPy ``.npy`` format.\n\n    Parameters\n    ----------\n    file : file or str\n        File or filename to which the data is saved.  If file is a file-object,\n        then the filename is unchanged.  If file is a string, a ``.npy``\n        extension will be appended to the file name if it does not already\n        have one.\n    arr : array_like\n        Array data to be saved.\n\n    See Also\n    --------\n    savez : Save several arrays into a ``.npz`` archive\n    savetxt, load\n\n    Notes\n    -----\n    For a description of the ``.npy`` format, see `format`.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n\n    >>> x = np.arange(10)\n    >>> np.save(outfile, x)\n\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> np.load(outfile)\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_433save = {"save", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_433save, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_432save};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_433save(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_file = 0;
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("save (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_file,&__pyx_n_s_arr,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_file)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("save", 1, 2, 2, 1); __PYX_ERR(0, 10739, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "save") < 0)) __PYX_ERR(0, 10739, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_file = values[0];
    __pyx_v_arr = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("save", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10739, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.save", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_432save(__pyx_self, __pyx_v_file, __pyx_v_arr);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_432save(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file, CYTHON_UNUSED PyObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("save", 0);

  /* "ga4py/gain/notimplemented.pyx":10774
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10774, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10739
 * 
 * 
 * def save(file, arr):             # <<<<<<<<<<<<<<
 *     """Save an array to a binary file in NumPy ``.npy`` format.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.save", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10777
 * 
 * 
 * def savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n'):             # <<<<<<<<<<<<<<
 *     """Save an array to a text file.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_435savetxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_434savetxt[] = "Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename or file handle\n        If the filename ends in ``.gz``, the file is automatically saved in\n        compressed gzip format.  `loadtxt` understands gzipped files\n        transparently.\n    X : array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case `delimiter` is ignored.\n    delimiter : str\n        Character separating columns.\n    newline : str\n        .. versionadded:: 1.5.0\n\n        Character separating lines.\n\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy ``.npy`` format\n    savez : Save several arrays into a ``.npz`` compressed archive\n\n    Notes\n    -----\n    Further explanation of the `fmt` parameter\n    (``%[flag]width[.precision]specifier``):\n\n    flags:\n        ``-`` : left justify\n\n        ``+`` : Forces to preceed result with + or -.\n\n        ``0`` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of\n          digits.\n        - For ``e, E`` and ``f`` specifiers, the number of digits to print\n          after the decimal point.\n        - For ``g`` and ``G``, the maximum number of significant digits.\n        - For ``s``, the maximum number of characters.\n\n    specifiers:\n        ``c`` : character\n\n        ``d`` or ``i`` : signed decimal integer\n\n        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n        ``f`` : decimal floating point\n\n        ``g,G`` : use the shorter of ``e,E`` or ``f``\n\n        ``o`` : signed octal\n\n        ``s`` : string of characters\n\n        ``u`` : un""signed decimal integer\n\n        ``x,X`` : unsigned hexadecimal integer\n\n    This explanation of ``fmt`` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] `Format Specification Mini-Language\n           <http://docs.python.org/library/string.html#\n           format-specification-mini-language>`_, Python Documentation.\n\n    Examples\n    --------\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_435savetxt = {"savetxt", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_435savetxt, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_434savetxt};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_435savetxt(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_fname = 0;
  CYTHON_UNUSED PyObject *__pyx_v_X = 0;
  CYTHON_UNUSED PyObject *__pyx_v_fmt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_delimiter = 0;
  CYTHON_UNUSED PyObject *__pyx_v_newline = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savetxt (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_fname,&__pyx_n_s_X,&__pyx_n_s_fmt,&__pyx_n_s_delimiter,&__pyx_n_s_newline,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[2] = ((PyObject *)__pyx_kp_s_18e);
    values[3] = ((PyObject *)__pyx_kp_s_);
    values[4] = ((PyObject *)__pyx_kp_s__14);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fname)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("savetxt", 0, 2, 5, 1); __PYX_ERR(0, 10777, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fmt);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_delimiter);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_newline);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "savetxt") < 0)) __PYX_ERR(0, 10777, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_fname = values[0];
    __pyx_v_X = values[1];
    __pyx_v_fmt = values[2];
    __pyx_v_delimiter = values[3];
    __pyx_v_newline = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("savetxt", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 10777, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savetxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_434savetxt(__pyx_self, __pyx_v_fname, __pyx_v_X, __pyx_v_fmt, __pyx_v_delimiter, __pyx_v_newline);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_434savetxt(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_fname, CYTHON_UNUSED PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_fmt, CYTHON_UNUSED PyObject *__pyx_v_delimiter, CYTHON_UNUSED PyObject *__pyx_v_newline) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savetxt", 0);

  /* "ga4py/gain/notimplemented.pyx":10865
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10865, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10777
 * 
 * 
 * def savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n'):             # <<<<<<<<<<<<<<
 *     """Save an array to a text file.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savetxt", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10868
 * 
 * 
 * def savez(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in uncompressed ``.npz`` format.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_437savez(PyObject *__pyx_self, PyObject *__pyx_v_file); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_436savez[] = "Save several arrays into a single file in uncompressed ``.npz`` format.\n\n    If arguments are passed in with no keywords, the corresponding variable\n    names, in the .npz file, are 'arr_0', 'arr_1', etc. If keyword arguments\n    are given, the corresponding variable names, in the ``.npz`` file will\n    match the keyword names.\n\n    Parameters\n    ----------\n    file : str or file\n        Either the file name (string) or an open file (file-like object)\n        where the data will be saved. If file is a string, the ``.npz``\n        extension will be appended to the file name if it is not already there.\n    *args : Arguments, optional\n        Arrays to save to the file. Since it is not possible for Python to\n        know the names of the arrays outside `savez`, the arrays will be saved\n        with names \"arr_0\", \"arr_1\", and so on. These arguments can be any\n        expression.\n    **kwds : Keyword arguments, optional\n        Arrays to save to the file. Arrays will be saved in the file with the\n        keyword names.\n\n    Returns\n    -------\n    None\n\n    See Also\n    --------\n    save : Save a single array to a binary file in NumPy format.\n    savetxt : Save an array to a file as plain text.\n\n    Notes\n    -----\n    The ``.npz`` file format is a zipped archive of files named after the\n    variables they contain.  The archive is not compressed and each file\n    in the archive contains one variable in ``.npy`` format. For a\n    description of the ``.npy`` format, see `format`.\n\n    When opening the saved ``.npz`` file with `load` a `NpzFile` object is\n    returned. This is a dictionary-like object which can be queried for\n    its list of arrays (with the ``.files`` attribute), and for the arrays\n    themselves.\n\n    Examples\n    --------\n    >>> from tempfile import TemporaryFile\n    >>> outfile = TemporaryFile()\n    >>> x = np.arange(10)\n    >>> y = np.sin(x)\n\n    Using `savez` with *args, the arrays are saved wit""h default names.\n\n    >>> np.savez(outfile, x, y)\n    >>> outfile.seek(0) # Only needed here to simulate closing & reopening file\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['arr_1', 'arr_0']\n    >>> npzfile['arr_0']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    Using `savez` with **kwds, the arrays are saved with the keyword names.\n\n    >>> outfile = TemporaryFile()\n    >>> np.savez(outfile, x=x, y=y)\n    >>> outfile.seek(0)\n    >>> npzfile = np.load(outfile)\n    >>> npzfile.files\n    ['y', 'x']\n    >>> npzfile['x']\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    See Also\n    --------\n    numpy.savez_compressed : Save several arrays into a compressed .npz file format\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_437savez = {"savez", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_437savez, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_436savez};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_437savez(PyObject *__pyx_self, PyObject *__pyx_v_file) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savez (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_436savez(__pyx_self, ((PyObject *)__pyx_v_file));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_436savez(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savez", 0);

  /* "ga4py/gain/notimplemented.pyx":10945
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10945, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10868
 * 
 * 
 * def savez(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in uncompressed ``.npz`` format.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savez", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10948
 * 
 * 
 * def savez_compressed(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in compressed ``.npz`` format.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_439savez_compressed(PyObject *__pyx_self, PyObject *__pyx_v_file); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_438savez_compressed[] = "Save several arrays into a single file in compressed ``.npz`` format.\n\n    If keyword arguments are given, then filenames are taken from the keywords.\n    If arguments are passed in with no keywords, then stored file names are\n    arr_0, arr_1, etc.\n\n    Parameters\n    ----------\n    file : str\n        File name of .npz file.\n    args : Arguments\n        Function arguments.\n    kwds : Keyword arguments\n        Keywords.\n\n    See Also\n    --------\n    numpy.savez : Save several arrays into an uncompressed .npz file format\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_439savez_compressed = {"savez_compressed", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_439savez_compressed, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_438savez_compressed};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_439savez_compressed(PyObject *__pyx_self, PyObject *__pyx_v_file) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savez_compressed (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_438savez_compressed(__pyx_self, ((PyObject *)__pyx_v_file));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_438savez_compressed(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_file) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("savez_compressed", 0);

  /* "ga4py/gain/notimplemented.pyx":10969
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 10969, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10948
 * 
 * 
 * def savez_compressed(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in compressed ``.npz`` format.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.savez_compressed", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":10972
 * 
 * 
 * def sctype2char(sctype):             # <<<<<<<<<<<<<<
 *     """Return the string representation of a scalar dtype.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_441sctype2char(PyObject *__pyx_self, PyObject *__pyx_v_sctype); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_440sctype2char[] = "Return the string representation of a scalar dtype.\n\n    Parameters\n    ----------\n    sctype : scalar dtype or object\n        If a scalar dtype, the corresponding string character is\n        returned. If an object, `sctype2char` tries to infer its scalar type\n        and then return the corresponding string character.\n\n    Returns\n    -------\n    typechar : str\n        The string character corresponding to the scalar type.\n\n    Raises\n    ------\n    ValueError\n        If `sctype` is an object for which the type can not be inferred.\n\n    See Also\n    --------\n    obj2sctype, issctype, issubsctype, mintypecode\n\n    Examples\n    --------\n    >>> for sctype in [np.int32, np.float, np.complex, np.string_, np.ndarray]:\n    ...     print np.sctype2char(sctype)\n    l\n    d\n    D\n    S\n    O\n\n    >>> x = np.array([1., 2-1.j])\n    >>> np.sctype2char(x)\n    'D'\n    >>> np.sctype2char(list)\n    'O'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_441sctype2char = {"sctype2char", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_441sctype2char, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_440sctype2char};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_441sctype2char(PyObject *__pyx_self, PyObject *__pyx_v_sctype) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sctype2char (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_440sctype2char(__pyx_self, ((PyObject *)__pyx_v_sctype));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_440sctype2char(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_sctype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sctype2char", 0);

  /* "ga4py/gain/notimplemented.pyx":11013
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11013, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10972
 * 
 * 
 * def sctype2char(sctype):             # <<<<<<<<<<<<<<
 *     """Return the string representation of a scalar dtype.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sctype2char", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11016
 * 
 * 
 * def searchsorted(a, v, side='left'):             # <<<<<<<<<<<<<<
 *     """Find indices where elements should be inserted to maintain order.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_443searchsorted(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_442searchsorted[] = "Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `a` such that, if the corresponding\n    elements in `v` were inserted before the indices, the order of `a` would\n    be preserved.\n\n    Parameters\n    ----------\n    a : 1-D array_like\n        Input array, sorted in ascending order.\n    v : array_like\n        Values to insert into `a`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.  If\n        'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `a`).\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `v`.\n\n    See Also\n    --------\n    sort : Return a sorted copy of an array.\n    histogram : Produce histogram from 1-D data.\n\n    Notes\n    -----\n    Binary search is used to find the required insertion points.\n\n    As of Numpy 1.4.0 `searchsorted` works with real/complex arrays containing\n    `nan` values. The enhanced sort order is documented in `sort`.\n\n    Examples\n    --------\n    >>> np.searchsorted([1,2,3,4,5], 3)\n    2\n    >>> np.searchsorted([1,2,3,4,5], 3, side='right')\n    3\n    >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\n    array([0, 5, 1, 2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_443searchsorted = {"searchsorted", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_443searchsorted, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_442searchsorted};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_443searchsorted(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_v = 0;
  CYTHON_UNUSED PyObject *__pyx_v_side = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("searchsorted (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_v,&__pyx_n_s_side,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s_left);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_v)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("searchsorted", 0, 2, 3, 1); __PYX_ERR(0, 11016, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_side);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "searchsorted") < 0)) __PYX_ERR(0, 11016, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_v = values[1];
    __pyx_v_side = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("searchsorted", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11016, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.searchsorted", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_442searchsorted(__pyx_self, __pyx_v_a, __pyx_v_v, __pyx_v_side);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_442searchsorted(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_v, CYTHON_UNUSED PyObject *__pyx_v_side) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("searchsorted", 0);

  /* "ga4py/gain/notimplemented.pyx":11061
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11061, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11016
 * 
 * 
 * def searchsorted(a, v, side='left'):             # <<<<<<<<<<<<<<
 *     """Find indices where elements should be inserted to maintain order.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.searchsorted", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11064
 * 
 * 
 * def select(condlist, choicelist, default=0):             # <<<<<<<<<<<<<<
 *     """Return an array drawn from elements in choicelist, depending on conditions.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_445select(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_444select[] = "Return an array drawn from elements in choicelist, depending on conditions.\n\n    Parameters\n    ----------\n    condlist : list of bool ndarrays\n        The list of conditions which determine from which array in `choicelist`\n        the output elements are taken. When multiple conditions are satisfied,\n        the first one encountered in `condlist` is used.\n    choicelist : list of ndarrays\n        The list of arrays from which the output elements are taken. It has\n        to be of the same length as `condlist`.\n    default : scalar, optional\n        The element inserted in `output` when all conditions evaluate to False.\n\n    Returns\n    -------\n    output : ndarray\n        The output at position m is the m-th element of the array in\n        `choicelist` where the m-th element of the corresponding array in\n        `condlist` is True.\n\n    See Also\n    --------\n    where : Return elements from one of two arrays depending on condition.\n    take, choose, compress, diag, diagonal\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> condlist = [x<3, x>5]\n    >>> choicelist = [x, x**2]\n    >>> np.select(condlist, choicelist)\n    array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_445select = {"select", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_445select, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_444select};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_445select(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_condlist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_choicelist = 0;
  CYTHON_UNUSED PyObject *__pyx_v_default = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("select (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_condlist,&__pyx_n_s_choicelist,&__pyx_n_s_default,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_condlist)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_choicelist)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("select", 0, 2, 3, 1); __PYX_ERR(0, 11064, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_default);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "select") < 0)) __PYX_ERR(0, 11064, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_condlist = values[0];
    __pyx_v_choicelist = values[1];
    __pyx_v_default = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("select", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11064, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_444select(__pyx_self, __pyx_v_condlist, __pyx_v_choicelist, __pyx_v_default);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_444select(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_condlist, CYTHON_UNUSED PyObject *__pyx_v_choicelist, CYTHON_UNUSED PyObject *__pyx_v_default) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("select", 0);

  /* "ga4py/gain/notimplemented.pyx":11100
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11100, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11064
 * 
 * 
 * def select(condlist, choicelist, default=0):             # <<<<<<<<<<<<<<
 *     """Return an array drawn from elements in choicelist, depending on conditions.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.select", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11103
 * 
 * 
 * def set_numeric_ops():             # <<<<<<<<<<<<<<
 *     """set_numeric_ops(op1=func1, op2=func2, ...)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_447set_numeric_ops(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_446set_numeric_ops[] = "set_numeric_ops(op1=func1, op2=func2, ...)\n\n    Set numerical operators for array objects.\n\n    Parameters\n    ----------\n    op1, op2, ... : callable\n        Each ``op = func`` pair describes an operator to be replaced.\n        For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace\n        addition by modulus 5 addition.\n\n    Returns\n    -------\n    saved_ops : list of callables\n        A list of all operators, stored before making replacements.\n\n    Notes\n    -----\n    .. WARNING::\n       Use with care!  Incorrect usage may lead to memory errors.\n\n    A function replacing an operator cannot make use of that operator.\n    For example, when replacing add, you may not use ``+``.  Instead,\n    directly call ufuncs.\n\n    Examples\n    --------\n    >>> def add_mod5(x, y):\n    ...     return np.add(x, y) % 5\n    ...\n    >>> old_funcs = np.set_numeric_ops(add=add_mod5)\n\n    >>> x = np.arange(12).reshape((3, 4))\n    >>> x + x\n    array([[0, 2, 4, 1],\n           [3, 0, 2, 4],\n           [1, 3, 0, 2]])\n\n    >>> ignore = np.set_numeric_ops(**old_funcs) # restore operators\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_447set_numeric_ops = {"set_numeric_ops", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_447set_numeric_ops, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_446set_numeric_ops};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_447set_numeric_ops(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_numeric_ops (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_446set_numeric_ops(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_446set_numeric_ops(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_numeric_ops", 0);

  /* "ga4py/gain/notimplemented.pyx":11146
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11146, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11103
 * 
 * 
 * def set_numeric_ops():             # <<<<<<<<<<<<<<
 *     """set_numeric_ops(op1=func1, op2=func2, ...)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_numeric_ops", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11149
 * 
 * 
 * def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None):             # <<<<<<<<<<<<<<
 *     """Set printing options.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_449set_printoptions(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_448set_printoptions[] = "Set printing options.\n\n    These options determine the way floating point numbers, arrays and\n    other NumPy objects are displayed.\n\n    Parameters\n    ----------\n    precision : int, optional\n        Number of digits of precision for floating point output (default 8).\n    threshold : int, optional\n        Total number of array elements which trigger summarization\n        rather than full repr (default 1000).\n    edgeitems : int, optional\n        Number of array items in summary at beginning and end of\n        each dimension (default 3).\n    linewidth : int, optional\n        The number of characters per line for the purpose of inserting\n        line breaks (default 75).\n    suppress : bool, optional\n        Whether or not suppress printing of small floating point values\n        using scientific notation (default False).\n    nanstr : str, optional\n        String representation of floating point not-a-number (default nan).\n    infstr : str, optional\n        String representation of floating point infinity (default inf).\n\n    See Also\n    --------\n    get_printoptions, set_string_function\n\n    Examples\n    --------\n    Floating point precision can be set:\n\n    >>> np.set_printoptions(precision=4)\n    >>> print np.array([1.123456789])\n    [ 1.1235]\n\n    Long arrays can be summarised:\n\n    >>> np.set_printoptions(threshold=5)\n    >>> print np.arange(10)\n    [0 1 2 ..., 7 8 9]\n\n    Small results can be suppressed:\n\n    >>> eps = np.finfo(float).eps\n    >>> x = np.arange(4.)\n    >>> x**2 - (x + eps)**2\n    array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])\n    >>> np.set_printoptions(suppress=True)\n    >>> x**2 - (x + eps)**2\n    array([-0., -0.,  0.,  0.])\n\n    To put back the default options, you can use:\n\n    >>> np.set_printoptions(edgeitems=3,infstr='Inf',\n    ... linewidth=75, nanstr='NaN', precision=8,\n    ... suppress=False, threshold=1000)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_449set_printoptions = {"set_printoptions", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_449set_printoptions, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_448set_printoptions};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_449set_printoptions(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_precision = 0;
  CYTHON_UNUSED PyObject *__pyx_v_threshold = 0;
  CYTHON_UNUSED PyObject *__pyx_v_edgeitems = 0;
  CYTHON_UNUSED PyObject *__pyx_v_linewidth = 0;
  CYTHON_UNUSED PyObject *__pyx_v_suppress = 0;
  CYTHON_UNUSED PyObject *__pyx_v_nanstr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_infstr = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_printoptions (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_precision,&__pyx_n_s_threshold,&__pyx_n_s_edgeitems,&__pyx_n_s_linewidth,&__pyx_n_s_suppress,&__pyx_n_s_nanstr,&__pyx_n_s_infstr,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)Py_None);
    values[6] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_precision);
          if (value) { values[0] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_threshold);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_edgeitems);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_linewidth);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_suppress);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nanstr);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_infstr);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_printoptions") < 0)) __PYX_ERR(0, 11149, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_precision = values[0];
    __pyx_v_threshold = values[1];
    __pyx_v_edgeitems = values[2];
    __pyx_v_linewidth = values[3];
    __pyx_v_suppress = values[4];
    __pyx_v_nanstr = values[5];
    __pyx_v_infstr = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("set_printoptions", 0, 0, 7, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11149, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_printoptions", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_448set_printoptions(__pyx_self, __pyx_v_precision, __pyx_v_threshold, __pyx_v_edgeitems, __pyx_v_linewidth, __pyx_v_suppress, __pyx_v_nanstr, __pyx_v_infstr);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_448set_printoptions(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_precision, CYTHON_UNUSED PyObject *__pyx_v_threshold, CYTHON_UNUSED PyObject *__pyx_v_edgeitems, CYTHON_UNUSED PyObject *__pyx_v_linewidth, CYTHON_UNUSED PyObject *__pyx_v_suppress, CYTHON_UNUSED PyObject *__pyx_v_nanstr, CYTHON_UNUSED PyObject *__pyx_v_infstr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_printoptions", 0);

  /* "ga4py/gain/notimplemented.pyx":11211
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11211, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11149
 * 
 * 
 * def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None):             # <<<<<<<<<<<<<<
 *     """Set printing options.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_printoptions", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11214
 * 
 * 
 * def set_string_function(f, repr=True):             # <<<<<<<<<<<<<<
 *     """Set a Python function to be used when pretty printing arrays.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_451set_string_function(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_450set_string_function[] = "Set a Python function to be used when pretty printing arrays.\n\n    Parameters\n    ----------\n    f : function or None\n        Function to be used to pretty print arrays. The function should expect\n        a single array argument and return a string of the representation of\n        the array. If None, the function is reset to the default NumPy function\n        to print arrays.\n    repr : bool, optional\n        If True (default), the function for pretty printing (``__repr__``)\n        is set, if False the function that returns the default string\n        representation (``__str__``) is set.\n\n    See Also\n    --------\n    set_printoptions, get_printoptions\n\n    Examples\n    --------\n    >>> def pprint(arr):\n    ...     return 'HA! - What are you going to do now?'\n    ...\n    >>> np.set_string_function(pprint)\n    >>> a = np.arange(10)\n    >>> a\n    HA! - What are you going to do now?\n    >>> print a\n    [0 1 2 3 4 5 6 7 8 9]\n\n    We can reset the function to the default:\n\n    >>> np.set_string_function(None)\n    >>> a\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    `repr` affects either pretty printing or normal string representation.\n    Note that ``__repr__`` is still affected by setting ``__str__``\n    because the width of each array element in the returned string becomes\n    equal to the length of the result of ``__str__()``.\n\n    >>> x = np.arange(4)\n    >>> np.set_string_function(lambda x:'random', repr=False)\n    >>> x.__str__()\n    'random'\n    >>> x.__repr__()\n    'array([     0,      1,      2,      3])'\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_451set_string_function = {"set_string_function", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_451set_string_function, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_450set_string_function};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_451set_string_function(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_f = 0;
  CYTHON_UNUSED PyObject *__pyx_v_repr = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_string_function (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_f,&__pyx_n_s_repr,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_f)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_repr);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_string_function") < 0)) __PYX_ERR(0, 11214, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_f = values[0];
    __pyx_v_repr = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("set_string_function", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11214, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_string_function", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_450set_string_function(__pyx_self, __pyx_v_f, __pyx_v_repr);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_450set_string_function(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_f, CYTHON_UNUSED PyObject *__pyx_v_repr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_string_function", 0);

  /* "ga4py/gain/notimplemented.pyx":11264
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11264, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11214
 * 
 * 
 * def set_string_function(f, repr=True):             # <<<<<<<<<<<<<<
 *     """Set a Python function to be used when pretty printing arrays.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.set_string_function", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11267
 * 
 * 
 * def setbufsize(size):             # <<<<<<<<<<<<<<
 *     """Set the size of the buffer used in ufuncs.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_453setbufsize(PyObject *__pyx_self, PyObject *__pyx_v_size); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_452setbufsize[] = "Set the size of the buffer used in ufuncs.\n\n    Parameters\n    ----------\n    size : int\n        Size of buffer.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_453setbufsize = {"setbufsize", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_453setbufsize, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_452setbufsize};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_453setbufsize(PyObject *__pyx_self, PyObject *__pyx_v_size) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setbufsize (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_452setbufsize(__pyx_self, ((PyObject *)__pyx_v_size));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_452setbufsize(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_size) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setbufsize", 0);

  /* "ga4py/gain/notimplemented.pyx":11276
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11276, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11267
 * 
 * 
 * def setbufsize(size):             # <<<<<<<<<<<<<<
 *     """Set the size of the buffer used in ufuncs.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setbufsize", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11279
 * 
 * 
 * def setdiff1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set difference of two arrays.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_455setdiff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_454setdiff1d[] = "Find the set difference of two arrays.\n\n    Return the sorted, unique values in `ar1` that are not in `ar2`.\n\n    Parameters\n    ----------\n    ar1 : array_like\n        Input array.\n    ar2 : array_like\n        Input comparison array.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    difference : ndarray\n        Sorted 1D array of values in `ar1` that are not in `ar2`.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4, 1])\n    >>> b = np.array([3, 4, 5, 6])\n    >>> np.setdiff1d(a, b)\n    array([1, 2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_455setdiff1d = {"setdiff1d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_455setdiff1d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_454setdiff1d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_455setdiff1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setdiff1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ar1,&__pyx_n_s_ar2,&__pyx_n_s_assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setdiff1d", 0, 2, 3, 1); __PYX_ERR(0, 11279, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setdiff1d") < 0)) __PYX_ERR(0, 11279, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setdiff1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11279, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setdiff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_454setdiff1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_454setdiff1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setdiff1d", 0);

  /* "ga4py/gain/notimplemented.pyx":11312
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11312, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11279
 * 
 * 
 * def setdiff1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set difference of two arrays.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setdiff1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11315
 * 
 * 
 * def seterr(all=None, divide=None, over=None, under=None, invalid=None):             # <<<<<<<<<<<<<<
 *     """Set how floating-point errors are handled.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_457seterr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_456seterr[] = "Set how floating-point errors are handled.\n\n    Note that operations on integer scalar types (such as `int16`) are\n    handled like floating point, and are affected by these settings.\n\n    Parameters\n    ----------\n    all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Set treatment for all types of floating-point errors at once:\n\n        - ignore: Take no action when the exception occurs.\n        - warn: Print a `RuntimeWarning` (via the Python `warnings` module).\n        - raise: Raise a `FloatingPointError`.\n        - call: Call a function specified using the `seterrcall` function.\n        - print: Print a warning directly to ``stdout``.\n        - log: Record error in a Log object specified by `seterrcall`.\n\n        The default is not to change the current behavior.\n    divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for division by zero.\n    over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point overflow.\n    under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for floating-point underflow.\n    invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n        Treatment for invalid floating-point operation.\n\n    Returns\n    -------\n    old_settings : dict\n        Dictionary containing the old settings.\n\n    See also\n    --------\n    seterrcall : Set a callback function for the 'call' mode.\n    geterr, geterrcall\n\n    Notes\n    -----\n    The floating-point exceptions are defined in the IEEE 754 standard [1]:\n\n    - Division by zero: infinite result obtained from finite numbers.\n    - Overflow: result too large to be expressed.\n    - Underflow: result so close to zero that some precision\n      was lost.\n    - Invalid operation: result is not an expressible number, typically\n      indicates that a NaN was produced.\n\n    .. [1] http://en.wikipedia.org/wiki/""IEEE_754\n\n    Examples\n    --------\n    >>> old_settings = np.seterr(all='ignore')  #seterr to known value\n    >>> np.seterr(over='raise')\n    {'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',\n     'under': 'ignore'}\n    >>> np.seterr(all='ignore')  # reset to default\n    {'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore', 'under': 'ignore'}\n\n    >>> np.int16(32000) * np.int16(3)\n    30464\n    >>> old_settings = np.seterr(all='warn', over='raise')\n    >>> np.int16(32000) * np.int16(3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    FloatingPointError: overflow encountered in short_scalars\n\n    >>> old_settings = np.seterr(all='print')\n    >>> np.geterr()\n    {'over': 'print', 'divide': 'print', 'invalid': 'print', 'under': 'print'}\n    >>> np.int16(32000) * np.int16(3)\n    Warning: overflow encountered in short_scalars\n    30464\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_457seterr = {"seterr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_457seterr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_456seterr};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_457seterr(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_all = 0;
  CYTHON_UNUSED PyObject *__pyx_v_divide = 0;
  CYTHON_UNUSED PyObject *__pyx_v_over = 0;
  CYTHON_UNUSED PyObject *__pyx_v_under = 0;
  CYTHON_UNUSED PyObject *__pyx_v_invalid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterr (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_all,&__pyx_n_s_divide,&__pyx_n_s_over,&__pyx_n_s_under,&__pyx_n_s_invalid,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_all);
          if (value) { values[0] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_divide);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_over);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_under);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_invalid);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "seterr") < 0)) __PYX_ERR(0, 11315, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_all = values[0];
    __pyx_v_divide = values[1];
    __pyx_v_over = values[2];
    __pyx_v_under = values[3];
    __pyx_v_invalid = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("seterr", 0, 0, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11315, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_456seterr(__pyx_self, __pyx_v_all, __pyx_v_divide, __pyx_v_over, __pyx_v_under, __pyx_v_invalid);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_456seterr(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_all, CYTHON_UNUSED PyObject *__pyx_v_divide, CYTHON_UNUSED PyObject *__pyx_v_over, CYTHON_UNUSED PyObject *__pyx_v_under, CYTHON_UNUSED PyObject *__pyx_v_invalid) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterr", 0);

  /* "ga4py/gain/notimplemented.pyx":11391
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11391, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11315
 * 
 * 
 * def seterr(all=None, divide=None, over=None, under=None, invalid=None):             # <<<<<<<<<<<<<<
 *     """Set how floating-point errors are handled.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11394
 * 
 * 
 * def seterrcall(func):             # <<<<<<<<<<<<<<
 *     """Set the floating-point error callback function or log object.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_459seterrcall(PyObject *__pyx_self, PyObject *__pyx_v_func); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_458seterrcall[] = "Set the floating-point error callback function or log object.\n\n    There are two ways to capture floating-point error messages.  The first\n    is to set the error-handler to 'call', using `seterr`.  Then, set\n    the function to call using this function.\n\n    The second is to set the error-handler to 'log', using `seterr`.\n    Floating-point errors then trigger a call to the 'write' method of\n    the provided object.\n\n    Parameters\n    ----------\n    func : callable f(err, flag) or object with write method\n        Function to call upon floating-point errors ('call'-mode) or\n        object whose 'write' method is used to log such message ('log'-mode).\n\n        The call function takes two arguments. The first is the\n        type of error (one of \"divide\", \"over\", \"under\", or \"invalid\"),\n        and the second is the status flag.  The flag is a byte, whose\n        least-significant bits indicate the status::\n\n          [0 0 0 0 invalid over under invalid]\n\n        In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n        If an object is provided, its write method should take one argument,\n        a string.\n\n    Returns\n    -------\n    h : callable, log instance or None\n        The old error handler.\n\n    See Also\n    --------\n    seterr, geterr, geterrcall\n\n    Examples\n    --------\n    Callback upon error:\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n\n    >>> saved_handler = np.seterrcall(err_handler)\n    >>> save_err = np.seterr(all='call')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    Floating point error (divide by zero), with flag 1\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <function err_handler at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'call', 'divide': 'call', 'invalid': 'call', 'under': 'call'}\n\n    Log error message:\n\n    >>> class Log(object):\n    ...     def writ""e(self, msg):\n    ...         print \"LOG: %s\" % msg\n    ...\n\n    >>> log = Log()\n    >>> saved_handler = np.seterrcall(log)\n    >>> save_err = np.seterr(all='log')\n\n    >>> np.array([1, 2, 3]) / 0.0\n    LOG: Warning: divide by zero encountered in divide\n    <BLANKLINE>\n    array([ Inf,  Inf,  Inf])\n\n    >>> np.seterrcall(saved_handler)\n    <__main__.Log object at 0x...>\n    >>> np.seterr(**save_err)\n    {'over': 'log', 'divide': 'log', 'invalid': 'log', 'under': 'log'}\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_459seterrcall = {"seterrcall", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_459seterrcall, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_458seterrcall};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_459seterrcall(PyObject *__pyx_self, PyObject *__pyx_v_func) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterrcall (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_458seterrcall(__pyx_self, ((PyObject *)__pyx_v_func));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_458seterrcall(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_func) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterrcall", 0);

  /* "ga4py/gain/notimplemented.pyx":11474
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11474, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11394
 * 
 * 
 * def seterrcall(func):             # <<<<<<<<<<<<<<
 *     """Set the floating-point error callback function or log object.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterrcall", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11477
 * 
 * 
 * def seterrobj(errobj):             # <<<<<<<<<<<<<<
 *     """seterrobj(errobj)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_461seterrobj(PyObject *__pyx_self, PyObject *__pyx_v_errobj); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_460seterrobj[] = "seterrobj(errobj)\n\n    Set the object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in Numpy. `seterrobj` is used internally by the other\n    functions that set error handling behavior (`seterr`, `seterrcall`).\n\n    Parameters\n    ----------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for \"invalid\", \"under\", \"over\", and\n        \"divide\" (in that order). The printed string can be interpreted with\n\n        * 0 : 'ignore'\n        * 1 : 'warn'\n        * 2 : 'raise'\n        * 3 : 'call'\n        * 4 : 'print'\n        * 5 : 'log'\n\n    See Also\n    --------\n    geterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> old_errobj = np.geterrobj()  # first get the defaults\n    >>> old_errobj\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print \"Floating point error (%s), with flag %s\" % (type, flag)\n    ...\n    >>> new_errobj = [20000, 12, err_handler]\n    >>> np.seterrobj(new_errobj)\n    >>> np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n    '14'\n    >>> np.geterr()\n    {'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n    >>> np.geterrcall() is err_handler\n    True\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_461seterrobj = {"seterrobj", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_461seterrobj, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_460seterrobj};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_461seterrobj(PyObject *__pyx_self, PyObject *__pyx_v_errobj) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterrobj (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_460seterrobj(__pyx_self, ((PyObject *)__pyx_v_errobj));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_460seterrobj(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_errobj) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seterrobj", 0);

  /* "ga4py/gain/notimplemented.pyx":11535
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11535, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11477
 * 
 * 
 * def seterrobj(errobj):             # <<<<<<<<<<<<<<
 *     """seterrobj(errobj)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.seterrobj", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11538
 * 
 * 
 * def setxor1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set exclusive-or of two arrays.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_463setxor1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_462setxor1d[] = "Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays.\n    assume_unique : bool\n        If True, the input arrays are both assumed to be unique, which\n        can speed up the calculation.  Default is False.\n\n    Returns\n    -------\n    xor : ndarray\n        Sorted 1D array of unique values that are in only one of the input\n        arrays.\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3, 2, 4])\n    >>> b = np.array([2, 3, 5, 7, 5])\n    >>> np.setxor1d(a,b)\n    array([1, 4, 5, 7])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_463setxor1d = {"setxor1d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_463setxor1d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_462setxor1d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_463setxor1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_assume_unique = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setxor1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ar1,&__pyx_n_s_ar2,&__pyx_n_s_assume_unique,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("setxor1d", 0, 2, 3, 1); __PYX_ERR(0, 11538, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_assume_unique);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setxor1d") < 0)) __PYX_ERR(0, 11538, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_assume_unique = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("setxor1d", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11538, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setxor1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_462setxor1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_assume_unique);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_462setxor1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2, CYTHON_UNUSED PyObject *__pyx_v_assume_unique) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("setxor1d", 0);

  /* "ga4py/gain/notimplemented.pyx":11566
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11566, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11538
 * 
 * 
 * def setxor1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set exclusive-or of two arrays.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.setxor1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11569
 * 
 * 
 * def show_config():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_465show_config(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_464show_config[] = "\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_465show_config = {"show_config", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_465show_config, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_464show_config};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_465show_config(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("show_config (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_464show_config(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_464show_config(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("show_config", 0);

  /* "ga4py/gain/notimplemented.pyx":11573
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11573, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11569
 * 
 * 
 * def show_config():             # <<<<<<<<<<<<<<
 *     """
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.show_config", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11576
 * 
 * 
 * def sinc(x):             # <<<<<<<<<<<<<<
 *     """Return the sinc function.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_467sinc(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_466sinc[] = "Return the sinc function.\n\n    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.\n\n    Parameters\n    ----------\n    x : ndarray\n        Array (possibly multi-dimensional) of values for which to to\n        calculate ``sinc(x)``.\n\n    Returns\n    -------\n    out : ndarray\n        ``sinc(x)``, which has the same shape as the input.\n\n    Notes\n    -----\n    ``sinc(0)`` is the limit value 1.\n\n    The name sinc is short for \"sine cardinal\" or \"sinus cardinalis\".\n\n    The sinc function is used in various signal processing applications,\n    including in anti-aliasing, in the construction of a\n    Lanczos resampling filter, and in interpolation.\n\n    For bandlimited interpolation of discrete-time signals, the ideal\n    interpolation kernel is proportional to the sinc function.\n\n    References\n    ----------\n    .. [1] Weisstein, Eric W. \"Sinc Function.\" From MathWorld--A Wolfram Web\n           Resource. http://mathworld.wolfram.com/SincFunction.html\n    .. [2] Wikipedia, \"Sinc function\",\n           http://en.wikipedia.org/wiki/Sinc_function\n\n    Examples\n    --------\n    >>> x = np.arange(-20., 21.)/5.\n    >>> np.sinc(x)\n    array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n             6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n             8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n             3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n             7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n             9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n             2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n            -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n            -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n             1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n            -5.84680802e-02,""  -8.90384387e-02,  -8.40918587e-02,\n            -4.92362781e-02,  -3.89804309e-17])\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(x, np.sinc(x))\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.title(\"Sinc Function\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.ylabel(\"Amplitude\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.xlabel(\"X\")\n    <matplotlib.text.Text object at 0x...>\n    >>> plt.show()\n\n    It works in 2-D as well:\n\n    >>> x = np.arange(-200., 201.)/50.\n    >>> xx = np.outer(x, x)\n    >>> plt.imshow(np.sinc(xx))\n    <matplotlib.image.AxesImage object at 0x...>\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_467sinc = {"sinc", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_467sinc, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_466sinc};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_467sinc(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sinc (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_466sinc(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_466sinc(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sinc", 0);

  /* "ga4py/gain/notimplemented.pyx":11650
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11650, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11576
 * 
 * 
 * def sinc(x):             # <<<<<<<<<<<<<<
 *     """Return the sinc function.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sinc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11653
 * 
 * 
 * def size(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the number of elements along a given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_469size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_468size[] = "Return the number of elements along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n    axis : int, optional\n        Axis along which the elements are counted.  By default, give\n        the total number of elements.\n\n    Returns\n    -------\n    element_count : int\n        Number of elements along the specified axis.\n\n    See Also\n    --------\n    shape : dimensions of array\n    ndarray.shape : dimensions of array\n    ndarray.size : number of elements in array\n\n    Examples\n    --------\n    >>> a = np.array([[1,2,3],[4,5,6]])\n    >>> np.size(a)\n    6\n    >>> np.size(a,1)\n    3\n    >>> np.size(a,0)\n    2\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_469size = {"size", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_469size, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_468size};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_469size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("size (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "size") < 0)) __PYX_ERR(0, 11653, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("size", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11653, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_468size(__pyx_self, __pyx_v_a, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_468size(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("size", 0);

  /* "ga4py/gain/notimplemented.pyx":11686
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11686, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11653
 * 
 * 
 * def size(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the number of elements along a given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11689
 * 
 * 
 * def sometrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check whether some values are true.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_471sometrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_470sometrue[] = "Check whether some values are true.\n\n    Refer to `any` for full documentation.\n\n    See Also\n    --------\n    any : equivalent function\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_471sometrue = {"sometrue", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_471sometrue, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_470sometrue};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_471sometrue(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sometrue (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_out,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sometrue") < 0)) __PYX_ERR(0, 11689, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_out = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sometrue", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11689, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sometrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_470sometrue(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_470sometrue(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sometrue", 0);

  /* "ga4py/gain/notimplemented.pyx":11699
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11699, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11689
 * 
 * 
 * def sometrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check whether some values are true.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sometrue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11702
 * 
 * 
 * def sort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Return a sorted copy of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_473sort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_472sort[] = "Return a sorted copy of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Array to be sorted.\n    axis : int or None, optional\n        Axis along which to sort. If None, the array is flattened before\n        sorting. The default is -1, which sorts along the last axis.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm. Default is 'quicksort'.\n    order : list, optional\n        When `a` is a structured array, this argument specifies which fields\n        to compare first, second, and so on.  This list does not need to\n        include all of the fields.\n\n    Returns\n    -------\n    sorted_array : ndarray\n        Array of the same type and shape as `a`.\n\n    See Also\n    --------\n    ndarray.sort : Method to sort an array in-place.\n    argsort : Indirect sort.\n    lexsort : Indirect stable sort on multiple keys.\n    searchsorted : Find elements in a sorted array.\n\n    Notes\n    -----\n    The various sorting algorithms are characterized by their average speed,\n    worst case performance, work space size, and whether they are stable. A\n    stable sort keeps items with the same key in the same relative\n    order. The three available algorithms have the following\n    properties:\n\n    =========== ======= ============= ============ =======\n       kind      speed   worst case    work space  stable\n    =========== ======= ============= ============ =======\n    'quicksort'    1     O(n^2)            0          no\n    'mergesort'    2     O(n*log(n))      ~n/2        yes\n    'heapsort'     3     O(n*log(n))       0          no\n    =========== ======= ============= ============ =======\n\n    All the sort algorithms make temporary copies of the data when\n    sorting along any but the last axis.  Consequently, sorting along\n    the last axis is faster and uses less space than sorting along\n    any other axis.\n\n    The sort order for complex numbers is lexicographic. If both the real""\n    and imaginary parts are non-nan then the order is determined by the\n    real parts except when they are equal, in which case the order is\n    determined by the imaginary parts.\n\n    Previous to numpy 1.4.0 sorting real and complex arrays containing nan\n    values led to undefined behaviour. In numpy versions >= 1.4.0 nan\n    values are sorted to the end. The extended sort order is:\n\n      * Real: [R, nan]\n      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]\n\n    where R is a non-nan real value. Complex values with the same nan\n    placements are sorted according to the non-nan part if it exists.\n    Non-nan values are sorted as before.\n\n    Examples\n    --------\n    >>> a = np.array([[1,4],[3,1]])\n    >>> np.sort(a)                # sort along the last axis\n    array([[1, 4],\n           [1, 3]])\n    >>> np.sort(a, axis=None)     # sort the flattened array\n    array([1, 1, 3, 4])\n    >>> np.sort(a, axis=0)        # sort along the first axis\n    array([[1, 1],\n           [3, 4]])\n\n    Use the `order` keyword to specify a field to use when sorting a\n    structured array:\n\n    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]\n    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n    ...           ('Galahad', 1.7, 38)]\n    >>> a = np.array(values, dtype=dtype)       # create a structured array\n    >>> np.sort(a, order='height')                        # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n           ('Lancelot', 1.8999999999999999, 38)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n\n    Sort by age, then height if ages are equal:\n\n    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP\n    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n           ('Arthur', 1.8, 41)],\n          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_473sort = {"sort", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_473sort, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_472sort};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_473sort(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_kind = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sort (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_kind,&__pyx_n_s_order,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_neg_1);
    values[2] = ((PyObject *)__pyx_n_s_quicksort);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_kind);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sort") < 0)) __PYX_ERR(0, 11702, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_kind = values[2];
    __pyx_v_order = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sort", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11702, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_472sort(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_kind, __pyx_v_order);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_472sort(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_kind, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sort", 0);

  /* "ga4py/gain/notimplemented.pyx":11800
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11800, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11702
 * 
 * 
 * def sort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Return a sorted copy of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11803
 * 
 * 
 * def sort_complex(a):             # <<<<<<<<<<<<<<
 *     """Sort a complex array using the real part first, then the imaginary part.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_475sort_complex(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_474sort_complex[] = "Sort a complex array using the real part first, then the imaginary part.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n\n    Returns\n    -------\n    out : complex ndarray\n        Always returns a sorted complex array.\n\n    Examples\n    --------\n    >>> np.sort_complex([5, 3, 6, 2, 1])\n    array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])\n\n    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\n    array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_475sort_complex = {"sort_complex", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_475sort_complex, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_474sort_complex};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_475sort_complex(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sort_complex (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_474sort_complex(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_474sort_complex(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sort_complex", 0);

  /* "ga4py/gain/notimplemented.pyx":11825
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11825, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11803
 * 
 * 
 * def sort_complex(a):             # <<<<<<<<<<<<<<
 *     """Sort a complex array using the real part first, then the imaginary part.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sort_complex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11828
 * 
 * 
 * def source(object, output=sys.stdout):             # <<<<<<<<<<<<<<
 *     """Print or write to a file the source code for a Numpy object.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_477source(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_476source[] = "Print or write to a file the source code for a Numpy object.\n\n    The source code is only returned for objects written in Python. Many\n    functions and classes are defined in C and will therefore not return\n    useful information.\n\n    Parameters\n    ----------\n    object : numpy object\n        Input object. This can be any object (function, class, module, ...).\n    output : file object, optional\n        If `output` not supplied then source code is printed to screen\n        (sys.stdout).  File object must be created with either write 'w' or\n        append 'a' modes.\n\n    See Also\n    --------\n    lookfor, info\n\n    Examples\n    --------\n    >>> np.source(np.interp)                        #doctest: +SKIP\n    In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\n    def interp(x, xp, fp, left=None, right=None):\n        '''.... (full docstring printed)'''\n        if isinstance(x, (float, int, number)):\n            return compiled_interp([x], xp, fp, left, right).item()\n        else:\n            return compiled_interp(x, xp, fp, left, right)\n\n    The source code is only returned for objects written in Python.\n\n    >>> np.source(np.array)                         #doctest: +SKIP\n    Not available for this object.\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_477source = {"source", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_477source, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_476source};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_477source(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_object = 0;
  CYTHON_UNUSED PyObject *__pyx_v_output = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("source (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_object,&__pyx_n_s_output,0};
    PyObject* values[2] = {0,0};
    values[1] = __pyx_k__15;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_object)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "source") < 0)) __PYX_ERR(0, 11828, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_object = values[0];
    __pyx_v_output = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("source", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11828, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.source", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_476source(__pyx_self, __pyx_v_object, __pyx_v_output);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_476source(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_object, CYTHON_UNUSED PyObject *__pyx_v_output) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("source", 0);

  /* "ga4py/gain/notimplemented.pyx":11865
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11865, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11828
 * 
 * 
 * def source(object, output=sys.stdout):             # <<<<<<<<<<<<<<
 *     """Print or write to a file the source code for a Numpy object.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.source", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11868
 * 
 * 
 * def split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal size.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_479split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_478split[] = "Split an array into multiple sub-arrays of equal size.\n\n    Parameters\n    ----------\n    ary : ndarray\n        Array to be divided into sub-arrays.\n    indices_or_sections : int or 1-D array\n        If `indices_or_sections` is an integer, N, the array will be divided\n        into N equal arrays along `axis`.  If such a split is not possible,\n        an error is raised.\n\n        If `indices_or_sections` is a 1-D array of sorted integers, the entries\n        indicate where along `axis` the array is split.  For example,\n        ``[2, 3]`` would, for ``axis=0``, result in\n\n          - ary[:2]\n          - ary[2:3]\n          - ary[3:]\n\n        If an index exceeds the dimension of the array along `axis`,\n        an empty sub-array is returned correspondingly.\n    axis : int, optional\n        The axis along which to split, default is 0.\n\n    Returns\n    -------\n    sub-arrays : list of ndarrays\n        A list of sub-arrays.\n\n    Raises\n    ------\n    ValueError\n        If `indices_or_sections` is given as an integer, but\n        a split does not result in equal division.\n\n    See Also\n    --------\n    array_split : Split an array into multiple sub-arrays of equal or\n                  near-equal size.  Does not raise an exception if\n                  an equal division cannot be made.\n    hsplit : Split array into multiple sub-arrays horizontally (column-wise).\n    vsplit : Split array into multiple sub-arrays vertically (row wise).\n    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).\n    concatenate : Join arrays together.\n    hstack : Stack arrays in sequence horizontally (column wise).\n    vstack : Stack arrays in sequence vertically (row wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n\n    Examples\n    --------\n    >>> x = np.arange(9.0)\n    >>> np.split(x, 3)\n    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]\n\n    >>> x = np.arange(8.""0)\n    >>> np.split(x, [3, 5, 6, 10])\n    [array([ 0.,  1.,  2.]),\n     array([ 3.,  4.]),\n     array([ 5.]),\n     array([ 6.,  7.]),\n     array([], dtype=float64)]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_479split = {"split", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_479split, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_478split};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_479split(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("split (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ary,&__pyx_n_s_indices_or_sections,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("split", 0, 2, 3, 1); __PYX_ERR(0, 11868, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "split") < 0)) __PYX_ERR(0, 11868, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("split", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11868, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_478split(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_478split(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("split", 0);

  /* "ga4py/gain/notimplemented.pyx":11932
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11932, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11868
 * 
 * 
 * def split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal size.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.split", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11935
 * 
 * 
 * def squeeze(a):             # <<<<<<<<<<<<<<
 *     """Remove single-dimensional entries from the shape of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_481squeeze(PyObject *__pyx_self, PyObject *__pyx_v_a); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_480squeeze[] = "Remove single-dimensional entries from the shape of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    squeezed : ndarray\n        The input array, but with with all dimensions of length 1\n        removed.  Whenever possible, a view on `a` is returned.\n\n    Examples\n    --------\n    >>> x = np.array([[[0], [1], [2]]])\n    >>> x.shape\n    (1, 3, 1)\n    >>> np.squeeze(x).shape\n    (3,)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_481squeeze = {"squeeze", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_481squeeze, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_480squeeze};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_481squeeze(PyObject *__pyx_self, PyObject *__pyx_v_a) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("squeeze (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_480squeeze(__pyx_self, ((PyObject *)__pyx_v_a));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_480squeeze(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("squeeze", 0);

  /* "ga4py/gain/notimplemented.pyx":11958
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 11958, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11935
 * 
 * 
 * def squeeze(a):             # <<<<<<<<<<<<<<
 *     """Remove single-dimensional entries from the shape of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.squeeze", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":11961
 * 
 * 
 * def std(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the standard deviation along the specified axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_483std(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_482std[] = "Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the array elements. The standard deviation is computed for the\n    flattened array by default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Calculate the standard deviation of these values.\n    axis : int, optional\n        Axis along which the standard deviation is computed. The default is\n        to compute the standard deviation of the flattened array.\n    dtype : dtype, optional\n        Type to use in computing the standard deviation. For arrays of\n        integer type the default is float64, for arrays of float types it is\n        the same as the array type.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must have\n        the same shape as the expected output but the type (of the calculated\n        values) will be cast if necessary.\n    ddof : int, optional\n        Means Delta Degrees of Freedom.  The divisor used in calculations\n        is ``N - ddof``, where ``N`` represents the number of elements.\n        By default `ddof` is zero.\n\n    Returns\n    -------\n    standard_deviation : ndarray, see dtype parameter above.\n        If `out` is None, return a new array containing the standard deviation,\n        otherwise return a reference to the output array.\n\n    See Also\n    --------\n    var, mean\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The standard deviation is the square root of the average of the squared\n    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.\n\n    The average squared deviation is normally calculated as ``x.sum() / N``, where\n    ``N = len(x)``.  If, however, `ddof` is specified, the divisor ``N - ddof``\n    is used instead. In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of t""he variance of the infinite population. ``ddof=0``\n    provides a maximum likelihood estimate of the variance for normally\n    distributed variables. The standard deviation computed in this function\n    is the square root of the estimated variance, so even with ``ddof=1``, it\n    will not be an unbiased estimate of the standard deviation per se.\n\n    Note that, for complex numbers, `std` takes the absolute\n    value before squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the *std* is computed using the same\n    precision the input has. Depending on the input data, this can cause\n    the results to be inaccurate, especially for float32 (see example below).\n    Specifying a higher-accuracy accumulator using the `dtype` keyword can\n    alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> np.std(a)\n    1.1180339887498949\n    >>> np.std(a, axis=0)\n    array([ 1.,  1.])\n    >>> np.std(a, axis=1)\n    array([ 0.5,  0.5])\n\n    In single precision, std() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.std(a)\n    0.45172946707416706\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.std(a, dtype=np.float64)\n    0.44999999925552653\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_483std = {"std", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_483std, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_482std};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_483std(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("std (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,&__pyx_n_s_ddof,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "std") < 0)) __PYX_ERR(0, 11961, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("std", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 11961, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.std", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_482std(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out, __pyx_v_ddof);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_482std(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("std", 0);

  /* "ga4py/gain/notimplemented.pyx":12046
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12046, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11961
 * 
 * 
 * def std(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the standard deviation along the specified axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.std", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12049
 * 
 * 
 * def sum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Sum of array elements over a given axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_485sum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_484sum[] = "Sum of array elements over a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Elements to sum.\n    axis : integer, optional\n        Axis over which the sum is taken. By default `axis` is None,\n        and all elements are summed.\n    dtype : dtype, optional\n        The type of the returned array and of the accumulator in which\n        the elements are summed.  By default, the dtype of `a` is used.\n        An exception is when `a` has an integer type with less precision\n        than the default platform integer.  In that case, the default\n        platform integer is used instead.\n    out : ndarray, optional\n        Array into which the output is placed.  By default, a new array is\n        created.  If `out` is given, it must be of the appropriate shape\n        (the shape of `a` with `axis` removed, i.e.,\n        ``numpy.delete(a.shape, axis)``).  Its type is preserved. See\n        `doc.ufuncs` (Section \"Output arguments\") for more details.\n\n    Returns\n    -------\n    sum_along_axis : ndarray\n        An array with the same shape as `a`, with the specified\n        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n        is returned.  If an output array is specified, a reference to\n        `out` is returned.\n\n    See Also\n    --------\n    ndarray.sum : Equivalent method.\n\n    cumsum : Cumulative sum of array elements.\n\n    trapz : Integration of array values using the composite trapezoidal rule.\n\n    mean, average\n\n    Notes\n    -----\n    Arithmetic is modular when using integer types, and no error is\n    raised on overflow.\n\n    Examples\n    --------\n    >>> np.sum([0.5, 1.5])\n    2.0\n    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n    1\n    >>> np.sum([[0, 1], [0, 5]])\n    6\n    >>> np.sum([[0, 1], [0, 5]], axis=0)\n    array([0, 6])\n    >>> np.sum([[0, 1], [0, 5]], axis=1)\n    array([1, 5])\n\n    If the accumulator is too small, overflow occurs:\n\n    >>> np.one""s(128, dtype=np.int8).sum(dtype=np.int8)\n    -128\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_485sum = {"sum", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_485sum, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_484sum};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_485sum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sum (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sum") < 0)) __PYX_ERR(0, 12049, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sum", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12049, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_484sum(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_484sum(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sum", 0);

  /* "ga4py/gain/notimplemented.pyx":12114
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12114, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12049
 * 
 * 
 * def sum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Sum of array elements over a given axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.sum", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12117
 * 
 * 
 * def swapaxes(a, axis1, axis2):             # <<<<<<<<<<<<<<
 *     """Interchange two axes of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_487swapaxes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_486swapaxes[] = "Interchange two axes of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axis1 : int\n        First axis.\n    axis2 : int\n        Second axis.\n\n    Returns\n    -------\n    a_swapped : ndarray\n        If `a` is an ndarray, then a view of `a` is returned; otherwise\n        a new array is created.\n\n    Examples\n    --------\n    >>> x = np.array([[1,2,3]])\n    >>> np.swapaxes(x,0,1)\n    array([[1],\n           [2],\n           [3]])\n\n    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n\n    >>> np.swapaxes(x,0,2)\n    array([[[0, 4],\n            [2, 6]],\n           [[1, 5],\n            [3, 7]]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_487swapaxes = {"swapaxes", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_487swapaxes, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_486swapaxes};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_487swapaxes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("swapaxes (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis1,&__pyx_n_s_axis2,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("swapaxes", 1, 3, 3, 1); __PYX_ERR(0, 12117, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("swapaxes", 1, 3, 3, 2); __PYX_ERR(0, 12117, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "swapaxes") < 0)) __PYX_ERR(0, 12117, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_a = values[0];
    __pyx_v_axis1 = values[1];
    __pyx_v_axis2 = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("swapaxes", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12117, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.swapaxes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_486swapaxes(__pyx_self, __pyx_v_a, __pyx_v_axis1, __pyx_v_axis2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_486swapaxes(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("swapaxes", 0);

  /* "ga4py/gain/notimplemented.pyx":12157
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12157, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12117
 * 
 * 
 * def swapaxes(a, axis1, axis2):             # <<<<<<<<<<<<<<
 *     """Interchange two axes of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.swapaxes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12160
 * 
 * 
 * def take(a, indices, axis=None, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Take elements from an array along an axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_489take(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_488take[] = "Take elements from an array along an axis.\n\n    This function does the same thing as \"fancy\" indexing (indexing arrays\n    using arrays); however, it can be easier to use if you need elements\n    along a given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        The source array.\n    indices : array_like\n        The indices of the values to extract.\n    axis : int, optional\n        The axis over which to select values. By default, the flattened\n        input array is used.\n    out : ndarray, optional\n        If provided, the result will be placed in this array. It should\n        be of the appropriate shape and dtype.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' -- raise an error (default)\n        * 'wrap' -- wrap around\n        * 'clip' -- clip to the range\n\n        'clip' mode means that all indices that are too large are replaced\n        by the index that addresses the last element along that axis. Note\n        that this disables indexing with negative numbers.\n\n    Returns\n    -------\n    subarray : ndarray\n        The returned array has the same type as `a`.\n\n    See Also\n    --------\n    ndarray.take : equivalent method\n\n    Examples\n    --------\n    >>> a = [4, 3, 5, 7, 6, 8]\n    >>> indices = [0, 1, 4]\n    >>> np.take(a, indices)\n    array([4, 3, 6])\n\n    In this example if `a` is an ndarray, \"fancy\" indexing can be used.\n\n    >>> a = np.array(a)\n    >>> a[indices]\n    array([4, 3, 6])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_489take = {"take", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_489take, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_488take};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_489take(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_mode = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("take (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_indices,&__pyx_n_s_axis,&__pyx_n_s_out,&__pyx_n_s_mode,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_n_s_raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_indices)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("take", 0, 2, 5, 1); __PYX_ERR(0, 12160, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "take") < 0)) __PYX_ERR(0, 12160, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_indices = values[1];
    __pyx_v_axis = values[2];
    __pyx_v_out = values[3];
    __pyx_v_mode = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("take", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12160, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.take", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_488take(__pyx_self, __pyx_v_a, __pyx_v_indices, __pyx_v_axis, __pyx_v_out, __pyx_v_mode);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_488take(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("take", 0);

  /* "ga4py/gain/notimplemented.pyx":12213
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12213, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12160
 * 
 * 
 * def take(a, indices, axis=None, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Take elements from an array along an axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.take", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12216
 * 
 * 
 * def tensordot(a, b, axes=2):             # <<<<<<<<<<<<<<
 *     """Compute tensor dot product along specified axes for arrays >= 1-D.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_491tensordot(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_490tensordot[] = "Compute tensor dot product along specified axes for arrays >= 1-D.\n\n    Given two tensors (arrays of dimension greater than or equal to one),\n    ``a`` and ``b``, and an array_like object containing two array_like\n    objects, ``(a_axes, b_axes)``, sum the products of ``a``'s and ``b``'s\n    elements (components) over the axes specified by ``a_axes`` and\n    ``b_axes``. The third argument can be a single non-negative\n    integer_like scalar, ``N``; if it is such, then the last ``N``\n    dimensions of ``a`` and the first ``N`` dimensions of ``b`` are summed\n    over.\n\n    Parameters\n    ----------\n    a, b : array_like, len(shape) >= 1\n        Tensors to \"dot\".\n\n    axes : variable type\n\n    * integer_like scalar\n      Number of axes to sum over (applies to both arrays); or\n\n    * array_like, shape = (2,), both elements array_like\n      Axes to be summed over, first sequence applying to ``a``, second\n      to ``b``.\n\n    See Also\n    --------\n    dot, einsum\n\n    Notes\n    -----\n    When there is more than one axis to sum over - and they are not the last\n    (first) axes of ``a`` (``b``) - the argument ``axes`` should consist of\n    two sequences of the same length, with the first axis to sum over given\n    first in both sequences, the second axis second, and so forth.\n\n    Examples\n    --------\n    A \"traditional\" example:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n    >>> c.shape\n    (5, 2)\n    >>> c\n    array([[ 4400.,  4730.],\n           [ 4532.,  4874.],\n           [ 4664.,  5018.],\n           [ 4796.,  5162.],\n           [ 4928.,  5306.]])\n    >>> # A slower but equivalent way of computing the same...\n    >>> d = np.zeros((5,2))\n    >>> for i in range(5):\n    ...   for j in range(2):\n    ...     for k in range(3):\n    ...       for n in range(4):\n    ...         d[i,j] += a[k,n,i] * b[n,k,j]\n    >>> c == d""\n    array([[ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True]], dtype=bool)\n\n    An extended example taking advantage of the overloading of + and \\*:\n\n    >>> a = np.array(range(1, 9))\n    >>> a.shape = (2, 2, 2)\n    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n    >>> A.shape = (2, 2)\n    >>> a; A\n    array([[[1, 2],\n            [3, 4]],\n           [[5, 6],\n            [7, 8]]])\n    array([[a, b],\n           [c, d]], dtype=object)\n\n    >>> np.tensordot(a, A) # third argument default is 2\n    array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, 1)\n    array([[[acc, bdd],\n            [aaacccc, bbbdddd]],\n           [[aaaaacccccc, bbbbbdddddd],\n            [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, 0) # \"Left for reader\" (result too long to incl.)\n    array([[[[[a, b],\n              [c, d]],\n              ...\n\n    >>> np.tensordot(a, A, (0, 1))\n    array([[[abbbbb, cddddd],\n            [aabbbbbb, ccdddddd]],\n           [[aaabbbbbbb, cccddddddd],\n            [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, (2, 1))\n    array([[[abb, cdd],\n            [aaabbbb, cccdddd]],\n           [[aaaaabbbbbb, cccccdddddd],\n            [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)\n\n    >>> np.tensordot(a, A, ((0, 1), (0, 1)))\n    array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)\n\n    >>> np.tensordot(a, A, ((2, 1), (1, 0)))\n    array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_491tensordot = {"tensordot", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_491tensordot, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_490tensordot};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_491tensordot(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_b = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axes = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tensordot (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_b,&__pyx_n_s_axes,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_int_2);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_b)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("tensordot", 0, 2, 3, 1); __PYX_ERR(0, 12216, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axes);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tensordot") < 0)) __PYX_ERR(0, 12216, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_b = values[1];
    __pyx_v_axes = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tensordot", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12216, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tensordot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_490tensordot(__pyx_self, __pyx_v_a, __pyx_v_b, __pyx_v_axes);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_490tensordot(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_b, CYTHON_UNUSED PyObject *__pyx_v_axes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tensordot", 0);

  /* "ga4py/gain/notimplemented.pyx":12329
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12329, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12216
 * 
 * 
 * def tensordot(a, b, axes=2):             # <<<<<<<<<<<<<<
 *     """Compute tensor dot product along specified axes for arrays >= 1-D.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tensordot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12332
 * 
 * 
 * def tile(A, reps):             # <<<<<<<<<<<<<<
 *     """Construct an array by repeating A the number of times given by reps.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_493tile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_492tile[] = "Construct an array by repeating A the number of times given by reps.\n\n    If `reps` has length ``d``, the result will have dimension of\n    ``max(d, A.ndim)``.\n\n    If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\n    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\n    or shape (1, 1, 3) for 3-D replication. If this is not the desired\n    behavior, promote `A` to d-dimensions manually before calling this\n    function.\n\n    If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.\n    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\n    (1, 1, 2, 2).\n\n    Parameters\n    ----------\n    A : array_like\n        The input array.\n    reps : array_like\n        The number of repetitions of `A` along each axis.\n\n    Returns\n    -------\n    c : ndarray\n        The tiled output array.\n\n    See Also\n    --------\n    repeat : Repeat elements of an array.\n\n    Examples\n    --------\n    >>> a = np.array([0, 1, 2])\n    >>> np.tile(a, 2)\n    array([0, 1, 2, 0, 1, 2])\n    >>> np.tile(a, (2, 2))\n    array([[0, 1, 2, 0, 1, 2],\n           [0, 1, 2, 0, 1, 2]])\n    >>> np.tile(a, (2, 1, 2))\n    array([[[0, 1, 2, 0, 1, 2]],\n           [[0, 1, 2, 0, 1, 2]]])\n\n    >>> b = np.array([[1, 2], [3, 4]])\n    >>> np.tile(b, 2)\n    array([[1, 2, 1, 2],\n           [3, 4, 3, 4]])\n    >>> np.tile(b, (2, 1))\n    array([[1, 2],\n           [3, 4],\n           [1, 2],\n           [3, 4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_493tile = {"tile", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_493tile, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_492tile};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_493tile(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_A = 0;
  CYTHON_UNUSED PyObject *__pyx_v_reps = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tile (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_A,&__pyx_n_s_reps,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_A)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_reps)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("tile", 1, 2, 2, 1); __PYX_ERR(0, 12332, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tile") < 0)) __PYX_ERR(0, 12332, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_A = values[0];
    __pyx_v_reps = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tile", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12332, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_492tile(__pyx_self, __pyx_v_A, __pyx_v_reps);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_492tile(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_A, CYTHON_UNUSED PyObject *__pyx_v_reps) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tile", 0);

  /* "ga4py/gain/notimplemented.pyx":12387
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12387, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12332
 * 
 * 
 * def tile(A, reps):             # <<<<<<<<<<<<<<
 *     """Construct an array by repeating A the number of times given by reps.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tile", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12390
 * 
 * 
 * def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the sum along diagonals of the array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_495trace(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_494trace[] = "Return the sum along diagonals of the array.\n\n    If `a` is 2-D, the sum along its diagonal with the given offset\n    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.\n\n    If `a` has more than two dimensions, then the axes specified by axis1 and\n    axis2 are used to determine the 2-D sub-arrays whose traces are returned.\n    The shape of the resulting array is the same as that of `a` with `axis1`\n    and `axis2` removed.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, from which the diagonals are taken.\n    offset : int, optional\n        Offset of the diagonal from the main diagonal. Can be both positive\n        and negative. Defaults to 0.\n    axis1, axis2 : int, optional\n        Axes to be used as the first and second axis of the 2-D sub-arrays\n        from which the diagonals should be taken. Defaults are the first two\n        axes of `a`.\n    dtype : dtype, optional\n        Determines the data-type of the returned array and of the accumulator\n        where the elements are summed. If dtype has the value None and `a` is\n        of integer type of precision less than the default integer\n        precision, then the default integer precision is used. Otherwise,\n        the precision is the same as that of `a`.\n    out : ndarray, optional\n        Array into which the output is placed. Its type is preserved and\n        it must be of the right shape to hold the output.\n\n    Returns\n    -------\n    sum_along_diagonals : ndarray\n        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has\n        larger dimensions, then an array of sums along diagonals is returned.\n\n    See Also\n    --------\n    diag, diagonal, diagflat\n\n    Examples\n    --------\n    >>> np.trace(np.eye(3))\n    3.0\n    >>> a = np.arange(8).reshape((2,2,2))\n    >>> np.trace(a)\n    array([6, 8])\n\n    >>> a = np.arange(24).reshape((2,2,2,3))\n    >>> np.trace(a).shape\n    (2, 3)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_495trace = {"trace", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_495trace, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_494trace};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_495trace(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_offset = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis2 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trace (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_offset,&__pyx_n_s_axis1,&__pyx_n_s_axis2,&__pyx_n_s_dtype,&__pyx_n_s_out,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    values[2] = ((PyObject *)__pyx_int_0);
    values[3] = ((PyObject *)__pyx_int_1);
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_offset);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis1);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis2);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "trace") < 0)) __PYX_ERR(0, 12390, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_offset = values[1];
    __pyx_v_axis1 = values[2];
    __pyx_v_axis2 = values[3];
    __pyx_v_dtype = values[4];
    __pyx_v_out = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("trace", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12390, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trace", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_494trace(__pyx_self, __pyx_v_a, __pyx_v_offset, __pyx_v_axis1, __pyx_v_axis2, __pyx_v_dtype, __pyx_v_out);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_494trace(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_offset, CYTHON_UNUSED PyObject *__pyx_v_axis1, CYTHON_UNUSED PyObject *__pyx_v_axis2, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trace", 0);

  /* "ga4py/gain/notimplemented.pyx":12445
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12445, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12390
 * 
 * 
 * def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the sum along diagonals of the array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trace", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12448
 * 
 * 
 * def transpose(a, axes=None):             # <<<<<<<<<<<<<<
 *     """Permute the dimensions of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_497transpose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_496transpose[] = "Permute the dimensions of an array.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    axes : list of ints, optional\n        By default, reverse the dimensions, otherwise permute the axes\n        according to the values given.\n\n    Returns\n    -------\n    p : ndarray\n        `a` with its axes permuted.  A view is returned whenever\n        possible.\n\n    See Also\n    --------\n    rollaxis\n\n    Examples\n    --------\n    >>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0, 1],\n           [2, 3]])\n\n    >>> np.transpose(x)\n    array([[0, 2],\n           [1, 3]])\n\n    >>> x = np.ones((1, 2, 3))\n    >>> np.transpose(x, (1, 0, 2)).shape\n    (2, 1, 3)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_497transpose = {"transpose", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_497transpose, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_496transpose};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_497transpose(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axes = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("transpose (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axes,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axes);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "transpose") < 0)) __PYX_ERR(0, 12448, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axes = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("transpose", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12448, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.transpose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_496transpose(__pyx_self, __pyx_v_a, __pyx_v_axes);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_496transpose(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axes) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("transpose", 0);

  /* "ga4py/gain/notimplemented.pyx":12485
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12485, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12448
 * 
 * 
 * def transpose(a, axes=None):             # <<<<<<<<<<<<<<
 *     """Permute the dimensions of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.transpose", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12488
 * 
 * 
 * def trapz(y, x=None, dx=1.0, axis=-1):             # <<<<<<<<<<<<<<
 *     """Integrate along the given axis using the composite trapezoidal rule.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_499trapz(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_498trapz[] = "Integrate along the given axis using the composite trapezoidal rule.\n\n    Integrate `y` (`x`) along given axis.\n\n    Parameters\n    ----------\n    y : array_like\n        Input array to integrate.\n    x : array_like, optional\n        If `x` is None, then spacing between all `y` elements is `dx`.\n    dx : scalar, optional\n        If `x` is None, spacing given by `dx` is assumed. Default is 1.\n    axis : int, optional\n        Specify the axis.\n\n    Returns\n    -------\n    out : float\n        Definite integral as approximated by trapezoidal rule.\n\n    See Also\n    --------\n    sum, cumsum\n\n    Notes\n    -----\n    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points will\n    be taken from `y` array, by default x-axis distances between points will be\n    1.0, alternatively they can be provided with `x` array or with `dx` scalar.\n    Return value will be equal to combined area under the red lines.\n\n\n    References\n    ----------\n    .. [1] Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule\n\n    .. [2] Illustration image:\n           http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\n    Examples\n    --------\n    >>> np.trapz([1,2,3])\n    4.0\n    >>> np.trapz([1,2,3], x=[4,6,8])\n    8.0\n    >>> np.trapz([1,2,3], dx=2)\n    8.0\n    >>> a = np.arange(6).reshape(2, 3)\n    >>> a\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.trapz(a, axis=0)\n    array([ 1.5,  2.5,  3.5])\n    >>> np.trapz(a, axis=1)\n    array([ 2.,  8.])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_499trapz = {"trapz", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_499trapz, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_498trapz};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_499trapz(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_y = 0;
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dx = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trapz (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_x,&__pyx_n_s_dx,&__pyx_n_s_axis,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_float_1_0);
    values[3] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dx);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "trapz") < 0)) __PYX_ERR(0, 12488, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_x = values[1];
    __pyx_v_dx = values[2];
    __pyx_v_axis = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("trapz", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12488, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trapz", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_498trapz(__pyx_self, __pyx_v_y, __pyx_v_x, __pyx_v_dx, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_498trapz(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_y, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_dx, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trapz", 0);

  /* "ga4py/gain/notimplemented.pyx":12546
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12546, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12488
 * 
 * 
 * def trapz(y, x=None, dx=1.0, axis=-1):             # <<<<<<<<<<<<<<
 *     """Integrate along the given axis using the composite trapezoidal rule.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trapz", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12549
 * 
 * 
 * def tri(N, M=None, k=0, dtype=float):             # <<<<<<<<<<<<<<
 *     """An array with ones at and below the given diagonal and zeros elsewhere.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_501tri(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_500tri[] = "An array with ones at and below the given diagonal and zeros elsewhere.\n\n    Parameters\n    ----------\n    N : int\n        Number of rows in the array.\n    M : int, optional\n        Number of columns in the array.\n        By default, `M` is taken equal to `N`.\n    k : int, optional\n        The sub-diagonal at and below which the array is filled.\n        `k` = 0 is the main diagonal, while `k` < 0 is below it,\n        and `k` > 0 is above.  The default is 0.\n    dtype : dtype, optional\n        Data type of the returned array.  The default is float.\n\n    Returns\n    -------\n    T : ndarray of shape (N, M)\n        Array with its lower triangle filled with ones and zero elsewhere;\n        in other words ``T[i,j] == 1`` for ``i <= j + k``, 0 otherwise.\n\n    Examples\n    --------\n    >>> np.tri(3, 5, 2, dtype=int)\n    array([[1, 1, 1, 0, 0],\n           [1, 1, 1, 1, 0],\n           [1, 1, 1, 1, 1]])\n\n    >>> np.tri(3, 5, -1)\n    array([[ 0.,  0.,  0.,  0.,  0.],\n           [ 1.,  0.,  0.,  0.,  0.],\n           [ 1.,  1.,  0.,  0.,  0.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_501tri = {"tri", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_501tri, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_500tri};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_501tri(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_N = 0;
  CYTHON_UNUSED PyObject *__pyx_v_M = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tri (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_N,&__pyx_n_s_M,&__pyx_n_s_k,&__pyx_n_s_dtype,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_int_0);
    values[3] = __pyx_k__16;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_N)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_M);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tri") < 0)) __PYX_ERR(0, 12549, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_N = values[0];
    __pyx_v_M = values[1];
    __pyx_v_k = values[2];
    __pyx_v_dtype = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tri", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12549, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tri", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_500tri(__pyx_self, __pyx_v_N, __pyx_v_M, __pyx_v_k, __pyx_v_dtype);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_500tri(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_N, CYTHON_UNUSED PyObject *__pyx_v_M, CYTHON_UNUSED PyObject *__pyx_v_k, CYTHON_UNUSED PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tri", 0);

  /* "ga4py/gain/notimplemented.pyx":12585
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12585, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12549
 * 
 * 
 * def tri(N, M=None, k=0, dtype=float):             # <<<<<<<<<<<<<<
 *     """An array with ones at and below the given diagonal and zeros elsewhere.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tri", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12588
 * 
 * 
 * def tril(m, k=0):             # <<<<<<<<<<<<<<
 *     """Lower triangle of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_503tril(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_502tril[] = "Lower triangle of an array.\n\n    Return a copy of an array with elements above the `k`-th diagonal zeroed.\n\n    Parameters\n    ----------\n    m : array_like, shape (M, N)\n        Input array.\n    k : int, optional\n        Diagonal above which to zero elements.  `k = 0` (the default) is the\n        main diagonal, `k < 0` is below it and `k > 0` is above.\n\n    Returns\n    -------\n    L : ndarray, shape (M, N)\n        Lower triangle of `m`, of same shape and data-type as `m`.\n\n    See Also\n    --------\n    triu : same thing, only for the upper triangle\n\n    Examples\n    --------\n    >>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 0,  0,  0],\n           [ 4,  0,  0],\n           [ 7,  8,  0],\n           [10, 11, 12]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_503tril = {"tril", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_503tril, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_502tril};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_503tril(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_m,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tril") < 0)) __PYX_ERR(0, 12588, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tril", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12588, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_502tril(__pyx_self, __pyx_v_m, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_502tril(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril", 0);

  /* "ga4py/gain/notimplemented.pyx":12619
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12619, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12588
 * 
 * 
 * def tril(m, k=0):             # <<<<<<<<<<<<<<
 *     """Lower triangle of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12622
 * 
 * 
 * def tril_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of an (n, n) array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_505tril_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_504tril_indices[] = "Return the indices for the lower-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The row dimension of the square arrays for which the returned\n        indices will be valid.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    triu_indices : similar function, for upper-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    tril, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    lower triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> il1 = np.tril_indices(4)\n    >>> il2 = np.tril_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[il1]\n    array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])\n\n    And for assigning values:\n\n    >>> a[il1] = -1\n    >>> a\n    array([[-1,  1,  2,  3],\n           [-1, -1,  6,  7],\n           [-1, -1, -1, 11],\n           [-1, -1, -1, -1]])\n\n    These cover almost the whole array (two diagonals right of the main one):\n\n    >>> a[il2] = -10\n    >>> a\n    array([[-10, -10, -10,   3],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10],\n           [-10, -10, -10, -10]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_505tril_indices = {"tril_indices", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_505tril_indices, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_504tril_indices};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_505tril_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tril_indices") < 0)) __PYX_ERR(0, 12622, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tril_indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12622, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_504tril_indices(__pyx_self, __pyx_v_n, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_504tril_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":12691
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12691, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12622
 * 
 * 
 * def tril_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of an (n, n) array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12694
 * 
 * 
 * def tril_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of arr.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_507tril_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_506tril_indices_from[] = "Return the indices for the lower-triangle of arr.\n\n    See `tril_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array_like\n        The indices will be valid for square arrays whose dimensions are\n        the same as arr.\n    k : int, optional\n        Diagonal offset (see `tril` for details).\n\n    See Also\n    --------\n    tril_indices, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_507tril_indices_from = {"tril_indices_from", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_507tril_indices_from, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_506tril_indices_from};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_507tril_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril_indices_from (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tril_indices_from") < 0)) __PYX_ERR(0, 12694, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tril_indices_from", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12694, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_506tril_indices_from(__pyx_self, __pyx_v_arr, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_506tril_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tril_indices_from", 0);

  /* "ga4py/gain/notimplemented.pyx":12716
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12716, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12694
 * 
 * 
 * def tril_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of arr.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.tril_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12719
 * 
 * 
 * def trim_zeros(filt, trim='fb'):             # <<<<<<<<<<<<<<
 *     """Trim the leading and/or trailing zeros from a 1-D array or sequence.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_509trim_zeros(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_508trim_zeros[] = "Trim the leading and/or trailing zeros from a 1-D array or sequence.\n\n    Parameters\n    ----------\n    filt : 1-D array or sequence\n        Input array.\n    trim : str, optional\n        A string with 'f' representing trim from front and 'b' to trim from\n        back. Default is 'fb', trim zeros from both front and back of the\n        array.\n\n    Returns\n    -------\n    trimmed : 1-D array or sequence\n        The result of trimming the input. The input data type is preserved.\n\n    Examples\n    --------\n    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n    >>> np.trim_zeros(a)\n    array([1, 2, 3, 0, 2, 1])\n\n    >>> np.trim_zeros(a, 'b')\n    array([0, 0, 0, 1, 2, 3, 0, 2, 1])\n\n    The input data type is preserved, list/tuple in means list/tuple out.\n\n    >>> np.trim_zeros([0, 1, 2, 0])\n    [1, 2]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_509trim_zeros = {"trim_zeros", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_509trim_zeros, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_508trim_zeros};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_509trim_zeros(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_filt = 0;
  CYTHON_UNUSED PyObject *__pyx_v_trim = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trim_zeros (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_filt,&__pyx_n_s_trim,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_s_fb);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_filt)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_trim);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "trim_zeros") < 0)) __PYX_ERR(0, 12719, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_filt = values[0];
    __pyx_v_trim = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("trim_zeros", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12719, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trim_zeros", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_508trim_zeros(__pyx_self, __pyx_v_filt, __pyx_v_trim);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_508trim_zeros(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_filt, CYTHON_UNUSED PyObject *__pyx_v_trim) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("trim_zeros", 0);

  /* "ga4py/gain/notimplemented.pyx":12751
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12751, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12719
 * 
 * 
 * def trim_zeros(filt, trim='fb'):             # <<<<<<<<<<<<<<
 *     """Trim the leading and/or trailing zeros from a 1-D array or sequence.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.trim_zeros", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12754
 * 
 * 
 * def triu(m, k=0):             # <<<<<<<<<<<<<<
 *     """Upper triangle of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_511triu(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_510triu[] = "Upper triangle of an array.\n\n    Return a copy of a matrix with the elements below the `k`-th diagonal\n    zeroed.\n\n    Please refer to the documentation for `tril` for further details.\n\n    See Also\n    --------\n    tril : lower triangle of an array\n\n    Examples\n    --------\n    >>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\n    array([[ 1,  2,  3],\n           [ 4,  5,  6],\n           [ 0,  8,  9],\n           [ 0,  0, 12]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_511triu = {"triu", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_511triu, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_510triu};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_511triu(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_m = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_m,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_m)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "triu") < 0)) __PYX_ERR(0, 12754, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_m = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("triu", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12754, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_510triu(__pyx_self, __pyx_v_m, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_510triu(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_m, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu", 0);

  /* "ga4py/gain/notimplemented.pyx":12775
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12775, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12754
 * 
 * 
 * def triu(m, k=0):             # <<<<<<<<<<<<<<
 *     """Upper triangle of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12778
 * 
 * 
 * def triu_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_513triu_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_512triu_indices[] = "Return the indices for the upper-triangle of an (n, n) array.\n\n    Parameters\n    ----------\n    n : int\n        The size of the arrays for which the returned indices will\n        be valid.\n    k : int, optional\n        Diagonal offset (see `triu` for details).\n\n    Returns\n    -------\n    inds : tuple of arrays\n        The indices for the triangle. The returned tuple contains two arrays,\n        each with the indices along one dimension of the array.\n\n    See also\n    --------\n    tril_indices : similar function, for lower-triangular.\n    mask_indices : generic function accepting an arbitrary mask function.\n    triu, tril\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    Compute two different sets of indices to access 4x4 arrays, one for the\n    upper triangular part starting at the main diagonal, and one starting two\n    diagonals further right:\n\n    >>> iu1 = np.triu_indices(4)\n    >>> iu2 = np.triu_indices(4, 2)\n\n    Here is how they can be used with a sample array:\n\n    >>> a = np.arange(16).reshape(4, 4)\n    >>> a\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n\n    Both for indexing:\n\n    >>> a[iu1]\n    array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])\n\n    And for assigning values:\n\n    >>> a[iu1] = -1\n    >>> a\n    array([[-1, -1, -1, -1],\n           [ 4, -1, -1, -1],\n           [ 8,  9, -1, -1],\n           [12, 13, 14, -1]])\n\n    These cover only a small part of the whole array (two diagonals right\n    of the main one):\n\n    >>> a[iu2] = -10\n    >>> a\n    array([[ -1,  -1, -10, -10],\n           [  4,  -1,  -1, -10],\n           [  8,   9,  -1,  -1],\n           [ 12,  13,  14,  -1]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_513triu_indices = {"triu_indices", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_513triu_indices, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_512triu_indices};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_513triu_indices(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_n = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu_indices (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "triu_indices") < 0)) __PYX_ERR(0, 12778, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("triu_indices", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12778, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_512triu_indices(__pyx_self, __pyx_v_n, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_512triu_indices(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_n, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu_indices", 0);

  /* "ga4py/gain/notimplemented.pyx":12848
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12848, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12778
 * 
 * 
 * def triu_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12851
 * 
 * 
 * def triu_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_515triu_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_514triu_indices_from[] = "Return the indices for the upper-triangle of an (n, n) array.\n\n    See `triu_indices` for full details.\n\n    Parameters\n    ----------\n    arr : array_like\n        The indices will be valid for square arrays whose dimensions are\n        the same as arr.\n    k : int, optional\n      Diagonal offset (see `triu` for details).\n\n    See Also\n    --------\n    triu_indices, triu\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_515triu_indices_from = {"triu_indices_from", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_515triu_indices_from, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_514triu_indices_from};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_515triu_indices_from(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_arr = 0;
  CYTHON_UNUSED PyObject *__pyx_v_k = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu_indices_from (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_k,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_k);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "triu_indices_from") < 0)) __PYX_ERR(0, 12851, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_k = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("triu_indices_from", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12851, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_514triu_indices_from(__pyx_self, __pyx_v_arr, __pyx_v_k);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_514triu_indices_from(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_arr, CYTHON_UNUSED PyObject *__pyx_v_k) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("triu_indices_from", 0);

  /* "ga4py/gain/notimplemented.pyx":12873
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12873, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12851
 * 
 * 
 * def triu_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.triu_indices_from", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12876
 * 
 * 
 * def typename(char_):             # <<<<<<<<<<<<<<
 *     """Return a description for the given data type code.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_517typename(PyObject *__pyx_self, PyObject *__pyx_v_char_); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_516typename[] = "Return a description for the given data type code.\n\n    Parameters\n    ----------\n    char : str\n        Data type code.\n\n    Returns\n    -------\n    out : str\n        Description of the input data type code.\n\n    See Also\n    --------\n    dtype, typecodes\n\n    Examples\n    --------\n    >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n    ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n    >>> for typechar in typechars:\n    ...     print typechar, ' : ', np.typename(typechar)\n    ...\n    S1  :  character\n    ?  :  bool\n    B  :  unsigned char\n    D  :  complex double precision\n    G  :  complex long double precision\n    F  :  complex single precision\n    I  :  unsigned integer\n    H  :  unsigned short\n    L  :  unsigned long integer\n    O  :  object\n    Q  :  unsigned long long integer\n    S  :  string\n    U  :  unicode\n    V  :  void\n    b  :  signed char\n    d  :  double precision\n    g  :  long precision\n    f  :  single precision\n    i  :  integer\n    h  :  short\n    l  :  long integer\n    q  :  long long integer\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_517typename = {"typename", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_517typename, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_516typename};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_517typename(PyObject *__pyx_self, PyObject *__pyx_v_char_) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("typename (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_516typename(__pyx_self, ((PyObject *)__pyx_v_char_));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_516typename(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_char_) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("typename", 0);

  /* "ga4py/gain/notimplemented.pyx":12924
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12924, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12876
 * 
 * 
 * def typename(char_):             # <<<<<<<<<<<<<<
 *     """Return a description for the given data type code.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.typename", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12927
 * 
 * 
 * def union1d(ar1, ar2):             # <<<<<<<<<<<<<<
 *     """Find the union of two arrays.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_519union1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_518union1d[] = "Find the union of two arrays.\n\n    Return the unique, sorted array of values that are in either of the two\n    input arrays.\n\n    Parameters\n    ----------\n    ar1, ar2 : array_like\n        Input arrays. They are flattened if they are not already 1D.\n\n    Returns\n    -------\n    union : ndarray\n        Unique, sorted union of the input arrays.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.union1d([-1, 0, 1], [-2, 0, 2])\n    array([-2, -1,  0,  1,  2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_519union1d = {"union1d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_519union1d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_518union1d};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_519union1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar1 = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ar2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("union1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ar1,&__pyx_n_s_ar2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("union1d", 1, 2, 2, 1); __PYX_ERR(0, 12927, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "union1d") < 0)) __PYX_ERR(0, 12927, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("union1d", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12927, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.union1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_518union1d(__pyx_self, __pyx_v_ar1, __pyx_v_ar2);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_518union1d(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar1, CYTHON_UNUSED PyObject *__pyx_v_ar2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("union1d", 0);

  /* "ga4py/gain/notimplemented.pyx":12954
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 12954, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12927
 * 
 * 
 * def union1d(ar1, ar2):             # <<<<<<<<<<<<<<
 *     """Find the union of two arrays.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.union1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":12957
 * 
 * 
 * def unique(ar, return_index=False, return_inverse=False):             # <<<<<<<<<<<<<<
 *     """Find the unique elements of an array.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_521unique(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_520unique[] = "Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. There are two optional\n    outputs in addition to the unique elements: the indices of the input array\n    that give the unique values, and the indices of the unique array that\n    reconstruct the input array.\n\n    Parameters\n    ----------\n    ar : array_like\n        Input array. This will be flattened if it is not already 1-D.\n    return_index : bool, optional\n        If True, also return the indices of `ar` that result in the unique\n        array.\n    return_inverse : bool, optional\n        If True, also return the indices of the unique array that can be used\n        to reconstruct `ar`.\n\n    Returns\n    -------\n    unique : ndarray\n        The sorted unique values.\n    unique_indices : ndarray, optional\n        The indices of the unique values in the (flattened) original array.\n        Only provided if `return_index` is True.\n    unique_inverse : ndarray, optional\n        The indices to reconstruct the (flattened) original array from the\n        unique array. Only provided if `return_inverse` is True.\n\n    See Also\n    --------\n    numpy.lib.arraysetops : Module with a number of other functions for\n                            performing set operations on arrays.\n\n    Examples\n    --------\n    >>> np.unique([1, 1, 2, 2, 3, 3])\n    array([1, 2, 3])\n    >>> a = np.array([[1, 1], [2, 3]])\n    >>> np.unique(a)\n    array([1, 2, 3])\n\n    Return the indices of the original array that give the unique values:\n\n    >>> a = np.array(['a', 'b', 'b', 'c', 'a'])\n    >>> u, indices = np.unique(a, return_index=True)\n    >>> u\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n    >>> indices\n    array([0, 1, 3])\n    >>> a[indices]\n    array(['a', 'b', 'c'],\n           dtype='|S1')\n\n    Reconstruct the input array from the unique values:\n\n    >>> a = np.array([1, 2, 6, 4, 2, 3, 2])\n    >>> u, indices = np.unique(a, return_inverse=True"")\n    >>> u\n    array([1, 2, 3, 4, 6])\n    >>> indices\n    array([0, 1, 4, 3, 1, 2, 1])\n    >>> u[indices]\n    array([1, 2, 6, 4, 2, 3, 2])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_521unique = {"unique", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_521unique, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_520unique};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_521unique(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ar = 0;
  CYTHON_UNUSED PyObject *__pyx_v_return_index = 0;
  CYTHON_UNUSED PyObject *__pyx_v_return_inverse = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unique (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ar,&__pyx_n_s_return_index,&__pyx_n_s_return_inverse,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_index);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_inverse);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unique") < 0)) __PYX_ERR(0, 12957, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar = values[0];
    __pyx_v_return_index = values[1];
    __pyx_v_return_inverse = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unique", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 12957, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unique", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_520unique(__pyx_self, __pyx_v_ar, __pyx_v_return_index, __pyx_v_return_inverse);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_520unique(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ar, CYTHON_UNUSED PyObject *__pyx_v_return_index, CYTHON_UNUSED PyObject *__pyx_v_return_inverse) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unique", 0);

  /* "ga4py/gain/notimplemented.pyx":13025
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13025, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12957
 * 
 * 
 * def unique(ar, return_index=False, return_inverse=False):             # <<<<<<<<<<<<<<
 *     """Find the unique elements of an array.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unique", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13028
 * 
 * 
 * def unpackbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """unpackbits(myarray, axis=None)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_523unpackbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_522unpackbits[] = "unpackbits(myarray, axis=None)\n\n    Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of `myarray` represents a bit-field that should be unpacked\n    into a binary-valued output array. The shape of the output array is either\n    1-D (if `axis` is None) or the same shape as the input array with unpacking\n    done along the axis specified.\n\n    Parameters\n    ----------\n    myarray : ndarray, uint8 type\n       Input array.\n    axis : int, optional\n       Unpacks along this axis.\n\n    Returns\n    -------\n    unpacked : ndarray, uint8 type\n       The elements are binary-valued (0 or 1).\n\n    See Also\n    --------\n    packbits : Packs the elements of a binary-valued array into bits in a uint8\n               array.\n\n    Examples\n    --------\n    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)\n    >>> a\n    array([[ 2],\n           [ 7],\n           [23]], dtype=uint8)\n    >>> b = np.unpackbits(a, axis=1)\n    >>> b\n    array([[0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_523unpackbits = {"unpackbits", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_523unpackbits, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_522unpackbits};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_523unpackbits(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_myarray = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unpackbits (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_myarray,&__pyx_n_s_axis,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_myarray)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unpackbits") < 0)) __PYX_ERR(0, 13028, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_myarray = values[0];
    __pyx_v_axis = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unpackbits", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13028, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unpackbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_522unpackbits(__pyx_self, __pyx_v_myarray, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_522unpackbits(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_myarray, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unpackbits", 0);

  /* "ga4py/gain/notimplemented.pyx":13070
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13070, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13028
 * 
 * 
 * def unpackbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """unpackbits(myarray, axis=None)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unpackbits", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13073
 * 
 * 
 * def unravel_index(indices, dims, order='C'):             # <<<<<<<<<<<<<<
 *     """unravel_index(indices, dims, order='C')
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_525unravel_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_524unravel_index[] = "unravel_index(indices, dims, order='C')\n\n    Converts a flat index or array of flat indices into a tuple\n    of coordinate arrays.\n\n    Parameters\n    ----------\n    indices : array_like\n        An integer array whose elements are indices into the flattened\n        version of an array of dimensions ``dims``. Before version 1.6.0,\n        this function accepted just one index value.\n    dims : tuple of ints\n        The shape of the array to use for unraveling ``indices``.\n    order : {'C', 'F'}, optional\n        .. versionadded:: 1.6.0\n\n        Determines whether the indices should be viewed as indexing in\n        C (row-major) order or FORTRAN (column-major) order.\n\n    Returns\n    -------\n    unraveled_coords : tuple of ndarray\n        Each array in the tuple has the same shape as the ``indices``\n        array.\n\n    See Also\n    --------\n    ravel_multi_index\n\n    Examples\n    --------\n    >>> np.unravel_index([22, 41, 37], (7,6))\n    (array([3, 6, 6]), array([4, 5, 1]))\n    >>> np.unravel_index([31, 41, 13], (7,6), order='F')\n    (array([3, 6, 6]), array([4, 5, 1]))\n\n    >>> np.unravel_index(1621, (6,7,8,9))\n    (3, 1, 4, 1)\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_525unravel_index = {"unravel_index", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_525unravel_index, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_524unravel_index};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_525unravel_index(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_indices = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dims = 0;
  CYTHON_UNUSED PyObject *__pyx_v_order = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unravel_index (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_indices,&__pyx_n_s_dims,&__pyx_n_s_order,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_s_C);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_indices)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dims)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("unravel_index", 0, 2, 3, 1); __PYX_ERR(0, 13073, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unravel_index") < 0)) __PYX_ERR(0, 13073, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_indices = values[0];
    __pyx_v_dims = values[1];
    __pyx_v_order = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unravel_index", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13073, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unravel_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_524unravel_index(__pyx_self, __pyx_v_indices, __pyx_v_dims, __pyx_v_order);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_524unravel_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_indices, CYTHON_UNUSED PyObject *__pyx_v_dims, CYTHON_UNUSED PyObject *__pyx_v_order) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unravel_index", 0);

  /* "ga4py/gain/notimplemented.pyx":13115
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13115, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13073
 * 
 * 
 * def unravel_index(indices, dims, order='C'):             # <<<<<<<<<<<<<<
 *     """unravel_index(indices, dims, order='C')
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unravel_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13118
 * 
 * 
 * def unwrap(p, discont=3.14159265359, axis=-1):             # <<<<<<<<<<<<<<
 *     """Unwrap by changing deltas between values to 2*pi complement.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_527unwrap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_526unwrap[] = "Unwrap by changing deltas between values to 2*pi complement.\n\n    Unwrap radian phase `p` by changing absolute jumps greater than\n    `discont` to their 2*pi complement along the given axis.\n\n    Parameters\n    ----------\n    p : array_like\n        Input array.\n    discont : float, optional\n        Maximum discontinuity between values, default is ``pi``.\n    axis : int, optional\n        Axis along which unwrap will operate, default is the last axis.\n\n    Returns\n    -------\n    out : ndarray\n        Output array.\n\n    See Also\n    --------\n    rad2deg, deg2rad\n\n    Notes\n    -----\n    If the discontinuity in `p` is smaller than ``pi``, but larger than\n    `discont`, no unwrapping is done because taking the 2*pi complement\n    would only make the discontinuity larger.\n\n    Examples\n    --------\n    >>> phase = np.linspace(0, np.pi, num=5)\n    >>> phase[3:] += np.pi\n    >>> phase\n    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])\n    >>> np.unwrap(phase)\n    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_527unwrap = {"unwrap", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_527unwrap, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_526unwrap};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_527unwrap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_p = 0;
  CYTHON_UNUSED PyObject *__pyx_v_discont = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unwrap (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_p,&__pyx_n_s_discont,&__pyx_n_s_axis,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_float_3_14159265359);
    values[2] = ((PyObject *)__pyx_int_neg_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_p)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_discont);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "unwrap") < 0)) __PYX_ERR(0, 13118, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_p = values[0];
    __pyx_v_discont = values[1];
    __pyx_v_axis = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("unwrap", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13118, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unwrap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_526unwrap(__pyx_self, __pyx_v_p, __pyx_v_discont, __pyx_v_axis);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_526unwrap(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_p, CYTHON_UNUSED PyObject *__pyx_v_discont, CYTHON_UNUSED PyObject *__pyx_v_axis) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("unwrap", 0);

  /* "ga4py/gain/notimplemented.pyx":13158
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13158, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13118
 * 
 * 
 * def unwrap(p, discont=3.14159265359, axis=-1):             # <<<<<<<<<<<<<<
 *     """Unwrap by changing deltas between values to 2*pi complement.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.unwrap", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13161
 * 
 * 
 * def vander(x, N=None):             # <<<<<<<<<<<<<<
 *     """Generate a Van der Monde matrix.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_529vander(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_528vander[] = "Generate a Van der Monde matrix.\n\n    The columns of the output matrix are decreasing powers of the input\n    vector.  Specifically, the `i`-th output column is the input vector\n    raised element-wise to the power of ``N - i - 1``.  Such a matrix with\n    a geometric progression in each row is named for Alexandre-Theophile\n    Vandermonde.\n\n    Parameters\n    ----------\n    x : array_like\n        1-D input array.\n    N : int, optional\n        Order of (number of columns in) the output.  If `N` is not specified,\n        a square array is returned (``N = len(x)``).\n\n    Returns\n    -------\n    out : ndarray\n        Van der Monde matrix of order `N`.  The first column is ``x^(N-1)``,\n        the second ``x^(N-2)`` and so forth.\n\n    Examples\n    --------\n    >>> x = np.array([1, 2, 3, 5])\n    >>> N = 3\n    >>> np.vander(x, N)\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> np.column_stack([x**(N-1-i) for i in range(N)])\n    array([[ 1,  1,  1],\n           [ 4,  2,  1],\n           [ 9,  3,  1],\n           [25,  5,  1]])\n\n    >>> x = np.array([1, 2, 3, 5])\n    >>> np.vander(x)\n    array([[  1,   1,   1,   1],\n           [  8,   4,   2,   1],\n           [ 27,   9,   3,   1],\n           [125,  25,   5,   1]])\n\n    The determinant of a square Vandermonde matrix is the product\n    of the differences between the values of the input vector:\n\n    >>> np.linalg.det(np.vander(x))\n    48.000000000000043\n    >>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n    48\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_529vander = {"vander", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_529vander, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_528vander};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_529vander(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_x = 0;
  CYTHON_UNUSED PyObject *__pyx_v_N = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vander (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_N,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_N);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "vander") < 0)) __PYX_ERR(0, 13161, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_x = values[0];
    __pyx_v_N = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("vander", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13161, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vander", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_528vander(__pyx_self, __pyx_v_x, __pyx_v_N);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_528vander(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_x, CYTHON_UNUSED PyObject *__pyx_v_N) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vander", 0);

  /* "ga4py/gain/notimplemented.pyx":13216
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13216, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13161
 * 
 * 
 * def vander(x, N=None):             # <<<<<<<<<<<<<<
 *     """Generate a Van der Monde matrix.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vander", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13219
 * 
 * 
 * def var(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the variance along the specified axis.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_531var(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_530var[] = "Compute the variance along the specified axis.\n\n    Returns the variance of the array elements, a measure of the spread of a\n    distribution.  The variance is computed for the flattened array by\n    default, otherwise over the specified axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose variance is desired.  If `a` is not an\n        array, a conversion is attempted.\n    axis : int, optional\n        Axis along which the variance is computed.  The default is to compute\n        the variance of the flattened array.\n    dtype : data-type, optional\n        Type to use in computing the variance.  For arrays of integer type\n        the default is `float32`; for arrays of float types it is the same as\n        the array type.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  It must have\n        the same shape as the expected output, but the type is cast if\n        necessary.\n    ddof : int, optional\n        \"Delta Degrees of Freedom\": the divisor used in the calculation is\n        ``N - ddof``, where ``N`` represents the number of elements. By\n        default `ddof` is zero.\n\n    Returns\n    -------\n    variance : ndarray, see dtype parameter above\n        If ``out=None``, returns a new array containing the variance;\n        otherwise, a reference to the output array is returned.\n\n    See Also\n    --------\n    std : Standard deviation\n    mean : Average\n    numpy.doc.ufuncs : Section \"Output arguments\"\n\n    Notes\n    -----\n    The variance is the average of the squared deviations from the mean,\n    i.e.,  ``var = mean(abs(x - x.mean())**2)``.\n\n    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.\n    If, however, `ddof` is specified, the divisor ``N - ddof`` is used\n    instead.  In standard statistical practice, ``ddof=1`` provides an\n    unbiased estimator of the variance of a hypothetical infinite population.\n    ""``ddof=0`` provides a maximum likelihood estimate of the variance for\n    normally distributed variables.\n\n    Note that for complex numbers, the absolute value is taken before\n    squaring, so that the result is always real and nonnegative.\n\n    For floating-point input, the variance is computed using the same\n    precision the input has.  Depending on the input data, this can cause\n    the results to be inaccurate, especially for `float32` (see example\n    below).  Specifying a higher-accuracy accumulator using the ``dtype``\n    keyword can alleviate this issue.\n\n    Examples\n    --------\n    >>> a = np.array([[1,2],[3,4]])\n    >>> np.var(a)\n    1.25\n    >>> np.var(a,0)\n    array([ 1.,  1.])\n    >>> np.var(a,1)\n    array([ 0.25,  0.25])\n\n    In single precision, var() can be inaccurate:\n\n    >>> a = np.zeros((2,512*512), dtype=np.float32)\n    >>> a[0,:] = 1.0\n    >>> a[1,:] = 0.1\n    >>> np.var(a)\n    0.20405951142311096\n\n    Computing the standard deviation in float64 is more accurate:\n\n    >>> np.var(a, dtype=np.float64)\n    0.20249999932997387\n    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2\n    0.20250000000000001\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_531var = {"var", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_531var, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_530var};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_531var(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_a = 0;
  CYTHON_UNUSED PyObject *__pyx_v_axis = 0;
  CYTHON_UNUSED PyObject *__pyx_v_dtype = 0;
  CYTHON_UNUSED PyObject *__pyx_v_out = 0;
  CYTHON_UNUSED PyObject *__pyx_v_ddof = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("var (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_a,&__pyx_n_s_axis,&__pyx_n_s_dtype,&__pyx_n_s_out,&__pyx_n_s_ddof,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_int_0);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_a)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_axis);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_out);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ddof);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "var") < 0)) __PYX_ERR(0, 13219, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_a = values[0];
    __pyx_v_axis = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_out = values[3];
    __pyx_v_ddof = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("var", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13219, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.var", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_530var(__pyx_self, __pyx_v_a, __pyx_v_axis, __pyx_v_dtype, __pyx_v_out, __pyx_v_ddof);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_530var(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_a, CYTHON_UNUSED PyObject *__pyx_v_axis, CYTHON_UNUSED PyObject *__pyx_v_dtype, CYTHON_UNUSED PyObject *__pyx_v_out, CYTHON_UNUSED PyObject *__pyx_v_ddof) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("var", 0);

  /* "ga4py/gain/notimplemented.pyx":13306
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13306, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13219
 * 
 * 
 * def var(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the variance along the specified axis.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.var", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13309
 * 
 * 
 * def vdot():             # <<<<<<<<<<<<<<
 *     """Return the dot product of two vectors.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_533vdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_532vdot[] = "Return the dot product of two vectors.\n\n    The vdot(`a`, `b`) function handles complex numbers differently than\n    dot(`a`, `b`).  If the first argument is complex the complex conjugate\n    of the first argument is used for the calculation of the dot product.\n\n    Note that `vdot` handles multidimensional arrays differently than `dot`:\n    it does *not* perform a matrix product, but flattens input arguments\n    to 1-D vectors first. Consequently, it should only be used for vectors.\n\n    Parameters\n    ----------\n    a : array_like\n        If `a` is complex the complex conjugate is taken before calculation\n        of the dot product.\n    b : array_like\n        Second argument to the dot product.\n\n    Returns\n    -------\n    output : ndarray\n        Dot product of `a` and `b`.  Can be an int, float, or\n        complex depending on the types of `a` and `b`.\n\n    See Also\n    --------\n    dot : Return the dot product without using the complex conjugate of the\n          first argument.\n\n    Examples\n    --------\n    >>> a = np.array([1+2j,3+4j])\n    >>> b = np.array([5+6j,7+8j])\n    >>> np.vdot(a, b)\n    (70-8j)\n    >>> np.vdot(b, a)\n    (70+8j)\n\n    Note that higher-dimensional arrays are flattened!\n\n    >>> a = np.array([[1, 4], [5, 6]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.vdot(a, b)\n    30\n    >>> np.vdot(b, a)\n    30\n    >>> 1*4 + 4*1 + 5*2 + 6*2\n    30\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_533vdot = {"vdot", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_533vdot, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_532vdot};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_533vdot(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vdot (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_532vdot(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_532vdot(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vdot", 0);

  /* "ga4py/gain/notimplemented.pyx":13361
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13361, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13309
 * 
 * 
 * def vdot():             # <<<<<<<<<<<<<<
 *     """Return the dot product of two vectors.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vdot", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13364
 * 
 * 
 * def vsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays vertically (row-wise).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_535vsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_534vsplit[] = "Split an array into multiple sub-arrays vertically (row-wise).\n\n    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent\n    to ``split`` with `axis=0` (default), the array is always split along the\n    first axis regardless of the array dimension.\n\n    See Also\n    --------\n    split : Split an array into multiple sub-arrays of equal size.\n\n    Examples\n    --------\n    >>> x = np.arange(16.0).reshape(4, 4)\n    >>> x\n    array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])\n    >>> np.vsplit(x, 2)\n    [array([[ 0.,  1.,  2.,  3.],\n           [ 4.,  5.,  6.,  7.]]),\n     array([[  8.,   9.,  10.,  11.],\n           [ 12.,  13.,  14.,  15.]])]\n    >>> np.vsplit(x, np.array([3, 6]))\n    [array([[  0.,   1.,   2.,   3.],\n           [  4.,   5.,   6.,   7.],\n           [  8.,   9.,  10.,  11.]]),\n     array([[ 12.,  13.,  14.,  15.]]),\n     array([], dtype=float64)]\n\n    With a higher dimensional array the split is still along the first axis.\n\n    >>> x = np.arange(8.0).reshape(2, 2, 2)\n    >>> x\n    array([[[ 0.,  1.],\n            [ 2.,  3.]],\n           [[ 4.,  5.],\n            [ 6.,  7.]]])\n    >>> np.vsplit(x, 2)\n    [array([[[ 0.,  1.],\n            [ 2.,  3.]]]),\n     array([[[ 4.,  5.],\n            [ 6.,  7.]]])]\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_535vsplit = {"vsplit", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_535vsplit, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_534vsplit};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_535vsplit(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_ary = 0;
  CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vsplit (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ary,&__pyx_n_s_indices_or_sections,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ary)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_indices_or_sections)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("vsplit", 1, 2, 2, 1); __PYX_ERR(0, 13364, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "vsplit") < 0)) __PYX_ERR(0, 13364, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_ary = values[0];
    __pyx_v_indices_or_sections = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("vsplit", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13364, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_534vsplit(__pyx_self, __pyx_v_ary, __pyx_v_indices_or_sections);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_534vsplit(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_ary, CYTHON_UNUSED PyObject *__pyx_v_indices_or_sections) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vsplit", 0);

  /* "ga4py/gain/notimplemented.pyx":13410
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13410, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13364
 * 
 * 
 * def vsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays vertically (row-wise).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vsplit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13413
 * 
 * 
 * def vstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_537vstack(PyObject *__pyx_self, PyObject *__pyx_v_tup); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_536vstack[] = "Stack arrays in sequence vertically (row wise).\n\n    Take a sequence of arrays and stack them vertically to make a single\n    array. Rebuild arrays divided by `vsplit`.\n\n    Parameters\n    ----------\n    tup : sequence of ndarrays\n        Tuple containing arrays to be stacked. The arrays must have the same\n        shape along all but the first axis.\n\n    Returns\n    -------\n    stacked : ndarray\n        The array formed by stacking the given arrays.\n\n    See Also\n    --------\n    hstack : Stack arrays in sequence horizontally (column wise).\n    dstack : Stack arrays in sequence depth wise (along third dimension).\n    concatenate : Join a sequence of arrays together.\n    vsplit : Split array into a list of multiple sub-arrays vertically.\n\n\n    Notes\n    -----\n    Equivalent to ``np.concatenate(tup, axis=0)``\n\n    Examples\n    --------\n    >>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a,b))\n    array([[1, 2, 3],\n           [2, 3, 4]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a,b))\n    array([[1],\n           [2],\n           [3],\n           [2],\n           [3],\n           [4]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_537vstack = {"vstack", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_537vstack, METH_O, __pyx_doc_5ga4py_4gain_14notimplemented_536vstack};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_537vstack(PyObject *__pyx_self, PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vstack (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_536vstack(__pyx_self, ((PyObject *)__pyx_v_tup));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_536vstack(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_tup) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("vstack", 0);

  /* "ga4py/gain/notimplemented.pyx":13461
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13461, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13413
 * 
 * 
 * def vstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.vstack", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13464
 * 
 * 
 * def where():             # <<<<<<<<<<<<<<
 *     """where(condition, [x, y])
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_539where(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_538where[] = "where(condition, [x, y])\n\n    Return elements, either from `x` or `y`, depending on `condition`.\n\n    If only `condition` is given, return ``condition.nonzero()``.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        When True, yield `x`, otherwise yield `y`.\n    x, y : array_like, optional\n        Values from which to choose. `x` and `y` need to have the same\n        shape as `condition`.\n\n    Returns\n    -------\n    out : ndarray or tuple of ndarrays\n        If both `x` and `y` are specified, the output array contains\n        elements of `x` where `condition` is True, and elements from\n        `y` elsewhere.\n\n        If only `condition` is given, return the tuple\n        ``condition.nonzero()``, the indices where `condition` is True.\n\n    See Also\n    --------\n    nonzero, choose\n\n    Notes\n    -----\n    If `x` and `y` are given and input arrays are 1-D, `where` is\n    equivalent to::\n\n        [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]\n\n    Examples\n    --------\n    >>> np.where([[True, False], [True, True]],\n    ...          [[1, 2], [3, 4]],\n    ...          [[9, 8], [7, 6]])\n    array([[1, 8],\n           [3, 4]])\n\n    >>> np.where([[0, 1], [1, 0]])\n    (array([0, 1]), array([1, 0]))\n\n    >>> x = np.arange(9.).reshape(3, 3)\n    >>> np.where( x > 5 )\n    (array([2, 2, 2]), array([0, 1, 2]))\n    >>> x[np.where( x > 3.0 )]               # Note: result is 1D.\n    array([ 4.,  5.,  6.,  7.,  8.])\n    >>> np.where(x < 5, x, -1)               # Note: broadcasting.\n    array([[ 0.,  1.,  2.],\n           [ 3.,  4., -1.],\n           [-1., -1., -1.]])\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_539where = {"where", (PyCFunction)__pyx_pw_5ga4py_4gain_14notimplemented_539where, METH_NOARGS, __pyx_doc_5ga4py_4gain_14notimplemented_538where};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_539where(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("where (wrapper)", 0);
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_538where(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_538where(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("where", 0);

  /* "ga4py/gain/notimplemented.pyx":13523
 *     """
 *     # BUILTIN
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13523, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13464
 * 
 * 
 * def where():             # <<<<<<<<<<<<<<
 *     """where(condition, [x, y])
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.where", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "ga4py/gain/notimplemented.pyx":13526
 * 
 * 
 * def who(vardict=None):             # <<<<<<<<<<<<<<
 *     """Print the Numpy arrays in the given dictionary.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_541who(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5ga4py_4gain_14notimplemented_540who[] = "Print the Numpy arrays in the given dictionary.\n\n    If there is no dictionary passed in or `vardict` is None then returns\n    Numpy arrays in the globals() dictionary (all Numpy arrays in the\n    namespace).\n\n    Parameters\n    ----------\n    vardict : dict, optional\n        A dictionary possibly containing ndarrays.  Default is globals().\n\n    Returns\n    -------\n    out : None\n        Returns 'None'.\n\n    Notes\n    -----\n    Prints out the name, shape, bytes and type of all of the ndarrays present\n    in `vardict`.\n\n    Examples\n    --------\n    >>> a = np.arange(10)\n    >>> b = np.ones(20)\n    >>> np.who()\n    Name            Shape            Bytes            Type\n    ===========================================================\n    a               10               40               int32\n    b               20               160              float64\n    Upper bound on total bytes  =       200\n\n    >>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n    ... 'idx':5}\n    >>> np.who(d)\n    Name            Shape            Bytes            Type\n    ===========================================================\n    y               3                24               float64\n    x               2                16               float64\n    Upper bound on total bytes  =       40\n    \n    ";
static PyMethodDef __pyx_mdef_5ga4py_4gain_14notimplemented_541who = {"who", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5ga4py_4gain_14notimplemented_541who, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5ga4py_4gain_14notimplemented_540who};
static PyObject *__pyx_pw_5ga4py_4gain_14notimplemented_541who(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_vardict = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("who (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_vardict,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_vardict);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "who") < 0)) __PYX_ERR(0, 13526, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_vardict = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("who", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 13526, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.who", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5ga4py_4gain_14notimplemented_540who(__pyx_self, __pyx_v_vardict);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5ga4py_4gain_14notimplemented_540who(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_vardict) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("who", 0);

  /* "ga4py/gain/notimplemented.pyx":13569
 * 
 *     """
 *     raise NotImplementedError             # <<<<<<<<<<<<<<
 * 
 */
  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);
  __PYX_ERR(0, 13569, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13526
 * 
 * 
 * def who(vardict=None):             # <<<<<<<<<<<<<<
 *     """Print the Numpy arrays in the given dictionary.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("ga4py.gain.notimplemented.who", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":258
 *         # experimental exception made for __getbuffer__ and __releasebuffer__
 *         # -- the details of this may change.
 *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fulfill the PEP.
 */

/* Python wrapper */
static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5numpy_7ndarray___getbuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_v_i;
  int __pyx_v_ndim;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  int __pyx_v_t;
  char *__pyx_v_f;
  PyArray_Descr *__pyx_v_descr = 0;
  int __pyx_v_offset;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  PyArray_Descr *__pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  char *__pyx_t_9;
  if (__pyx_v_info == NULL) {
    PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
    return -1;
  }
  __Pyx_RefNannySetupContext("__getbuffer__", 0);
  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(__pyx_v_info->obj);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":265
 * 
 *             cdef int i, ndim
 *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 */
  __pyx_v_endian_detector = 1;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":266
 *             cdef int i, ndim
 *             cdef int endian_detector = 1
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 * 
 *             ndim = PyArray_NDIM(self)
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":268
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 */
  __pyx_v_ndim = PyArray_NDIM(__pyx_v_self);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":270
 *             ndim = PyArray_NDIM(self)
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")
 */
  __pyx_t_2 = (((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS) != 0);
  if (__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":271
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 */
  __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_ARRAY_C_CONTIGUOUS) != 0)) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":270
 *             ndim = PyArray_NDIM(self)
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")
 */
  if (unlikely(__pyx_t_1)) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":272
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 272, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(1, 272, __pyx_L1_error)

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":270
 *             ndim = PyArray_NDIM(self)
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")
 */
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":274
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 */
  __pyx_t_2 = (((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS) != 0);
  if (__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L7_bool_binop_done;
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":275
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 */
  __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_ARRAY_F_CONTIGUOUS) != 0)) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L7_bool_binop_done:;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":274
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 */
  if (unlikely(__pyx_t_1)) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":276
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
 * 
 *             info.buf = PyArray_DATA(self)
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 276, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(1, 276, __pyx_L1_error)

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":274
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 */
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":278
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
 *             info.ndim = ndim
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_v_info->buf = PyArray_DATA(__pyx_v_self);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":279
 * 
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim             # <<<<<<<<<<<<<<
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 # Allocate new buffer for strides and shape info.
 */
  __pyx_v_info->ndim = __pyx_v_ndim;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":280
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 # Allocate new buffer for strides and shape info.
 *                 # This is allocated as one block, strides first.
 */
  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
  if (__pyx_t_1) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":283
 *                 # Allocate new buffer for strides and shape info.
 *                 # This is allocated as one block, strides first.
 *                 info.strides = <Py_ssize_t*>PyObject_Malloc(sizeof(Py_ssize_t) * 2 * <size_t>ndim)             # <<<<<<<<<<<<<<
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 */
    __pyx_v_info->strides = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * 2) * ((size_t)__pyx_v_ndim))));

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":284
 *                 # This is allocated as one block, strides first.
 *                 info.strides = <Py_ssize_t*>PyObject_Malloc(sizeof(Py_ssize_t) * 2 * <size_t>ndim)
 *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 */
    __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":285
 *                 info.strides = <Py_ssize_t*>PyObject_Malloc(sizeof(Py_ssize_t) * 2 * <size_t>ndim)
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):             # <<<<<<<<<<<<<<
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 */
    __pyx_t_4 = __pyx_v_ndim;
    __pyx_t_5 = __pyx_t_4;
    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
      __pyx_v_i = __pyx_t_6;

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":286
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 */
      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(__pyx_v_self)[__pyx_v_i]);

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":287
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 */
      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(__pyx_v_self)[__pyx_v_i]);
    }

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":280
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 # Allocate new buffer for strides and shape info.
 *                 # This is allocated as one block, strides first.
 */
    goto __pyx_L9;
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":289
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 */
  /*else*/ {
    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(__pyx_v_self));

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":290
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 */
    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(__pyx_v_self));
  }
  __pyx_L9:;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":291
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 */
  __pyx_v_info->suboffsets = NULL;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":292
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 * 
 */
  __pyx_v_info->itemsize = PyArray_ITEMSIZE(__pyx_v_self);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":293
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
 * 
 *             cdef int t
 */
  __pyx_v_info->readonly = (!(PyArray_ISWRITEABLE(__pyx_v_self) != 0));

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":296
 * 
 *             cdef int t
 *             cdef char* f = NULL             # <<<<<<<<<<<<<<
 *             cdef dtype descr = <dtype>PyArray_DESCR(self)
 *             cdef int offset
 */
  __pyx_v_f = NULL;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":297
 *             cdef int t
 *             cdef char* f = NULL
 *             cdef dtype descr = <dtype>PyArray_DESCR(self)             # <<<<<<<<<<<<<<
 *             cdef int offset
 * 
 */
  __pyx_t_7 = PyArray_DESCR(__pyx_v_self);
  __pyx_t_3 = ((PyObject *)__pyx_t_7);
  __Pyx_INCREF(__pyx_t_3);
  __pyx_v_descr = ((PyArray_Descr *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":300
 *             cdef int offset
 * 
 *             info.obj = self             # <<<<<<<<<<<<<<
 * 
 *             if not PyDataType_HASFIELDS(descr):
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __Pyx_GOTREF(__pyx_v_info->obj);
  __Pyx_DECREF(__pyx_v_info->obj);
  __pyx_v_info->obj = ((PyObject *)__pyx_v_self);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":302
 *             info.obj = self
 * 
 *             if not PyDataType_HASFIELDS(descr):             # <<<<<<<<<<<<<<
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or
 */
  __pyx_t_1 = ((!(PyDataType_HASFIELDS(__pyx_v_descr) != 0)) != 0);
  if (__pyx_t_1) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":303
 * 
 *             if not PyDataType_HASFIELDS(descr):
 *                 t = descr.type_num             # <<<<<<<<<<<<<<
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 */
    __pyx_t_4 = __pyx_v_descr->type_num;
    __pyx_v_t = __pyx_t_4;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":304
 *             if not PyDataType_HASFIELDS(descr):
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_2 = ((__pyx_v_descr->byteorder == '>') != 0);
    if (!__pyx_t_2) {
      goto __pyx_L15_next_or;
    } else {
    }
    __pyx_t_2 = (__pyx_v_little_endian != 0);
    if (!__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L14_bool_binop_done;
    }
    __pyx_L15_next_or:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":305
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 */
    __pyx_t_2 = ((__pyx_v_descr->byteorder == '<') != 0);
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L14_bool_binop_done;
    }
    __pyx_t_2 = ((!(__pyx_v_little_endian != 0)) != 0);
    __pyx_t_1 = __pyx_t_2;
    __pyx_L14_bool_binop_done:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":304
 *             if not PyDataType_HASFIELDS(descr):
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 */
    if (unlikely(__pyx_t_1)) {

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":306
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 */
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 306, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(1, 306, __pyx_L1_error)

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":304
 *             if not PyDataType_HASFIELDS(descr):
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 */
    }

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":307
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 */
    switch (__pyx_v_t) {
      case NPY_BYTE:
      __pyx_v_f = ((char *)"b");
      break;
      case NPY_UBYTE:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":308
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 */
      __pyx_v_f = ((char *)"B");
      break;
      case NPY_SHORT:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":309
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 */
      __pyx_v_f = ((char *)"h");
      break;
      case NPY_USHORT:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":310
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 */
      __pyx_v_f = ((char *)"H");
      break;
      case NPY_INT:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":311
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 */
      __pyx_v_f = ((char *)"i");
      break;
      case NPY_UINT:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":312
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 */
      __pyx_v_f = ((char *)"I");
      break;
      case NPY_LONG:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":313
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 */
      __pyx_v_f = ((char *)"l");
      break;
      case NPY_ULONG:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":314
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 */
      __pyx_v_f = ((char *)"L");
      break;
      case NPY_LONGLONG:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":315
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 */
      __pyx_v_f = ((char *)"q");
      break;
      case NPY_ULONGLONG:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":316
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 */
      __pyx_v_f = ((char *)"Q");
      break;
      case NPY_FLOAT:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":317
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 */
      __pyx_v_f = ((char *)"f");
      break;
      case NPY_DOUBLE:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":318
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 */
      __pyx_v_f = ((char *)"d");
      break;
      case NPY_LONGDOUBLE:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":319
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 */
      __pyx_v_f = ((char *)"g");
      break;
      case NPY_CFLOAT:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":320
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 */
      __pyx_v_f = ((char *)"Zf");
      break;
      case NPY_CDOUBLE:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":321
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"
 */
      __pyx_v_f = ((char *)"Zd");
      break;
      case NPY_CLONGDOUBLE:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":322
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 */
      __pyx_v_f = ((char *)"Zg");
      break;
      case NPY_OBJECT:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":323
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
      __pyx_v_f = ((char *)"O");
      break;
      default:

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":325
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *                 info.format = f
 *                 return
 */
      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_t); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 325, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_8 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 325, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 325, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(1, 325, __pyx_L1_error)
      break;
    }

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":326
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f             # <<<<<<<<<<<<<<
 *                 return
 *             else:
 */
    __pyx_v_info->format = __pyx_v_f;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":327
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f
 *                 return             # <<<<<<<<<<<<<<
 *             else:
 *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)
 */
    __pyx_r = 0;
    goto __pyx_L0;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":302
 *             info.obj = self
 * 
 *             if not PyDataType_HASFIELDS(descr):             # <<<<<<<<<<<<<<
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or
 */
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":329
 *                 return
 *             else:
 *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
 *                 info.format[0] = c'^' # Native data types, manual alignment
 *                 offset = 0
 */
  /*else*/ {
    __pyx_v_info->format = ((char *)PyObject_Malloc(0xFF));

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":330
 *             else:
 *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)
 *                 info.format[0] = c'^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
 *                 offset = 0
 *                 f = _util_dtypestring(descr, info.format + 1,
 */
    (__pyx_v_info->format[0]) = '^';

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":331
 *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)
 *                 info.format[0] = c'^' # Native data types, manual alignment
 *                 offset = 0             # <<<<<<<<<<<<<<
 *                 f = _util_dtypestring(descr, info.format + 1,
 *                                       info.format + _buffer_format_string_len,
 */
    __pyx_v_offset = 0;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":332
 *                 info.format[0] = c'^' # Native data types, manual alignment
 *                 offset = 0
 *                 f = _util_dtypestring(descr, info.format + 1,             # <<<<<<<<<<<<<<
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)
 */
    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 0xFF), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == ((char *)NULL))) __PYX_ERR(1, 332, __pyx_L1_error)
    __pyx_v_f = __pyx_t_9;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":335
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)
 *                 f[0] = c'\0' # Terminate format string             # <<<<<<<<<<<<<<
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 */
    (__pyx_v_f[0]) = '\x00';
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":258
 *         # experimental exception made for __getbuffer__ and __releasebuffer__
 *         # -- the details of this may change.
 *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fulfill the PEP.
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("numpy.ndarray.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  if (__pyx_v_info->obj != NULL) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
  }
  goto __pyx_L2;
  __pyx_L0:;
  if (__pyx_v_info->obj == Py_None) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
  }
  __pyx_L2:;
  __Pyx_XDECREF((PyObject *)__pyx_v_descr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":337
 *                 f[0] = c'\0' # Terminate format string
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             if PyArray_HASFIELDS(self):
 *                 PyObject_Free(info.format)
 */

/* Python wrapper */
static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
  __pyx_pf_5numpy_7ndarray_2__releasebuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__releasebuffer__", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":338
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
 *                 PyObject_Free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_t_1 = (PyArray_HASFIELDS(__pyx_v_self) != 0);
  if (__pyx_t_1) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":339
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):
 *                 PyObject_Free(info.format)             # <<<<<<<<<<<<<<
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 PyObject_Free(info.strides)
 */
    PyObject_Free(__pyx_v_info->format);

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":338
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
 *                 PyObject_Free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":340
 *             if PyArray_HASFIELDS(self):
 *                 PyObject_Free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 PyObject_Free(info.strides)
 *                 # info.shape was stored after info.strides in the same block
 */
  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
  if (__pyx_t_1) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":341
 *                 PyObject_Free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 PyObject_Free(info.strides)             # <<<<<<<<<<<<<<
 *                 # info.shape was stored after info.strides in the same block
 * 
 */
    PyObject_Free(__pyx_v_info->strides);

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":340
 *             if PyArray_HASFIELDS(self):
 *                 PyObject_Free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 PyObject_Free(info.strides)
 *                 # info.shape was stored after info.strides in the same block
 */
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":337
 *                 f[0] = c'\0' # Terminate format string
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             if PyArray_HASFIELDS(self):
 *                 PyObject_Free(info.format)
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":821
 * ctypedef npy_cdouble     complex_t
 * 
 * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":822
 * 
 * cdef inline object PyArray_MultiIterNew1(a):
 *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 822, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":821
 * ctypedef npy_cdouble     complex_t
 * 
 * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew1", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":824
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":825
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 825, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":824
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":827
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":828
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":827
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew3", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":830
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":831
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 831, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":830
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew4", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":833
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":834
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
 * 
 * cdef inline tuple PyDataType_SHAPE(dtype d):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 834, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":833
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew5", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":836
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
 *     if PyDataType_HASSUBARRAY(d):
 *         return <tuple>d.subarray.shape
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("PyDataType_SHAPE", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":837
 * 
 * cdef inline tuple PyDataType_SHAPE(dtype d):
 *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
 *         return <tuple>d.subarray.shape
 *     else:
 */
  __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);
  if (__pyx_t_1) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":838
 * cdef inline tuple PyDataType_SHAPE(dtype d):
 *     if PyDataType_HASSUBARRAY(d):
 *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
 *     else:
 *         return ()
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
    __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
    goto __pyx_L0;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":837
 * 
 * cdef inline tuple PyDataType_SHAPE(dtype d):
 *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
 *         return <tuple>d.subarray.shape
 *     else:
 */
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":840
 *         return <tuple>d.subarray.shape
 *     else:
 *         return ()             # <<<<<<<<<<<<<<
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_empty_tuple);
    __pyx_r = __pyx_empty_tuple;
    goto __pyx_L0;
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":836
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
 *     if PyDataType_HASSUBARRAY(d):
 *         return <tuple>d.subarray.shape
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":842
 *         return ()
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
 *     # Recursive utility function used in __getbuffer__ to get format
 *     # string. The new location in the format string is returned.
 */

static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *__pyx_v_descr, char *__pyx_v_f, char *__pyx_v_end, int *__pyx_v_offset) {
  PyArray_Descr *__pyx_v_child = 0;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  PyObject *__pyx_v_fields = 0;
  PyObject *__pyx_v_childname = NULL;
  PyObject *__pyx_v_new_offset = NULL;
  PyObject *__pyx_v_t = NULL;
  char *__pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  long __pyx_t_8;
  char *__pyx_t_9;
  __Pyx_RefNannySetupContext("_util_dtypestring", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":847
 * 
 *     cdef dtype child
 *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 *     cdef tuple fields
 */
  __pyx_v_endian_detector = 1;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":848
 *     cdef dtype child
 *     cdef int endian_detector = 1
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 *     cdef tuple fields
 * 
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":851
 *     cdef tuple fields
 * 
 *     for childname in descr.names:             # <<<<<<<<<<<<<<
 *         fields = descr.fields[childname]
 *         child, new_offset = fields
 */
  if (unlikely(__pyx_v_descr->names == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(1, 851, __pyx_L1_error)
  }
  __pyx_t_1 = __pyx_v_descr->names; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 851, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 851, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_childname, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":852
 * 
 *     for childname in descr.names:
 *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<
 *         child, new_offset = fields
 * 
 */
    if (unlikely(__pyx_v_descr->fields == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(1, 852, __pyx_L1_error)
    }
    __pyx_t_3 = __Pyx_PyDict_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 852, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_t_3)->tp_name), 0))) __PYX_ERR(1, 852, __pyx_L1_error)
    __Pyx_XDECREF_SET(__pyx_v_fields, ((PyObject*)__pyx_t_3));
    __pyx_t_3 = 0;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":853
 *     for childname in descr.names:
 *         fields = descr.fields[childname]
 *         child, new_offset = fields             # <<<<<<<<<<<<<<
 * 
 *         if (end - f) - <int>(new_offset - offset[0]) < 15:
 */
    if (likely(__pyx_v_fields != Py_None)) {
      PyObject* sequence = __pyx_v_fields;
      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        __PYX_ERR(1, 853, __pyx_L1_error)
      }
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      #else
      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 853, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 853, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      #endif
    } else {
      __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 853, __pyx_L1_error)
    }
    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) __PYX_ERR(1, 853, __pyx_L1_error)
    __Pyx_XDECREF_SET(__pyx_v_child, ((PyArray_Descr *)__pyx_t_3));
    __pyx_t_3 = 0;
    __Pyx_XDECREF_SET(__pyx_v_new_offset, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":855
 *         child, new_offset = fields
 * 
 *         if (end - f) - <int>(new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 */
    __pyx_t_4 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 855, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 855, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 855, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_6 = ((((__pyx_v_end - __pyx_v_f) - ((int)__pyx_t_5)) < 15) != 0);
    if (unlikely(__pyx_t_6)) {

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":856
 * 
 *         if (end - f) - <int>(new_offset - offset[0]) < 15:
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 */
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 856, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(1, 856, __pyx_L1_error)

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":855
 *         child, new_offset = fields
 * 
 *         if (end - f) - <int>(new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 */
    }

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":858
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_7 = ((__pyx_v_child->byteorder == '>') != 0);
    if (!__pyx_t_7) {
      goto __pyx_L8_next_or;
    } else {
    }
    __pyx_t_7 = (__pyx_v_little_endian != 0);
    if (!__pyx_t_7) {
    } else {
      __pyx_t_6 = __pyx_t_7;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_L8_next_or:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":859
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
 *             raise ValueError(u"Non-native byte order not supported")
 *             # One could encode it in the format string and have Cython
 */
    __pyx_t_7 = ((__pyx_v_child->byteorder == '<') != 0);
    if (__pyx_t_7) {
    } else {
      __pyx_t_6 = __pyx_t_7;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_7 = ((!(__pyx_v_little_endian != 0)) != 0);
    __pyx_t_6 = __pyx_t_7;
    __pyx_L7_bool_binop_done:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":858
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")
 */
    if (unlikely(__pyx_t_6)) {

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":860
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *             # One could encode it in the format string and have Cython
 *             # complain instead, BUT: < and > in format strings also imply
 */
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 860, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(1, 860, __pyx_L1_error)

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":858
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")
 */
    }

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":870
 * 
 *         # Output padding bytes
 *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 */
    while (1) {
      __pyx_t_3 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 870, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_v_new_offset, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 870, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 870, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (!__pyx_t_6) break;

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":871
 *         # Output padding bytes
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
 *             f += 1
 *             offset[0] += 1
 */
      (__pyx_v_f[0]) = 0x78;

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":872
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte
 *             f += 1             # <<<<<<<<<<<<<<
 *             offset[0] += 1
 * 
 */
      __pyx_v_f = (__pyx_v_f + 1);

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":873
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 *             offset[0] += 1             # <<<<<<<<<<<<<<
 * 
 *         offset[0] += child.itemsize
 */
      __pyx_t_8 = 0;
      (__pyx_v_offset[__pyx_t_8]) = ((__pyx_v_offset[__pyx_t_8]) + 1);
    }

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":875
 *             offset[0] += 1
 * 
 *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
 * 
 *         if not PyDataType_HASFIELDS(child):
 */
    __pyx_t_8 = 0;
    (__pyx_v_offset[__pyx_t_8]) = ((__pyx_v_offset[__pyx_t_8]) + __pyx_v_child->elsize);

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":877
 *         offset[0] += child.itemsize
 * 
 *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
 *             t = child.type_num
 *             if end - f < 5:
 */
    __pyx_t_6 = ((!(PyDataType_HASFIELDS(__pyx_v_child) != 0)) != 0);
    if (__pyx_t_6) {

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":878
 * 
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num             # <<<<<<<<<<<<<<
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")
 */
      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_child->type_num); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 878, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_XDECREF_SET(__pyx_v_t, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":879
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num
 *             if end - f < 5:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError(u"Format string allocated too short.")
 * 
 */
      __pyx_t_6 = (((__pyx_v_end - __pyx_v_f) < 5) != 0);
      if (unlikely(__pyx_t_6)) {

        /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":880
 *             t = child.type_num
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 */
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 880, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __PYX_ERR(1, 880, __pyx_L1_error)

        /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":879
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num
 *             if end - f < 5:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError(u"Format string allocated too short.")
 * 
 */
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":883
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_BYTE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 883, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 883, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 883, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 98;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":884
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_UBYTE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 884, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 884, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 884, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 66;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":885
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_SHORT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 885, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 885, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 885, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 0x68;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":886
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_USHORT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 886, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 886, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 886, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 72;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":887
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_INT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 887, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 887, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 887, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 0x69;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":888
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_UINT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 888, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 888, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 888, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 73;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":889
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONG); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 889, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 889, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 889, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 0x6C;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":890
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_ULONG); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 890, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 890, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 890, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 76;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":891
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONGLONG); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 891, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 891, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 891, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 0x71;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":892
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_ULONGLONG); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 892, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 892, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 892, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 81;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":893
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_FLOAT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 893, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 893, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 893, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 0x66;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":894
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_DOUBLE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 894, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 894, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 894, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 0x64;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":895
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 895, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 895, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 895, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 0x67;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":896
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CFLOAT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 896, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 896, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 896, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 0x66;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":897
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CDOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 897, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 897, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 897, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 0x64;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":898
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 */
      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 898, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 898, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 898, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (__pyx_t_6) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 0x67;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":899
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_OBJECT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 899, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 899, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 899, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (likely(__pyx_t_6)) {
        (__pyx_v_f[0]) = 79;
        goto __pyx_L15;
      }

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":901
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *             f += 1
 *         else:
 */
      /*else*/ {
        __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_v_t); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 901, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 901, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __PYX_ERR(1, 901, __pyx_L1_error)
      }
      __pyx_L15:;

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":902
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *             f += 1             # <<<<<<<<<<<<<<
 *         else:
 *             # Cython ignores struct boundary information ("T{...}"),
 */
      __pyx_v_f = (__pyx_v_f + 1);

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":877
 *         offset[0] += child.itemsize
 * 
 *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
 *             t = child.type_num
 *             if end - f < 5:
 */
      goto __pyx_L13;
    }

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":906
 *             # Cython ignores struct boundary information ("T{...}"),
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
 *     return f
 * 
 */
    /*else*/ {
      __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_9 == ((char *)NULL))) __PYX_ERR(1, 906, __pyx_L1_error)
      __pyx_v_f = __pyx_t_9;
    }
    __pyx_L13:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":851
 *     cdef tuple fields
 * 
 *     for childname in descr.names:             # <<<<<<<<<<<<<<
 *         fields = descr.fields[childname]
 *         child, new_offset = fields
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":907
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)
 *     return f             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_f;
  goto __pyx_L0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":842
 *         return ()
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
 *     # Recursive utility function used in __getbuffer__ to get format
 *     # string. The new location in the format string is returned.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("numpy._util_dtypestring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_child);
  __Pyx_XDECREF(__pyx_v_fields);
  __Pyx_XDECREF(__pyx_v_childname);
  __Pyx_XDECREF(__pyx_v_new_offset);
  __Pyx_XDECREF(__pyx_v_t);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1022
 *     int _import_umath() except -1
 * 
 * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
 *     Py_INCREF(base) # important to do this before stealing the reference below!
 *     PyArray_SetBaseObject(arr, base)
 */

static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_array_base", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1023
 * 
 * cdef inline void set_array_base(ndarray arr, object base):
 *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
 *     PyArray_SetBaseObject(arr, base)
 * 
 */
  Py_INCREF(__pyx_v_base);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1024
 * cdef inline void set_array_base(ndarray arr, object base):
 *     Py_INCREF(base) # important to do this before stealing the reference below!
 *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object get_array_base(ndarray arr):
 */
  (void)(PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base));

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1022
 *     int _import_umath() except -1
 * 
 * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
 *     Py_INCREF(base) # important to do this before stealing the reference below!
 *     PyArray_SetBaseObject(arr, base)
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1026
 *     PyArray_SetBaseObject(arr, base)
 * 
 * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
 *     base = PyArray_BASE(arr)
 *     if base is NULL:
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
  PyObject *__pyx_v_base;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("get_array_base", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1027
 * 
 * cdef inline object get_array_base(ndarray arr):
 *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
 *     if base is NULL:
 *         return None
 */
  __pyx_v_base = PyArray_BASE(__pyx_v_arr);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1028
 * cdef inline object get_array_base(ndarray arr):
 *     base = PyArray_BASE(arr)
 *     if base is NULL:             # <<<<<<<<<<<<<<
 *         return None
 *     return <object>base
 */
  __pyx_t_1 = ((__pyx_v_base == NULL) != 0);
  if (__pyx_t_1) {

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1029
 *     base = PyArray_BASE(arr)
 *     if base is NULL:
 *         return None             # <<<<<<<<<<<<<<
 *     return <object>base
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1028
 * cdef inline object get_array_base(ndarray arr):
 *     base = PyArray_BASE(arr)
 *     if base is NULL:             # <<<<<<<<<<<<<<
 *         return None
 *     return <object>base
 */
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1030
 *     if base is NULL:
 *         return None
 *     return <object>base             # <<<<<<<<<<<<<<
 * 
 * # Versions of the import_* functions which are more suitable for
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_base));
  __pyx_r = ((PyObject *)__pyx_v_base);
  goto __pyx_L0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1026
 *     PyArray_SetBaseObject(arr, base)
 * 
 * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
 *     base = PyArray_BASE(arr)
 *     if base is NULL:
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1034
 * # Versions of the import_* functions which are more suitable for
 * # Cython code.
 * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
 *     try:
 *         _import_array()
 */

static CYTHON_INLINE int __pyx_f_5numpy_import_array(void) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("import_array", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1035
 * # Cython code.
 * cdef inline int import_array() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_array()
 *     except Exception:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_1);
    __Pyx_XGOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1036
 * cdef inline int import_array() except -1:
 *     try:
 *         _import_array()             # <<<<<<<<<<<<<<
 *     except Exception:
 *         raise ImportError("numpy.core.multiarray failed to import")
 */
      __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1036, __pyx_L3_error)

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1035
 * # Cython code.
 * cdef inline int import_array() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_array()
 *     except Exception:
 */
    }
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8_try_end;
    __pyx_L3_error:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1037
 *     try:
 *         _import_array()
 *     except Exception:             # <<<<<<<<<<<<<<
 *         raise ImportError("numpy.core.multiarray failed to import")
 * 
 */
    __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
    if (__pyx_t_4) {
      __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1037, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GOTREF(__pyx_t_7);

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1038
 *         _import_array()
 *     except Exception:
 *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
 * 
 * cdef inline int import_umath() except -1:
 */
      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1038, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __PYX_ERR(1, 1038, __pyx_L5_except_error)
    }
    goto __pyx_L5_except_error;
    __pyx_L5_except_error:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1035
 * # Cython code.
 * cdef inline int import_array() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_array()
 *     except Exception:
 */
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L8_try_end:;
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1034
 * # Versions of the import_* functions which are more suitable for
 * # Cython code.
 * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
 *     try:
 *         _import_array()
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1040
 *         raise ImportError("numpy.core.multiarray failed to import")
 * 
 * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
 *     try:
 *         _import_umath()
 */

static CYTHON_INLINE int __pyx_f_5numpy_import_umath(void) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("import_umath", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1041
 * 
 * cdef inline int import_umath() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_umath()
 *     except Exception:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_1);
    __Pyx_XGOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1042
 * cdef inline int import_umath() except -1:
 *     try:
 *         _import_umath()             # <<<<<<<<<<<<<<
 *     except Exception:
 *         raise ImportError("numpy.core.umath failed to import")
 */
      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1042, __pyx_L3_error)

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1041
 * 
 * cdef inline int import_umath() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_umath()
 *     except Exception:
 */
    }
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8_try_end;
    __pyx_L3_error:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1043
 *     try:
 *         _import_umath()
 *     except Exception:             # <<<<<<<<<<<<<<
 *         raise ImportError("numpy.core.umath failed to import")
 * 
 */
    __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
    if (__pyx_t_4) {
      __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1043, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GOTREF(__pyx_t_7);

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1044
 *         _import_umath()
 *     except Exception:
 *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
 * 
 * cdef inline int import_ufunc() except -1:
 */
      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1044, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __PYX_ERR(1, 1044, __pyx_L5_except_error)
    }
    goto __pyx_L5_except_error;
    __pyx_L5_except_error:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1041
 * 
 * cdef inline int import_umath() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_umath()
 *     except Exception:
 */
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L8_try_end:;
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1040
 *         raise ImportError("numpy.core.multiarray failed to import")
 * 
 * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
 *     try:
 *         _import_umath()
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1046
 *         raise ImportError("numpy.core.umath failed to import")
 * 
 * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
 *     try:
 *         _import_umath()
 */

static CYTHON_INLINE int __pyx_f_5numpy_import_ufunc(void) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("import_ufunc", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1047
 * 
 * cdef inline int import_ufunc() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_umath()
 *     except Exception:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_1);
    __Pyx_XGOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1048
 * cdef inline int import_ufunc() except -1:
 *     try:
 *         _import_umath()             # <<<<<<<<<<<<<<
 *     except Exception:
 *         raise ImportError("numpy.core.umath failed to import")
 */
      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1048, __pyx_L3_error)

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1047
 * 
 * cdef inline int import_ufunc() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_umath()
 *     except Exception:
 */
    }
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8_try_end;
    __pyx_L3_error:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1049
 *     try:
 *         _import_umath()
 *     except Exception:             # <<<<<<<<<<<<<<
 *         raise ImportError("numpy.core.umath failed to import")
 */
    __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
    if (__pyx_t_4) {
      __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1049, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GOTREF(__pyx_t_7);

      /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1050
 *         _import_umath()
 *     except Exception:
 *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
 */
      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1050, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __PYX_ERR(1, 1050, __pyx_L5_except_error)
    }
    goto __pyx_L5_except_error;
    __pyx_L5_except_error:;

    /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1047
 * 
 * cdef inline int import_ufunc() except -1:
 *     try:             # <<<<<<<<<<<<<<
 *         _import_umath()
 *     except Exception:
 */
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L8_try_end:;
  }

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1046
 *         raise ImportError("numpy.core.umath failed to import")
 * 
 * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
 *     try:
 *         _import_umath()
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
#if CYTHON_PEP489_MULTI_PHASE_INIT
static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
static int __pyx_pymod_exec_notimplemented(PyObject* module); /*proto*/
static PyModuleDef_Slot __pyx_moduledef_slots[] = {
  {Py_mod_create, (void*)__pyx_pymod_create},
  {Py_mod_exec, (void*)__pyx_pymod_exec_notimplemented},
  {0, NULL}
};
#endif

static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    "notimplemented",
    0, /* m_doc */
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    0, /* m_size */
  #else
    -1, /* m_size */
  #endif
    __pyx_methods /* m_methods */,
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    __pyx_moduledef_slots, /* m_slots */
  #else
    NULL, /* m_reload */
  #endif
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif
#ifndef CYTHON_SMALL_CODE
#if defined(__clang__)
    #define CYTHON_SMALL_CODE
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
    #define CYTHON_SMALL_CODE __attribute__((cold))
#else
    #define CYTHON_SMALL_CODE
#endif
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_, __pyx_k_, sizeof(__pyx_k_), 0, 0, 1, 0},
  {&__pyx_kp_s_18e, __pyx_k_18e, sizeof(__pyx_k_18e), 0, 0, 1, 0},
  {&__pyx_n_s_A, __pyx_k_A, sizeof(__pyx_k_A), 0, 0, 1, 1},
  {&__pyx_kp_u_An_array_with_ones_at_and_below, __pyx_k_An_array_with_ones_at_and_below, sizeof(__pyx_k_An_array_with_ones_at_and_below), 0, 1, 0, 0},
  {&__pyx_kp_u_Append_values_to_the_end_of_an_a, __pyx_k_Append_values_to_the_end_of_an_a, sizeof(__pyx_k_Append_values_to_the_end_of_an_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Apply_a_function_repeatedly_over, __pyx_k_Apply_a_function_repeatedly_over, sizeof(__pyx_k_Apply_a_function_repeatedly_over), 0, 1, 0, 0},
  {&__pyx_kp_u_Apply_a_function_to_1_D_slices_a, __pyx_k_Apply_a_function_to_1_D_slices_a, sizeof(__pyx_k_Apply_a_function_to_1_D_slices_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Broadcast_any_number_of_arrays_a, __pyx_k_Broadcast_any_number_of_arrays_a, sizeof(__pyx_k_Broadcast_any_number_of_arrays_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Build_a_matrix_object_from_a_str, __pyx_k_Build_a_matrix_object_from_a_str, sizeof(__pyx_k_Build_a_matrix_object_from_a_str), 0, 1, 0, 0},
  {&__pyx_n_s_C, __pyx_k_C, sizeof(__pyx_k_C), 0, 0, 1, 1},
  {&__pyx_kp_u_Calculate_the_n_th_order_discret, __pyx_k_Calculate_the_n_th_order_discret, sizeof(__pyx_k_Calculate_the_n_th_order_discret), 0, 1, 0, 0},
  {&__pyx_kp_u_Change_elements_of_an_array_base, __pyx_k_Change_elements_of_an_array_base, sizeof(__pyx_k_Change_elements_of_an_array_base), 0, 1, 0, 0},
  {&__pyx_kp_u_Check_whether_or_not_an_object_c, __pyx_k_Check_whether_or_not_an_object_c, sizeof(__pyx_k_Check_whether_or_not_an_object_c), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_tensor_dot_product_along, __pyx_k_Compute_tensor_dot_product_along, sizeof(__pyx_k_Compute_tensor_dot_product_along), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_arithmetic_mean_alon, __pyx_k_Compute_the_arithmetic_mean_alon, sizeof(__pyx_k_Compute_the_arithmetic_mean_alon), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_bi_dimensional_histo, __pyx_k_Compute_the_bi_dimensional_histo, sizeof(__pyx_k_Compute_the_bi_dimensional_histo), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_future_value_Given_a, __pyx_k_Compute_the_future_value_Given_a, sizeof(__pyx_k_Compute_the_future_value_Given_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_histogram_of_a_set_o, __pyx_k_Compute_the_histogram_of_a_set_o, sizeof(__pyx_k_Compute_the_histogram_of_a_set_o), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_median_along_the_spe, __pyx_k_Compute_the_median_along_the_spe, sizeof(__pyx_k_Compute_the_median_along_the_spe), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_multidimensional_his, __pyx_k_Compute_the_multidimensional_his, sizeof(__pyx_k_Compute_the_multidimensional_his), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_number_of_periodic_p, __pyx_k_Compute_the_number_of_periodic_p, sizeof(__pyx_k_Compute_the_number_of_periodic_p), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_outer_product_of_two, __pyx_k_Compute_the_outer_product_of_two, sizeof(__pyx_k_Compute_the_outer_product_of_two), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_payment_against_loan, __pyx_k_Compute_the_payment_against_loan, sizeof(__pyx_k_Compute_the_payment_against_loan), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_present_value_Given, __pyx_k_Compute_the_present_value_Given, sizeof(__pyx_k_Compute_the_present_value_Given), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_qth_percentile_of_th, __pyx_k_Compute_the_qth_percentile_of_th, sizeof(__pyx_k_Compute_the_qth_percentile_of_th), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_standard_deviation_a, __pyx_k_Compute_the_standard_deviation_a, sizeof(__pyx_k_Compute_the_standard_deviation_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_variance_along_the_s, __pyx_k_Compute_the_variance_along_the_s, sizeof(__pyx_k_Compute_the_variance_along_the_s), 0, 1, 0, 0},
  {&__pyx_kp_u_Compute_the_weighted_average_alo, __pyx_k_Compute_the_weighted_average_alo, sizeof(__pyx_k_Compute_the_weighted_average_alo), 0, 1, 0, 0},
  {&__pyx_kp_u_Construct_an_array_by_repeating, __pyx_k_Construct_an_array_by_repeating, sizeof(__pyx_k_Construct_an_array_by_repeating), 0, 1, 0, 0},
  {&__pyx_kp_u_Construct_an_array_from_a_text_f, __pyx_k_Construct_an_array_from_a_text_f, sizeof(__pyx_k_Construct_an_array_from_a_text_f), 0, 1, 0, 0},
  {&__pyx_kp_u_Construct_an_array_from_an_index, __pyx_k_Construct_an_array_from_an_index, sizeof(__pyx_k_Construct_an_array_from_an_index), 0, 1, 0, 0},
  {&__pyx_kp_u_Construct_an_open_mesh_from_mult, __pyx_k_Construct_an_open_mesh_from_mult, sizeof(__pyx_k_Construct_an_open_mesh_from_mult), 0, 1, 0, 0},
  {&__pyx_kp_u_Convert_an_array_of_size_1_to_it, __pyx_k_Convert_an_array_of_size_1_to_it, sizeof(__pyx_k_Convert_an_array_of_size_1_to_it), 0, 1, 0, 0},
  {&__pyx_kp_u_Convert_inputs_to_arrays_with_at, __pyx_k_Convert_inputs_to_arrays_with_at, sizeof(__pyx_k_Convert_inputs_to_arrays_with_at), 0, 1, 0, 0},
  {&__pyx_kp_u_Convert_the_input_to_an_array_ch, __pyx_k_Convert_the_input_to_an_array_ch, sizeof(__pyx_k_Convert_the_input_to_an_array_ch), 0, 1, 0, 0},
  {&__pyx_kp_u_Convert_the_input_to_an_ndarray, __pyx_k_Convert_the_input_to_an_ndarray, sizeof(__pyx_k_Convert_the_input_to_an_ndarray), 0, 1, 0, 0},
  {&__pyx_kp_u_Create_a_two_dimensional_array_w, __pyx_k_Create_a_two_dimensional_array_w, sizeof(__pyx_k_Create_a_two_dimensional_array_w), 0, 1, 0, 0},
  {&__pyx_kp_u_Cross_correlation_of_two_1_dimen, __pyx_k_Cross_correlation_of_two_1_dimen, sizeof(__pyx_k_Cross_correlation_of_two_1_dimen), 0, 1, 0, 0},
  {&__pyx_kp_u_Determine_common_type_following, __pyx_k_Determine_common_type_following, sizeof(__pyx_k_Determine_common_type_following), 0, 1, 0, 0},
  {&__pyx_kp_u_Determine_if_a_class_is_a_subcla, __pyx_k_Determine_if_a_class_is_a_subcla, sizeof(__pyx_k_Determine_if_a_class_is_a_subcla), 0, 1, 0, 0},
  {&__pyx_kp_u_Determine_if_the_first_argument, __pyx_k_Determine_if_the_first_argument, sizeof(__pyx_k_Determine_if_the_first_argument), 0, 1, 0, 0},
  {&__pyx_kp_u_Determine_if_two_arrays_can_shar, __pyx_k_Determine_if_two_arrays_can_shar, sizeof(__pyx_k_Determine_if_two_arrays_can_shar), 0, 1, 0, 0},
  {&__pyx_kp_u_Determines_whether_the_given_obj, __pyx_k_Determines_whether_the_given_obj, sizeof(__pyx_k_Determines_whether_the_given_obj), 0, 1, 0, 0},
  {&__pyx_kp_u_Difference_subtraction_of_two_po, __pyx_k_Difference_subtraction_of_two_po, sizeof(__pyx_k_Difference_subtraction_of_two_po), 0, 1, 0, 0},
  {&__pyx_kp_u_Display_a_message_on_a_device_Pa, __pyx_k_Display_a_message_on_a_device_Pa, sizeof(__pyx_k_Display_a_message_on_a_device_Pa), 0, 1, 0, 0},
  {&__pyx_kp_u_Do_a_keyword_search_on_docstring, __pyx_k_Do_a_keyword_search_on_docstring, sizeof(__pyx_k_Do_a_keyword_search_on_docstring), 0, 1, 0, 0},
  {&__pyx_kp_u_Estimate_a_covariance_matrix_giv, __pyx_k_Estimate_a_covariance_matrix_giv, sizeof(__pyx_k_Estimate_a_covariance_matrix_giv), 0, 1, 0, 0},
  {&__pyx_kp_u_Evaluate_a_piecewise_defined_fun, __pyx_k_Evaluate_a_piecewise_defined_fun, sizeof(__pyx_k_Evaluate_a_piecewise_defined_fun), 0, 1, 0, 0},
  {&__pyx_kp_u_Evaluate_a_polynomial_at_specifi, __pyx_k_Evaluate_a_polynomial_at_specifi, sizeof(__pyx_k_Evaluate_a_polynomial_at_specifi), 0, 1, 0, 0},
  {&__pyx_kp_u_Evenly_round_to_the_given_number, __pyx_k_Evenly_round_to_the_given_number, sizeof(__pyx_k_Evenly_round_to_the_given_number), 0, 1, 0, 0},
  {&__pyx_kp_u_Expand_the_shape_of_an_array_Ins, __pyx_k_Expand_the_shape_of_an_array_Ins, sizeof(__pyx_k_Expand_the_shape_of_an_array_Ins), 0, 1, 0, 0},
  {&__pyx_kp_u_Fill_the_main_diagonal_of_the_gi, __pyx_k_Fill_the_main_diagonal_of_the_gi, sizeof(__pyx_k_Fill_the_main_diagonal_of_the_gi), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_indices_where_elements_shou, __pyx_k_Find_indices_where_elements_shou, sizeof(__pyx_k_Find_indices_where_elements_shou), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_coefficients_of_a_polyn, __pyx_k_Find_the_coefficients_of_a_polyn, sizeof(__pyx_k_Find_the_coefficients_of_a_polyn), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_indices_of_array_elemen, __pyx_k_Find_the_indices_of_array_elemen, sizeof(__pyx_k_Find_the_indices_of_array_elemen), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_intersection_of_two_arr, __pyx_k_Find_the_intersection_of_two_arr, sizeof(__pyx_k_Find_the_intersection_of_two_arr), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_product_of_two_polynomi, __pyx_k_Find_the_product_of_two_polynomi, sizeof(__pyx_k_Find_the_product_of_two_polynomi), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_set_difference_of_two_a, __pyx_k_Find_the_set_difference_of_two_a, sizeof(__pyx_k_Find_the_set_difference_of_two_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_set_exclusive_or_of_two, __pyx_k_Find_the_set_exclusive_or_of_two, sizeof(__pyx_k_Find_the_set_exclusive_or_of_two), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_sum_of_two_polynomials, __pyx_k_Find_the_sum_of_two_polynomials, sizeof(__pyx_k_Find_the_sum_of_two_polynomials), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_union_of_two_arrays_Ret, __pyx_k_Find_the_union_of_two_arrays_Ret, sizeof(__pyx_k_Find_the_union_of_two_arrays_Ret), 0, 1, 0, 0},
  {&__pyx_kp_u_Find_the_unique_elements_of_an_a, __pyx_k_Find_the_unique_elements_of_an_a, sizeof(__pyx_k_Find_the_unique_elements_of_an_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Flip_array_in_the_left_right_dir, __pyx_k_Flip_array_in_the_left_right_dir, sizeof(__pyx_k_Flip_array_in_the_left_right_dir), 0, 1, 0, 0},
  {&__pyx_kp_u_Flip_array_in_the_up_down_direct, __pyx_k_Flip_array_in_the_up_down_direct, sizeof(__pyx_k_Flip_array_in_the_up_down_direct), 0, 1, 0, 0},
  {&__pyx_kp_u_Format_string_allocated_too_shor, __pyx_k_Format_string_allocated_too_shor, sizeof(__pyx_k_Format_string_allocated_too_shor), 0, 1, 0, 0},
  {&__pyx_kp_u_Format_string_allocated_too_shor_2, __pyx_k_Format_string_allocated_too_shor_2, sizeof(__pyx_k_Format_string_allocated_too_shor_2), 0, 1, 0, 0},
  {&__pyx_n_s_GDFgdf, __pyx_k_GDFgdf, sizeof(__pyx_k_GDFgdf), 0, 0, 1, 1},
  {&__pyx_kp_u_Generate_a_Van_der_Monde_matrix, __pyx_k_Generate_a_Van_der_Monde_matrix, sizeof(__pyx_k_Generate_a_Van_der_Monde_matrix), 0, 1, 0, 0},
  {&__pyx_kp_u_Get_help_information_for_a_funct, __pyx_k_Get_help_information_for_a_funct, sizeof(__pyx_k_Get_help_information_for_a_funct), 0, 1, 0, 0},
  {&__pyx_kp_u_Get_the_current_way_of_handling, __pyx_k_Get_the_current_way_of_handling, sizeof(__pyx_k_Get_the_current_way_of_handling), 0, 1, 0, 0},
  {&__pyx_kp_u_Gives_a_new_shape_to_an_array_wi, __pyx_k_Gives_a_new_shape_to_an_array_wi, sizeof(__pyx_k_Gives_a_new_shape_to_an_array_wi), 0, 1, 0, 0},
  {&__pyx_kp_u_If_complex_input_returns_a_real, __pyx_k_If_complex_input_returns_a_real, sizeof(__pyx_k_If_complex_input_returns_a_real), 0, 1, 0, 0},
  {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
  {&__pyx_kp_u_Indices_of_the_maximum_values_al, __pyx_k_Indices_of_the_maximum_values_al, sizeof(__pyx_k_Indices_of_the_maximum_values_al), 0, 1, 0, 0},
  {&__pyx_kp_u_Insert_values_along_the_given_ax, __pyx_k_Insert_values_along_the_given_ax, sizeof(__pyx_k_Insert_values_along_the_given_ax), 0, 1, 0, 0},
  {&__pyx_kp_u_Integrate_along_the_given_axis_u, __pyx_k_Integrate_along_the_given_axis_u, sizeof(__pyx_k_Integrate_along_the_given_axis_u), 0, 1, 0, 0},
  {&__pyx_kp_u_Interchange_two_axes_of_an_array, __pyx_k_Interchange_two_axes_of_an_array, sizeof(__pyx_k_Interchange_two_axes_of_an_array), 0, 1, 0, 0},
  {&__pyx_kp_u_Interpret_the_input_as_a_matrix, __pyx_k_Interpret_the_input_as_a_matrix, sizeof(__pyx_k_Interpret_the_input_as_a_matrix), 0, 1, 0, 0},
  {&__pyx_kp_u_Issues_a_DeprecationWarning_adds, __pyx_k_Issues_a_DeprecationWarning_adds, sizeof(__pyx_k_Issues_a_DeprecationWarning_adds), 0, 1, 0, 0},
  {&__pyx_kp_u_Kronecker_product_of_two_arrays, __pyx_k_Kronecker_product_of_two_arrays, sizeof(__pyx_k_Kronecker_product_of_two_arrays), 0, 1, 0, 0},
  {&__pyx_kp_u_Least_squares_polynomial_fit_Fit, __pyx_k_Least_squares_polynomial_fit_Fit, sizeof(__pyx_k_Least_squares_polynomial_fit_Fit), 0, 1, 0, 0},
  {&__pyx_kp_u_Load_a_pickled_npy_or_npz_binary, __pyx_k_Load_a_pickled_npy_or_npz_binary, sizeof(__pyx_k_Load_a_pickled_npy_or_npz_binary), 0, 1, 0, 0},
  {&__pyx_kp_u_Load_data_from_a_text_file_Each, __pyx_k_Load_data_from_a_text_file_Each, sizeof(__pyx_k_Load_data_from_a_text_file_Each), 0, 1, 0, 0},
  {&__pyx_kp_u_Load_data_from_a_text_file_with, __pyx_k_Load_data_from_a_text_file_with, sizeof(__pyx_k_Load_data_from_a_text_file_with), 0, 1, 0, 0},
  {&__pyx_kp_u_Lower_triangle_of_an_array_Retur, __pyx_k_Lower_triangle_of_an_array_Retur, sizeof(__pyx_k_Lower_triangle_of_an_array_Retur), 0, 1, 0, 0},
  {&__pyx_n_s_M, __pyx_k_M, sizeof(__pyx_k_M), 0, 0, 1, 1},
  {&__pyx_kp_u_Modified_Bessel_function_of_the, __pyx_k_Modified_Bessel_function_of_the, sizeof(__pyx_k_Modified_Bessel_function_of_the), 0, 1, 0, 0},
  {&__pyx_n_s_N, __pyx_k_N, sizeof(__pyx_k_N), 0, 0, 1, 1},
  {&__pyx_kp_u_Non_native_byte_order_not_suppor, __pyx_k_Non_native_byte_order_not_suppor, sizeof(__pyx_k_Non_native_byte_order_not_suppor), 0, 1, 0, 0},
  {&__pyx_n_s_NotImplementedError, __pyx_k_NotImplementedError, sizeof(__pyx_k_NotImplementedError), 0, 0, 1, 1},
  {&__pyx_kp_u_One_dimensional_linear_interpola, __pyx_k_One_dimensional_linear_interpola, sizeof(__pyx_k_One_dimensional_linear_interpola), 0, 1, 0, 0},
  {&__pyx_kp_u_Permute_the_dimensions_of_an_arr, __pyx_k_Permute_the_dimensions_of_an_arr, sizeof(__pyx_k_Permute_the_dimensions_of_an_arr), 0, 1, 0, 0},
  {&__pyx_kp_u_Print_or_write_to_a_file_the_sou, __pyx_k_Print_or_write_to_a_file_the_sou, sizeof(__pyx_k_Print_or_write_to_a_file_the_sou), 0, 1, 0, 0},
  {&__pyx_kp_u_Print_the_Numpy_arrays_in_the_gi, __pyx_k_Print_the_Numpy_arrays_in_the_gi, sizeof(__pyx_k_Print_the_Numpy_arrays_in_the_gi), 0, 1, 0, 0},
  {&__pyx_kp_u_Protected_string_evaluation_Eval, __pyx_k_Protected_string_evaluation_Eval, sizeof(__pyx_k_Protected_string_evaluation_Eval), 0, 1, 0, 0},
  {&__pyx_kp_u_Range_of_values_maximum_minimum, __pyx_k_Range_of_values_maximum_minimum, sizeof(__pyx_k_Range_of_values_maximum_minimum), 0, 1, 0, 0},
  {&__pyx_kp_u_Remove_single_dimensional_entrie, __pyx_k_Remove_single_dimensional_entrie, sizeof(__pyx_k_Remove_single_dimensional_entrie), 0, 1, 0, 0},
  {&__pyx_kp_u_Repeat_elements_of_an_array_Para, __pyx_k_Repeat_elements_of_an_array_Para, sizeof(__pyx_k_Repeat_elements_of_an_array_Para), 0, 1, 0, 0},
  {&__pyx_kp_u_Replace_nan_with_zero_and_inf_wi, __pyx_k_Replace_nan_with_zero_and_inf_wi, sizeof(__pyx_k_Replace_nan_with_zero_and_inf_wi), 0, 1, 0, 0},
  {&__pyx_kp_u_Replaces_specified_elements_of_a, __pyx_k_Replaces_specified_elements_of_a, sizeof(__pyx_k_Replaces_specified_elements_of_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_True_if_x_is_a_complex_ty, __pyx_k_Return_True_if_x_is_a_complex_ty, sizeof(__pyx_k_Return_True_if_x_is_a_complex_ty), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_True_if_x_is_a_not_comple, __pyx_k_Return_True_if_x_is_a_not_comple, sizeof(__pyx_k_Return_True_if_x_is_a_not_comple), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_contiguous_array_in_mem, __pyx_k_Return_a_contiguous_array_in_mem, sizeof(__pyx_k_Return_a_contiguous_array_in_mem), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_description_for_the_giv, __pyx_k_Return_a_description_for_the_giv, sizeof(__pyx_k_Return_a_description_for_the_giv), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_flattened_array_A_1_D_a, __pyx_k_Return_a_flattened_array_A_1_D_a, sizeof(__pyx_k_Return_a_flattened_array_A_1_D_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_new_array_with_sub_arra, __pyx_k_Return_a_new_array_with_sub_arra, sizeof(__pyx_k_Return_a_new_array_with_sub_arra), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_new_array_with_the_spec, __pyx_k_Return_a_new_array_with_the_spec, sizeof(__pyx_k_Return_a_new_array_with_the_spec), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_scalar_type_which_is_co, __pyx_k_Return_a_scalar_type_which_is_co, sizeof(__pyx_k_Return_a_scalar_type_which_is_co), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_sorted_copy_of_an_array, __pyx_k_Return_a_sorted_copy_of_an_array, sizeof(__pyx_k_Return_a_sorted_copy_of_an_array), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_string_representation_o, __pyx_k_Return_a_string_representation_o, sizeof(__pyx_k_Return_a_string_representation_o), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_string_representation_o_2, __pyx_k_Return_a_string_representation_o_2, sizeof(__pyx_k_Return_a_string_representation_o_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_a_string_representation_o_3, __pyx_k_Return_a_string_representation_o_3, sizeof(__pyx_k_Return_a_string_representation_o_3), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_an_antiderivative_indefin, __pyx_k_Return_an_antiderivative_indefin, sizeof(__pyx_k_Return_an_antiderivative_indefin), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_an_array_converted_to_a_f, __pyx_k_Return_an_array_converted_to_a_f, sizeof(__pyx_k_Return_an_array_converted_to_a_f), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_an_array_copy_of_the_give, __pyx_k_Return_an_array_copy_of_the_give, sizeof(__pyx_k_Return_an_array_copy_of_the_give), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_an_array_drawn_from_eleme, __pyx_k_Return_an_array_drawn_from_eleme, sizeof(__pyx_k_Return_an_array_drawn_from_eleme), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_an_array_laid_out_in_Fort, __pyx_k_Return_an_array_laid_out_in_Fort, sizeof(__pyx_k_Return_an_array_laid_out_in_Fort), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_an_array_representing_the, __pyx_k_Return_an_array_representing_the, sizeof(__pyx_k_Return_an_array_representing_the), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_an_ndarray_of_the_provide, __pyx_k_Return_an_ndarray_of_the_provide, sizeof(__pyx_k_Return_an_ndarray_of_the_provide), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_coordinate_matrices_from, __pyx_k_Return_coordinate_matrices_from, sizeof(__pyx_k_Return_coordinate_matrices_from), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_indices_of_the_maximum_va, __pyx_k_Return_indices_of_the_maximum_va, sizeof(__pyx_k_Return_indices_of_the_maximum_va), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_indices_of_the_minimum_va, __pyx_k_Return_indices_of_the_minimum_va, sizeof(__pyx_k_Return_indices_of_the_minimum_va), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_indices_that_are_non_zero, __pyx_k_Return_indices_that_are_non_zero, sizeof(__pyx_k_Return_indices_that_are_non_zero), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_selected_slices_of_an_arr, __pyx_k_Return_selected_slices_of_an_arr, sizeof(__pyx_k_Return_selected_slices_of_an_arr), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_Bartlett_window_The_B, __pyx_k_Return_the_Bartlett_window_The_B, sizeof(__pyx_k_Return_the_Bartlett_window_The_B), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_Blackman_window_The_B, __pyx_k_Return_the_Blackman_window_The_B, sizeof(__pyx_k_Return_the_Blackman_window_The_B), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_Hamming_window_The_Ha, __pyx_k_Return_the_Hamming_window_The_Ha, sizeof(__pyx_k_Return_the_Hamming_window_The_Ha), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_Hanning_window_The_Ha, __pyx_k_Return_the_Hanning_window_The_Ha, sizeof(__pyx_k_Return_the_Hanning_window_The_Ha), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_Internal_Rate_of_Retu, __pyx_k_Return_the_Internal_Rate_of_Retu, sizeof(__pyx_k_Return_the_Internal_Rate_of_Retu), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_Kaiser_window_The_Kai, __pyx_k_Return_the_Kaiser_window_The_Kai, sizeof(__pyx_k_Return_the_Kaiser_window_The_Kai), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_angle_of_the_complex, __pyx_k_Return_the_angle_of_the_complex, sizeof(__pyx_k_Return_the_angle_of_the_complex), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_binary_representation, __pyx_k_Return_the_binary_representation, sizeof(__pyx_k_Return_the_binary_representation), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_character_for_the_min, __pyx_k_Return_the_character_for_the_min, sizeof(__pyx_k_Return_the_character_for_the_min), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_cross_product_of_two, __pyx_k_Return_the_cross_product_of_two, sizeof(__pyx_k_Return_the_cross_product_of_two), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_cumulative_product_of, __pyx_k_Return_the_cumulative_product_of, sizeof(__pyx_k_Return_the_cumulative_product_of), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_cumulative_sum_of_the, __pyx_k_Return_the_cumulative_sum_of_the, sizeof(__pyx_k_Return_the_cumulative_sum_of_the), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_current_callback_func, __pyx_k_Return_the_current_callback_func, sizeof(__pyx_k_Return_the_current_callback_func), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_derivative_of_the_spe, __pyx_k_Return_the_derivative_of_the_spe, sizeof(__pyx_k_Return_the_derivative_of_the_spe), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_dot_product_of_two_ve, __pyx_k_Return_the_dot_product_of_two_ve, sizeof(__pyx_k_Return_the_dot_product_of_two_ve), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_elements_of_an_array, __pyx_k_Return_the_elements_of_an_array, sizeof(__pyx_k_Return_the_elements_of_an_array), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_gradient_of_an_N_dime, __pyx_k_Return_the_gradient_of_an_N_dime, sizeof(__pyx_k_Return_the_gradient_of_an_N_dime), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_imaginary_part_of_the, __pyx_k_Return_the_imaginary_part_of_the, sizeof(__pyx_k_Return_the_imaginary_part_of_the), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_indices_for_the_lower, __pyx_k_Return_the_indices_for_the_lower, sizeof(__pyx_k_Return_the_indices_for_the_lower), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_indices_for_the_upper, __pyx_k_Return_the_indices_for_the_upper, sizeof(__pyx_k_Return_the_indices_for_the_upper), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_indices_of_the_elemen, __pyx_k_Return_the_indices_of_the_elemen, sizeof(__pyx_k_Return_the_indices_of_the_elemen), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_indices_to_access_n_n, __pyx_k_Return_the_indices_to_access_n_n, sizeof(__pyx_k_Return_the_indices_to_access_n_n), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_indices_to_access_the, __pyx_k_Return_the_indices_to_access_the, sizeof(__pyx_k_Return_the_indices_to_access_the), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_maximum_of_an_array_o, __pyx_k_Return_the_maximum_of_an_array_o, sizeof(__pyx_k_Return_the_maximum_of_an_array_o), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_maximum_of_an_array_o_2, __pyx_k_Return_the_maximum_of_an_array_o_2, sizeof(__pyx_k_Return_the_maximum_of_an_array_o_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_minimum_of_an_array_o, __pyx_k_Return_the_minimum_of_an_array_o, sizeof(__pyx_k_Return_the_minimum_of_an_array_o), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_minimum_of_an_array_o_2, __pyx_k_Return_the_minimum_of_an_array_o_2, sizeof(__pyx_k_Return_the_minimum_of_an_array_o_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_number_of_dimensions, __pyx_k_Return_the_number_of_dimensions, sizeof(__pyx_k_Return_the_number_of_dimensions), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_number_of_dimensions_2, __pyx_k_Return_the_number_of_dimensions_2, sizeof(__pyx_k_Return_the_number_of_dimensions_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_number_of_elements_al, __pyx_k_Return_the_number_of_elements_al, sizeof(__pyx_k_Return_the_number_of_elements_al), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_product_of_array_elem, __pyx_k_Return_the_product_of_array_elem, sizeof(__pyx_k_Return_the_product_of_array_elem), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_real_part_of_the_elem, __pyx_k_Return_the_real_part_of_the_elem, sizeof(__pyx_k_Return_the_real_part_of_the_elem), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_roots_of_a_polynomial, __pyx_k_Return_the_roots_of_a_polynomial, sizeof(__pyx_k_Return_the_roots_of_a_polynomial), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_scalar_dtype_or_NumPy, __pyx_k_Return_the_scalar_dtype_or_NumPy, sizeof(__pyx_k_Return_the_scalar_dtype_or_NumPy), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_scalar_type_of_highes, __pyx_k_Return_the_scalar_type_of_highes, sizeof(__pyx_k_Return_the_scalar_type_of_highes), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_sinc_function_The_sin, __pyx_k_Return_the_sinc_function_The_sin, sizeof(__pyx_k_Return_the_sinc_function_The_sin), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_string_representation, __pyx_k_Return_the_string_representation, sizeof(__pyx_k_Return_the_string_representation), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_string_representation_2, __pyx_k_Return_the_string_representation_2, sizeof(__pyx_k_Return_the_string_representation_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_sum_along_diagonals_o, __pyx_k_Return_the_sum_along_diagonals_o, sizeof(__pyx_k_Return_the_sum_along_diagonals_o), 0, 1, 0, 0},
  {&__pyx_kp_u_Return_the_sum_of_array_elements, __pyx_k_Return_the_sum_of_array_elements, sizeof(__pyx_k_Return_the_sum_of_array_elements), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_True_if_array_is_arrange, __pyx_k_Returns_True_if_array_is_arrange, sizeof(__pyx_k_Returns_True_if_array_is_arrange), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_True_if_first_argument_i, __pyx_k_Returns_True_if_first_argument_i, sizeof(__pyx_k_Returns_True_if_first_argument_i), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_True_if_input_arrays_are, __pyx_k_Returns_True_if_input_arrays_are, sizeof(__pyx_k_Returns_True_if_input_arrays_are), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_True_if_the_type_of_num, __pyx_k_Returns_True_if_the_type_of_num, sizeof(__pyx_k_Returns_True_if_the_type_of_num), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_True_if_two_arrays_are_e, __pyx_k_Returns_True_if_two_arrays_are_e, sizeof(__pyx_k_Returns_True_if_two_arrays_are_e), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_a_bool_array_where_True, __pyx_k_Returns_a_bool_array_where_True, sizeof(__pyx_k_Returns_a_bool_array_where_True), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_a_bool_array_where_True_2, __pyx_k_Returns_a_bool_array_where_True_2, sizeof(__pyx_k_Returns_a_bool_array_where_True_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_pointers_to_the_end_poin, __pyx_k_Returns_pointers_to_the_end_poin, sizeof(__pyx_k_Returns_pointers_to_the_end_poin), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_the_NPV_Net_Present_Valu, __pyx_k_Returns_the_NPV_Net_Present_Valu, sizeof(__pyx_k_Returns_the_NPV_Net_Present_Valu), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_the_discrete_linear_conv, __pyx_k_Returns_the_discrete_linear_conv, sizeof(__pyx_k_Returns_the_discrete_linear_conv), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_the_indices_that_would_s, __pyx_k_Returns_the_indices_that_would_s, sizeof(__pyx_k_Returns_the_indices_that_would_s), 0, 1, 0, 0},
  {&__pyx_kp_u_Returns_the_quotient_and_remaind, __pyx_k_Returns_the_quotient_and_remaind, sizeof(__pyx_k_Returns_the_quotient_and_remaind), 0, 1, 0, 0},
  {&__pyx_kp_u_Roll_array_elements_along_a_give, __pyx_k_Roll_array_elements_along_a_give, sizeof(__pyx_k_Roll_array_elements_along_a_give), 0, 1, 0, 0},
  {&__pyx_kp_u_Roll_the_specified_axis_backward, __pyx_k_Roll_the_specified_axis_backward, sizeof(__pyx_k_Roll_the_specified_axis_backward), 0, 1, 0, 0},
  {&__pyx_kp_u_Rotate_an_array_by_90_degrees_in, __pyx_k_Rotate_an_array_by_90_degrees_in, sizeof(__pyx_k_Rotate_an_array_by_90_degrees_in), 0, 1, 0, 0},
  {&__pyx_kp_u_Round_to_nearest_integer_towards, __pyx_k_Round_to_nearest_integer_towards, sizeof(__pyx_k_Round_to_nearest_integer_towards), 0, 1, 0, 0},
  {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
  {&__pyx_kp_u_Save_an_array_to_a_binary_file_i, __pyx_k_Save_an_array_to_a_binary_file_i, sizeof(__pyx_k_Save_an_array_to_a_binary_file_i), 0, 1, 0, 0},
  {&__pyx_kp_u_Save_an_array_to_a_text_file_Par, __pyx_k_Save_an_array_to_a_text_file_Par, sizeof(__pyx_k_Save_an_array_to_a_text_file_Par), 0, 1, 0, 0},
  {&__pyx_kp_u_Save_several_arrays_into_a_singl, __pyx_k_Save_several_arrays_into_a_singl, sizeof(__pyx_k_Save_several_arrays_into_a_singl), 0, 1, 0, 0},
  {&__pyx_kp_u_Set_a_Python_function_to_be_used, __pyx_k_Set_a_Python_function_to_be_used, sizeof(__pyx_k_Set_a_Python_function_to_be_used), 0, 1, 0, 0},
  {&__pyx_kp_u_Set_how_floating_point_errors_ar, __pyx_k_Set_how_floating_point_errors_ar, sizeof(__pyx_k_Set_how_floating_point_errors_ar), 0, 1, 0, 0},
  {&__pyx_kp_u_Set_printing_options_These_optio, __pyx_k_Set_printing_options_These_optio, sizeof(__pyx_k_Set_printing_options_These_optio), 0, 1, 0, 0},
  {&__pyx_kp_u_Set_the_floating_point_error_cal, __pyx_k_Set_the_floating_point_error_cal, sizeof(__pyx_k_Set_the_floating_point_error_cal), 0, 1, 0, 0},
  {&__pyx_kp_u_Sort_a_complex_array_using_the_r, __pyx_k_Sort_a_complex_array_using_the_r, sizeof(__pyx_k_Sort_a_complex_array_using_the_r), 0, 1, 0, 0},
  {&__pyx_kp_u_Split_an_array_into_multiple_sub, __pyx_k_Split_an_array_into_multiple_sub, sizeof(__pyx_k_Split_an_array_into_multiple_sub), 0, 1, 0, 0},
  {&__pyx_kp_u_Split_an_array_into_multiple_sub_2, __pyx_k_Split_an_array_into_multiple_sub_2, sizeof(__pyx_k_Split_an_array_into_multiple_sub_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Split_an_array_into_multiple_sub_3, __pyx_k_Split_an_array_into_multiple_sub_3, sizeof(__pyx_k_Split_an_array_into_multiple_sub_3), 0, 1, 0, 0},
  {&__pyx_kp_u_Split_an_array_into_multiple_sub_4, __pyx_k_Split_an_array_into_multiple_sub_4, sizeof(__pyx_k_Split_an_array_into_multiple_sub_4), 0, 1, 0, 0},
  {&__pyx_kp_u_Split_array_into_multiple_sub_ar, __pyx_k_Split_array_into_multiple_sub_ar, sizeof(__pyx_k_Split_array_into_multiple_sub_ar), 0, 1, 0, 0},
  {&__pyx_kp_u_Stack_1_D_arrays_as_columns_into, __pyx_k_Stack_1_D_arrays_as_columns_into, sizeof(__pyx_k_Stack_1_D_arrays_as_columns_into), 0, 1, 0, 0},
  {&__pyx_kp_u_Stack_arrays_in_sequence_depth_w, __pyx_k_Stack_arrays_in_sequence_depth_w, sizeof(__pyx_k_Stack_arrays_in_sequence_depth_w), 0, 1, 0, 0},
  {&__pyx_kp_u_Stack_arrays_in_sequence_horizon, __pyx_k_Stack_arrays_in_sequence_horizon, sizeof(__pyx_k_Stack_arrays_in_sequence_horizon), 0, 1, 0, 0},
  {&__pyx_kp_u_Stack_arrays_in_sequence_vertica, __pyx_k_Stack_arrays_in_sequence_vertica, sizeof(__pyx_k_Stack_arrays_in_sequence_vertica), 0, 1, 0, 0},
  {&__pyx_kp_u_Sum_of_array_elements_over_a_giv, __pyx_k_Sum_of_array_elements_over_a_giv, sizeof(__pyx_k_Sum_of_array_elements_over_a_giv), 0, 1, 0, 0},
  {&__pyx_kp_u_Take_elements_from_an_array_alon, __pyx_k_Take_elements_from_an_array_alon, sizeof(__pyx_k_Take_elements_from_an_array_alon), 0, 1, 0, 0},
  {&__pyx_kp_u_Test_element_wise_for_negative_i, __pyx_k_Test_element_wise_for_negative_i, sizeof(__pyx_k_Test_element_wise_for_negative_i), 0, 1, 0, 0},
  {&__pyx_kp_u_Test_element_wise_for_positive_i, __pyx_k_Test_element_wise_for_positive_i, sizeof(__pyx_k_Test_element_wise_for_positive_i), 0, 1, 0, 0},
  {&__pyx_kp_u_Test_whether_all_array_elements, __pyx_k_Test_whether_all_array_elements, sizeof(__pyx_k_Test_whether_all_array_elements), 0, 1, 0, 0},
  {&__pyx_kp_u_Test_whether_any_array_element_a, __pyx_k_Test_whether_any_array_element_a, sizeof(__pyx_k_Test_whether_any_array_element_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Test_whether_each_element_of_a_1, __pyx_k_Test_whether_each_element_of_a_1, sizeof(__pyx_k_Test_whether_each_element_of_a_1), 0, 1, 0, 0},
  {&__pyx_kp_u_The_differences_between_consecut, __pyx_k_The_differences_between_consecut, sizeof(__pyx_k_The_differences_between_consecut), 0, 1, 0, 0},
  {&__pyx_kp_u_Trim_the_leading_and_or_trailing, __pyx_k_Trim_the_leading_and_or_trailing, sizeof(__pyx_k_Trim_the_leading_and_or_trailing), 0, 1, 0, 0},
  {&__pyx_kp_u_True_if_two_arrays_have_the_same, __pyx_k_True_if_two_arrays_have_the_same, sizeof(__pyx_k_True_if_two_arrays_have_the_same), 0, 1, 0, 0},
  {&__pyx_kp_u_Unwrap_by_changing_deltas_betwee, __pyx_k_Unwrap_by_changing_deltas_betwee, sizeof(__pyx_k_Unwrap_by_changing_deltas_betwee), 0, 1, 0, 0},
  {&__pyx_kp_u_Upper_triangle_of_an_array_Retur, __pyx_k_Upper_triangle_of_an_array_Retur, sizeof(__pyx_k_Upper_triangle_of_an_array_Retur), 0, 1, 0, 0},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_kp_u_View_inputs_as_arrays_with_at_le, __pyx_k_View_inputs_as_arrays_with_at_le, sizeof(__pyx_k_View_inputs_as_arrays_with_at_le), 0, 1, 0, 0},
  {&__pyx_kp_u_View_inputs_as_arrays_with_at_le_2, __pyx_k_View_inputs_as_arrays_with_at_le_2, sizeof(__pyx_k_View_inputs_as_arrays_with_at_le_2), 0, 1, 0, 0},
  {&__pyx_n_s_X, __pyx_k_X, sizeof(__pyx_k_X), 0, 0, 1, 1},
  {&__pyx_n_s__10, __pyx_k__10, sizeof(__pyx_k__10), 0, 0, 1, 1},
  {&__pyx_kp_s__14, __pyx_k__14, sizeof(__pyx_k__14), 0, 0, 1, 0},
  {&__pyx_kp_s__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 0, 1, 0},
  {&__pyx_kp_s__9, __pyx_k__9, sizeof(__pyx_k__9), 0, 0, 1, 0},
  {&__pyx_n_s_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 0, 1, 1},
  {&__pyx_n_s_a1, __pyx_k_a1, sizeof(__pyx_k_a1), 0, 0, 1, 1},
  {&__pyx_n_s_a2, __pyx_k_a2, sizeof(__pyx_k_a2), 0, 0, 1, 1},
  {&__pyx_n_s_add_newdoc, __pyx_k_add_newdoc, sizeof(__pyx_k_add_newdoc), 0, 0, 1, 1},
  {&__pyx_n_s_all, __pyx_k_all, sizeof(__pyx_k_all), 0, 0, 1, 1},
  {&__pyx_kp_u_all_line_40, __pyx_k_all_line_40, sizeof(__pyx_k_all_line_40), 0, 1, 0, 0},
  {&__pyx_n_s_allclose, __pyx_k_allclose, sizeof(__pyx_k_allclose), 0, 0, 1, 1},
  {&__pyx_kp_u_allclose_line_99, __pyx_k_allclose_line_99, sizeof(__pyx_k_allclose_line_99), 0, 1, 0, 0},
  {&__pyx_n_s_alltrue, __pyx_k_alltrue, sizeof(__pyx_k_alltrue), 0, 0, 1, 1},
  {&__pyx_n_s_alterdot, __pyx_k_alterdot, sizeof(__pyx_k_alterdot), 0, 0, 1, 1},
  {&__pyx_n_s_amax, __pyx_k_amax, sizeof(__pyx_k_amax), 0, 0, 1, 1},
  {&__pyx_kp_u_amax_line_187, __pyx_k_amax_line_187, sizeof(__pyx_k_amax_line_187), 0, 1, 0, 0},
  {&__pyx_n_s_amin, __pyx_k_amin, sizeof(__pyx_k_amin), 0, 0, 1, 1},
  {&__pyx_kp_u_amin_line_244, __pyx_k_amin_line_244, sizeof(__pyx_k_amin_line_244), 0, 1, 0, 0},
  {&__pyx_n_s_angle, __pyx_k_angle, sizeof(__pyx_k_angle), 0, 0, 1, 1},
  {&__pyx_kp_u_angle_line_301, __pyx_k_angle_line_301, sizeof(__pyx_k_angle_line_301), 0, 1, 0, 0},
  {&__pyx_n_s_any, __pyx_k_any, sizeof(__pyx_k_any), 0, 0, 1, 1},
  {&__pyx_kp_u_any_line_335, __pyx_k_any_line_335, sizeof(__pyx_k_any_line_335), 0, 1, 0, 0},
  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
  {&__pyx_kp_u_append_line_401, __pyx_k_append_line_401, sizeof(__pyx_k_append_line_401), 0, 1, 0, 0},
  {&__pyx_n_s_apply_along_axis, __pyx_k_apply_along_axis, sizeof(__pyx_k_apply_along_axis), 0, 0, 1, 1},
  {&__pyx_kp_u_apply_along_axis_line_449, __pyx_k_apply_along_axis_line_449, sizeof(__pyx_k_apply_along_axis_line_449), 0, 1, 0, 0},
  {&__pyx_n_s_apply_over_axes, __pyx_k_apply_over_axes, sizeof(__pyx_k_apply_over_axes), 0, 0, 1, 1},
  {&__pyx_kp_u_apply_over_axes_line_506, __pyx_k_apply_over_axes_line_506, sizeof(__pyx_k_apply_over_axes_line_506), 0, 1, 0, 0},
  {&__pyx_n_s_ar, __pyx_k_ar, sizeof(__pyx_k_ar), 0, 0, 1, 1},
  {&__pyx_n_s_ar1, __pyx_k_ar1, sizeof(__pyx_k_ar1), 0, 0, 1, 1},
  {&__pyx_n_s_ar2, __pyx_k_ar2, sizeof(__pyx_k_ar2), 0, 0, 1, 1},
  {&__pyx_n_s_arg1, __pyx_k_arg1, sizeof(__pyx_k_arg1), 0, 0, 1, 1},
  {&__pyx_n_s_arg2, __pyx_k_arg2, sizeof(__pyx_k_arg2), 0, 0, 1, 1},
  {&__pyx_n_s_argmax, __pyx_k_argmax, sizeof(__pyx_k_argmax), 0, 0, 1, 1},
  {&__pyx_kp_u_argmax_line_560, __pyx_k_argmax_line_560, sizeof(__pyx_k_argmax_line_560), 0, 1, 0, 0},
  {&__pyx_n_s_argmin, __pyx_k_argmin, sizeof(__pyx_k_argmin), 0, 0, 1, 1},
  {&__pyx_n_s_argsort, __pyx_k_argsort, sizeof(__pyx_k_argsort), 0, 0, 1, 1},
  {&__pyx_kp_u_argsort_line_624, __pyx_k_argsort_line_624, sizeof(__pyx_k_argsort_line_624), 0, 1, 0, 0},
  {&__pyx_n_s_argwhere, __pyx_k_argwhere, sizeof(__pyx_k_argwhere), 0, 0, 1, 1},
  {&__pyx_kp_u_argwhere_line_704, __pyx_k_argwhere_line_704, sizeof(__pyx_k_argwhere_line_704), 0, 1, 0, 0},
  {&__pyx_n_s_around, __pyx_k_around, sizeof(__pyx_k_around), 0, 0, 1, 1},
  {&__pyx_kp_u_around_line_744, __pyx_k_around_line_744, sizeof(__pyx_k_around_line_744), 0, 1, 0, 0},
  {&__pyx_n_s_arr, __pyx_k_arr, sizeof(__pyx_k_arr), 0, 0, 1, 1},
  {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
  {&__pyx_n_s_array2string, __pyx_k_array2string, sizeof(__pyx_k_array2string), 0, 0, 1, 1},
  {&__pyx_kp_u_array2string_line_906, __pyx_k_array2string_line_906, sizeof(__pyx_k_array2string_line_906), 0, 1, 0, 0},
  {&__pyx_n_s_array_equal, __pyx_k_array_equal, sizeof(__pyx_k_array_equal), 0, 0, 1, 1},
  {&__pyx_kp_u_array_equal_line_955, __pyx_k_array_equal_line_955, sizeof(__pyx_k_array_equal_line_955), 0, 1, 0, 0},
  {&__pyx_n_s_array_equiv, __pyx_k_array_equiv, sizeof(__pyx_k_array_equiv), 0, 0, 1, 1},
  {&__pyx_kp_u_array_equiv_line_990, __pyx_k_array_equiv_line_990, sizeof(__pyx_k_array_equiv_line_990), 0, 1, 0, 0},
  {&__pyx_kp_u_array_line_812, __pyx_k_array_line_812, sizeof(__pyx_k_array_line_812), 0, 1, 0, 0},
  {&__pyx_kp_u_array_object_dtype_None_copy_Tru, __pyx_k_array_object_dtype_None_copy_Tru, sizeof(__pyx_k_array_object_dtype_None_copy_Tru), 0, 1, 0, 0},
  {&__pyx_n_s_array_repr, __pyx_k_array_repr, sizeof(__pyx_k_array_repr), 0, 0, 1, 1},
  {&__pyx_kp_u_array_repr_line_1027, __pyx_k_array_repr_line_1027, sizeof(__pyx_k_array_repr_line_1027), 0, 1, 0, 0},
  {&__pyx_n_s_array_split, __pyx_k_array_split, sizeof(__pyx_k_array_split), 0, 0, 1, 1},
  {&__pyx_kp_u_array_split_line_1071, __pyx_k_array_split_line_1071, sizeof(__pyx_k_array_split_line_1071), 0, 1, 0, 0},
  {&__pyx_n_s_array_str, __pyx_k_array_str, sizeof(__pyx_k_array_str), 0, 0, 1, 1},
  {&__pyx_kp_u_array_str_line_1093, __pyx_k_array_str_line_1093, sizeof(__pyx_k_array_str_line_1093), 0, 1, 0, 0},
  {&__pyx_n_s_array_types, __pyx_k_array_types, sizeof(__pyx_k_array_types), 0, 0, 1, 1},
  {&__pyx_n_s_arrays_and_dtypes, __pyx_k_arrays_and_dtypes, sizeof(__pyx_k_arrays_and_dtypes), 0, 0, 1, 1},
  {&__pyx_n_s_ary, __pyx_k_ary, sizeof(__pyx_k_ary), 0, 0, 1, 1},
  {&__pyx_n_s_asanyarray, __pyx_k_asanyarray, sizeof(__pyx_k_asanyarray), 0, 0, 1, 1},
  {&__pyx_kp_u_asanyarray_line_1129, __pyx_k_asanyarray_line_1129, sizeof(__pyx_k_asanyarray_line_1129), 0, 1, 0, 0},
  {&__pyx_n_s_asarray_chkfinite, __pyx_k_asarray_chkfinite, sizeof(__pyx_k_asarray_chkfinite), 0, 0, 1, 1},
  {&__pyx_kp_u_asarray_chkfinite_line_1181, __pyx_k_asarray_chkfinite_line_1181, sizeof(__pyx_k_asarray_chkfinite_line_1181), 0, 1, 0, 0},
  {&__pyx_n_s_ascontiguousarray, __pyx_k_ascontiguousarray, sizeof(__pyx_k_ascontiguousarray), 0, 0, 1, 1},
  {&__pyx_kp_u_ascontiguousarray_line_1243, __pyx_k_ascontiguousarray_line_1243, sizeof(__pyx_k_ascontiguousarray_line_1243), 0, 1, 0, 0},
  {&__pyx_n_s_asfarray, __pyx_k_asfarray, sizeof(__pyx_k_asfarray), 0, 0, 1, 1},
  {&__pyx_kp_u_asfarray_line_1279, __pyx_k_asfarray_line_1279, sizeof(__pyx_k_asfarray_line_1279), 0, 1, 0, 0},
  {&__pyx_n_s_asfortranarray, __pyx_k_asfortranarray, sizeof(__pyx_k_asfortranarray), 0, 0, 1, 1},
  {&__pyx_kp_u_asfortranarray_line_1308, __pyx_k_asfortranarray_line_1308, sizeof(__pyx_k_asfortranarray_line_1308), 0, 1, 0, 0},
  {&__pyx_n_s_asmatrix, __pyx_k_asmatrix, sizeof(__pyx_k_asmatrix), 0, 0, 1, 1},
  {&__pyx_kp_u_asmatrix_line_1344, __pyx_k_asmatrix_line_1344, sizeof(__pyx_k_asmatrix_line_1344), 0, 1, 0, 0},
  {&__pyx_n_s_asscalar, __pyx_k_asscalar, sizeof(__pyx_k_asscalar), 0, 0, 1, 1},
  {&__pyx_kp_u_asscalar_line_1376, __pyx_k_asscalar_line_1376, sizeof(__pyx_k_asscalar_line_1376), 0, 1, 0, 0},
  {&__pyx_n_s_assume_unique, __pyx_k_assume_unique, sizeof(__pyx_k_assume_unique), 0, 0, 1, 1},
  {&__pyx_n_s_atleast_1d, __pyx_k_atleast_1d, sizeof(__pyx_k_atleast_1d), 0, 0, 1, 1},
  {&__pyx_kp_u_atleast_1d_line_1398, __pyx_k_atleast_1d_line_1398, sizeof(__pyx_k_atleast_1d_line_1398), 0, 1, 0, 0},
  {&__pyx_n_s_atleast_2d, __pyx_k_atleast_2d, sizeof(__pyx_k_atleast_2d), 0, 0, 1, 1},
  {&__pyx_kp_u_atleast_2d_line_1439, __pyx_k_atleast_2d_line_1439, sizeof(__pyx_k_atleast_2d_line_1439), 0, 1, 0, 0},
  {&__pyx_n_s_atleast_3d, __pyx_k_atleast_3d, sizeof(__pyx_k_atleast_3d), 0, 0, 1, 1},
  {&__pyx_kp_u_atleast_3d_line_1478, __pyx_k_atleast_3d_line_1478, sizeof(__pyx_k_atleast_3d_line_1478), 0, 1, 0, 0},
  {&__pyx_n_s_atol, __pyx_k_atol, sizeof(__pyx_k_atol), 0, 0, 1, 1},
  {&__pyx_n_s_autostrip, __pyx_k_autostrip, sizeof(__pyx_k_autostrip), 0, 0, 1, 1},
  {&__pyx_n_s_average, __pyx_k_average, sizeof(__pyx_k_average), 0, 0, 1, 1},
  {&__pyx_kp_u_average_line_1529, __pyx_k_average_line_1529, sizeof(__pyx_k_average_line_1529), 0, 1, 0, 0},
  {&__pyx_n_s_axes, __pyx_k_axes, sizeof(__pyx_k_axes), 0, 0, 1, 1},
  {&__pyx_n_s_axis, __pyx_k_axis, sizeof(__pyx_k_axis), 0, 0, 1, 1},
  {&__pyx_n_s_axis1, __pyx_k_axis1, sizeof(__pyx_k_axis1), 0, 0, 1, 1},
  {&__pyx_n_s_axis2, __pyx_k_axis2, sizeof(__pyx_k_axis2), 0, 0, 1, 1},
  {&__pyx_n_s_axisa, __pyx_k_axisa, sizeof(__pyx_k_axisa), 0, 0, 1, 1},
  {&__pyx_n_s_axisb, __pyx_k_axisb, sizeof(__pyx_k_axisb), 0, 0, 1, 1},
  {&__pyx_n_s_axisc, __pyx_k_axisc, sizeof(__pyx_k_axisc), 0, 0, 1, 1},
  {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
  {&__pyx_n_s_bartlett, __pyx_k_bartlett, sizeof(__pyx_k_bartlett), 0, 0, 1, 1},
  {&__pyx_kp_u_bartlett_line_1604, __pyx_k_bartlett_line_1604, sizeof(__pyx_k_bartlett_line_1604), 0, 1, 0, 0},
  {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
  {&__pyx_n_s_base_repr, __pyx_k_base_repr, sizeof(__pyx_k_base_repr), 0, 0, 1, 1},
  {&__pyx_kp_u_base_repr_line_1708, __pyx_k_base_repr_line_1708, sizeof(__pyx_k_base_repr_line_1708), 0, 1, 0, 0},
  {&__pyx_n_s_beta, __pyx_k_beta, sizeof(__pyx_k_beta), 0, 0, 1, 1},
  {&__pyx_n_s_bias, __pyx_k_bias, sizeof(__pyx_k_bias), 0, 0, 1, 1},
  {&__pyx_n_s_binary_repr, __pyx_k_binary_repr, sizeof(__pyx_k_binary_repr), 0, 0, 1, 1},
  {&__pyx_kp_u_binary_repr_line_1748, __pyx_k_binary_repr_line_1748, sizeof(__pyx_k_binary_repr_line_1748), 0, 1, 0, 0},
  {&__pyx_n_s_bincount, __pyx_k_bincount, sizeof(__pyx_k_bincount), 0, 0, 1, 1},
  {&__pyx_kp_u_bincount_line_1808, __pyx_k_bincount_line_1808, sizeof(__pyx_k_bincount_line_1808), 0, 1, 0, 0},
  {&__pyx_kp_u_bincount_x_weights_None_minlengt, __pyx_k_bincount_x_weights_None_minlengt, sizeof(__pyx_k_bincount_x_weights_None_minlengt), 0, 1, 0, 0},
  {&__pyx_n_s_bins, __pyx_k_bins, sizeof(__pyx_k_bins), 0, 0, 1, 1},
  {&__pyx_n_s_blackman, __pyx_k_blackman, sizeof(__pyx_k_blackman), 0, 0, 1, 1},
  {&__pyx_kp_u_blackman_line_1883, __pyx_k_blackman_line_1883, sizeof(__pyx_k_blackman_line_1883), 0, 1, 0, 0},
  {&__pyx_n_s_bmat, __pyx_k_bmat, sizeof(__pyx_k_bmat), 0, 0, 1, 1},
  {&__pyx_kp_u_bmat_line_1979, __pyx_k_bmat_line_1979, sizeof(__pyx_k_bmat_line_1979), 0, 1, 0, 0},
  {&__pyx_n_s_broadcast_arrays, __pyx_k_broadcast_arrays, sizeof(__pyx_k_broadcast_arrays), 0, 0, 1, 1},
  {&__pyx_kp_u_broadcast_arrays_line_2026, __pyx_k_broadcast_arrays_line_2026, sizeof(__pyx_k_broadcast_arrays_line_2026), 0, 1, 0, 0},
  {&__pyx_n_s_buffer, __pyx_k_buffer, sizeof(__pyx_k_buffer), 0, 0, 1, 1},
  {&__pyx_n_s_byte_bounds, __pyx_k_byte_bounds, sizeof(__pyx_k_byte_bounds), 0, 0, 1, 1},
  {&__pyx_kp_u_byte_bounds_line_2067, __pyx_k_byte_bounds_line_2067, sizeof(__pyx_k_byte_bounds_line_2067), 0, 1, 0, 0},
  {&__pyx_n_s_can_cast, __pyx_k_can_cast, sizeof(__pyx_k_can_cast), 0, 0, 1, 1},
  {&__pyx_kp_u_can_cast_from_totype_casting_saf, __pyx_k_can_cast_from_totype_casting_saf, sizeof(__pyx_k_can_cast_from_totype_casting_saf), 0, 1, 0, 0},
  {&__pyx_kp_u_can_cast_line_2099, __pyx_k_can_cast_line_2099, sizeof(__pyx_k_can_cast_line_2099), 0, 1, 0, 0},
  {&__pyx_n_s_case_sensitive, __pyx_k_case_sensitive, sizeof(__pyx_k_case_sensitive), 0, 0, 1, 1},
  {&__pyx_n_s_char, __pyx_k_char, sizeof(__pyx_k_char), 0, 0, 1, 1},
  {&__pyx_n_s_choicelist, __pyx_k_choicelist, sizeof(__pyx_k_choicelist), 0, 0, 1, 1},
  {&__pyx_n_s_choices, __pyx_k_choices, sizeof(__pyx_k_choices), 0, 0, 1, 1},
  {&__pyx_n_s_choose, __pyx_k_choose, sizeof(__pyx_k_choose), 0, 0, 1, 1},
  {&__pyx_kp_u_choose_line_2202, __pyx_k_choose_line_2202, sizeof(__pyx_k_choose_line_2202), 0, 1, 0, 0},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_column_stack, __pyx_k_column_stack, sizeof(__pyx_k_column_stack), 0, 0, 1, 1},
  {&__pyx_kp_u_column_stack_line_2323, __pyx_k_column_stack_line_2323, sizeof(__pyx_k_column_stack_line_2323), 0, 1, 0, 0},
  {&__pyx_n_s_comments, __pyx_k_comments, sizeof(__pyx_k_comments), 0, 0, 1, 1},
  {&__pyx_n_s_common_type, __pyx_k_common_type, sizeof(__pyx_k_common_type), 0, 0, 1, 1},
  {&__pyx_kp_u_common_type_line_2362, __pyx_k_common_type_line_2362, sizeof(__pyx_k_common_type_line_2362), 0, 1, 0, 0},
  {&__pyx_n_s_compare_chararrays, __pyx_k_compare_chararrays, sizeof(__pyx_k_compare_chararrays), 0, 0, 1, 1},
  {&__pyx_n_s_compress, __pyx_k_compress, sizeof(__pyx_k_compress), 0, 0, 1, 1},
  {&__pyx_kp_u_compress_line_2408, __pyx_k_compress_line_2408, sizeof(__pyx_k_compress_line_2408), 0, 1, 0, 0},
  {&__pyx_n_s_concatenate, __pyx_k_concatenate, sizeof(__pyx_k_concatenate), 0, 0, 1, 1},
  {&__pyx_kp_u_concatenate_a1_a2_axis_0_Join_a, __pyx_k_concatenate_a1_a2_axis_0_Join_a, sizeof(__pyx_k_concatenate_a1_a2_axis_0_Join_a), 0, 1, 0, 0},
  {&__pyx_kp_u_concatenate_line_2469, __pyx_k_concatenate_line_2469, sizeof(__pyx_k_concatenate_line_2469), 0, 1, 0, 0},
  {&__pyx_n_s_condition, __pyx_k_condition, sizeof(__pyx_k_condition), 0, 0, 1, 1},
  {&__pyx_n_s_condlist, __pyx_k_condlist, sizeof(__pyx_k_condlist), 0, 0, 1, 1},
  {&__pyx_n_s_converters, __pyx_k_converters, sizeof(__pyx_k_converters), 0, 0, 1, 1},
  {&__pyx_n_s_convolve, __pyx_k_convolve, sizeof(__pyx_k_convolve), 0, 0, 1, 1},
  {&__pyx_kp_u_convolve_line_2545, __pyx_k_convolve_line_2545, sizeof(__pyx_k_convolve_line_2545), 0, 1, 0, 0},
  {&__pyx_n_s_copy, __pyx_k_copy, sizeof(__pyx_k_copy), 0, 0, 1, 1},
  {&__pyx_kp_u_copy_line_2630, __pyx_k_copy_line_2630, sizeof(__pyx_k_copy_line_2630), 0, 1, 0, 0},
  {&__pyx_n_s_corrcoef, __pyx_k_corrcoef, sizeof(__pyx_k_corrcoef), 0, 0, 1, 1},
  {&__pyx_n_s_correlate, __pyx_k_correlate, sizeof(__pyx_k_correlate), 0, 0, 1, 1},
  {&__pyx_kp_u_correlate_line_2718, __pyx_k_correlate_line_2718, sizeof(__pyx_k_correlate_line_2718), 0, 1, 0, 0},
  {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
  {&__pyx_n_s_count_nonzero, __pyx_k_count_nonzero, sizeof(__pyx_k_count_nonzero), 0, 0, 1, 1},
  {&__pyx_kp_u_count_nonzero_a_Counts_the_numbe, __pyx_k_count_nonzero_a_Counts_the_numbe, sizeof(__pyx_k_count_nonzero_a_Counts_the_numbe), 0, 1, 0, 0},
  {&__pyx_kp_u_count_nonzero_line_2758, __pyx_k_count_nonzero_line_2758, sizeof(__pyx_k_count_nonzero_line_2758), 0, 1, 0, 0},
  {&__pyx_n_s_cov, __pyx_k_cov, sizeof(__pyx_k_cov), 0, 0, 1, 1},
  {&__pyx_kp_u_cov_line_2790, __pyx_k_cov_line_2790, sizeof(__pyx_k_cov_line_2790), 0, 1, 0, 0},
  {&__pyx_n_s_cross, __pyx_k_cross, sizeof(__pyx_k_cross), 0, 0, 1, 1},
  {&__pyx_kp_u_cross_line_2871, __pyx_k_cross_line_2871, sizeof(__pyx_k_cross_line_2871), 0, 1, 0, 0},
  {&__pyx_n_s_cumprod, __pyx_k_cumprod, sizeof(__pyx_k_cumprod), 0, 0, 1, 1},
  {&__pyx_kp_u_cumprod_line_2979, __pyx_k_cumprod_line_2979, sizeof(__pyx_k_cumprod_line_2979), 0, 1, 0, 0},
  {&__pyx_n_s_cumproduct, __pyx_k_cumproduct, sizeof(__pyx_k_cumproduct), 0, 0, 1, 1},
  {&__pyx_n_s_cumsum, __pyx_k_cumsum, sizeof(__pyx_k_cumsum), 0, 0, 1, 1},
  {&__pyx_kp_u_cumsum_line_3053, __pyx_k_cumsum_line_3053, sizeof(__pyx_k_cumsum_line_3053), 0, 1, 0, 0},
  {&__pyx_n_s_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 0, 1, 1},
  {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
  {&__pyx_n_s_datetime_data, __pyx_k_datetime_data, sizeof(__pyx_k_datetime_data), 0, 0, 1, 1},
  {&__pyx_n_s_ddof, __pyx_k_ddof, sizeof(__pyx_k_ddof), 0, 0, 1, 1},
  {&__pyx_n_s_decimals, __pyx_k_decimals, sizeof(__pyx_k_decimals), 0, 0, 1, 1},
  {&__pyx_n_s_default, __pyx_k_default, sizeof(__pyx_k_default), 0, 0, 1, 1},
  {&__pyx_n_s_defaultfmt, __pyx_k_defaultfmt, sizeof(__pyx_k_defaultfmt), 0, 0, 1, 1},
  {&__pyx_n_s_deg, __pyx_k_deg, sizeof(__pyx_k_deg), 0, 0, 1, 1},
  {&__pyx_n_s_delete, __pyx_k_delete, sizeof(__pyx_k_delete), 0, 0, 1, 1},
  {&__pyx_kp_u_delete_line_3124, __pyx_k_delete_line_3124, sizeof(__pyx_k_delete_line_3124), 0, 1, 0, 0},
  {&__pyx_n_s_deletechars, __pyx_k_deletechars, sizeof(__pyx_k_deletechars), 0, 0, 1, 1},
  {&__pyx_n_s_delimiter, __pyx_k_delimiter, sizeof(__pyx_k_delimiter), 0, 0, 1, 1},
  {&__pyx_n_s_density, __pyx_k_density, sizeof(__pyx_k_density), 0, 0, 1, 1},
  {&__pyx_n_s_deprecate, __pyx_k_deprecate, sizeof(__pyx_k_deprecate), 0, 0, 1, 1},
  {&__pyx_kp_u_deprecate_line_3171, __pyx_k_deprecate_line_3171, sizeof(__pyx_k_deprecate_line_3171), 0, 1, 0, 0},
  {&__pyx_n_s_deprecate_with_doc, __pyx_k_deprecate_with_doc, sizeof(__pyx_k_deprecate_with_doc), 0, 0, 1, 1},
  {&__pyx_n_s_device, __pyx_k_device, sizeof(__pyx_k_device), 0, 0, 1, 1},
  {&__pyx_n_s_diag_indices, __pyx_k_diag_indices, sizeof(__pyx_k_diag_indices), 0, 0, 1, 1},
  {&__pyx_n_s_diag_indices_from, __pyx_k_diag_indices_from, sizeof(__pyx_k_diag_indices_from), 0, 0, 1, 1},
  {&__pyx_kp_u_diag_indices_line_3221, __pyx_k_diag_indices_line_3221, sizeof(__pyx_k_diag_indices_line_3221), 0, 1, 0, 0},
  {&__pyx_n_s_diagflat, __pyx_k_diagflat, sizeof(__pyx_k_diagflat), 0, 0, 1, 1},
  {&__pyx_kp_u_diagflat_line_3308, __pyx_k_diagflat_line_3308, sizeof(__pyx_k_diagflat_line_3308), 0, 1, 0, 0},
  {&__pyx_n_s_diff, __pyx_k_diff, sizeof(__pyx_k_diff), 0, 0, 1, 1},
  {&__pyx_kp_u_diff_line_3349, __pyx_k_diff_line_3349, sizeof(__pyx_k_diff_line_3349), 0, 1, 0, 0},
  {&__pyx_n_s_digitize, __pyx_k_digitize, sizeof(__pyx_k_digitize), 0, 0, 1, 1},
  {&__pyx_kp_u_digitize_line_3394, __pyx_k_digitize_line_3394, sizeof(__pyx_k_digitize_line_3394), 0, 1, 0, 0},
  {&__pyx_kp_u_digitize_x_bins_Return_the_indic, __pyx_k_digitize_x_bins_Return_the_indic, sizeof(__pyx_k_digitize_x_bins_Return_the_indic), 0, 1, 0, 0},
  {&__pyx_n_s_dimensions, __pyx_k_dimensions, sizeof(__pyx_k_dimensions), 0, 0, 1, 1},
  {&__pyx_n_s_dims, __pyx_k_dims, sizeof(__pyx_k_dims), 0, 0, 1, 1},
  {&__pyx_n_s_discont, __pyx_k_discont, sizeof(__pyx_k_discont), 0, 0, 1, 1},
  {&__pyx_n_s_disp, __pyx_k_disp, sizeof(__pyx_k_disp), 0, 0, 1, 1},
  {&__pyx_kp_u_disp_line_3453, __pyx_k_disp_line_3453, sizeof(__pyx_k_disp_line_3453), 0, 1, 0, 0},
  {&__pyx_n_s_divide, __pyx_k_divide, sizeof(__pyx_k_divide), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_docstring, __pyx_k_docstring, sizeof(__pyx_k_docstring), 0, 0, 1, 1},
  {&__pyx_n_s_dsplit, __pyx_k_dsplit, sizeof(__pyx_k_dsplit), 0, 0, 1, 1},
  {&__pyx_kp_u_dsplit_line_3487, __pyx_k_dsplit_line_3487, sizeof(__pyx_k_dsplit_line_3487), 0, 1, 0, 0},
  {&__pyx_n_s_dstack, __pyx_k_dstack, sizeof(__pyx_k_dstack), 0, 0, 1, 1},
  {&__pyx_kp_u_dstack_line_3530, __pyx_k_dstack_line_3530, sizeof(__pyx_k_dstack_line_3530), 0, 1, 0, 0},
  {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_dx, __pyx_k_dx, sizeof(__pyx_k_dx), 0, 0, 1, 1},
  {&__pyx_n_s_edgeitems, __pyx_k_edgeitems, sizeof(__pyx_k_edgeitems), 0, 0, 1, 1},
  {&__pyx_n_s_ediff1d, __pyx_k_ediff1d, sizeof(__pyx_k_ediff1d), 0, 0, 1, 1},
  {&__pyx_kp_u_ediff1d_line_3580, __pyx_k_ediff1d_line_3580, sizeof(__pyx_k_ediff1d_line_3580), 0, 1, 0, 0},
  {&__pyx_n_s_einsum, __pyx_k_einsum, sizeof(__pyx_k_einsum), 0, 0, 1, 1},
  {&__pyx_kp_u_einsum_line_3625, __pyx_k_einsum_line_3625, sizeof(__pyx_k_einsum_line_3625), 0, 1, 0, 0},
  {&__pyx_kp_u_einsum_subscripts_operands_out_N, __pyx_k_einsum_subscripts_operands_out_N, sizeof(__pyx_k_einsum_subscripts_operands_out_N), 0, 1, 0, 0},
  {&__pyx_n_s_end, __pyx_k_end, sizeof(__pyx_k_end), 0, 0, 1, 1},
  {&__pyx_n_s_errobj, __pyx_k_errobj, sizeof(__pyx_k_errobj), 0, 0, 1, 1},
  {&__pyx_n_s_excludelist, __pyx_k_excludelist, sizeof(__pyx_k_excludelist), 0, 0, 1, 1},
  {&__pyx_n_s_expand_dims, __pyx_k_expand_dims, sizeof(__pyx_k_expand_dims), 0, 0, 1, 1},
  {&__pyx_kp_u_expand_dims_line_3817, __pyx_k_expand_dims_line_3817, sizeof(__pyx_k_expand_dims_line_3817), 0, 1, 0, 0},
  {&__pyx_n_s_extract, __pyx_k_extract, sizeof(__pyx_k_extract), 0, 0, 1, 1},
  {&__pyx_kp_u_extract_line_3870, __pyx_k_extract_line_3870, sizeof(__pyx_k_extract_line_3870), 0, 1, 0, 0},
  {&__pyx_n_s_f, __pyx_k_f, sizeof(__pyx_k_f), 0, 0, 1, 1},
  {&__pyx_kp_s_f_i, __pyx_k_f_i, sizeof(__pyx_k_f_i), 0, 0, 1, 0},
  {&__pyx_n_s_fastCopyAndTranspose, __pyx_k_fastCopyAndTranspose, sizeof(__pyx_k_fastCopyAndTranspose), 0, 0, 1, 1},
  {&__pyx_n_s_fb, __pyx_k_fb, sizeof(__pyx_k_fb), 0, 0, 1, 1},
  {&__pyx_n_s_file, __pyx_k_file, sizeof(__pyx_k_file), 0, 0, 1, 1},
  {&__pyx_n_s_fill_diagonal, __pyx_k_fill_diagonal, sizeof(__pyx_k_fill_diagonal), 0, 0, 1, 1},
  {&__pyx_kp_u_fill_diagonal_line_3921, __pyx_k_fill_diagonal_line_3921, sizeof(__pyx_k_fill_diagonal_line_3921), 0, 1, 0, 0},
  {&__pyx_n_s_filling_values, __pyx_k_filling_values, sizeof(__pyx_k_filling_values), 0, 0, 1, 1},
  {&__pyx_n_s_filt, __pyx_k_filt, sizeof(__pyx_k_filt), 0, 0, 1, 1},
  {&__pyx_n_s_finance_rate, __pyx_k_finance_rate, sizeof(__pyx_k_finance_rate), 0, 0, 1, 1},
  {&__pyx_n_s_find_common_type, __pyx_k_find_common_type, sizeof(__pyx_k_find_common_type), 0, 0, 1, 1},
  {&__pyx_kp_u_find_common_type_line_3982, __pyx_k_find_common_type_line_3982, sizeof(__pyx_k_find_common_type_line_3982), 0, 1, 0, 0},
  {&__pyx_n_s_fix, __pyx_k_fix, sizeof(__pyx_k_fix), 0, 0, 1, 1},
  {&__pyx_kp_u_fix_line_4035, __pyx_k_fix_line_4035, sizeof(__pyx_k_fix_line_4035), 0, 1, 0, 0},
  {&__pyx_n_s_flatnonzero, __pyx_k_flatnonzero, sizeof(__pyx_k_flatnonzero), 0, 0, 1, 1},
  {&__pyx_kp_u_flatnonzero_line_4071, __pyx_k_flatnonzero_line_4071, sizeof(__pyx_k_flatnonzero_line_4071), 0, 1, 0, 0},
  {&__pyx_n_s_fliplr, __pyx_k_fliplr, sizeof(__pyx_k_fliplr), 0, 0, 1, 1},
  {&__pyx_kp_u_fliplr_line_4110, __pyx_k_fliplr_line_4110, sizeof(__pyx_k_fliplr_line_4110), 0, 1, 0, 0},
  {&__pyx_n_s_flipud, __pyx_k_flipud, sizeof(__pyx_k_flipud), 0, 0, 1, 1},
  {&__pyx_kp_u_flipud_line_4157, __pyx_k_flipud_line_4157, sizeof(__pyx_k_flipud_line_4157), 0, 1, 0, 0},
  {&__pyx_n_s_float64, __pyx_k_float64, sizeof(__pyx_k_float64), 0, 0, 1, 1},
  {&__pyx_n_s_fmt, __pyx_k_fmt, sizeof(__pyx_k_fmt), 0, 0, 1, 1},
  {&__pyx_n_s_fname, __pyx_k_fname, sizeof(__pyx_k_fname), 0, 0, 1, 1},
  {&__pyx_n_s_fp, __pyx_k_fp, sizeof(__pyx_k_fp), 0, 0, 1, 1},
  {&__pyx_n_s_frombuffer, __pyx_k_frombuffer, sizeof(__pyx_k_frombuffer), 0, 0, 1, 1},
  {&__pyx_kp_u_frombuffer_buffer_dtype_float_co, __pyx_k_frombuffer_buffer_dtype_float_co, sizeof(__pyx_k_frombuffer_buffer_dtype_float_co), 0, 1, 0, 0},
  {&__pyx_kp_u_frombuffer_line_4207, __pyx_k_frombuffer_line_4207, sizeof(__pyx_k_frombuffer_line_4207), 0, 1, 0, 0},
  {&__pyx_n_s_fromfile, __pyx_k_fromfile, sizeof(__pyx_k_fromfile), 0, 0, 1, 1},
  {&__pyx_kp_u_fromfile_file_dtype_float_count, __pyx_k_fromfile_file_dtype_float_count, sizeof(__pyx_k_fromfile_file_dtype_float_count), 0, 1, 0, 0},
  {&__pyx_kp_u_fromfile_line_4247, __pyx_k_fromfile_line_4247, sizeof(__pyx_k_fromfile_line_4247), 0, 1, 0, 0},
  {&__pyx_n_s_fromiter, __pyx_k_fromiter, sizeof(__pyx_k_fromiter), 0, 0, 1, 1},
  {&__pyx_kp_u_fromiter_iterable_dtype_count_1, __pyx_k_fromiter_iterable_dtype_count_1, sizeof(__pyx_k_fromiter_iterable_dtype_count_1), 0, 1, 0, 0},
  {&__pyx_kp_u_fromiter_line_4324, __pyx_k_fromiter_line_4324, sizeof(__pyx_k_fromiter_line_4324), 0, 1, 0, 0},
  {&__pyx_n_s_frompyfunc, __pyx_k_frompyfunc, sizeof(__pyx_k_frompyfunc), 0, 0, 1, 1},
  {&__pyx_kp_u_frompyfunc_func_nin_nout_Takes_a, __pyx_k_frompyfunc_func_nin_nout_Takes_a, sizeof(__pyx_k_frompyfunc_func_nin_nout_Takes_a), 0, 1, 0, 0},
  {&__pyx_kp_u_frompyfunc_line_4360, __pyx_k_frompyfunc_line_4360, sizeof(__pyx_k_frompyfunc_line_4360), 0, 1, 0, 0},
  {&__pyx_n_s_fromregex, __pyx_k_fromregex, sizeof(__pyx_k_fromregex), 0, 0, 1, 1},
  {&__pyx_kp_u_fromregex_line_4402, __pyx_k_fromregex_line_4402, sizeof(__pyx_k_fromregex_line_4402), 0, 1, 0, 0},
  {&__pyx_n_s_fromstring, __pyx_k_fromstring, sizeof(__pyx_k_fromstring), 0, 0, 1, 1},
  {&__pyx_kp_u_fromstring_line_4459, __pyx_k_fromstring_line_4459, sizeof(__pyx_k_fromstring_line_4459), 0, 1, 0, 0},
  {&__pyx_kp_u_fromstring_string_dtype_float_co, __pyx_k_fromstring_string_dtype_float_co, sizeof(__pyx_k_fromstring_string_dtype_float_co), 0, 1, 0, 0},
  {&__pyx_n_s_full, __pyx_k_full, sizeof(__pyx_k_full), 0, 0, 1, 1},
  {&__pyx_n_s_func, __pyx_k_func, sizeof(__pyx_k_func), 0, 0, 1, 1},
  {&__pyx_n_s_func1d, __pyx_k_func1d, sizeof(__pyx_k_func1d), 0, 0, 1, 1},
  {&__pyx_n_s_funclist, __pyx_k_funclist, sizeof(__pyx_k_funclist), 0, 0, 1, 1},
  {&__pyx_n_s_fv, __pyx_k_fv, sizeof(__pyx_k_fv), 0, 0, 1, 1},
  {&__pyx_kp_u_fv_line_4513, __pyx_k_fv_line_4513, sizeof(__pyx_k_fv_line_4513), 0, 1, 0, 0},
  {&__pyx_n_s_ga4py_gain_notimplemented, __pyx_k_ga4py_gain_notimplemented, sizeof(__pyx_k_ga4py_gain_notimplemented), 0, 0, 1, 1},
  {&__pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_k_ga4py_gain_notimplemented_pyx, sizeof(__pyx_k_ga4py_gain_notimplemented_pyx), 0, 0, 1, 0},
  {&__pyx_n_s_gdict, __pyx_k_gdict, sizeof(__pyx_k_gdict), 0, 0, 1, 1},
  {&__pyx_n_s_genfromtxt, __pyx_k_genfromtxt, sizeof(__pyx_k_genfromtxt), 0, 0, 1, 1},
  {&__pyx_kp_u_genfromtxt_line_4596, __pyx_k_genfromtxt_line_4596, sizeof(__pyx_k_genfromtxt_line_4596), 0, 1, 0, 0},
  {&__pyx_n_s_get_array_wrap, __pyx_k_get_array_wrap, sizeof(__pyx_k_get_array_wrap), 0, 0, 1, 1},
  {&__pyx_n_s_get_include, __pyx_k_get_include, sizeof(__pyx_k_get_include), 0, 0, 1, 1},
  {&__pyx_n_s_get_numarray_include, __pyx_k_get_numarray_include, sizeof(__pyx_k_get_numarray_include), 0, 0, 1, 1},
  {&__pyx_n_s_get_printoptions, __pyx_k_get_printoptions, sizeof(__pyx_k_get_printoptions), 0, 0, 1, 1},
  {&__pyx_n_s_getbuffer, __pyx_k_getbuffer, sizeof(__pyx_k_getbuffer), 0, 0, 1, 1},
  {&__pyx_kp_u_getbuffer_line_4826, __pyx_k_getbuffer_line_4826, sizeof(__pyx_k_getbuffer_line_4826), 0, 1, 0, 0},
  {&__pyx_kp_u_getbuffer_obj_offset_size_Create, __pyx_k_getbuffer_obj_offset_size_Create, sizeof(__pyx_k_getbuffer_obj_offset_size_Create), 0, 1, 0, 0},
  {&__pyx_n_s_getbufsize, __pyx_k_getbufsize, sizeof(__pyx_k_getbufsize), 0, 0, 1, 1},
  {&__pyx_n_s_geterr, __pyx_k_geterr, sizeof(__pyx_k_geterr), 0, 0, 1, 1},
  {&__pyx_kp_u_geterr_line_4869, __pyx_k_geterr_line_4869, sizeof(__pyx_k_geterr_line_4869), 0, 1, 0, 0},
  {&__pyx_n_s_geterrcall, __pyx_k_geterrcall, sizeof(__pyx_k_geterrcall), 0, 0, 1, 1},
  {&__pyx_kp_u_geterrcall_line_4908, __pyx_k_geterrcall_line_4908, sizeof(__pyx_k_geterrcall_line_4908), 0, 1, 0, 0},
  {&__pyx_n_s_geterrobj, __pyx_k_geterrobj, sizeof(__pyx_k_geterrobj), 0, 0, 1, 1},
  {&__pyx_kp_u_geterrobj_Return_the_current_obj, __pyx_k_geterrobj_Return_the_current_obj, sizeof(__pyx_k_geterrobj_Return_the_current_obj), 0, 1, 0, 0},
  {&__pyx_kp_u_geterrobj_line_4952, __pyx_k_geterrobj_line_4952, sizeof(__pyx_k_geterrobj_line_4952), 0, 1, 0, 0},
  {&__pyx_n_s_gradient, __pyx_k_gradient, sizeof(__pyx_k_gradient), 0, 0, 1, 1},
  {&__pyx_kp_u_gradient_line_5018, __pyx_k_gradient_line_5018, sizeof(__pyx_k_gradient_line_5018), 0, 1, 0, 0},
  {&__pyx_n_s_guess, __pyx_k_guess, sizeof(__pyx_k_guess), 0, 0, 1, 1},
  {&__pyx_n_s_hamming, __pyx_k_hamming, sizeof(__pyx_k_hamming), 0, 0, 1, 1},
  {&__pyx_kp_u_hamming_line_5058, __pyx_k_hamming_line_5058, sizeof(__pyx_k_hamming_line_5058), 0, 1, 0, 0},
  {&__pyx_n_s_hanning, __pyx_k_hanning, sizeof(__pyx_k_hanning), 0, 0, 1, 1},
  {&__pyx_kp_u_hanning_line_5152, __pyx_k_hanning_line_5152, sizeof(__pyx_k_hanning_line_5152), 0, 1, 0, 0},
  {&__pyx_n_s_histogram, __pyx_k_histogram, sizeof(__pyx_k_histogram), 0, 0, 1, 1},
  {&__pyx_n_s_histogram2d, __pyx_k_histogram2d, sizeof(__pyx_k_histogram2d), 0, 0, 1, 1},
  {&__pyx_kp_u_histogram2d_line_5333, __pyx_k_histogram2d_line_5333, sizeof(__pyx_k_histogram2d_line_5333), 0, 1, 0, 0},
  {&__pyx_kp_u_histogram_line_5248, __pyx_k_histogram_line_5248, sizeof(__pyx_k_histogram_line_5248), 0, 1, 0, 0},
  {&__pyx_n_s_histogramdd, __pyx_k_histogramdd, sizeof(__pyx_k_histogramdd), 0, 0, 1, 1},
  {&__pyx_kp_u_histogramdd_line_5418, __pyx_k_histogramdd_line_5418, sizeof(__pyx_k_histogramdd_line_5418), 0, 1, 0, 0},
  {&__pyx_n_s_hsplit, __pyx_k_hsplit, sizeof(__pyx_k_hsplit), 0, 0, 1, 1},
  {&__pyx_kp_u_hsplit_line_5471, __pyx_k_hsplit_line_5471, sizeof(__pyx_k_hsplit_line_5471), 0, 1, 0, 0},
  {&__pyx_n_s_hstack, __pyx_k_hstack, sizeof(__pyx_k_hstack), 0, 0, 1, 1},
  {&__pyx_kp_u_hstack_line_5528, __pyx_k_hstack_line_5528, sizeof(__pyx_k_hstack_line_5528), 0, 1, 0, 0},
  {&__pyx_n_s_i0, __pyx_k_i0, sizeof(__pyx_k_i0), 0, 0, 1, 1},
  {&__pyx_kp_u_i0_line_5572, __pyx_k_i0_line_5572, sizeof(__pyx_k_i0_line_5572), 0, 1, 0, 0},
  {&__pyx_n_s_imag, __pyx_k_imag, sizeof(__pyx_k_imag), 0, 0, 1, 1},
  {&__pyx_kp_u_imag_line_5628, __pyx_k_imag_line_5628, sizeof(__pyx_k_imag_line_5628), 0, 1, 0, 0},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_import_modules, __pyx_k_import_modules, sizeof(__pyx_k_import_modules), 0, 0, 1, 1},
  {&__pyx_n_s_in1d, __pyx_k_in1d, sizeof(__pyx_k_in1d), 0, 0, 1, 1},
  {&__pyx_kp_u_in1d_line_5659, __pyx_k_in1d_line_5659, sizeof(__pyx_k_in1d_line_5659), 0, 1, 0, 0},
  {&__pyx_n_s_ind, __pyx_k_ind, sizeof(__pyx_k_ind), 0, 0, 1, 1},
  {&__pyx_n_s_indices, __pyx_k_indices, sizeof(__pyx_k_indices), 0, 0, 1, 1},
  {&__pyx_kp_u_indices_line_5707, __pyx_k_indices_line_5707, sizeof(__pyx_k_indices_line_5707), 0, 1, 0, 0},
  {&__pyx_n_s_indices_or_sections, __pyx_k_indices_or_sections, sizeof(__pyx_k_indices_or_sections), 0, 0, 1, 1},
  {&__pyx_n_s_info, __pyx_k_info, sizeof(__pyx_k_info), 0, 0, 1, 1},
  {&__pyx_kp_u_info_line_5769, __pyx_k_info_line_5769, sizeof(__pyx_k_info_line_5769), 0, 1, 0, 0},
  {&__pyx_n_s_infstr, __pyx_k_infstr, sizeof(__pyx_k_infstr), 0, 0, 1, 1},
  {&__pyx_n_s_inner, __pyx_k_inner, sizeof(__pyx_k_inner), 0, 0, 1, 1},
  {&__pyx_kp_u_inner_a_b_Inner_product_of_two_a, __pyx_k_inner_a_b_Inner_product_of_two_a, sizeof(__pyx_k_inner_a_b_Inner_product_of_two_a), 0, 1, 0, 0},
  {&__pyx_kp_u_inner_line_5819, __pyx_k_inner_line_5819, sizeof(__pyx_k_inner_line_5819), 0, 1, 0, 0},
  {&__pyx_n_s_insert, __pyx_k_insert, sizeof(__pyx_k_insert), 0, 0, 1, 1},
  {&__pyx_kp_u_insert_line_5895, __pyx_k_insert_line_5895, sizeof(__pyx_k_insert_line_5895), 0, 1, 0, 0},
  {&__pyx_n_s_int_asbuffer, __pyx_k_int_asbuffer, sizeof(__pyx_k_int_asbuffer), 0, 0, 1, 1},
  {&__pyx_n_s_interp, __pyx_k_interp, sizeof(__pyx_k_interp), 0, 0, 1, 1},
  {&__pyx_kp_u_interp_line_5968, __pyx_k_interp_line_5968, sizeof(__pyx_k_interp_line_5968), 0, 1, 0, 0},
  {&__pyx_n_s_intersect1d, __pyx_k_intersect1d, sizeof(__pyx_k_intersect1d), 0, 0, 1, 1},
  {&__pyx_kp_u_intersect1d_line_6039, __pyx_k_intersect1d_line_6039, sizeof(__pyx_k_intersect1d_line_6039), 0, 1, 0, 0},
  {&__pyx_n_s_invalid, __pyx_k_invalid, sizeof(__pyx_k_invalid), 0, 0, 1, 1},
  {&__pyx_n_s_invalid_raise, __pyx_k_invalid_raise, sizeof(__pyx_k_invalid_raise), 0, 0, 1, 1},
  {&__pyx_n_s_ipmt, __pyx_k_ipmt, sizeof(__pyx_k_ipmt), 0, 0, 1, 1},
  {&__pyx_n_s_irr, __pyx_k_irr, sizeof(__pyx_k_irr), 0, 0, 1, 1},
  {&__pyx_kp_u_irr_line_6113, __pyx_k_irr_line_6113, sizeof(__pyx_k_irr_line_6113), 0, 1, 0, 0},
  {&__pyx_n_s_iscomplex, __pyx_k_iscomplex, sizeof(__pyx_k_iscomplex), 0, 0, 1, 1},
  {&__pyx_kp_u_iscomplex_line_6168, __pyx_k_iscomplex_line_6168, sizeof(__pyx_k_iscomplex_line_6168), 0, 1, 0, 0},
  {&__pyx_n_s_iscomplexobj, __pyx_k_iscomplexobj, sizeof(__pyx_k_iscomplexobj), 0, 0, 1, 1},
  {&__pyx_kp_u_iscomplexobj_line_6199, __pyx_k_iscomplexobj_line_6199, sizeof(__pyx_k_iscomplexobj_line_6199), 0, 1, 0, 0},
  {&__pyx_n_s_isfortran, __pyx_k_isfortran, sizeof(__pyx_k_isfortran), 0, 0, 1, 1},
  {&__pyx_kp_u_isfortran_line_6233, __pyx_k_isfortran_line_6233, sizeof(__pyx_k_isfortran_line_6233), 0, 1, 0, 0},
  {&__pyx_n_s_isneginf, __pyx_k_isneginf, sizeof(__pyx_k_isneginf), 0, 0, 1, 1},
  {&__pyx_kp_u_isneginf_line_6290, __pyx_k_isneginf_line_6290, sizeof(__pyx_k_isneginf_line_6290), 0, 1, 0, 0},
  {&__pyx_n_s_isposinf, __pyx_k_isposinf, sizeof(__pyx_k_isposinf), 0, 0, 1, 1},
  {&__pyx_kp_u_isposinf_line_6349, __pyx_k_isposinf_line_6349, sizeof(__pyx_k_isposinf_line_6349), 0, 1, 0, 0},
  {&__pyx_n_s_isreal, __pyx_k_isreal, sizeof(__pyx_k_isreal), 0, 0, 1, 1},
  {&__pyx_kp_u_isreal_line_6407, __pyx_k_isreal_line_6407, sizeof(__pyx_k_isreal_line_6407), 0, 1, 0, 0},
  {&__pyx_n_s_isrealobj, __pyx_k_isrealobj, sizeof(__pyx_k_isrealobj), 0, 0, 1, 1},
  {&__pyx_kp_u_isrealobj_line_6437, __pyx_k_isrealobj_line_6437, sizeof(__pyx_k_isrealobj_line_6437), 0, 1, 0, 0},
  {&__pyx_n_s_isscalar, __pyx_k_isscalar, sizeof(__pyx_k_isscalar), 0, 0, 1, 1},
  {&__pyx_kp_u_isscalar_line_6471, __pyx_k_isscalar_line_6471, sizeof(__pyx_k_isscalar_line_6471), 0, 1, 0, 0},
  {&__pyx_n_s_issctype, __pyx_k_issctype, sizeof(__pyx_k_issctype), 0, 0, 1, 1},
  {&__pyx_kp_u_issctype_line_6497, __pyx_k_issctype_line_6497, sizeof(__pyx_k_issctype_line_6497), 0, 1, 0, 0},
  {&__pyx_n_s_issubclass, __pyx_k_issubclass, sizeof(__pyx_k_issubclass), 0, 0, 1, 1},
  {&__pyx_kp_u_issubclass__line_6533, __pyx_k_issubclass__line_6533, sizeof(__pyx_k_issubclass__line_6533), 0, 1, 0, 0},
  {&__pyx_n_s_issubdtype, __pyx_k_issubdtype, sizeof(__pyx_k_issubdtype), 0, 0, 1, 1},
  {&__pyx_kp_u_issubdtype_line_6568, __pyx_k_issubdtype_line_6568, sizeof(__pyx_k_issubdtype_line_6568), 0, 1, 0, 0},
  {&__pyx_n_s_issubsctype, __pyx_k_issubsctype, sizeof(__pyx_k_issubsctype), 0, 0, 1, 1},
  {&__pyx_kp_u_issubsctype_line_6596, __pyx_k_issubsctype_line_6596, sizeof(__pyx_k_issubsctype_line_6596), 0, 1, 0, 0},
  {&__pyx_n_s_iterable, __pyx_k_iterable, sizeof(__pyx_k_iterable), 0, 0, 1, 1},
  {&__pyx_kp_u_iterable_line_6626, __pyx_k_iterable_line_6626, sizeof(__pyx_k_iterable_line_6626), 0, 1, 0, 0},
  {&__pyx_n_s_ix, __pyx_k_ix, sizeof(__pyx_k_ix), 0, 0, 1, 1},
  {&__pyx_kp_u_ix__line_6652, __pyx_k_ix__line_6652, sizeof(__pyx_k_ix__line_6652), 0, 1, 0, 0},
  {&__pyx_n_s_k, __pyx_k_k, sizeof(__pyx_k_k), 0, 0, 1, 1},
  {&__pyx_n_s_kaiser, __pyx_k_kaiser, sizeof(__pyx_k_kaiser), 0, 0, 1, 1},
  {&__pyx_kp_u_kaiser_line_6698, __pyx_k_kaiser_line_6698, sizeof(__pyx_k_kaiser_line_6698), 0, 1, 0, 0},
  {&__pyx_n_s_keys, __pyx_k_keys, sizeof(__pyx_k_keys), 0, 0, 1, 1},
  {&__pyx_n_s_kind, __pyx_k_kind, sizeof(__pyx_k_kind), 0, 0, 1, 1},
  {&__pyx_n_s_kron, __pyx_k_kron, sizeof(__pyx_k_kron), 0, 0, 1, 1},
  {&__pyx_kp_u_kron_line_6825, __pyx_k_kron_line_6825, sizeof(__pyx_k_kron_line_6825), 0, 1, 0, 0},
  {&__pyx_n_s_ldict, __pyx_k_ldict, sizeof(__pyx_k_ldict), 0, 0, 1, 1},
  {&__pyx_n_s_left, __pyx_k_left, sizeof(__pyx_k_left), 0, 0, 1, 1},
  {&__pyx_n_s_lexsort, __pyx_k_lexsort, sizeof(__pyx_k_lexsort), 0, 0, 1, 1},
  {&__pyx_kp_u_lexsort_keys_axis_1_Perform_an_i, __pyx_k_lexsort_keys_axis_1_Perform_an_i, sizeof(__pyx_k_lexsort_keys_axis_1_Perform_an_i), 0, 1, 0, 0},
  {&__pyx_kp_u_lexsort_line_6897, __pyx_k_lexsort_line_6897, sizeof(__pyx_k_lexsort_line_6897), 0, 1, 0, 0},
  {&__pyx_n_s_linefeed, __pyx_k_linefeed, sizeof(__pyx_k_linefeed), 0, 0, 1, 1},
  {&__pyx_n_s_linewidth, __pyx_k_linewidth, sizeof(__pyx_k_linewidth), 0, 0, 1, 1},
  {&__pyx_n_s_load, __pyx_k_load, sizeof(__pyx_k_load), 0, 0, 1, 1},
  {&__pyx_kp_u_load_line_6975, __pyx_k_load_line_6975, sizeof(__pyx_k_load_line_6975), 0, 1, 0, 0},
  {&__pyx_n_s_loads, __pyx_k_loads, sizeof(__pyx_k_loads), 0, 0, 1, 1},
  {&__pyx_n_s_loadtxt, __pyx_k_loadtxt, sizeof(__pyx_k_loadtxt), 0, 0, 1, 1},
  {&__pyx_kp_u_loadtxt_line_7045, __pyx_k_loadtxt_line_7045, sizeof(__pyx_k_loadtxt_line_7045), 0, 1, 0, 0},
  {&__pyx_n_s_lookfor, __pyx_k_lookfor, sizeof(__pyx_k_lookfor), 0, 0, 1, 1},
  {&__pyx_kp_u_lookfor_line_7132, __pyx_k_lookfor_line_7132, sizeof(__pyx_k_lookfor_line_7132), 0, 1, 0, 0},
  {&__pyx_n_s_loose, __pyx_k_loose, sizeof(__pyx_k_loose), 0, 0, 1, 1},
  {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
  {&__pyx_n_s_mafromtxt, __pyx_k_mafromtxt, sizeof(__pyx_k_mafromtxt), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_mask, __pyx_k_mask, sizeof(__pyx_k_mask), 0, 0, 1, 1},
  {&__pyx_n_s_mask_func, __pyx_k_mask_func, sizeof(__pyx_k_mask_func), 0, 0, 1, 1},
  {&__pyx_n_s_mask_indices, __pyx_k_mask_indices, sizeof(__pyx_k_mask_indices), 0, 0, 1, 1},
  {&__pyx_kp_u_mask_indices_line_7192, __pyx_k_mask_indices_line_7192, sizeof(__pyx_k_mask_indices_line_7192), 0, 1, 0, 0},
  {&__pyx_n_s_mat, __pyx_k_mat, sizeof(__pyx_k_mat), 0, 0, 1, 1},
  {&__pyx_kp_u_mat_line_7259, __pyx_k_mat_line_7259, sizeof(__pyx_k_mat_line_7259), 0, 1, 0, 0},
  {&__pyx_n_s_max, __pyx_k_max, sizeof(__pyx_k_max), 0, 0, 1, 1},
  {&__pyx_kp_u_max_line_7291, __pyx_k_max_line_7291, sizeof(__pyx_k_max_line_7291), 0, 1, 0, 0},
  {&__pyx_n_s_max_line_width, __pyx_k_max_line_width, sizeof(__pyx_k_max_line_width), 0, 0, 1, 1},
  {&__pyx_n_s_maximum_sctype, __pyx_k_maximum_sctype, sizeof(__pyx_k_maximum_sctype), 0, 0, 1, 1},
  {&__pyx_kp_u_maximum_sctype_line_7348, __pyx_k_maximum_sctype_line_7348, sizeof(__pyx_k_maximum_sctype_line_7348), 0, 1, 0, 0},
  {&__pyx_n_s_maxiter, __pyx_k_maxiter, sizeof(__pyx_k_maxiter), 0, 0, 1, 1},
  {&__pyx_n_s_maxwidth, __pyx_k_maxwidth, sizeof(__pyx_k_maxwidth), 0, 0, 1, 1},
  {&__pyx_n_s_may_share_memory, __pyx_k_may_share_memory, sizeof(__pyx_k_may_share_memory), 0, 0, 1, 1},
  {&__pyx_kp_u_may_share_memory_line_7388, __pyx_k_may_share_memory_line_7388, sizeof(__pyx_k_may_share_memory_line_7388), 0, 1, 0, 0},
  {&__pyx_n_s_mean, __pyx_k_mean, sizeof(__pyx_k_mean), 0, 0, 1, 1},
  {&__pyx_kp_u_mean_line_7414, __pyx_k_mean_line_7414, sizeof(__pyx_k_mean_line_7414), 0, 1, 0, 0},
  {&__pyx_n_s_median, __pyx_k_median, sizeof(__pyx_k_median), 0, 0, 1, 1},
  {&__pyx_kp_u_median_line_7487, __pyx_k_median_line_7487, sizeof(__pyx_k_median_line_7487), 0, 1, 0, 0},
  {&__pyx_n_s_mesg, __pyx_k_mesg, sizeof(__pyx_k_mesg), 0, 0, 1, 1},
  {&__pyx_n_s_meshgrid, __pyx_k_meshgrid, sizeof(__pyx_k_meshgrid), 0, 0, 1, 1},
  {&__pyx_kp_u_meshgrid_line_7563, __pyx_k_meshgrid_line_7563, sizeof(__pyx_k_meshgrid_line_7563), 0, 1, 0, 0},
  {&__pyx_n_s_min, __pyx_k_min, sizeof(__pyx_k_min), 0, 0, 1, 1},
  {&__pyx_kp_u_min_line_7611, __pyx_k_min_line_7611, sizeof(__pyx_k_min_line_7611), 0, 1, 0, 0},
  {&__pyx_n_s_min_scalar_type, __pyx_k_min_scalar_type, sizeof(__pyx_k_min_scalar_type), 0, 0, 1, 1},
  {&__pyx_kp_u_min_scalar_type_a_For_scalar_a_r, __pyx_k_min_scalar_type_a_For_scalar_a_r, sizeof(__pyx_k_min_scalar_type_a_For_scalar_a_r), 0, 1, 0, 0},
  {&__pyx_kp_u_min_scalar_type_line_7668, __pyx_k_min_scalar_type_line_7668, sizeof(__pyx_k_min_scalar_type_line_7668), 0, 1, 0, 0},
  {&__pyx_n_s_minlength, __pyx_k_minlength, sizeof(__pyx_k_minlength), 0, 0, 1, 1},
  {&__pyx_n_s_mintypecode, __pyx_k_mintypecode, sizeof(__pyx_k_mintypecode), 0, 0, 1, 1},
  {&__pyx_kp_u_mintypecode_line_7718, __pyx_k_mintypecode_line_7718, sizeof(__pyx_k_mintypecode_line_7718), 0, 1, 0, 0},
  {&__pyx_n_s_mirr, __pyx_k_mirr, sizeof(__pyx_k_mirr), 0, 0, 1, 1},
  {&__pyx_n_s_missing, __pyx_k_missing, sizeof(__pyx_k_missing), 0, 0, 1, 1},
  {&__pyx_n_s_missing_values, __pyx_k_missing_values, sizeof(__pyx_k_missing_values), 0, 0, 1, 1},
  {&__pyx_n_s_mmap_mode, __pyx_k_mmap_mode, sizeof(__pyx_k_mmap_mode), 0, 0, 1, 1},
  {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_msg, __pyx_k_msg, sizeof(__pyx_k_msg), 0, 0, 1, 1},
  {&__pyx_n_s_msort, __pyx_k_msort, sizeof(__pyx_k_msort), 0, 0, 1, 1},
  {&__pyx_n_s_multi_index, __pyx_k_multi_index, sizeof(__pyx_k_multi_index), 0, 0, 1, 1},
  {&__pyx_n_s_myarray, __pyx_k_myarray, sizeof(__pyx_k_myarray), 0, 0, 1, 1},
  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_names, __pyx_k_names, sizeof(__pyx_k_names), 0, 0, 1, 1},
  {&__pyx_n_s_nan_to_num, __pyx_k_nan_to_num, sizeof(__pyx_k_nan_to_num), 0, 0, 1, 1},
  {&__pyx_kp_u_nan_to_num_line_7810, __pyx_k_nan_to_num_line_7810, sizeof(__pyx_k_nan_to_num_line_7810), 0, 1, 0, 0},
  {&__pyx_n_s_nanargmax, __pyx_k_nanargmax, sizeof(__pyx_k_nanargmax), 0, 0, 1, 1},
  {&__pyx_kp_u_nanargmax_line_7857, __pyx_k_nanargmax_line_7857, sizeof(__pyx_k_nanargmax_line_7857), 0, 1, 0, 0},
  {&__pyx_n_s_nanargmin, __pyx_k_nanargmin, sizeof(__pyx_k_nanargmin), 0, 0, 1, 1},
  {&__pyx_kp_u_nanargmin_line_7892, __pyx_k_nanargmin_line_7892, sizeof(__pyx_k_nanargmin_line_7892), 0, 1, 0, 0},
  {&__pyx_n_s_nanmax, __pyx_k_nanmax, sizeof(__pyx_k_nanmax), 0, 0, 1, 1},
  {&__pyx_kp_u_nanmax_line_7927, __pyx_k_nanmax_line_7927, sizeof(__pyx_k_nanmax_line_7927), 0, 1, 0, 0},
  {&__pyx_n_s_nanmin, __pyx_k_nanmin, sizeof(__pyx_k_nanmin), 0, 0, 1, 1},
  {&__pyx_kp_u_nanmin_line_7984, __pyx_k_nanmin_line_7984, sizeof(__pyx_k_nanmin_line_7984), 0, 1, 0, 0},
  {&__pyx_n_s_nanstr, __pyx_k_nanstr, sizeof(__pyx_k_nanstr), 0, 0, 1, 1},
  {&__pyx_n_s_nansum, __pyx_k_nansum, sizeof(__pyx_k_nansum), 0, 0, 1, 1},
  {&__pyx_kp_u_nansum_line_8039, __pyx_k_nansum_line_8039, sizeof(__pyx_k_nansum_line_8039), 0, 1, 0, 0},
  {&__pyx_kp_u_ndarray_is_not_C_contiguous, __pyx_k_ndarray_is_not_C_contiguous, sizeof(__pyx_k_ndarray_is_not_C_contiguous), 0, 1, 0, 0},
  {&__pyx_kp_u_ndarray_is_not_Fortran_contiguou, __pyx_k_ndarray_is_not_Fortran_contiguou, sizeof(__pyx_k_ndarray_is_not_Fortran_contiguou), 0, 1, 0, 0},
  {&__pyx_n_s_ndfromtxt, __pyx_k_ndfromtxt, sizeof(__pyx_k_ndfromtxt), 0, 0, 1, 1},
  {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
  {&__pyx_kp_u_ndim_line_8121, __pyx_k_ndim_line_8121, sizeof(__pyx_k_ndim_line_8121), 0, 1, 0, 0},
  {&__pyx_n_s_ndmin, __pyx_k_ndmin, sizeof(__pyx_k_ndmin), 0, 0, 1, 1},
  {&__pyx_n_s_nested_iters, __pyx_k_nested_iters, sizeof(__pyx_k_nested_iters), 0, 0, 1, 1},
  {&__pyx_n_s_new_shape, __pyx_k_new_shape, sizeof(__pyx_k_new_shape), 0, 0, 1, 1},
  {&__pyx_n_s_newbuffer, __pyx_k_newbuffer, sizeof(__pyx_k_newbuffer), 0, 0, 1, 1},
  {&__pyx_n_s_newline, __pyx_k_newline, sizeof(__pyx_k_newline), 0, 0, 1, 1},
  {&__pyx_n_s_newshape, __pyx_k_newshape, sizeof(__pyx_k_newshape), 0, 0, 1, 1},
  {&__pyx_n_s_nin, __pyx_k_nin, sizeof(__pyx_k_nin), 0, 0, 1, 1},
  {&__pyx_n_s_nonzero, __pyx_k_nonzero, sizeof(__pyx_k_nonzero), 0, 0, 1, 1},
  {&__pyx_kp_u_nonzero_line_8172, __pyx_k_nonzero_line_8172, sizeof(__pyx_k_nonzero_line_8172), 0, 1, 0, 0},
  {&__pyx_n_s_normed, __pyx_k_normed, sizeof(__pyx_k_normed), 0, 0, 1, 1},
  {&__pyx_n_s_nout, __pyx_k_nout, sizeof(__pyx_k_nout), 0, 0, 1, 1},
  {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
  {&__pyx_n_s_nper, __pyx_k_nper, sizeof(__pyx_k_nper), 0, 0, 1, 1},
  {&__pyx_kp_u_nper_line_8247, __pyx_k_nper_line_8247, sizeof(__pyx_k_nper_line_8247), 0, 1, 0, 0},
  {&__pyx_n_s_npv, __pyx_k_npv, sizeof(__pyx_k_npv), 0, 0, 1, 1},
  {&__pyx_kp_u_npv_line_8298, __pyx_k_npv_line_8298, sizeof(__pyx_k_npv_line_8298), 0, 1, 0, 0},
  {&__pyx_n_s_num, __pyx_k_num, sizeof(__pyx_k_num), 0, 0, 1, 1},
  {&__pyx_n_s_number, __pyx_k_number, sizeof(__pyx_k_number), 0, 0, 1, 1},
  {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
  {&__pyx_kp_s_numpy_core_multiarray_failed_to, __pyx_k_numpy_core_multiarray_failed_to, sizeof(__pyx_k_numpy_core_multiarray_failed_to), 0, 0, 1, 0},
  {&__pyx_kp_s_numpy_core_umath_failed_to_impor, __pyx_k_numpy_core_umath_failed_to_impor, sizeof(__pyx_k_numpy_core_umath_failed_to_impor), 0, 0, 1, 0},
  {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
  {&__pyx_n_s_obj2sctype, __pyx_k_obj2sctype, sizeof(__pyx_k_obj2sctype), 0, 0, 1, 1},
  {&__pyx_kp_u_obj2sctype_line_8342, __pyx_k_obj2sctype_line_8342, sizeof(__pyx_k_obj2sctype_line_8342), 0, 1, 0, 0},
  {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
  {&__pyx_n_s_offset, __pyx_k_offset, sizeof(__pyx_k_offset), 0, 0, 1, 1},
  {&__pyx_n_s_old_behavior, __pyx_k_old_behavior, sizeof(__pyx_k_old_behavior), 0, 0, 1, 1},
  {&__pyx_n_s_order, __pyx_k_order, sizeof(__pyx_k_order), 0, 0, 1, 1},
  {&__pyx_n_s_out, __pyx_k_out, sizeof(__pyx_k_out), 0, 0, 1, 1},
  {&__pyx_n_s_outer, __pyx_k_outer, sizeof(__pyx_k_outer), 0, 0, 1, 1},
  {&__pyx_kp_u_outer_line_8383, __pyx_k_outer_line_8383, sizeof(__pyx_k_outer_line_8383), 0, 1, 0, 0},
  {&__pyx_n_s_output, __pyx_k_output, sizeof(__pyx_k_output), 0, 0, 1, 1},
  {&__pyx_n_s_over, __pyx_k_over, sizeof(__pyx_k_over), 0, 0, 1, 1},
  {&__pyx_n_s_overwrite_input, __pyx_k_overwrite_input, sizeof(__pyx_k_overwrite_input), 0, 0, 1, 1},
  {&__pyx_n_s_p, __pyx_k_p, sizeof(__pyx_k_p), 0, 0, 1, 1},
  {&__pyx_n_s_packbits, __pyx_k_packbits, sizeof(__pyx_k_packbits), 0, 0, 1, 1},
  {&__pyx_kp_u_packbits_line_8454, __pyx_k_packbits_line_8454, sizeof(__pyx_k_packbits_line_8454), 0, 1, 0, 0},
  {&__pyx_kp_u_packbits_myarray_axis_None_Packs, __pyx_k_packbits_myarray_axis_None_Packs, sizeof(__pyx_k_packbits_myarray_axis_None_Packs), 0, 1, 0, 0},
  {&__pyx_n_s_padding, __pyx_k_padding, sizeof(__pyx_k_padding), 0, 0, 1, 1},
  {&__pyx_n_s_per, __pyx_k_per, sizeof(__pyx_k_per), 0, 0, 1, 1},
  {&__pyx_n_s_percentile, __pyx_k_percentile, sizeof(__pyx_k_percentile), 0, 0, 1, 1},
  {&__pyx_kp_u_percentile_line_8500, __pyx_k_percentile_line_8500, sizeof(__pyx_k_percentile_line_8500), 0, 1, 0, 0},
  {&__pyx_n_s_piecewise, __pyx_k_piecewise, sizeof(__pyx_k_piecewise), 0, 0, 1, 1},
  {&__pyx_kp_u_piecewise_line_8580, __pyx_k_piecewise_line_8580, sizeof(__pyx_k_piecewise_line_8580), 0, 1, 0, 0},
  {&__pyx_n_s_pkgload, __pyx_k_pkgload, sizeof(__pyx_k_pkgload), 0, 0, 1, 1},
  {&__pyx_n_s_place, __pyx_k_place, sizeof(__pyx_k_place), 0, 0, 1, 1},
  {&__pyx_kp_u_place_line_8702, __pyx_k_place_line_8702, sizeof(__pyx_k_place_line_8702), 0, 1, 0, 0},
  {&__pyx_n_s_pmt, __pyx_k_pmt, sizeof(__pyx_k_pmt), 0, 0, 1, 1},
  {&__pyx_kp_u_pmt_line_8738, __pyx_k_pmt_line_8738, sizeof(__pyx_k_pmt_line_8738), 0, 1, 0, 0},
  {&__pyx_n_s_poly, __pyx_k_poly, sizeof(__pyx_k_poly), 0, 0, 1, 1},
  {&__pyx_kp_u_poly_line_8823, __pyx_k_poly_line_8823, sizeof(__pyx_k_poly_line_8823), 0, 1, 0, 0},
  {&__pyx_n_s_polyadd, __pyx_k_polyadd, sizeof(__pyx_k_polyadd), 0, 0, 1, 1},
  {&__pyx_kp_u_polyadd_line_8917, __pyx_k_polyadd_line_8917, sizeof(__pyx_k_polyadd_line_8917), 0, 1, 0, 0},
  {&__pyx_n_s_polyder, __pyx_k_polyder, sizeof(__pyx_k_polyder), 0, 0, 1, 1},
  {&__pyx_kp_u_polyder_line_8963, __pyx_k_polyder_line_8963, sizeof(__pyx_k_polyder_line_8963), 0, 1, 0, 0},
  {&__pyx_n_s_polydiv, __pyx_k_polydiv, sizeof(__pyx_k_polydiv), 0, 0, 1, 1},
  {&__pyx_kp_u_polydiv_line_9017, __pyx_k_polydiv_line_9017, sizeof(__pyx_k_polydiv_line_9017), 0, 1, 0, 0},
  {&__pyx_n_s_polyfit, __pyx_k_polyfit, sizeof(__pyx_k_polyfit), 0, 0, 1, 1},
  {&__pyx_kp_u_polyfit_line_9064, __pyx_k_polyfit_line_9064, sizeof(__pyx_k_polyfit_line_9064), 0, 1, 0, 0},
  {&__pyx_n_s_polyint, __pyx_k_polyint, sizeof(__pyx_k_polyint), 0, 0, 1, 1},
  {&__pyx_kp_u_polyint_line_9200, __pyx_k_polyint_line_9200, sizeof(__pyx_k_polyint_line_9200), 0, 1, 0, 0},
  {&__pyx_n_s_polymul, __pyx_k_polymul, sizeof(__pyx_k_polymul), 0, 0, 1, 1},
  {&__pyx_kp_u_polymul_line_9269, __pyx_k_polymul_line_9269, sizeof(__pyx_k_polymul_line_9269), 0, 1, 0, 0},
  {&__pyx_n_s_polysub, __pyx_k_polysub, sizeof(__pyx_k_polysub), 0, 0, 1, 1},
  {&__pyx_kp_u_polysub_line_9318, __pyx_k_polysub_line_9318, sizeof(__pyx_k_polysub_line_9318), 0, 1, 0, 0},
  {&__pyx_n_s_polyval, __pyx_k_polyval, sizeof(__pyx_k_polyval), 0, 0, 1, 1},
  {&__pyx_kp_u_polyval_line_9350, __pyx_k_polyval_line_9350, sizeof(__pyx_k_polyval_line_9350), 0, 1, 0, 0},
  {&__pyx_n_s_ppmt, __pyx_k_ppmt, sizeof(__pyx_k_ppmt), 0, 0, 1, 1},
  {&__pyx_n_s_precision, __pyx_k_precision, sizeof(__pyx_k_precision), 0, 0, 1, 1},
  {&__pyx_n_s_prefix, __pyx_k_prefix, sizeof(__pyx_k_prefix), 0, 0, 1, 1},
  {&__pyx_n_s_prod, __pyx_k_prod, sizeof(__pyx_k_prod), 0, 0, 1, 1},
  {&__pyx_kp_u_prod_line_9438, __pyx_k_prod_line_9438, sizeof(__pyx_k_prod_line_9438), 0, 1, 0, 0},
  {&__pyx_n_s_product, __pyx_k_product, sizeof(__pyx_k_product), 0, 0, 1, 1},
  {&__pyx_n_s_promote_types, __pyx_k_promote_types, sizeof(__pyx_k_promote_types), 0, 0, 1, 1},
  {&__pyx_kp_u_promote_types_line_9525, __pyx_k_promote_types_line_9525, sizeof(__pyx_k_promote_types_line_9525), 0, 1, 0, 0},
  {&__pyx_kp_u_promote_types_type1_type2_Return, __pyx_k_promote_types_type1_type2_Return, sizeof(__pyx_k_promote_types_type1_type2_Return), 0, 1, 0, 0},
  {&__pyx_n_s_ptp, __pyx_k_ptp, sizeof(__pyx_k_ptp), 0, 0, 1, 1},
  {&__pyx_kp_u_ptp_line_9575, __pyx_k_ptp_line_9575, sizeof(__pyx_k_ptp_line_9575), 0, 1, 0, 0},
  {&__pyx_n_s_put, __pyx_k_put, sizeof(__pyx_k_put), 0, 0, 1, 1},
  {&__pyx_kp_u_put_line_9615, __pyx_k_put_line_9615, sizeof(__pyx_k_put_line_9615), 0, 1, 0, 0},
  {&__pyx_n_s_putmask, __pyx_k_putmask, sizeof(__pyx_k_putmask), 0, 0, 1, 1},
  {&__pyx_kp_u_putmask_a_mask_values_Changes_el, __pyx_k_putmask_a_mask_values_Changes_el, sizeof(__pyx_k_putmask_a_mask_values_Changes_el), 0, 1, 0, 0},
  {&__pyx_kp_u_putmask_line_9665, __pyx_k_putmask_line_9665, sizeof(__pyx_k_putmask_line_9665), 0, 1, 0, 0},
  {&__pyx_n_s_pv, __pyx_k_pv, sizeof(__pyx_k_pv), 0, 0, 1, 1},
  {&__pyx_kp_u_pv_line_9709, __pyx_k_pv_line_9709, sizeof(__pyx_k_pv_line_9709), 0, 1, 0, 0},
  {&__pyx_n_s_q, __pyx_k_q, sizeof(__pyx_k_q), 0, 0, 1, 1},
  {&__pyx_n_s_quicksort, __pyx_k_quicksort, sizeof(__pyx_k_quicksort), 0, 0, 1, 1},
  {&__pyx_n_s_raise, __pyx_k_raise, sizeof(__pyx_k_raise), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_rank, __pyx_k_rank, sizeof(__pyx_k_rank), 0, 0, 1, 1},
  {&__pyx_kp_u_rank_line_9797, __pyx_k_rank_line_9797, sizeof(__pyx_k_rank_line_9797), 0, 1, 0, 0},
  {&__pyx_n_s_rate, __pyx_k_rate, sizeof(__pyx_k_rate), 0, 0, 1, 1},
  {&__pyx_n_s_ravel, __pyx_k_ravel, sizeof(__pyx_k_ravel), 0, 0, 1, 1},
  {&__pyx_kp_u_ravel_line_9884, __pyx_k_ravel_line_9884, sizeof(__pyx_k_ravel_line_9884), 0, 1, 0, 0},
  {&__pyx_n_s_ravel_multi_index, __pyx_k_ravel_multi_index, sizeof(__pyx_k_ravel_multi_index), 0, 0, 1, 1},
  {&__pyx_kp_u_ravel_multi_index_line_9968, __pyx_k_ravel_multi_index_line_9968, sizeof(__pyx_k_ravel_multi_index_line_9968), 0, 1, 0, 0},
  {&__pyx_kp_u_ravel_multi_index_multi_index_di, __pyx_k_ravel_multi_index_multi_index_di, sizeof(__pyx_k_ravel_multi_index_multi_index_di), 0, 1, 0, 0},
  {&__pyx_n_s_rcond, __pyx_k_rcond, sizeof(__pyx_k_rcond), 0, 0, 1, 1},
  {&__pyx_n_s_real, __pyx_k_real, sizeof(__pyx_k_real), 0, 0, 1, 1},
  {&__pyx_n_s_real_if_close, __pyx_k_real_if_close, sizeof(__pyx_k_real_if_close), 0, 0, 1, 1},
  {&__pyx_kp_u_real_if_close_line_10062, __pyx_k_real_if_close_line_10062, sizeof(__pyx_k_real_if_close_line_10062), 0, 1, 0, 0},
  {&__pyx_kp_u_real_line_10028, __pyx_k_real_line_10028, sizeof(__pyx_k_real_line_10028), 0, 1, 0, 0},
  {&__pyx_n_s_recfromcsv, __pyx_k_recfromcsv, sizeof(__pyx_k_recfromcsv), 0, 0, 1, 1},
  {&__pyx_n_s_recfromtxt, __pyx_k_recfromtxt, sizeof(__pyx_k_recfromtxt), 0, 0, 1, 1},
  {&__pyx_n_s_regenerate, __pyx_k_regenerate, sizeof(__pyx_k_regenerate), 0, 0, 1, 1},
  {&__pyx_n_s_regexp, __pyx_k_regexp, sizeof(__pyx_k_regexp), 0, 0, 1, 1},
  {&__pyx_n_s_reinvest_rate, __pyx_k_reinvest_rate, sizeof(__pyx_k_reinvest_rate), 0, 0, 1, 1},
  {&__pyx_n_s_rep, __pyx_k_rep, sizeof(__pyx_k_rep), 0, 0, 1, 1},
  {&__pyx_n_s_repeat, __pyx_k_repeat, sizeof(__pyx_k_repeat), 0, 0, 1, 1},
  {&__pyx_kp_u_repeat_line_10146, __pyx_k_repeat_line_10146, sizeof(__pyx_k_repeat_line_10146), 0, 1, 0, 0},
  {&__pyx_n_s_repeats, __pyx_k_repeats, sizeof(__pyx_k_repeats), 0, 0, 1, 1},
  {&__pyx_n_s_replace_space, __pyx_k_replace_space, sizeof(__pyx_k_replace_space), 0, 0, 1, 1},
  {&__pyx_n_s_repr, __pyx_k_repr, sizeof(__pyx_k_repr), 0, 0, 1, 1},
  {&__pyx_n_s_reps, __pyx_k_reps, sizeof(__pyx_k_reps), 0, 0, 1, 1},
  {&__pyx_n_s_require, __pyx_k_require, sizeof(__pyx_k_require), 0, 0, 1, 1},
  {&__pyx_kp_u_require_line_10187, __pyx_k_require_line_10187, sizeof(__pyx_k_require_line_10187), 0, 1, 0, 0},
  {&__pyx_n_s_requirements, __pyx_k_requirements, sizeof(__pyx_k_requirements), 0, 0, 1, 1},
  {&__pyx_n_s_reshape, __pyx_k_reshape, sizeof(__pyx_k_reshape), 0, 0, 1, 1},
  {&__pyx_kp_u_reshape_line_10246, __pyx_k_reshape_line_10246, sizeof(__pyx_k_reshape_line_10246), 0, 1, 0, 0},
  {&__pyx_n_s_resize, __pyx_k_resize, sizeof(__pyx_k_resize), 0, 0, 1, 1},
  {&__pyx_kp_u_resize_line_10308, __pyx_k_resize_line_10308, sizeof(__pyx_k_resize_line_10308), 0, 1, 0, 0},
  {&__pyx_n_s_restoredot, __pyx_k_restoredot, sizeof(__pyx_k_restoredot), 0, 0, 1, 1},
  {&__pyx_n_s_result_type, __pyx_k_result_type, sizeof(__pyx_k_result_type), 0, 0, 1, 1},
  {&__pyx_kp_u_result_type_arrays_and_dtypes_Re, __pyx_k_result_type_arrays_and_dtypes_Re, sizeof(__pyx_k_result_type_arrays_and_dtypes_Re), 0, 1, 0, 0},
  {&__pyx_kp_u_result_type_line_10366, __pyx_k_result_type_line_10366, sizeof(__pyx_k_result_type_line_10366), 0, 1, 0, 0},
  {&__pyx_n_s_return_index, __pyx_k_return_index, sizeof(__pyx_k_return_index), 0, 0, 1, 1},
  {&__pyx_n_s_return_inverse, __pyx_k_return_inverse, sizeof(__pyx_k_return_inverse), 0, 0, 1, 1},
  {&__pyx_n_s_returned, __pyx_k_returned, sizeof(__pyx_k_returned), 0, 0, 1, 1},
  {&__pyx_n_s_right, __pyx_k_right, sizeof(__pyx_k_right), 0, 0, 1, 1},
  {&__pyx_n_s_roll, __pyx_k_roll, sizeof(__pyx_k_roll), 0, 0, 1, 1},
  {&__pyx_kp_u_roll_line_10437, __pyx_k_roll_line_10437, sizeof(__pyx_k_roll_line_10437), 0, 1, 0, 0},
  {&__pyx_n_s_rollaxis, __pyx_k_rollaxis, sizeof(__pyx_k_rollaxis), 0, 0, 1, 1},
  {&__pyx_kp_u_rollaxis_line_10488, __pyx_k_rollaxis_line_10488, sizeof(__pyx_k_rollaxis_line_10488), 0, 1, 0, 0},
  {&__pyx_n_s_roots, __pyx_k_roots, sizeof(__pyx_k_roots), 0, 0, 1, 1},
  {&__pyx_kp_u_roots_line_10526, __pyx_k_roots_line_10526, sizeof(__pyx_k_roots_line_10526), 0, 1, 0, 0},
  {&__pyx_n_s_rot90, __pyx_k_rot90, sizeof(__pyx_k_rot90), 0, 0, 1, 1},
  {&__pyx_kp_u_rot90_line_10577, __pyx_k_rot90_line_10577, sizeof(__pyx_k_rot90_line_10577), 0, 1, 0, 0},
  {&__pyx_n_s_round, __pyx_k_round, sizeof(__pyx_k_round), 0, 0, 1, 1},
  {&__pyx_n_s_round_2, __pyx_k_round_2, sizeof(__pyx_k_round_2), 0, 0, 1, 1},
  {&__pyx_n_s_row_stack, __pyx_k_row_stack, sizeof(__pyx_k_row_stack), 0, 0, 1, 1},
  {&__pyx_kp_u_row_stack_line_10643, __pyx_k_row_stack_line_10643, sizeof(__pyx_k_row_stack_line_10643), 0, 1, 0, 0},
  {&__pyx_n_s_rowvar, __pyx_k_rowvar, sizeof(__pyx_k_rowvar), 0, 0, 1, 1},
  {&__pyx_n_s_rtol, __pyx_k_rtol, sizeof(__pyx_k_rtol), 0, 0, 1, 1},
  {&__pyx_n_s_safe_eval, __pyx_k_safe_eval, sizeof(__pyx_k_safe_eval), 0, 0, 1, 1},
  {&__pyx_kp_u_safe_eval_line_10694, __pyx_k_safe_eval_line_10694, sizeof(__pyx_k_safe_eval_line_10694), 0, 1, 0, 0},
  {&__pyx_n_s_sample, __pyx_k_sample, sizeof(__pyx_k_sample), 0, 0, 1, 1},
  {&__pyx_n_s_save, __pyx_k_save, sizeof(__pyx_k_save), 0, 0, 1, 1},
  {&__pyx_kp_u_save_line_10739, __pyx_k_save_line_10739, sizeof(__pyx_k_save_line_10739), 0, 1, 0, 0},
  {&__pyx_n_s_savetxt, __pyx_k_savetxt, sizeof(__pyx_k_savetxt), 0, 0, 1, 1},
  {&__pyx_kp_u_savetxt_line_10777, __pyx_k_savetxt_line_10777, sizeof(__pyx_k_savetxt_line_10777), 0, 1, 0, 0},
  {&__pyx_n_s_savez, __pyx_k_savez, sizeof(__pyx_k_savez), 0, 0, 1, 1},
  {&__pyx_n_s_savez_compressed, __pyx_k_savez_compressed, sizeof(__pyx_k_savez_compressed), 0, 0, 1, 1},
  {&__pyx_kp_u_savez_line_10868, __pyx_k_savez_line_10868, sizeof(__pyx_k_savez_line_10868), 0, 1, 0, 0},
  {&__pyx_n_s_scalar_types, __pyx_k_scalar_types, sizeof(__pyx_k_scalar_types), 0, 0, 1, 1},
  {&__pyx_n_s_sctype, __pyx_k_sctype, sizeof(__pyx_k_sctype), 0, 0, 1, 1},
  {&__pyx_n_s_sctype2char, __pyx_k_sctype2char, sizeof(__pyx_k_sctype2char), 0, 0, 1, 1},
  {&__pyx_kp_u_sctype2char_line_10972, __pyx_k_sctype2char_line_10972, sizeof(__pyx_k_sctype2char_line_10972), 0, 1, 0, 0},
  {&__pyx_n_s_searchsorted, __pyx_k_searchsorted, sizeof(__pyx_k_searchsorted), 0, 0, 1, 1},
  {&__pyx_kp_u_searchsorted_line_11016, __pyx_k_searchsorted_line_11016, sizeof(__pyx_k_searchsorted_line_11016), 0, 1, 0, 0},
  {&__pyx_n_s_select, __pyx_k_select, sizeof(__pyx_k_select), 0, 0, 1, 1},
  {&__pyx_kp_u_select_line_11064, __pyx_k_select_line_11064, sizeof(__pyx_k_select_line_11064), 0, 1, 0, 0},
  {&__pyx_n_s_sep, __pyx_k_sep, sizeof(__pyx_k_sep), 0, 0, 1, 1},
  {&__pyx_n_s_separator, __pyx_k_separator, sizeof(__pyx_k_separator), 0, 0, 1, 1},
  {&__pyx_n_s_seq_of_zeros, __pyx_k_seq_of_zeros, sizeof(__pyx_k_seq_of_zeros), 0, 0, 1, 1},
  {&__pyx_n_s_set_numeric_ops, __pyx_k_set_numeric_ops, sizeof(__pyx_k_set_numeric_ops), 0, 0, 1, 1},
  {&__pyx_kp_u_set_numeric_ops_line_11103, __pyx_k_set_numeric_ops_line_11103, sizeof(__pyx_k_set_numeric_ops_line_11103), 0, 1, 0, 0},
  {&__pyx_kp_u_set_numeric_ops_op1_func1_op2_fu, __pyx_k_set_numeric_ops_op1_func1_op2_fu, sizeof(__pyx_k_set_numeric_ops_op1_func1_op2_fu), 0, 1, 0, 0},
  {&__pyx_n_s_set_printoptions, __pyx_k_set_printoptions, sizeof(__pyx_k_set_printoptions), 0, 0, 1, 1},
  {&__pyx_kp_u_set_printoptions_line_11149, __pyx_k_set_printoptions_line_11149, sizeof(__pyx_k_set_printoptions_line_11149), 0, 1, 0, 0},
  {&__pyx_n_s_set_string_function, __pyx_k_set_string_function, sizeof(__pyx_k_set_string_function), 0, 0, 1, 1},
  {&__pyx_kp_u_set_string_function_line_11214, __pyx_k_set_string_function_line_11214, sizeof(__pyx_k_set_string_function_line_11214), 0, 1, 0, 0},
  {&__pyx_n_s_setbufsize, __pyx_k_setbufsize, sizeof(__pyx_k_setbufsize), 0, 0, 1, 1},
  {&__pyx_n_s_setdiff1d, __pyx_k_setdiff1d, sizeof(__pyx_k_setdiff1d), 0, 0, 1, 1},
  {&__pyx_kp_u_setdiff1d_line_11279, __pyx_k_setdiff1d_line_11279, sizeof(__pyx_k_setdiff1d_line_11279), 0, 1, 0, 0},
  {&__pyx_n_s_seterr, __pyx_k_seterr, sizeof(__pyx_k_seterr), 0, 0, 1, 1},
  {&__pyx_kp_u_seterr_line_11315, __pyx_k_seterr_line_11315, sizeof(__pyx_k_seterr_line_11315), 0, 1, 0, 0},
  {&__pyx_n_s_seterrcall, __pyx_k_seterrcall, sizeof(__pyx_k_seterrcall), 0, 0, 1, 1},
  {&__pyx_kp_u_seterrcall_line_11394, __pyx_k_seterrcall_line_11394, sizeof(__pyx_k_seterrcall_line_11394), 0, 1, 0, 0},
  {&__pyx_n_s_seterrobj, __pyx_k_seterrobj, sizeof(__pyx_k_seterrobj), 0, 0, 1, 1},
  {&__pyx_kp_u_seterrobj_errobj_Set_the_object, __pyx_k_seterrobj_errobj_Set_the_object, sizeof(__pyx_k_seterrobj_errobj_Set_the_object), 0, 1, 0, 0},
  {&__pyx_kp_u_seterrobj_line_11477, __pyx_k_seterrobj_line_11477, sizeof(__pyx_k_seterrobj_line_11477), 0, 1, 0, 0},
  {&__pyx_n_s_setxor1d, __pyx_k_setxor1d, sizeof(__pyx_k_setxor1d), 0, 0, 1, 1},
  {&__pyx_kp_u_setxor1d_line_11538, __pyx_k_setxor1d_line_11538, sizeof(__pyx_k_setxor1d_line_11538), 0, 1, 0, 0},
  {&__pyx_n_s_shift, __pyx_k_shift, sizeof(__pyx_k_shift), 0, 0, 1, 1},
  {&__pyx_n_s_show_config, __pyx_k_show_config, sizeof(__pyx_k_show_config), 0, 0, 1, 1},
  {&__pyx_n_s_side, __pyx_k_side, sizeof(__pyx_k_side), 0, 0, 1, 1},
  {&__pyx_n_s_sinc, __pyx_k_sinc, sizeof(__pyx_k_sinc), 0, 0, 1, 1},
  {&__pyx_kp_u_sinc_line_11576, __pyx_k_sinc_line_11576, sizeof(__pyx_k_sinc_line_11576), 0, 1, 0, 0},
  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
  {&__pyx_kp_u_size_line_11653, __pyx_k_size_line_11653, sizeof(__pyx_k_size_line_11653), 0, 1, 0, 0},
  {&__pyx_n_s_skip_footer, __pyx_k_skip_footer, sizeof(__pyx_k_skip_footer), 0, 0, 1, 1},
  {&__pyx_n_s_skip_header, __pyx_k_skip_header, sizeof(__pyx_k_skip_header), 0, 0, 1, 1},
  {&__pyx_n_s_skiprows, __pyx_k_skiprows, sizeof(__pyx_k_skiprows), 0, 0, 1, 1},
  {&__pyx_n_s_sometrue, __pyx_k_sometrue, sizeof(__pyx_k_sometrue), 0, 0, 1, 1},
  {&__pyx_n_s_sort, __pyx_k_sort, sizeof(__pyx_k_sort), 0, 0, 1, 1},
  {&__pyx_n_s_sort_complex, __pyx_k_sort_complex, sizeof(__pyx_k_sort_complex), 0, 0, 1, 1},
  {&__pyx_kp_u_sort_complex_line_11803, __pyx_k_sort_complex_line_11803, sizeof(__pyx_k_sort_complex_line_11803), 0, 1, 0, 0},
  {&__pyx_kp_u_sort_line_11702, __pyx_k_sort_line_11702, sizeof(__pyx_k_sort_line_11702), 0, 1, 0, 0},
  {&__pyx_n_s_source, __pyx_k_source, sizeof(__pyx_k_source), 0, 0, 1, 1},
  {&__pyx_kp_u_source_line_11828, __pyx_k_source_line_11828, sizeof(__pyx_k_source_line_11828), 0, 1, 0, 0},
  {&__pyx_n_s_split, __pyx_k_split, sizeof(__pyx_k_split), 0, 0, 1, 1},
  {&__pyx_kp_u_split_line_11868, __pyx_k_split_line_11868, sizeof(__pyx_k_split_line_11868), 0, 1, 0, 0},
  {&__pyx_n_s_squeeze, __pyx_k_squeeze, sizeof(__pyx_k_squeeze), 0, 0, 1, 1},
  {&__pyx_kp_u_squeeze_line_11935, __pyx_k_squeeze_line_11935, sizeof(__pyx_k_squeeze_line_11935), 0, 1, 0, 0},
  {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
  {&__pyx_n_s_std, __pyx_k_std, sizeof(__pyx_k_std), 0, 0, 1, 1},
  {&__pyx_kp_u_std_line_11961, __pyx_k_std_line_11961, sizeof(__pyx_k_std_line_11961), 0, 1, 0, 0},
  {&__pyx_n_s_stdout, __pyx_k_stdout, sizeof(__pyx_k_stdout), 0, 0, 1, 1},
  {&__pyx_n_s_string, __pyx_k_string, sizeof(__pyx_k_string), 0, 0, 1, 1},
  {&__pyx_n_s_style, __pyx_k_style, sizeof(__pyx_k_style), 0, 0, 1, 1},
  {&__pyx_n_s_subok, __pyx_k_subok, sizeof(__pyx_k_subok), 0, 0, 1, 1},
  {&__pyx_n_s_sum, __pyx_k_sum, sizeof(__pyx_k_sum), 0, 0, 1, 1},
  {&__pyx_kp_u_sum_line_12049, __pyx_k_sum_line_12049, sizeof(__pyx_k_sum_line_12049), 0, 1, 0, 0},
  {&__pyx_n_s_suppress, __pyx_k_suppress, sizeof(__pyx_k_suppress), 0, 0, 1, 1},
  {&__pyx_n_s_suppress_small, __pyx_k_suppress_small, sizeof(__pyx_k_suppress_small), 0, 0, 1, 1},
  {&__pyx_n_s_swapaxes, __pyx_k_swapaxes, sizeof(__pyx_k_swapaxes), 0, 0, 1, 1},
  {&__pyx_kp_u_swapaxes_line_12117, __pyx_k_swapaxes_line_12117, sizeof(__pyx_k_swapaxes_line_12117), 0, 1, 0, 0},
  {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
  {&__pyx_n_s_t, __pyx_k_t, sizeof(__pyx_k_t), 0, 0, 1, 1},
  {&__pyx_n_s_take, __pyx_k_take, sizeof(__pyx_k_take), 0, 0, 1, 1},
  {&__pyx_kp_u_take_line_12160, __pyx_k_take_line_12160, sizeof(__pyx_k_take_line_12160), 0, 1, 0, 0},
  {&__pyx_n_s_tensordot, __pyx_k_tensordot, sizeof(__pyx_k_tensordot), 0, 0, 1, 1},
  {&__pyx_kp_u_tensordot_line_12216, __pyx_k_tensordot_line_12216, sizeof(__pyx_k_tensordot_line_12216), 0, 1, 0, 0},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_threshold, __pyx_k_threshold, sizeof(__pyx_k_threshold), 0, 0, 1, 1},
  {&__pyx_n_s_tile, __pyx_k_tile, sizeof(__pyx_k_tile), 0, 0, 1, 1},
  {&__pyx_kp_u_tile_line_12332, __pyx_k_tile_line_12332, sizeof(__pyx_k_tile_line_12332), 0, 1, 0, 0},
  {&__pyx_n_s_to_begin, __pyx_k_to_begin, sizeof(__pyx_k_to_begin), 0, 0, 1, 1},
  {&__pyx_n_s_to_end, __pyx_k_to_end, sizeof(__pyx_k_to_end), 0, 0, 1, 1},
  {&__pyx_n_s_tol, __pyx_k_tol, sizeof(__pyx_k_tol), 0, 0, 1, 1},
  {&__pyx_n_s_toplevel, __pyx_k_toplevel, sizeof(__pyx_k_toplevel), 0, 0, 1, 1},
  {&__pyx_n_s_trace, __pyx_k_trace, sizeof(__pyx_k_trace), 0, 0, 1, 1},
  {&__pyx_kp_u_trace_line_12390, __pyx_k_trace_line_12390, sizeof(__pyx_k_trace_line_12390), 0, 1, 0, 0},
  {&__pyx_n_s_transpose, __pyx_k_transpose, sizeof(__pyx_k_transpose), 0, 0, 1, 1},
  {&__pyx_kp_u_transpose_line_12448, __pyx_k_transpose_line_12448, sizeof(__pyx_k_transpose_line_12448), 0, 1, 0, 0},
  {&__pyx_n_s_trapz, __pyx_k_trapz, sizeof(__pyx_k_trapz), 0, 0, 1, 1},
  {&__pyx_kp_u_trapz_line_12488, __pyx_k_trapz_line_12488, sizeof(__pyx_k_trapz_line_12488), 0, 1, 0, 0},
  {&__pyx_n_s_tri, __pyx_k_tri, sizeof(__pyx_k_tri), 0, 0, 1, 1},
  {&__pyx_kp_u_tri_line_12549, __pyx_k_tri_line_12549, sizeof(__pyx_k_tri_line_12549), 0, 1, 0, 0},
  {&__pyx_n_s_tril, __pyx_k_tril, sizeof(__pyx_k_tril), 0, 0, 1, 1},
  {&__pyx_n_s_tril_indices, __pyx_k_tril_indices, sizeof(__pyx_k_tril_indices), 0, 0, 1, 1},
  {&__pyx_n_s_tril_indices_from, __pyx_k_tril_indices_from, sizeof(__pyx_k_tril_indices_from), 0, 0, 1, 1},
  {&__pyx_kp_u_tril_indices_line_12622, __pyx_k_tril_indices_line_12622, sizeof(__pyx_k_tril_indices_line_12622), 0, 1, 0, 0},
  {&__pyx_kp_u_tril_line_12588, __pyx_k_tril_line_12588, sizeof(__pyx_k_tril_line_12588), 0, 1, 0, 0},
  {&__pyx_n_s_trim, __pyx_k_trim, sizeof(__pyx_k_trim), 0, 0, 1, 1},
  {&__pyx_n_s_trim_zeros, __pyx_k_trim_zeros, sizeof(__pyx_k_trim_zeros), 0, 0, 1, 1},
  {&__pyx_kp_u_trim_zeros_line_12719, __pyx_k_trim_zeros_line_12719, sizeof(__pyx_k_trim_zeros_line_12719), 0, 1, 0, 0},
  {&__pyx_n_s_triu, __pyx_k_triu, sizeof(__pyx_k_triu), 0, 0, 1, 1},
  {&__pyx_n_s_triu_indices, __pyx_k_triu_indices, sizeof(__pyx_k_triu_indices), 0, 0, 1, 1},
  {&__pyx_n_s_triu_indices_from, __pyx_k_triu_indices_from, sizeof(__pyx_k_triu_indices_from), 0, 0, 1, 1},
  {&__pyx_kp_u_triu_indices_line_12778, __pyx_k_triu_indices_line_12778, sizeof(__pyx_k_triu_indices_line_12778), 0, 1, 0, 0},
  {&__pyx_kp_u_triu_line_12754, __pyx_k_triu_line_12754, sizeof(__pyx_k_triu_line_12754), 0, 1, 0, 0},
  {&__pyx_n_s_tup, __pyx_k_tup, sizeof(__pyx_k_tup), 0, 0, 1, 1},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_n_s_type1, __pyx_k_type1, sizeof(__pyx_k_type1), 0, 0, 1, 1},
  {&__pyx_n_s_type2, __pyx_k_type2, sizeof(__pyx_k_type2), 0, 0, 1, 1},
  {&__pyx_n_s_typechars, __pyx_k_typechars, sizeof(__pyx_k_typechars), 0, 0, 1, 1},
  {&__pyx_n_s_typename, __pyx_k_typename, sizeof(__pyx_k_typename), 0, 0, 1, 1},
  {&__pyx_kp_u_typename_line_12876, __pyx_k_typename_line_12876, sizeof(__pyx_k_typename_line_12876), 0, 1, 0, 0},
  {&__pyx_n_s_typeset, __pyx_k_typeset, sizeof(__pyx_k_typeset), 0, 0, 1, 1},
  {&__pyx_n_s_u, __pyx_k_u, sizeof(__pyx_k_u), 0, 0, 1, 1},
  {&__pyx_n_s_under, __pyx_k_under, sizeof(__pyx_k_under), 0, 0, 1, 1},
  {&__pyx_n_s_union1d, __pyx_k_union1d, sizeof(__pyx_k_union1d), 0, 0, 1, 1},
  {&__pyx_kp_u_union1d_line_12927, __pyx_k_union1d_line_12927, sizeof(__pyx_k_union1d_line_12927), 0, 1, 0, 0},
  {&__pyx_n_s_unique, __pyx_k_unique, sizeof(__pyx_k_unique), 0, 0, 1, 1},
  {&__pyx_kp_u_unique_line_12957, __pyx_k_unique_line_12957, sizeof(__pyx_k_unique_line_12957), 0, 1, 0, 0},
  {&__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_k_unknown_dtype_code_in_numpy_pxd, sizeof(__pyx_k_unknown_dtype_code_in_numpy_pxd), 0, 1, 0, 0},
  {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
  {&__pyx_n_s_unpackbits, __pyx_k_unpackbits, sizeof(__pyx_k_unpackbits), 0, 0, 1, 1},
  {&__pyx_kp_u_unpackbits_line_13028, __pyx_k_unpackbits_line_13028, sizeof(__pyx_k_unpackbits_line_13028), 0, 1, 0, 0},
  {&__pyx_kp_u_unpackbits_myarray_axis_None_Unp, __pyx_k_unpackbits_myarray_axis_None_Unp, sizeof(__pyx_k_unpackbits_myarray_axis_None_Unp), 0, 1, 0, 0},
  {&__pyx_n_s_unravel_index, __pyx_k_unravel_index, sizeof(__pyx_k_unravel_index), 0, 0, 1, 1},
  {&__pyx_kp_u_unravel_index_indices_dims_order, __pyx_k_unravel_index_indices_dims_order, sizeof(__pyx_k_unravel_index_indices_dims_order), 0, 1, 0, 0},
  {&__pyx_kp_u_unravel_index_line_13073, __pyx_k_unravel_index_line_13073, sizeof(__pyx_k_unravel_index_line_13073), 0, 1, 0, 0},
  {&__pyx_n_s_unwrap, __pyx_k_unwrap, sizeof(__pyx_k_unwrap), 0, 0, 1, 1},
  {&__pyx_kp_u_unwrap_line_13118, __pyx_k_unwrap_line_13118, sizeof(__pyx_k_unwrap_line_13118), 0, 1, 0, 0},
  {&__pyx_n_s_usecols, __pyx_k_usecols, sizeof(__pyx_k_usecols), 0, 0, 1, 1},
  {&__pyx_n_s_usemask, __pyx_k_usemask, sizeof(__pyx_k_usemask), 0, 0, 1, 1},
  {&__pyx_n_s_v, __pyx_k_v, sizeof(__pyx_k_v), 0, 0, 1, 1},
  {&__pyx_n_s_val, __pyx_k_val, sizeof(__pyx_k_val), 0, 0, 1, 1},
  {&__pyx_n_s_valid, __pyx_k_valid, sizeof(__pyx_k_valid), 0, 0, 1, 1},
  {&__pyx_n_s_vals, __pyx_k_vals, sizeof(__pyx_k_vals), 0, 0, 1, 1},
  {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
  {&__pyx_n_s_vander, __pyx_k_vander, sizeof(__pyx_k_vander), 0, 0, 1, 1},
  {&__pyx_kp_u_vander_line_13161, __pyx_k_vander_line_13161, sizeof(__pyx_k_vander_line_13161), 0, 1, 0, 0},
  {&__pyx_n_s_var, __pyx_k_var, sizeof(__pyx_k_var), 0, 0, 1, 1},
  {&__pyx_kp_u_var_line_13219, __pyx_k_var_line_13219, sizeof(__pyx_k_var_line_13219), 0, 1, 0, 0},
  {&__pyx_n_s_vardict, __pyx_k_vardict, sizeof(__pyx_k_vardict), 0, 0, 1, 1},
  {&__pyx_n_s_vdot, __pyx_k_vdot, sizeof(__pyx_k_vdot), 0, 0, 1, 1},
  {&__pyx_kp_u_vdot_line_13309, __pyx_k_vdot_line_13309, sizeof(__pyx_k_vdot_line_13309), 0, 1, 0, 0},
  {&__pyx_n_s_vsplit, __pyx_k_vsplit, sizeof(__pyx_k_vsplit), 0, 0, 1, 1},
  {&__pyx_kp_u_vsplit_line_13364, __pyx_k_vsplit_line_13364, sizeof(__pyx_k_vsplit_line_13364), 0, 1, 0, 0},
  {&__pyx_n_s_vstack, __pyx_k_vstack, sizeof(__pyx_k_vstack), 0, 0, 1, 1},
  {&__pyx_kp_u_vstack_line_13413, __pyx_k_vstack_line_13413, sizeof(__pyx_k_vstack_line_13413), 0, 1, 0, 0},
  {&__pyx_n_s_weights, __pyx_k_weights, sizeof(__pyx_k_weights), 0, 0, 1, 1},
  {&__pyx_n_s_what, __pyx_k_what, sizeof(__pyx_k_what), 0, 0, 1, 1},
  {&__pyx_n_s_when, __pyx_k_when, sizeof(__pyx_k_when), 0, 0, 1, 1},
  {&__pyx_n_s_where, __pyx_k_where, sizeof(__pyx_k_where), 0, 0, 1, 1},
  {&__pyx_kp_u_where_condition_x_y_Return_eleme, __pyx_k_where_condition_x_y_Return_eleme, sizeof(__pyx_k_where_condition_x_y_Return_eleme), 0, 1, 0, 0},
  {&__pyx_kp_u_where_line_13464, __pyx_k_where_line_13464, sizeof(__pyx_k_where_line_13464), 0, 1, 0, 0},
  {&__pyx_n_s_who, __pyx_k_who, sizeof(__pyx_k_who), 0, 0, 1, 1},
  {&__pyx_kp_u_who_line_13526, __pyx_k_who_line_13526, sizeof(__pyx_k_who_line_13526), 0, 1, 0, 0},
  {&__pyx_n_s_width, __pyx_k_width, sizeof(__pyx_k_width), 0, 0, 1, 1},
  {&__pyx_n_s_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 0, 1, 1},
  {&__pyx_n_s_xp, __pyx_k_xp, sizeof(__pyx_k_xp), 0, 0, 1, 1},
  {&__pyx_n_s_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 0, 1, 1},
  {&__pyx_n_s_z, __pyx_k_z, sizeof(__pyx_k_z), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 18, __pyx_L1_error)
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 272, __pyx_L1_error)
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(1, 285, __pyx_L1_error)
  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(1, 856, __pyx_L1_error)
  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(1, 1038, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":272
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_C_contiguous); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":276
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
 * 
 *             info.buf = PyArray_DATA(self)
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_Fortran_contiguou); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":306
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 306, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":856
 * 
 *         if (end - f) - <int>(new_offset - offset[0]) < 15:
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 856, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":880
 *             t = child.type_num
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor_2); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 880, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1038
 *         _import_array()
 *     except Exception:
 *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
 * 
 * cdef inline int import_umath() except -1:
 */
  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 1038, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1044
 *         _import_umath()
 *     except Exception:
 *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
 * 
 * cdef inline int import_ufunc() except -1:
 */
  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 1044, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);

  /* "ga4py/gain/notimplemented.pyx":8
 * 
 * 
 * def docstring(obj, docstring):             # <<<<<<<<<<<<<<
 *     """docstring(obj, docstring)
 * 
 */
  __pyx_tuple__24 = PyTuple_Pack(2, __pyx_n_s_obj, __pyx_n_s_docstring); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(0, 8, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__24);
  __Pyx_GIVEREF(__pyx_tuple__24);
  __pyx_codeobj__25 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__24, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_docstring, 8, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__25)) __PYX_ERR(0, 8, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":21
 * 
 * 
 * def add_newdoc(place, obj, doc):             # <<<<<<<<<<<<<<
 *     """Adds documentation to obj which is in module place.
 * 
 */
  __pyx_tuple__26 = PyTuple_Pack(3, __pyx_n_s_place, __pyx_n_s_obj, __pyx_n_s_doc); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 21, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);
  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_add_newdoc, 21, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(0, 21, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":40
 * 
 * 
 * def all(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether all array elements along a given axis evaluate to True.
 * 
 */
  __pyx_tuple__28 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);
  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_all, 40, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(0, 40, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":99
 * 
 * 
 * def allclose(a, b, rtol=1e-05, atol=1e-08):             # <<<<<<<<<<<<<<
 *     """Returns True if two arrays are element-wise equal within a tolerance.
 * 
 */
  __pyx_tuple__30 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_rtol, __pyx_n_s_atol); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 99, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);
  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__30, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_allclose, 99, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 99, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":153
 * 
 * 
 * def alltrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check if all elements of input array are true.
 * 
 */
  __pyx_tuple__32 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 153, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);
  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_alltrue, 153, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 153, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":164
 * 
 * 
 * def alterdot():             # <<<<<<<<<<<<<<
 *     """Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.
 * 
 */
  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_alterdot, 164, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 164, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":187
 * 
 * 
 * def amax(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_tuple__35 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__35);
  __Pyx_GIVEREF(__pyx_tuple__35);
  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_amax, 187, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 187, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":244
 * 
 * 
 * def amin(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_tuple__37 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__37);
  __Pyx_GIVEREF(__pyx_tuple__37);
  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_amin, 244, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 244, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":301
 * 
 * 
 * def angle(z, deg=0):             # <<<<<<<<<<<<<<
 *     """Return the angle of the complex argument.
 * 
 */
  __pyx_tuple__39 = PyTuple_Pack(2, __pyx_n_s_z, __pyx_n_s_deg); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__39);
  __Pyx_GIVEREF(__pyx_tuple__39);
  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_angle, 301, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 301, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":335
 * 
 * 
 * def any(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether any array element along a given axis evaluates to True.
 * 
 */
  __pyx_tuple__41 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 335, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__41);
  __Pyx_GIVEREF(__pyx_tuple__41);
  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_any, 335, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 335, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":401
 * 
 * 
 * def append(arr, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Append values to the end of an array.
 * 
 */
  __pyx_tuple__43 = PyTuple_Pack(3, __pyx_n_s_arr, __pyx_n_s_values, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 401, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__43);
  __Pyx_GIVEREF(__pyx_tuple__43);
  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_append, 401, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 401, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":449
 * 
 * 
 * def apply_along_axis(func1d, axis, arr):             # <<<<<<<<<<<<<<
 *     """Apply a function to 1-D slices along the given axis.
 * 
 */
  __pyx_tuple__45 = PyTuple_Pack(3, __pyx_n_s_func1d, __pyx_n_s_axis, __pyx_n_s_arr); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 449, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);
  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_apply_along_axis, 449, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(0, 449, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":506
 * 
 * 
 * def apply_over_axes(func, a, axes):             # <<<<<<<<<<<<<<
 *     """Apply a function repeatedly over multiple axes.
 * 
 */
  __pyx_tuple__47 = PyTuple_Pack(3, __pyx_n_s_func, __pyx_n_s_a, __pyx_n_s_axes); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 506, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);
  __pyx_codeobj__48 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__47, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_apply_over_axes, 506, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__48)) __PYX_ERR(0, 506, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":560
 * 
 * 
 * def argmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Indices of the maximum values along an axis.
 * 
 */
  __pyx_tuple__49 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(0, 560, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__49);
  __Pyx_GIVEREF(__pyx_tuple__49);
  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_argmax, 560, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) __PYX_ERR(0, 560, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":612
 * 
 * 
 * def argmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the indices of the minimum values along an axis.
 * 
 */
  __pyx_tuple__51 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 612, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);
  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_argmin, 612, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(0, 612, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":624
 * 
 * 
 * def argsort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Returns the indices that would sort an array.
 * 
 */
  __pyx_tuple__53 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_kind, __pyx_n_s_order); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 624, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);
  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_argsort, 624, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 624, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":704
 * 
 * 
 * def argwhere(a):             # <<<<<<<<<<<<<<
 *     """Find the indices of array elements that are non-zero, grouped by element.
 * 
 */
  __pyx_tuple__55 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 704, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);
  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_argwhere, 704, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 704, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":744
 * 
 * 
 * def around(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Evenly round to the given number of decimals.
 * 
 */
  __pyx_tuple__57 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_decimals, __pyx_n_s_out); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 744, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);
  __pyx_codeobj__58 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__57, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_around, 744, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__58)) __PYX_ERR(0, 744, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":812
 * 
 * 
 * def array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
 * 
 */
  __pyx_tuple__59 = PyTuple_Pack(6, __pyx_n_s_object, __pyx_n_s_dtype, __pyx_n_s_copy, __pyx_n_s_order, __pyx_n_s_subok, __pyx_n_s_ndmin); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);
  __pyx_codeobj__60 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__59, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_array, 812, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__60)) __PYX_ERR(0, 812, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":906
 * 
 * 
 * def array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=repr):             # <<<<<<<<<<<<<<
 *     """Return a string representation of an array.
 * 
 */
  __pyx_tuple__61 = PyTuple_Pack(7, __pyx_n_s_a, __pyx_n_s_max_line_width, __pyx_n_s_precision, __pyx_n_s_suppress_small, __pyx_n_s_separator, __pyx_n_s_prefix, __pyx_n_s_style); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);
  __pyx_codeobj__62 = (PyObject*)__Pyx_PyCode_New(7, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__61, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_array2string, 906, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__62)) __PYX_ERR(0, 906, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":955
 * 
 * 
 * def array_equal(a1, a2):             # <<<<<<<<<<<<<<
 *     """True if two arrays have the same shape and elements, False otherwise.
 * 
 */
  __pyx_tuple__63 = PyTuple_Pack(2, __pyx_n_s_a1, __pyx_n_s_a2); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 955, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__63);
  __Pyx_GIVEREF(__pyx_tuple__63);
  __pyx_codeobj__64 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__63, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_array_equal, 955, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__64)) __PYX_ERR(0, 955, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":990
 * 
 * 
 * def array_equiv(a1, a2):             # <<<<<<<<<<<<<<
 *     """Returns True if input arrays are shape consistent and all elements equal.
 * 
 */
  __pyx_tuple__65 = PyTuple_Pack(2, __pyx_n_s_a1, __pyx_n_s_a2); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 990, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);
  __pyx_codeobj__66 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__65, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_array_equiv, 990, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__66)) __PYX_ERR(0, 990, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1027
 * 
 * 
 * def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return the string representation of an array.
 * 
 */
  __pyx_tuple__67 = PyTuple_Pack(4, __pyx_n_s_arr, __pyx_n_s_max_line_width, __pyx_n_s_precision, __pyx_n_s_suppress_small); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 1027, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);
  __pyx_codeobj__68 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__67, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_array_repr, 1027, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__68)) __PYX_ERR(0, 1027, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1071
 * 
 * 
 * def array_split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal or near-equal size.
 * 
 */
  __pyx_tuple__69 = PyTuple_Pack(3, __pyx_n_s_ary, __pyx_n_s_indices_or_sections, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 1071, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__69);
  __Pyx_GIVEREF(__pyx_tuple__69);
  __pyx_codeobj__70 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__69, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_array_split, 1071, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__70)) __PYX_ERR(0, 1071, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1093
 * 
 * 
 * def array_str(a, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return a string representation of the data in an array.
 * 
 */
  __pyx_tuple__71 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_max_line_width, __pyx_n_s_precision, __pyx_n_s_suppress_small); if (unlikely(!__pyx_tuple__71)) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__71);
  __Pyx_GIVEREF(__pyx_tuple__71);
  __pyx_codeobj__72 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__71, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_array_str, 1093, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__72)) __PYX_ERR(0, 1093, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1129
 * 
 * 
 * def asanyarray(a, dtype=None, order=None):             # <<<<<<<<<<<<<<
 *     """Convert the input to an ndarray, but pass ndarray subclasses through.
 * 
 */
  __pyx_tuple__73 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_dtype, __pyx_n_s_order); if (unlikely(!__pyx_tuple__73)) __PYX_ERR(0, 1129, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__73);
  __Pyx_GIVEREF(__pyx_tuple__73);
  __pyx_codeobj__74 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__73, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_asanyarray, 1129, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__74)) __PYX_ERR(0, 1129, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1181
 * 
 * 
 * def asarray_chkfinite(a):             # <<<<<<<<<<<<<<
 *     """Convert the input to an array, checking for NaNs or Infs.
 * 
 */
  __pyx_tuple__75 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__75)) __PYX_ERR(0, 1181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__75);
  __Pyx_GIVEREF(__pyx_tuple__75);
  __pyx_codeobj__76 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__75, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_asarray_chkfinite, 1181, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__76)) __PYX_ERR(0, 1181, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1243
 * 
 * 
 * def ascontiguousarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return a contiguous array in memory (C order).
 * 
 */
  __pyx_tuple__77 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__77)) __PYX_ERR(0, 1243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__77);
  __Pyx_GIVEREF(__pyx_tuple__77);
  __pyx_codeobj__78 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__77, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ascontiguousarray, 1243, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__78)) __PYX_ERR(0, 1243, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1279
 * 
 * 
 * def asfarray(a, dtype=np.float64):             # <<<<<<<<<<<<<<
 *     """Return an array converted to a float type.
 * 
 */
  __pyx_tuple__79 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__79)) __PYX_ERR(0, 1279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__79);
  __Pyx_GIVEREF(__pyx_tuple__79);
  __pyx_codeobj__80 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__79, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_asfarray, 1279, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__80)) __PYX_ERR(0, 1279, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1308
 * 
 * 
 * def asfortranarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return an array laid out in Fortran order in memory.
 * 
 */
  __pyx_tuple__81 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__81)) __PYX_ERR(0, 1308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__81);
  __Pyx_GIVEREF(__pyx_tuple__81);
  __pyx_codeobj__82 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__81, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_asfortranarray, 1308, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__82)) __PYX_ERR(0, 1308, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1344
 * 
 * 
 * def asmatrix(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_tuple__83 = PyTuple_Pack(2, __pyx_n_s_data, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__83)) __PYX_ERR(0, 1344, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__83);
  __Pyx_GIVEREF(__pyx_tuple__83);
  __pyx_codeobj__84 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__83, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_asmatrix, 1344, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__84)) __PYX_ERR(0, 1344, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1376
 * 
 * 
 * def asscalar(a):             # <<<<<<<<<<<<<<
 *     """Convert an array of size 1 to its scalar equivalent.
 * 
 */
  __pyx_tuple__85 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__85)) __PYX_ERR(0, 1376, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__85);
  __Pyx_GIVEREF(__pyx_tuple__85);
  __pyx_codeobj__86 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__85, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_asscalar, 1376, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__86)) __PYX_ERR(0, 1376, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1398
 * 
 * 
 * def atleast_1d():             # <<<<<<<<<<<<<<
 *     """Convert inputs to arrays with at least one dimension.
 * 
 */
  __pyx_codeobj__87 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_atleast_1d, 1398, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__87)) __PYX_ERR(0, 1398, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1439
 * 
 * 
 * def atleast_2d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least two dimensions.
 * 
 */
  __pyx_codeobj__88 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_atleast_2d, 1439, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__88)) __PYX_ERR(0, 1439, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1478
 * 
 * 
 * def atleast_3d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least three dimensions.
 * 
 */
  __pyx_codeobj__89 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_atleast_3d, 1478, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__89)) __PYX_ERR(0, 1478, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1529
 * 
 * 
 * def average(a, axis=None, weights=None, returned=False):             # <<<<<<<<<<<<<<
 *     """Compute the weighted average along the specified axis.
 * 
 */
  __pyx_tuple__90 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_weights, __pyx_n_s_returned); if (unlikely(!__pyx_tuple__90)) __PYX_ERR(0, 1529, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__90);
  __Pyx_GIVEREF(__pyx_tuple__90);
  __pyx_codeobj__91 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__90, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_average, 1529, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__91)) __PYX_ERR(0, 1529, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1604
 * 
 * 
 * def bartlett(M):             # <<<<<<<<<<<<<<
 *     """Return the Bartlett window.
 * 
 */
  __pyx_tuple__92 = PyTuple_Pack(1, __pyx_n_s_M); if (unlikely(!__pyx_tuple__92)) __PYX_ERR(0, 1604, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__92);
  __Pyx_GIVEREF(__pyx_tuple__92);
  __pyx_codeobj__93 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__92, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_bartlett, 1604, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__93)) __PYX_ERR(0, 1604, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1708
 * 
 * 
 * def base_repr(number, base=2, padding=0):             # <<<<<<<<<<<<<<
 *     """Return a string representation of a number in the given base system.
 * 
 */
  __pyx_tuple__94 = PyTuple_Pack(3, __pyx_n_s_number, __pyx_n_s_base, __pyx_n_s_padding); if (unlikely(!__pyx_tuple__94)) __PYX_ERR(0, 1708, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__94);
  __Pyx_GIVEREF(__pyx_tuple__94);
  __pyx_codeobj__95 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__94, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_base_repr, 1708, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__95)) __PYX_ERR(0, 1708, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1748
 * 
 * 
 * def binary_repr(num, width=None):             # <<<<<<<<<<<<<<
 *     """Return the binary representation of the input number as a string.
 * 
 */
  __pyx_tuple__96 = PyTuple_Pack(2, __pyx_n_s_num, __pyx_n_s_width); if (unlikely(!__pyx_tuple__96)) __PYX_ERR(0, 1748, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__96);
  __Pyx_GIVEREF(__pyx_tuple__96);
  __pyx_codeobj__97 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__96, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_binary_repr, 1748, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__97)) __PYX_ERR(0, 1748, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1808
 * 
 * 
 * def bincount(x, weights=None, minlength=None):             # <<<<<<<<<<<<<<
 *     """bincount(x, weights=None, minlength=None)
 * 
 */
  __pyx_tuple__98 = PyTuple_Pack(3, __pyx_n_s_x, __pyx_n_s_weights, __pyx_n_s_minlength); if (unlikely(!__pyx_tuple__98)) __PYX_ERR(0, 1808, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__98);
  __Pyx_GIVEREF(__pyx_tuple__98);
  __pyx_codeobj__99 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__98, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_bincount, 1808, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__99)) __PYX_ERR(0, 1808, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1883
 * 
 * 
 * def blackman(M):             # <<<<<<<<<<<<<<
 *     """Return the Blackman window.
 * 
 */
  __pyx_tuple__100 = PyTuple_Pack(1, __pyx_n_s_M); if (unlikely(!__pyx_tuple__100)) __PYX_ERR(0, 1883, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__100);
  __Pyx_GIVEREF(__pyx_tuple__100);
  __pyx_codeobj__101 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__100, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_blackman, 1883, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__101)) __PYX_ERR(0, 1883, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":1979
 * 
 * 
 * def bmat(obj, ldict=None, gdict=None):             # <<<<<<<<<<<<<<
 *     """Build a matrix object from a string, nested sequence, or array.
 * 
 */
  __pyx_tuple__102 = PyTuple_Pack(3, __pyx_n_s_obj, __pyx_n_s_ldict, __pyx_n_s_gdict); if (unlikely(!__pyx_tuple__102)) __PYX_ERR(0, 1979, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__102);
  __Pyx_GIVEREF(__pyx_tuple__102);
  __pyx_codeobj__103 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__102, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_bmat, 1979, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__103)) __PYX_ERR(0, 1979, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2026
 * 
 * 
 * def broadcast_arrays():             # <<<<<<<<<<<<<<
 *     """Broadcast any number of arrays against each other.
 * 
 */
  __pyx_codeobj__104 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_broadcast_arrays, 2026, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__104)) __PYX_ERR(0, 2026, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2067
 * 
 * 
 * def byte_bounds(a):             # <<<<<<<<<<<<<<
 *     """Returns pointers to the end-points of an array.
 * 
 */
  __pyx_tuple__105 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__105)) __PYX_ERR(0, 2067, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__105);
  __Pyx_GIVEREF(__pyx_tuple__105);
  __pyx_codeobj__106 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__105, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_byte_bounds, 2067, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__106)) __PYX_ERR(0, 2067, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2099
 * 
 * 
 * def can_cast():             # <<<<<<<<<<<<<<
 *     """can_cast(from, totype, casting = 'safe')
 * 
 */
  __pyx_codeobj__107 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_can_cast, 2099, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__107)) __PYX_ERR(0, 2099, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2202
 * 
 * 
 * def choose(a, choices, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Construct an array from an index array and a set of arrays to choose from.
 * 
 */
  __pyx_tuple__108 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_choices, __pyx_n_s_out, __pyx_n_s_mode); if (unlikely(!__pyx_tuple__108)) __PYX_ERR(0, 2202, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__108);
  __Pyx_GIVEREF(__pyx_tuple__108);
  __pyx_codeobj__109 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__108, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_choose, 2202, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__109)) __PYX_ERR(0, 2202, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2323
 * 
 * 
 * def column_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack 1-D arrays as columns into a 2-D array.
 * 
 */
  __pyx_tuple__110 = PyTuple_Pack(1, __pyx_n_s_tup); if (unlikely(!__pyx_tuple__110)) __PYX_ERR(0, 2323, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__110);
  __Pyx_GIVEREF(__pyx_tuple__110);
  __pyx_codeobj__111 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__110, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_column_stack, 2323, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__111)) __PYX_ERR(0, 2323, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2362
 * 
 * 
 * def common_type():             # <<<<<<<<<<<<<<
 *     """Return a scalar type which is common to the input arrays.
 * 
 */
  __pyx_codeobj__112 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_common_type, 2362, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__112)) __PYX_ERR(0, 2362, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2400
 * 
 * 
 * def compare_chararrays():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_codeobj__113 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_compare_chararrays, 2400, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__113)) __PYX_ERR(0, 2400, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2408
 * 
 * 
 * def compress(condition, a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return selected slices of an array along given axis.
 * 
 */
  __pyx_tuple__114 = PyTuple_Pack(4, __pyx_n_s_condition, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__114)) __PYX_ERR(0, 2408, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__114);
  __Pyx_GIVEREF(__pyx_tuple__114);
  __pyx_codeobj__115 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__114, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_compress, 2408, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__115)) __PYX_ERR(0, 2408, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2469
 * 
 * 
 * def concatenate():             # <<<<<<<<<<<<<<
 *     """concatenate((a1, a2, ...), axis=0)
 * 
 */
  __pyx_codeobj__116 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_concatenate, 2469, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__116)) __PYX_ERR(0, 2469, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2545
 * 
 * 
 * def convolve(a, v, mode='full'):             # <<<<<<<<<<<<<<
 *     """Returns the discrete, linear convolution of two one-dimensional sequences.
 * 
 */
  __pyx_tuple__117 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_v, __pyx_n_s_mode); if (unlikely(!__pyx_tuple__117)) __PYX_ERR(0, 2545, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__117);
  __Pyx_GIVEREF(__pyx_tuple__117);
  __pyx_codeobj__118 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__117, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_convolve, 2545, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__118)) __PYX_ERR(0, 2545, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2630
 * 
 * 
 * def copy(a):             # <<<<<<<<<<<<<<
 *     """Return an array copy of the given object.
 * 
 */
  __pyx_tuple__119 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__119)) __PYX_ERR(0, 2630, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__119);
  __Pyx_GIVEREF(__pyx_tuple__119);
  __pyx_codeobj__120 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__119, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_copy, 2630, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__120)) __PYX_ERR(0, 2630, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2669
 * 
 * 
 * def corrcoef(x, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Return correlation coefficients.
 * 
 */
  __pyx_tuple__121 = PyTuple_Pack(5, __pyx_n_s_x, __pyx_n_s_y, __pyx_n_s_rowvar, __pyx_n_s_bias, __pyx_n_s_ddof); if (unlikely(!__pyx_tuple__121)) __PYX_ERR(0, 2669, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__121);
  __Pyx_GIVEREF(__pyx_tuple__121);
  __pyx_codeobj__122 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__121, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_corrcoef, 2669, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__122)) __PYX_ERR(0, 2669, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2718
 * 
 * 
 * def correlate(a, v, mode='valid', old_behavior=False):             # <<<<<<<<<<<<<<
 *     """Cross-correlation of two 1-dimensional sequences.
 * 
 */
  __pyx_tuple__123 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_v, __pyx_n_s_mode, __pyx_n_s_old_behavior); if (unlikely(!__pyx_tuple__123)) __PYX_ERR(0, 2718, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__123);
  __Pyx_GIVEREF(__pyx_tuple__123);
  __pyx_codeobj__124 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__123, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_correlate, 2718, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__124)) __PYX_ERR(0, 2718, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2758
 * 
 * 
 * def count_nonzero(a):             # <<<<<<<<<<<<<<
 *     """count_nonzero(a)
 * 
 */
  __pyx_tuple__125 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__125)) __PYX_ERR(0, 2758, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__125);
  __Pyx_GIVEREF(__pyx_tuple__125);
  __pyx_codeobj__126 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__125, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_count_nonzero, 2758, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__126)) __PYX_ERR(0, 2758, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2790
 * 
 * 
 * def cov(m, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Estimate a covariance matrix, given data.
 * 
 */
  __pyx_tuple__127 = PyTuple_Pack(5, __pyx_n_s_m, __pyx_n_s_y, __pyx_n_s_rowvar, __pyx_n_s_bias, __pyx_n_s_ddof); if (unlikely(!__pyx_tuple__127)) __PYX_ERR(0, 2790, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__127);
  __Pyx_GIVEREF(__pyx_tuple__127);
  __pyx_codeobj__128 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__127, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_cov, 2790, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__128)) __PYX_ERR(0, 2790, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2871
 * 
 * 
 * def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the cross product of two (arrays of) vectors.
 * 
 */
  __pyx_tuple__129 = PyTuple_Pack(6, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_axisa, __pyx_n_s_axisb, __pyx_n_s_axisc, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__129)) __PYX_ERR(0, 2871, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__129);
  __Pyx_GIVEREF(__pyx_tuple__129);
  __pyx_codeobj__130 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__129, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_cross, 2871, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__130)) __PYX_ERR(0, 2871, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":2979
 * 
 * 
 * def cumprod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product of elements along a given axis.
 * 
 */
  __pyx_tuple__131 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__131)) __PYX_ERR(0, 2979, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__131);
  __Pyx_GIVEREF(__pyx_tuple__131);
  __pyx_codeobj__132 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__131, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_cumprod, 2979, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__132)) __PYX_ERR(0, 2979, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3041
 * 
 * 
 * def cumproduct(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product over the given axis.
 * 
 */
  __pyx_tuple__133 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__133)) __PYX_ERR(0, 3041, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__133);
  __Pyx_GIVEREF(__pyx_tuple__133);
  __pyx_codeobj__134 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__133, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_cumproduct, 3041, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__134)) __PYX_ERR(0, 3041, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3053
 * 
 * 
 * def cumsum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative sum of the elements along a given axis.
 * 
 */
  __pyx_tuple__135 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__135)) __PYX_ERR(0, 3053, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__135);
  __Pyx_GIVEREF(__pyx_tuple__135);
  __pyx_codeobj__136 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__135, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_cumsum, 3053, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__136)) __PYX_ERR(0, 3053, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3117
 * 
 * 
 * def datetime_data(dtype):             # <<<<<<<<<<<<<<
 *     """Return (unit, numerator, denominator, events) from a datetime dtype
 * 
 */
  __pyx_tuple__137 = PyTuple_Pack(1, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__137)) __PYX_ERR(0, 3117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__137);
  __Pyx_GIVEREF(__pyx_tuple__137);
  __pyx_codeobj__138 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__137, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_datetime_data, 3117, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__138)) __PYX_ERR(0, 3117, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3124
 * 
 * 
 * def delete(arr, obj, axis=None):             # <<<<<<<<<<<<<<
 *     """Return a new array with sub-arrays along an axis deleted.
 * 
 */
  __pyx_tuple__139 = PyTuple_Pack(3, __pyx_n_s_arr, __pyx_n_s_obj, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__139)) __PYX_ERR(0, 3124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__139);
  __Pyx_GIVEREF(__pyx_tuple__139);
  __pyx_codeobj__140 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__139, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_delete, 3124, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__140)) __PYX_ERR(0, 3124, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3171
 * 
 * 
 * def deprecate():             # <<<<<<<<<<<<<<
 *     """Issues a DeprecationWarning, adds warning to `old_name`'s
 *     docstring, rebinds ``old_name.__name__`` and returns the new
 */
  __pyx_codeobj__141 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_deprecate, 3171, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__141)) __PYX_ERR(0, 3171, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3214
 * 
 * 
 * def deprecate_with_doc(msg):             # <<<<<<<<<<<<<<
 *     """message
 * 
 */
  __pyx_tuple__142 = PyTuple_Pack(1, __pyx_n_s_msg); if (unlikely(!__pyx_tuple__142)) __PYX_ERR(0, 3214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__142);
  __Pyx_GIVEREF(__pyx_tuple__142);
  __pyx_codeobj__143 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__142, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_deprecate_with_doc, 3214, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__143)) __PYX_ERR(0, 3214, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3221
 * 
 * 
 * def diag_indices(n, ndim=2):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an array.
 * 
 */
  __pyx_tuple__144 = PyTuple_Pack(2, __pyx_n_s_n, __pyx_n_s_ndim); if (unlikely(!__pyx_tuple__144)) __PYX_ERR(0, 3221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__144);
  __Pyx_GIVEREF(__pyx_tuple__144);
  __pyx_codeobj__145 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__144, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_diag_indices, 3221, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__145)) __PYX_ERR(0, 3221, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3287
 * 
 * 
 * def diag_indices_from(arr):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an n-dimensional array.
 * 
 */
  __pyx_tuple__146 = PyTuple_Pack(1, __pyx_n_s_arr); if (unlikely(!__pyx_tuple__146)) __PYX_ERR(0, 3287, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__146);
  __Pyx_GIVEREF(__pyx_tuple__146);
  __pyx_codeobj__147 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__146, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_diag_indices_from, 3287, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__147)) __PYX_ERR(0, 3287, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3308
 * 
 * 
 * def diagflat(v, k=0):             # <<<<<<<<<<<<<<
 *     """Create a two-dimensional array with the flattened input as a diagonal.
 * 
 */
  __pyx_tuple__148 = PyTuple_Pack(2, __pyx_n_s_v, __pyx_n_s_k); if (unlikely(!__pyx_tuple__148)) __PYX_ERR(0, 3308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__148);
  __Pyx_GIVEREF(__pyx_tuple__148);
  __pyx_codeobj__149 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__148, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_diagflat, 3308, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__149)) __PYX_ERR(0, 3308, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3349
 * 
 * 
 * def diff(a, n=1, axis=-1):             # <<<<<<<<<<<<<<
 *     """Calculate the n-th order discrete difference along given axis.
 * 
 */
  __pyx_tuple__150 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_n, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__150)) __PYX_ERR(0, 3349, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__150);
  __Pyx_GIVEREF(__pyx_tuple__150);
  __pyx_codeobj__151 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__150, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_diff, 3349, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__151)) __PYX_ERR(0, 3349, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3394
 * 
 * 
 * def digitize(x, bins):             # <<<<<<<<<<<<<<
 *     """digitize(x, bins)
 * 
 */
  __pyx_tuple__152 = PyTuple_Pack(2, __pyx_n_s_x, __pyx_n_s_bins); if (unlikely(!__pyx_tuple__152)) __PYX_ERR(0, 3394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__152);
  __Pyx_GIVEREF(__pyx_tuple__152);
  __pyx_codeobj__153 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__152, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_digitize, 3394, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__153)) __PYX_ERR(0, 3394, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3453
 * 
 * 
 * def disp(mesg, device=None, linefeed=True):             # <<<<<<<<<<<<<<
 *     """Display a message on a device.
 * 
 */
  __pyx_tuple__154 = PyTuple_Pack(3, __pyx_n_s_mesg, __pyx_n_s_device, __pyx_n_s_linefeed); if (unlikely(!__pyx_tuple__154)) __PYX_ERR(0, 3453, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__154);
  __Pyx_GIVEREF(__pyx_tuple__154);
  __pyx_codeobj__155 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__154, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_disp, 3453, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__155)) __PYX_ERR(0, 3453, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3487
 * 
 * 
 * def dsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split array into multiple sub-arrays along the 3rd axis (depth).
 * 
 */
  __pyx_tuple__156 = PyTuple_Pack(2, __pyx_n_s_ary, __pyx_n_s_indices_or_sections); if (unlikely(!__pyx_tuple__156)) __PYX_ERR(0, 3487, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__156);
  __Pyx_GIVEREF(__pyx_tuple__156);
  __pyx_codeobj__157 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__156, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_dsplit, 3487, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__157)) __PYX_ERR(0, 3487, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3530
 * 
 * 
 * def dstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence depth wise (along third axis).
 * 
 */
  __pyx_tuple__158 = PyTuple_Pack(1, __pyx_n_s_tup); if (unlikely(!__pyx_tuple__158)) __PYX_ERR(0, 3530, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__158);
  __Pyx_GIVEREF(__pyx_tuple__158);
  __pyx_codeobj__159 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__158, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_dstack, 3530, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__159)) __PYX_ERR(0, 3530, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3580
 * 
 * 
 * def ediff1d(ary, to_end=None, to_begin=None):             # <<<<<<<<<<<<<<
 *     """The differences between consecutive elements of an array.
 * 
 */
  __pyx_tuple__160 = PyTuple_Pack(3, __pyx_n_s_ary, __pyx_n_s_to_end, __pyx_n_s_to_begin); if (unlikely(!__pyx_tuple__160)) __PYX_ERR(0, 3580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__160);
  __Pyx_GIVEREF(__pyx_tuple__160);
  __pyx_codeobj__161 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__160, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ediff1d, 3580, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__161)) __PYX_ERR(0, 3580, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3625
 * 
 * 
 * def einsum():             # <<<<<<<<<<<<<<
 *     """einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')
 * 
 */
  __pyx_codeobj__162 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_einsum, 3625, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__162)) __PYX_ERR(0, 3625, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3817
 * 
 * 
 * def expand_dims(a, axis):             # <<<<<<<<<<<<<<
 *     """Expand the shape of an array.
 * 
 */
  __pyx_tuple__163 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__163)) __PYX_ERR(0, 3817, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__163);
  __Pyx_GIVEREF(__pyx_tuple__163);
  __pyx_codeobj__164 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__163, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_expand_dims, 3817, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__164)) __PYX_ERR(0, 3817, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3870
 * 
 * 
 * def extract(condition, arr):             # <<<<<<<<<<<<<<
 *     """Return the elements of an array that satisfy some condition.
 * 
 */
  __pyx_tuple__165 = PyTuple_Pack(2, __pyx_n_s_condition, __pyx_n_s_arr); if (unlikely(!__pyx_tuple__165)) __PYX_ERR(0, 3870, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__165);
  __Pyx_GIVEREF(__pyx_tuple__165);
  __pyx_codeobj__166 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__165, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_extract, 3870, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__166)) __PYX_ERR(0, 3870, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3913
 * 
 * 
 * def _fastCopyAndTranspose(a):             # <<<<<<<<<<<<<<
 *     """_fastCopyAndTranspose(a)
 * 
 */
  __pyx_tuple__167 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__167)) __PYX_ERR(0, 3913, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__167);
  __Pyx_GIVEREF(__pyx_tuple__167);
  __pyx_codeobj__168 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__167, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fastCopyAndTranspose, 3913, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__168)) __PYX_ERR(0, 3913, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3921
 * 
 * 
 * def fill_diagonal(a, val):             # <<<<<<<<<<<<<<
 *     """Fill the main diagonal of the given array of any dimensionality.
 * 
 */
  __pyx_tuple__169 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_val); if (unlikely(!__pyx_tuple__169)) __PYX_ERR(0, 3921, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__169);
  __Pyx_GIVEREF(__pyx_tuple__169);
  __pyx_codeobj__170 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__169, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fill_diagonal, 3921, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__170)) __PYX_ERR(0, 3921, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":3982
 * 
 * 
 * def find_common_type(array_types, scalar_types):             # <<<<<<<<<<<<<<
 *     """Determine common type following standard coercion rules.
 * 
 */
  __pyx_tuple__171 = PyTuple_Pack(2, __pyx_n_s_array_types, __pyx_n_s_scalar_types); if (unlikely(!__pyx_tuple__171)) __PYX_ERR(0, 3982, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__171);
  __Pyx_GIVEREF(__pyx_tuple__171);
  __pyx_codeobj__172 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__171, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_find_common_type, 3982, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__172)) __PYX_ERR(0, 3982, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4035
 * 
 * 
 * def fix(x, y=None):             # <<<<<<<<<<<<<<
 *     """Round to nearest integer towards zero.
 * 
 */
  __pyx_tuple__173 = PyTuple_Pack(2, __pyx_n_s_x, __pyx_n_s_y); if (unlikely(!__pyx_tuple__173)) __PYX_ERR(0, 4035, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__173);
  __Pyx_GIVEREF(__pyx_tuple__173);
  __pyx_codeobj__174 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__173, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fix, 4035, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__174)) __PYX_ERR(0, 4035, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4071
 * 
 * 
 * def flatnonzero(a):             # <<<<<<<<<<<<<<
 *     """Return indices that are non-zero in the flattened version of a.
 * 
 */
  __pyx_tuple__175 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__175)) __PYX_ERR(0, 4071, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__175);
  __Pyx_GIVEREF(__pyx_tuple__175);
  __pyx_codeobj__176 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__175, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_flatnonzero, 4071, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__176)) __PYX_ERR(0, 4071, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4110
 * 
 * 
 * def fliplr(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the left/right direction.
 * 
 */
  __pyx_tuple__177 = PyTuple_Pack(1, __pyx_n_s_m); if (unlikely(!__pyx_tuple__177)) __PYX_ERR(0, 4110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__177);
  __Pyx_GIVEREF(__pyx_tuple__177);
  __pyx_codeobj__178 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__177, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fliplr, 4110, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__178)) __PYX_ERR(0, 4110, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4157
 * 
 * 
 * def flipud(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the up/down direction.
 * 
 */
  __pyx_tuple__179 = PyTuple_Pack(1, __pyx_n_s_m); if (unlikely(!__pyx_tuple__179)) __PYX_ERR(0, 4157, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__179);
  __Pyx_GIVEREF(__pyx_tuple__179);
  __pyx_codeobj__180 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__179, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_flipud, 4157, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__180)) __PYX_ERR(0, 4157, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4207
 * 
 * 
 * def frombuffer(buffer, dtype=float, count=-1, offset=0):             # <<<<<<<<<<<<<<
 *     """frombuffer(buffer, dtype=float, count=-1, offset=0)
 * 
 */
  __pyx_tuple__181 = PyTuple_Pack(4, __pyx_n_s_buffer, __pyx_n_s_dtype, __pyx_n_s_count, __pyx_n_s_offset); if (unlikely(!__pyx_tuple__181)) __PYX_ERR(0, 4207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__181);
  __Pyx_GIVEREF(__pyx_tuple__181);
  __pyx_codeobj__182 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__181, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_frombuffer, 4207, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__182)) __PYX_ERR(0, 4207, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4247
 * 
 * 
 * def fromfile(file, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromfile(file, dtype=float, count=-1, sep='')
 * 
 */
  __pyx_tuple__183 = PyTuple_Pack(4, __pyx_n_s_file, __pyx_n_s_dtype, __pyx_n_s_count, __pyx_n_s_sep); if (unlikely(!__pyx_tuple__183)) __PYX_ERR(0, 4247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__183);
  __Pyx_GIVEREF(__pyx_tuple__183);
  __pyx_codeobj__184 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__183, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fromfile, 4247, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__184)) __PYX_ERR(0, 4247, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4324
 * 
 * 
 * def fromiter(iterable, dtype, count=-1):             # <<<<<<<<<<<<<<
 *     """fromiter(iterable, dtype, count=-1)
 * 
 */
  __pyx_tuple__185 = PyTuple_Pack(3, __pyx_n_s_iterable, __pyx_n_s_dtype, __pyx_n_s_count); if (unlikely(!__pyx_tuple__185)) __PYX_ERR(0, 4324, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__185);
  __Pyx_GIVEREF(__pyx_tuple__185);
  __pyx_codeobj__186 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__185, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fromiter, 4324, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__186)) __PYX_ERR(0, 4324, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4360
 * 
 * 
 * def frompyfunc(func, nin, nout):             # <<<<<<<<<<<<<<
 *     """frompyfunc(func, nin, nout)
 * 
 */
  __pyx_tuple__187 = PyTuple_Pack(3, __pyx_n_s_func, __pyx_n_s_nin, __pyx_n_s_nout); if (unlikely(!__pyx_tuple__187)) __PYX_ERR(0, 4360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__187);
  __Pyx_GIVEREF(__pyx_tuple__187);
  __pyx_codeobj__188 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__187, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_frompyfunc, 4360, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__188)) __PYX_ERR(0, 4360, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4402
 * 
 * 
 * def fromregex(file, regexp, dtype):             # <<<<<<<<<<<<<<
 *     """Construct an array from a text file, using regular expression parsing.
 * 
 */
  __pyx_tuple__189 = PyTuple_Pack(3, __pyx_n_s_file, __pyx_n_s_regexp, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__189)) __PYX_ERR(0, 4402, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__189);
  __Pyx_GIVEREF(__pyx_tuple__189);
  __pyx_codeobj__190 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__189, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fromregex, 4402, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__190)) __PYX_ERR(0, 4402, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4459
 * 
 * 
 * def fromstring(string, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromstring(string, dtype=float, count=-1, sep='')
 * 
 */
  __pyx_tuple__191 = PyTuple_Pack(4, __pyx_n_s_string, __pyx_n_s_dtype, __pyx_n_s_count, __pyx_n_s_sep); if (unlikely(!__pyx_tuple__191)) __PYX_ERR(0, 4459, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__191);
  __Pyx_GIVEREF(__pyx_tuple__191);
  __pyx_codeobj__192 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__191, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fromstring, 4459, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__192)) __PYX_ERR(0, 4459, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4513
 * 
 * 
 * def fv(rate, nper, pmt, pv, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the future value.
 * 
 */
  __pyx_tuple__193 = PyTuple_Pack(5, __pyx_n_s_rate, __pyx_n_s_nper, __pyx_n_s_pmt, __pyx_n_s_pv, __pyx_n_s_when); if (unlikely(!__pyx_tuple__193)) __PYX_ERR(0, 4513, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__193);
  __Pyx_GIVEREF(__pyx_tuple__193);
  __pyx_codeobj__194 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__193, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_fv, 4513, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__194)) __PYX_ERR(0, 4513, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4596
 * 
 * 
 * def genfromtxt(fname, dtype=float, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True):             # <<<<<<<<<<<<<<
 *     """Load data from a text file, with missing values handled as specified.
 * 
 */
  __pyx_tuple__195 = PyTuple_Pack(23, __pyx_n_s_fname, __pyx_n_s_dtype, __pyx_n_s_comments, __pyx_n_s_delimiter, __pyx_n_s_skiprows, __pyx_n_s_skip_header, __pyx_n_s_skip_footer, __pyx_n_s_converters, __pyx_n_s_missing, __pyx_n_s_missing_values, __pyx_n_s_filling_values, __pyx_n_s_usecols, __pyx_n_s_names, __pyx_n_s_excludelist, __pyx_n_s_deletechars, __pyx_n_s_replace_space, __pyx_n_s_autostrip, __pyx_n_s_case_sensitive, __pyx_n_s_defaultfmt, __pyx_n_s_unpack, __pyx_n_s_usemask, __pyx_n_s_loose, __pyx_n_s_invalid_raise); if (unlikely(!__pyx_tuple__195)) __PYX_ERR(0, 4596, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__195);
  __Pyx_GIVEREF(__pyx_tuple__195);
  __pyx_codeobj__196 = (PyObject*)__Pyx_PyCode_New(23, 0, 23, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__195, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_genfromtxt, 4596, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__196)) __PYX_ERR(0, 4596, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4734
 * 
 * 
 * def get_array_wrap():             # <<<<<<<<<<<<<<
 *     """Find the wrapper for the array with the highest priority.
 * 
 */
  __pyx_codeobj__197 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_get_array_wrap, 4734, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__197)) __PYX_ERR(0, 4734, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4743
 * 
 * 
 * def get_include():             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the NumPy \*.h header files.
 * 
 */
  __pyx_codeobj__198 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_get_include, 4743, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__198)) __PYX_ERR(0, 4743, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4764
 * 
 * 
 * def get_numarray_include(type=None):             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the numarray \*.h header files.
 * 
 */
  __pyx_tuple__199 = PyTuple_Pack(1, __pyx_n_s_type); if (unlikely(!__pyx_tuple__199)) __PYX_ERR(0, 4764, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__199);
  __Pyx_GIVEREF(__pyx_tuple__199);
  __pyx_codeobj__200 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__199, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_get_numarray_include, 4764, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__200)) __PYX_ERR(0, 4764, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4800
 * 
 * 
 * def get_printoptions():             # <<<<<<<<<<<<<<
 *     """Return the current print options.
 * 
 */
  __pyx_codeobj__201 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_get_printoptions, 4800, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__201)) __PYX_ERR(0, 4800, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4826
 * 
 * 
 * def getbuffer():             # <<<<<<<<<<<<<<
 *     """getbuffer(obj [,offset[, size]])
 * 
 */
  __pyx_codeobj__202 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_getbuffer, 4826, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__202)) __PYX_ERR(0, 4826, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4862
 * 
 * 
 * def getbufsize():             # <<<<<<<<<<<<<<
 *     """Return the size of the buffer used in ufuncs.
 * 
 */
  __pyx_codeobj__203 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_getbufsize, 4862, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__203)) __PYX_ERR(0, 4862, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4869
 * 
 * 
 * def geterr():             # <<<<<<<<<<<<<<
 *     """Get the current way of handling floating-point errors.
 * 
 */
  __pyx_codeobj__204 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_geterr, 4869, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__204)) __PYX_ERR(0, 4869, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4908
 * 
 * 
 * def geterrcall():             # <<<<<<<<<<<<<<
 *     """Return the current callback function used on floating-point errors.
 * 
 */
  __pyx_codeobj__205 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_geterrcall, 4908, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__205)) __PYX_ERR(0, 4908, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":4952
 * 
 * 
 * def geterrobj():             # <<<<<<<<<<<<<<
 *     """geterrobj()
 * 
 */
  __pyx_codeobj__206 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_geterrobj, 4952, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__206)) __PYX_ERR(0, 4952, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5018
 * 
 * 
 * def gradient(f):             # <<<<<<<<<<<<<<
 *     """Return the gradient of an N-dimensional array.
 * 
 */
  __pyx_tuple__207 = PyTuple_Pack(1, __pyx_n_s_f); if (unlikely(!__pyx_tuple__207)) __PYX_ERR(0, 5018, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__207);
  __Pyx_GIVEREF(__pyx_tuple__207);
  __pyx_codeobj__208 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__207, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_gradient, 5018, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__208)) __PYX_ERR(0, 5018, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5058
 * 
 * 
 * def hamming(M):             # <<<<<<<<<<<<<<
 *     """Return the Hamming window.
 * 
 */
  __pyx_tuple__209 = PyTuple_Pack(1, __pyx_n_s_M); if (unlikely(!__pyx_tuple__209)) __PYX_ERR(0, 5058, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__209);
  __Pyx_GIVEREF(__pyx_tuple__209);
  __pyx_codeobj__210 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__209, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_hamming, 5058, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__210)) __PYX_ERR(0, 5058, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5152
 * 
 * 
 * def hanning(M):             # <<<<<<<<<<<<<<
 *     """Return the Hanning window.
 * 
 */
  __pyx_tuple__211 = PyTuple_Pack(1, __pyx_n_s_M); if (unlikely(!__pyx_tuple__211)) __PYX_ERR(0, 5152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__211);
  __Pyx_GIVEREF(__pyx_tuple__211);
  __pyx_codeobj__212 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__211, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_hanning, 5152, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__212)) __PYX_ERR(0, 5152, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5248
 * 
 * 
 * def histogram(a, bins=10, range=None, normed=False, weights=None, density=None):             # <<<<<<<<<<<<<<
 *     """Compute the histogram of a set of data.
 * 
 */
  __pyx_tuple__213 = PyTuple_Pack(6, __pyx_n_s_a, __pyx_n_s_bins, __pyx_n_s_range, __pyx_n_s_normed, __pyx_n_s_weights, __pyx_n_s_density); if (unlikely(!__pyx_tuple__213)) __PYX_ERR(0, 5248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__213);
  __Pyx_GIVEREF(__pyx_tuple__213);
  __pyx_codeobj__214 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__213, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_histogram, 5248, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__214)) __PYX_ERR(0, 5248, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5333
 * 
 * 
 * def histogram2d(x, y, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the bi-dimensional histogram of two data samples.
 * 
 */
  __pyx_tuple__215 = PyTuple_Pack(6, __pyx_n_s_x, __pyx_n_s_y, __pyx_n_s_bins, __pyx_n_s_range, __pyx_n_s_normed, __pyx_n_s_weights); if (unlikely(!__pyx_tuple__215)) __PYX_ERR(0, 5333, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__215);
  __Pyx_GIVEREF(__pyx_tuple__215);
  __pyx_codeobj__216 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__215, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_histogram2d, 5333, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__216)) __PYX_ERR(0, 5333, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5418
 * 
 * 
 * def histogramdd(sample, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the multidimensional histogram of some data.
 * 
 */
  __pyx_tuple__217 = PyTuple_Pack(5, __pyx_n_s_sample, __pyx_n_s_bins, __pyx_n_s_range, __pyx_n_s_normed, __pyx_n_s_weights); if (unlikely(!__pyx_tuple__217)) __PYX_ERR(0, 5418, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__217);
  __Pyx_GIVEREF(__pyx_tuple__217);
  __pyx_codeobj__218 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__217, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_histogramdd, 5418, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__218)) __PYX_ERR(0, 5418, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5471
 * 
 * 
 * def hsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays horizontally (column-wise).
 * 
 */
  __pyx_tuple__219 = PyTuple_Pack(2, __pyx_n_s_ary, __pyx_n_s_indices_or_sections); if (unlikely(!__pyx_tuple__219)) __PYX_ERR(0, 5471, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__219);
  __Pyx_GIVEREF(__pyx_tuple__219);
  __pyx_codeobj__220 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__219, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_hsplit, 5471, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__220)) __PYX_ERR(0, 5471, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5528
 * 
 * 
 * def hstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence horizontally (column wise).
 * 
 */
  __pyx_tuple__221 = PyTuple_Pack(1, __pyx_n_s_tup); if (unlikely(!__pyx_tuple__221)) __PYX_ERR(0, 5528, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__221);
  __Pyx_GIVEREF(__pyx_tuple__221);
  __pyx_codeobj__222 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__221, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_hstack, 5528, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__222)) __PYX_ERR(0, 5528, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5572
 * 
 * 
 * def i0(x):             # <<<<<<<<<<<<<<
 *     """Modified Bessel function of the first kind, order 0.
 * 
 */
  __pyx_tuple__223 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__223)) __PYX_ERR(0, 5572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__223);
  __Pyx_GIVEREF(__pyx_tuple__223);
  __pyx_codeobj__224 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__223, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_i0, 5572, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__224)) __PYX_ERR(0, 5572, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5628
 * 
 * 
 * def imag(val):             # <<<<<<<<<<<<<<
 *     """Return the imaginary part of the elements of the array.
 * 
 */
  __pyx_tuple__225 = PyTuple_Pack(1, __pyx_n_s_val); if (unlikely(!__pyx_tuple__225)) __PYX_ERR(0, 5628, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__225);
  __Pyx_GIVEREF(__pyx_tuple__225);
  __pyx_codeobj__226 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__225, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_imag, 5628, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__226)) __PYX_ERR(0, 5628, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5659
 * 
 * 
 * def in1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Test whether each element of a 1D array is also present in a second array.
 * 
 */
  __pyx_tuple__227 = PyTuple_Pack(3, __pyx_n_s_ar1, __pyx_n_s_ar2, __pyx_n_s_assume_unique); if (unlikely(!__pyx_tuple__227)) __PYX_ERR(0, 5659, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__227);
  __Pyx_GIVEREF(__pyx_tuple__227);
  __pyx_codeobj__228 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__227, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_in1d, 5659, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__228)) __PYX_ERR(0, 5659, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5707
 * 
 * 
 * def indices(dimensions, dtype=int):             # <<<<<<<<<<<<<<
 *     """Return an array representing the indices of a grid.
 * 
 */
  __pyx_tuple__229 = PyTuple_Pack(2, __pyx_n_s_dimensions, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__229)) __PYX_ERR(0, 5707, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__229);
  __Pyx_GIVEREF(__pyx_tuple__229);
  __pyx_codeobj__230 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__229, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_indices, 5707, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__230)) __PYX_ERR(0, 5707, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5769
 * 
 * 
 * def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):             # <<<<<<<<<<<<<<
 *     """Get help information for a function, class, or module.
 * 
 */
  __pyx_tuple__231 = PyTuple_Pack(4, __pyx_n_s_object, __pyx_n_s_maxwidth, __pyx_n_s_output, __pyx_n_s_toplevel); if (unlikely(!__pyx_tuple__231)) __PYX_ERR(0, 5769, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__231);
  __Pyx_GIVEREF(__pyx_tuple__231);
  __pyx_codeobj__232 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__231, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_info, 5769, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__232)) __PYX_ERR(0, 5769, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5819
 * 
 * 
 * def inner(a, b):             # <<<<<<<<<<<<<<
 *     """inner(a, b)
 * 
 */
  __pyx_tuple__233 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_b); if (unlikely(!__pyx_tuple__233)) __PYX_ERR(0, 5819, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__233);
  __Pyx_GIVEREF(__pyx_tuple__233);
  __pyx_codeobj__234 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__233, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_inner, 5819, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__234)) __PYX_ERR(0, 5819, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5895
 * 
 * 
 * def insert(arr, obj, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Insert values along the given axis before the given indices.
 * 
 */
  __pyx_tuple__235 = PyTuple_Pack(4, __pyx_n_s_arr, __pyx_n_s_obj, __pyx_n_s_values, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__235)) __PYX_ERR(0, 5895, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__235);
  __Pyx_GIVEREF(__pyx_tuple__235);
  __pyx_codeobj__236 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__235, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_insert, 5895, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__236)) __PYX_ERR(0, 5895, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5960
 * 
 * 
 * def int_asbuffer():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_codeobj__237 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_int_asbuffer, 5960, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__237)) __PYX_ERR(0, 5960, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":5968
 * 
 * 
 * def interp(x, xp, fp, left=None, right=None):             # <<<<<<<<<<<<<<
 *     """One-dimensional linear interpolation.
 * 
 */
  __pyx_tuple__238 = PyTuple_Pack(5, __pyx_n_s_x, __pyx_n_s_xp, __pyx_n_s_fp, __pyx_n_s_left, __pyx_n_s_right); if (unlikely(!__pyx_tuple__238)) __PYX_ERR(0, 5968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__238);
  __Pyx_GIVEREF(__pyx_tuple__238);
  __pyx_codeobj__239 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__238, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_interp, 5968, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__239)) __PYX_ERR(0, 5968, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6039
 * 
 * 
 * def intersect1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the intersection of two arrays.
 * 
 */
  __pyx_tuple__240 = PyTuple_Pack(3, __pyx_n_s_ar1, __pyx_n_s_ar2, __pyx_n_s_assume_unique); if (unlikely(!__pyx_tuple__240)) __PYX_ERR(0, 6039, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__240);
  __Pyx_GIVEREF(__pyx_tuple__240);
  __pyx_codeobj__241 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__240, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_intersect1d, 6039, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__241)) __PYX_ERR(0, 6039, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6071
 * 
 * 
 * def ipmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment portion for loan interest.
 * 
 */
  __pyx_tuple__242 = PyTuple_Pack(6, __pyx_n_s_rate, __pyx_n_s_per, __pyx_n_s_nper, __pyx_n_s_pv, __pyx_n_s_fv, __pyx_n_s_when); if (unlikely(!__pyx_tuple__242)) __PYX_ERR(0, 6071, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__242);
  __Pyx_GIVEREF(__pyx_tuple__242);
  __pyx_codeobj__243 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__242, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ipmt, 6071, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__243)) __PYX_ERR(0, 6071, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6113
 * 
 * 
 * def irr(values):             # <<<<<<<<<<<<<<
 *     """Return the Internal Rate of Return (IRR).
 * 
 */
  __pyx_tuple__244 = PyTuple_Pack(1, __pyx_n_s_values); if (unlikely(!__pyx_tuple__244)) __PYX_ERR(0, 6113, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__244);
  __Pyx_GIVEREF(__pyx_tuple__244);
  __pyx_codeobj__245 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__244, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_irr, 6113, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__245)) __PYX_ERR(0, 6113, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6168
 * 
 * 
 * def iscomplex(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is complex.
 * 
 */
  __pyx_tuple__246 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__246)) __PYX_ERR(0, 6168, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__246);
  __Pyx_GIVEREF(__pyx_tuple__246);
  __pyx_codeobj__247 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__246, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_iscomplex, 6168, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__247)) __PYX_ERR(0, 6168, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6199
 * 
 * 
 * def iscomplexobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a complex type or an array of complex numbers.
 * 
 */
  __pyx_tuple__248 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__248)) __PYX_ERR(0, 6199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__248);
  __Pyx_GIVEREF(__pyx_tuple__248);
  __pyx_codeobj__249 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__248, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_iscomplexobj, 6199, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__249)) __PYX_ERR(0, 6199, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6233
 * 
 * 
 * def isfortran(a):             # <<<<<<<<<<<<<<
 *     """Returns True if array is arranged in Fortran-order in memory
 *     and dimension > 1.
 */
  __pyx_tuple__250 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__250)) __PYX_ERR(0, 6233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__250);
  __Pyx_GIVEREF(__pyx_tuple__250);
  __pyx_codeobj__251 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__250, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_isfortran, 6233, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__251)) __PYX_ERR(0, 6233, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6290
 * 
 * 
 * def isneginf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for negative infinity, return result as bool array.
 * 
 */
  __pyx_tuple__252 = PyTuple_Pack(2, __pyx_n_s_x, __pyx_n_s_y); if (unlikely(!__pyx_tuple__252)) __PYX_ERR(0, 6290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__252);
  __Pyx_GIVEREF(__pyx_tuple__252);
  __pyx_codeobj__253 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__252, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_isneginf, 6290, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__253)) __PYX_ERR(0, 6290, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6349
 * 
 * 
 * def isposinf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for positive infinity, return result as bool array.
 * 
 */
  __pyx_tuple__254 = PyTuple_Pack(2, __pyx_n_s_x, __pyx_n_s_y); if (unlikely(!__pyx_tuple__254)) __PYX_ERR(0, 6349, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__254);
  __Pyx_GIVEREF(__pyx_tuple__254);
  __pyx_codeobj__255 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__254, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_isposinf, 6349, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__255)) __PYX_ERR(0, 6349, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6407
 * 
 * 
 * def isreal(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is real.
 * 
 */
  __pyx_tuple__256 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__256)) __PYX_ERR(0, 6407, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__256);
  __Pyx_GIVEREF(__pyx_tuple__256);
  __pyx_codeobj__257 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__256, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_isreal, 6407, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__257)) __PYX_ERR(0, 6407, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6437
 * 
 * 
 * def isrealobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a not complex type or an array of complex numbers.
 * 
 */
  __pyx_tuple__258 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__258)) __PYX_ERR(0, 6437, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__258);
  __Pyx_GIVEREF(__pyx_tuple__258);
  __pyx_codeobj__259 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__258, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_isrealobj, 6437, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__259)) __PYX_ERR(0, 6437, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6471
 * 
 * 
 * def isscalar(num):             # <<<<<<<<<<<<<<
 *     """Returns True if the type of `num` is a scalar type.
 * 
 */
  __pyx_tuple__260 = PyTuple_Pack(1, __pyx_n_s_num); if (unlikely(!__pyx_tuple__260)) __PYX_ERR(0, 6471, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__260);
  __Pyx_GIVEREF(__pyx_tuple__260);
  __pyx_codeobj__261 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__260, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_isscalar, 6471, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__261)) __PYX_ERR(0, 6471, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6497
 * 
 * 
 * def issctype(rep):             # <<<<<<<<<<<<<<
 *     """Determines whether the given object represents a scalar data-type.
 * 
 */
  __pyx_tuple__262 = PyTuple_Pack(1, __pyx_n_s_rep); if (unlikely(!__pyx_tuple__262)) __PYX_ERR(0, 6497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__262);
  __Pyx_GIVEREF(__pyx_tuple__262);
  __pyx_codeobj__263 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__262, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_issctype, 6497, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__263)) __PYX_ERR(0, 6497, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6533
 * 
 * 
 * def issubclass_(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if a class is a subclass of a second class.
 * 
 */
  __pyx_tuple__264 = PyTuple_Pack(2, __pyx_n_s_arg1, __pyx_n_s_arg2); if (unlikely(!__pyx_tuple__264)) __PYX_ERR(0, 6533, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__264);
  __Pyx_GIVEREF(__pyx_tuple__264);
  __pyx_codeobj__265 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__264, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_issubclass, 6533, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__265)) __PYX_ERR(0, 6533, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6568
 * 
 * 
 * def issubdtype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Returns True if first argument is a typecode lower/equal in type hierarchy.
 * 
 */
  __pyx_tuple__266 = PyTuple_Pack(2, __pyx_n_s_arg1, __pyx_n_s_arg2); if (unlikely(!__pyx_tuple__266)) __PYX_ERR(0, 6568, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__266);
  __Pyx_GIVEREF(__pyx_tuple__266);
  __pyx_codeobj__267 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__266, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_issubdtype, 6568, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__267)) __PYX_ERR(0, 6568, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6596
 * 
 * 
 * def issubsctype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if the first argument is a subclass of the second argument.
 * 
 */
  __pyx_tuple__268 = PyTuple_Pack(2, __pyx_n_s_arg1, __pyx_n_s_arg2); if (unlikely(!__pyx_tuple__268)) __PYX_ERR(0, 6596, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__268);
  __Pyx_GIVEREF(__pyx_tuple__268);
  __pyx_codeobj__269 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__268, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_issubsctype, 6596, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__269)) __PYX_ERR(0, 6596, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6626
 * 
 * 
 * def iterable(y):             # <<<<<<<<<<<<<<
 *     """Check whether or not an object can be iterated over.
 * 
 */
  __pyx_tuple__270 = PyTuple_Pack(1, __pyx_n_s_y); if (unlikely(!__pyx_tuple__270)) __PYX_ERR(0, 6626, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__270);
  __Pyx_GIVEREF(__pyx_tuple__270);
  __pyx_codeobj__271 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__270, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_iterable, 6626, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__271)) __PYX_ERR(0, 6626, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6652
 * 
 * 
 * def ix_():             # <<<<<<<<<<<<<<
 *     """Construct an open mesh from multiple sequences.
 * 
 */
  __pyx_codeobj__272 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ix, 6652, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__272)) __PYX_ERR(0, 6652, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6698
 * 
 * 
 * def kaiser(M, beta):             # <<<<<<<<<<<<<<
 *     """Return the Kaiser window.
 * 
 */
  __pyx_tuple__273 = PyTuple_Pack(2, __pyx_n_s_M, __pyx_n_s_beta); if (unlikely(!__pyx_tuple__273)) __PYX_ERR(0, 6698, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__273);
  __Pyx_GIVEREF(__pyx_tuple__273);
  __pyx_codeobj__274 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__273, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_kaiser, 6698, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__274)) __PYX_ERR(0, 6698, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6825
 * 
 * 
 * def kron(a, b):             # <<<<<<<<<<<<<<
 *     """Kronecker product of two arrays.
 * 
 */
  __pyx_tuple__275 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_b); if (unlikely(!__pyx_tuple__275)) __PYX_ERR(0, 6825, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__275);
  __Pyx_GIVEREF(__pyx_tuple__275);
  __pyx_codeobj__276 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__275, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_kron, 6825, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__276)) __PYX_ERR(0, 6825, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6897
 * 
 * 
 * def lexsort(keys, axis=-1):             # <<<<<<<<<<<<<<
 *     """lexsort(keys, axis=-1)
 * 
 */
  __pyx_tuple__277 = PyTuple_Pack(2, __pyx_n_s_keys, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__277)) __PYX_ERR(0, 6897, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__277);
  __Pyx_GIVEREF(__pyx_tuple__277);
  __pyx_codeobj__278 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__277, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_lexsort, 6897, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__278)) __PYX_ERR(0, 6897, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":6975
 * 
 * 
 * def load(file, mmap_mode=None):             # <<<<<<<<<<<<<<
 *     """Load a pickled, ``.npy``, or ``.npz`` binary file.
 * 
 */
  __pyx_tuple__279 = PyTuple_Pack(2, __pyx_n_s_file, __pyx_n_s_mmap_mode); if (unlikely(!__pyx_tuple__279)) __PYX_ERR(0, 6975, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__279);
  __Pyx_GIVEREF(__pyx_tuple__279);
  __pyx_codeobj__280 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__279, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_load, 6975, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__280)) __PYX_ERR(0, 6975, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7037
 * 
 * 
 * def loads():             # <<<<<<<<<<<<<<
 *     """loads(string) -- Load a pickle from the given string
 * 
 */
  __pyx_codeobj__281 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_loads, 7037, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__281)) __PYX_ERR(0, 7037, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7045
 * 
 * 
 * def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """Load data from a text file.
 * 
 */
  __pyx_tuple__282 = PyTuple_Pack(9, __pyx_n_s_fname, __pyx_n_s_dtype, __pyx_n_s_comments, __pyx_n_s_delimiter, __pyx_n_s_converters, __pyx_n_s_skiprows, __pyx_n_s_usecols, __pyx_n_s_unpack, __pyx_n_s_ndmin); if (unlikely(!__pyx_tuple__282)) __PYX_ERR(0, 7045, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__282);
  __Pyx_GIVEREF(__pyx_tuple__282);
  __pyx_codeobj__283 = (PyObject*)__Pyx_PyCode_New(9, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__282, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_loadtxt, 7045, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__283)) __PYX_ERR(0, 7045, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7132
 * 
 * 
 * def lookfor(what, module=None, import_modules=True, regenerate=False, output=None):             # <<<<<<<<<<<<<<
 *     """Do a keyword search on docstrings.
 * 
 */
  __pyx_tuple__284 = PyTuple_Pack(5, __pyx_n_s_what, __pyx_n_s_module, __pyx_n_s_import_modules, __pyx_n_s_regenerate, __pyx_n_s_output); if (unlikely(!__pyx_tuple__284)) __PYX_ERR(0, 7132, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__284);
  __Pyx_GIVEREF(__pyx_tuple__284);
  __pyx_codeobj__285 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__284, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_lookfor, 7132, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__285)) __PYX_ERR(0, 7132, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7179
 * 
 * 
 * def mafromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a text file and return a masked array.
 * 
 */
  __pyx_tuple__286 = PyTuple_Pack(1, __pyx_n_s_fname); if (unlikely(!__pyx_tuple__286)) __PYX_ERR(0, 7179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__286);
  __Pyx_GIVEREF(__pyx_tuple__286);
  __pyx_codeobj__287 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__286, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_mafromtxt, 7179, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__287)) __PYX_ERR(0, 7179, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7192
 * 
 * 
 * def mask_indices(n, mask_func, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices to access (n, n) arrays, given a masking function.
 * 
 */
  __pyx_tuple__288 = PyTuple_Pack(3, __pyx_n_s_n, __pyx_n_s_mask_func, __pyx_n_s_k); if (unlikely(!__pyx_tuple__288)) __PYX_ERR(0, 7192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__288);
  __Pyx_GIVEREF(__pyx_tuple__288);
  __pyx_codeobj__289 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__288, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_mask_indices, 7192, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__289)) __PYX_ERR(0, 7192, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7259
 * 
 * 
 * def mat(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_tuple__290 = PyTuple_Pack(2, __pyx_n_s_data, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__290)) __PYX_ERR(0, 7259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__290);
  __Pyx_GIVEREF(__pyx_tuple__290);
  __pyx_codeobj__291 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__290, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_mat, 7259, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__291)) __PYX_ERR(0, 7259, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7291
 * 
 * 
 * def max(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_tuple__292 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__292)) __PYX_ERR(0, 7291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__292);
  __Pyx_GIVEREF(__pyx_tuple__292);
  __pyx_codeobj__293 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__292, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_max, 7291, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__293)) __PYX_ERR(0, 7291, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7348
 * 
 * 
 * def maximum_sctype(t):             # <<<<<<<<<<<<<<
 *     """Return the scalar type of highest precision of the same kind as the input.
 * 
 */
  __pyx_tuple__294 = PyTuple_Pack(1, __pyx_n_s_t); if (unlikely(!__pyx_tuple__294)) __PYX_ERR(0, 7348, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__294);
  __Pyx_GIVEREF(__pyx_tuple__294);
  __pyx_codeobj__295 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__294, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_maximum_sctype, 7348, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__295)) __PYX_ERR(0, 7348, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7388
 * 
 * 
 * def may_share_memory(a, b):             # <<<<<<<<<<<<<<
 *     """Determine if two arrays can share memory
 * 
 */
  __pyx_tuple__296 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_b); if (unlikely(!__pyx_tuple__296)) __PYX_ERR(0, 7388, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__296);
  __Pyx_GIVEREF(__pyx_tuple__296);
  __pyx_codeobj__297 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__296, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_may_share_memory, 7388, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__297)) __PYX_ERR(0, 7388, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7414
 * 
 * 
 * def mean(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Compute the arithmetic mean along the specified axis.
 * 
 */
  __pyx_tuple__298 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__298)) __PYX_ERR(0, 7414, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__298);
  __Pyx_GIVEREF(__pyx_tuple__298);
  __pyx_codeobj__299 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__298, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_mean, 7414, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__299)) __PYX_ERR(0, 7414, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7487
 * 
 * 
 * def median(a, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the median along the specified axis.
 * 
 */
  __pyx_tuple__300 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out, __pyx_n_s_overwrite_input); if (unlikely(!__pyx_tuple__300)) __PYX_ERR(0, 7487, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__300);
  __Pyx_GIVEREF(__pyx_tuple__300);
  __pyx_codeobj__301 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__300, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_median, 7487, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__301)) __PYX_ERR(0, 7487, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7563
 * 
 * 
 * def meshgrid(x, y):             # <<<<<<<<<<<<<<
 *     """Return coordinate matrices from two coordinate vectors.
 * 
 */
  __pyx_tuple__302 = PyTuple_Pack(2, __pyx_n_s_x, __pyx_n_s_y); if (unlikely(!__pyx_tuple__302)) __PYX_ERR(0, 7563, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__302);
  __Pyx_GIVEREF(__pyx_tuple__302);
  __pyx_codeobj__303 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__302, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_meshgrid, 7563, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__303)) __PYX_ERR(0, 7563, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7611
 * 
 * 
 * def min(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_tuple__304 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__304)) __PYX_ERR(0, 7611, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__304);
  __Pyx_GIVEREF(__pyx_tuple__304);
  __pyx_codeobj__305 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__304, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_min, 7611, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__305)) __PYX_ERR(0, 7611, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7668
 * 
 * 
 * def min_scalar_type(a):             # <<<<<<<<<<<<<<
 *     """min_scalar_type(a)
 * 
 */
  __pyx_tuple__306 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__306)) __PYX_ERR(0, 7668, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__306);
  __Pyx_GIVEREF(__pyx_tuple__306);
  __pyx_codeobj__307 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__306, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_min_scalar_type, 7668, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__307)) __PYX_ERR(0, 7668, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7718
 * 
 * 
 * def mintypecode(typechars, typeset='GDFgdf', default='d'):             # <<<<<<<<<<<<<<
 *     """Return the character for the minimum-size type to which given types can
 *     be safely cast.
 */
  __pyx_tuple__308 = PyTuple_Pack(3, __pyx_n_s_typechars, __pyx_n_s_typeset, __pyx_n_s_default); if (unlikely(!__pyx_tuple__308)) __PYX_ERR(0, 7718, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__308);
  __Pyx_GIVEREF(__pyx_tuple__308);
  __pyx_codeobj__309 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__308, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_mintypecode, 7718, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__309)) __PYX_ERR(0, 7718, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7763
 * 
 * 
 * def mirr(values, finance_rate, reinvest_rate):             # <<<<<<<<<<<<<<
 *     """Modified internal rate of return.
 * 
 */
  __pyx_tuple__310 = PyTuple_Pack(3, __pyx_n_s_values, __pyx_n_s_finance_rate, __pyx_n_s_reinvest_rate); if (unlikely(!__pyx_tuple__310)) __PYX_ERR(0, 7763, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__310);
  __Pyx_GIVEREF(__pyx_tuple__310);
  __pyx_codeobj__311 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__310, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_mirr, 7763, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__311)) __PYX_ERR(0, 7763, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7785
 * 
 * 
 * def msort(a):             # <<<<<<<<<<<<<<
 *     """Return a copy of an array sorted along the first axis.
 * 
 */
  __pyx_tuple__312 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__312)) __PYX_ERR(0, 7785, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__312);
  __Pyx_GIVEREF(__pyx_tuple__312);
  __pyx_codeobj__313 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__312, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_msort, 7785, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__313)) __PYX_ERR(0, 7785, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7810
 * 
 * 
 * def nan_to_num(x):             # <<<<<<<<<<<<<<
 *     """Replace nan with zero and inf with finite numbers.
 * 
 */
  __pyx_tuple__314 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__314)) __PYX_ERR(0, 7810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__314);
  __Pyx_GIVEREF(__pyx_tuple__314);
  __pyx_codeobj__315 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__314, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nan_to_num, 7810, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__315)) __PYX_ERR(0, 7810, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7857
 * 
 * 
 * def nanargmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the maximum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_tuple__316 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__316)) __PYX_ERR(0, 7857, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__316);
  __Pyx_GIVEREF(__pyx_tuple__316);
  __pyx_codeobj__317 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__316, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nanargmax, 7857, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__317)) __PYX_ERR(0, 7857, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7892
 * 
 * 
 * def nanargmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the minimum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_tuple__318 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__318)) __PYX_ERR(0, 7892, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__318);
  __Pyx_GIVEREF(__pyx_tuple__318);
  __pyx_codeobj__319 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__318, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nanargmin, 7892, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__319)) __PYX_ERR(0, 7892, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7927
 * 
 * 
 * def nanmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis ignoring any NaNs.
 * 
 */
  __pyx_tuple__320 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__320)) __PYX_ERR(0, 7927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__320);
  __Pyx_GIVEREF(__pyx_tuple__320);
  __pyx_codeobj__321 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__320, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nanmax, 7927, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__321)) __PYX_ERR(0, 7927, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":7984
 * 
 * 
 * def nanmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis ignoring any NaNs.
 * 
 */
  __pyx_tuple__322 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__322)) __PYX_ERR(0, 7984, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__322);
  __Pyx_GIVEREF(__pyx_tuple__322);
  __pyx_codeobj__323 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__322, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nanmin, 7984, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__323)) __PYX_ERR(0, 7984, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8039
 * 
 * 
 * def nansum(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the sum of array elements over a given axis treating
 *     Not a Numbers (NaNs) as zero.
 */
  __pyx_tuple__324 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__324)) __PYX_ERR(0, 8039, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__324);
  __Pyx_GIVEREF(__pyx_tuple__324);
  __pyx_codeobj__325 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__324, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nansum, 8039, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__325)) __PYX_ERR(0, 8039, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8107
 * 
 * 
 * def ndfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a file and return it as a single array.
 * 
 */
  __pyx_tuple__326 = PyTuple_Pack(1, __pyx_n_s_fname); if (unlikely(!__pyx_tuple__326)) __PYX_ERR(0, 8107, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__326);
  __Pyx_GIVEREF(__pyx_tuple__326);
  __pyx_codeobj__327 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__326, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ndfromtxt, 8107, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__327)) __PYX_ERR(0, 8107, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8121
 * 
 * 
 * def ndim(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_tuple__328 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__328)) __PYX_ERR(0, 8121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__328);
  __Pyx_GIVEREF(__pyx_tuple__328);
  __pyx_codeobj__329 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__328, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ndim, 8121, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__329)) __PYX_ERR(0, 8121, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8154
 * 
 * 
 * def nested_iters():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_codeobj__330 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nested_iters, 8154, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__330)) __PYX_ERR(0, 8154, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8162
 * 
 * 
 * def newbuffer(size):             # <<<<<<<<<<<<<<
 *     """newbuffer(size)
 * 
 */
  __pyx_tuple__331 = PyTuple_Pack(1, __pyx_n_s_size); if (unlikely(!__pyx_tuple__331)) __PYX_ERR(0, 8162, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__331);
  __Pyx_GIVEREF(__pyx_tuple__331);
  __pyx_codeobj__332 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__331, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_newbuffer, 8162, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__332)) __PYX_ERR(0, 8162, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8172
 * 
 * 
 * def nonzero(a):             # <<<<<<<<<<<<<<
 *     """Return the indices of the elements that are non-zero.
 * 
 */
  __pyx_tuple__333 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__333)) __PYX_ERR(0, 8172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__333);
  __Pyx_GIVEREF(__pyx_tuple__333);
  __pyx_codeobj__334 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__333, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nonzero, 8172, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__334)) __PYX_ERR(0, 8172, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8247
 * 
 * 
 * def nper(rate, pmt, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the number of periodic payments.
 * 
 */
  __pyx_tuple__335 = PyTuple_Pack(5, __pyx_n_s_rate, __pyx_n_s_pmt, __pyx_n_s_pv, __pyx_n_s_fv, __pyx_n_s_when); if (unlikely(!__pyx_tuple__335)) __PYX_ERR(0, 8247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__335);
  __Pyx_GIVEREF(__pyx_tuple__335);
  __pyx_codeobj__336 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__335, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_nper, 8247, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__336)) __PYX_ERR(0, 8247, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8298
 * 
 * 
 * def npv(rate, values):             # <<<<<<<<<<<<<<
 *     """Returns the NPV (Net Present Value) of a cash flow series.
 * 
 */
  __pyx_tuple__337 = PyTuple_Pack(2, __pyx_n_s_rate, __pyx_n_s_values); if (unlikely(!__pyx_tuple__337)) __PYX_ERR(0, 8298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__337);
  __Pyx_GIVEREF(__pyx_tuple__337);
  __pyx_codeobj__338 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__337, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_npv, 8298, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__338)) __PYX_ERR(0, 8298, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8342
 * 
 * 
 * def obj2sctype(rep, default=None):             # <<<<<<<<<<<<<<
 *     """Return the scalar dtype or NumPy equivalent of Python type of an object.
 * 
 */
  __pyx_tuple__339 = PyTuple_Pack(2, __pyx_n_s_rep, __pyx_n_s_default); if (unlikely(!__pyx_tuple__339)) __PYX_ERR(0, 8342, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__339);
  __Pyx_GIVEREF(__pyx_tuple__339);
  __pyx_codeobj__340 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__339, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_obj2sctype, 8342, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__340)) __PYX_ERR(0, 8342, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8383
 * 
 * 
 * def outer(a, b):             # <<<<<<<<<<<<<<
 *     """Compute the outer product of two vectors.
 * 
 */
  __pyx_tuple__341 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_b); if (unlikely(!__pyx_tuple__341)) __PYX_ERR(0, 8383, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__341);
  __Pyx_GIVEREF(__pyx_tuple__341);
  __pyx_codeobj__342 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__341, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_outer, 8383, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__342)) __PYX_ERR(0, 8383, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8454
 * 
 * 
 * def packbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """packbits(myarray, axis=None)
 * 
 */
  __pyx_tuple__343 = PyTuple_Pack(2, __pyx_n_s_myarray, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__343)) __PYX_ERR(0, 8454, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__343);
  __Pyx_GIVEREF(__pyx_tuple__343);
  __pyx_codeobj__344 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__343, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_packbits, 8454, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__344)) __PYX_ERR(0, 8454, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8500
 * 
 * 
 * def percentile(a, q, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the qth percentile of the data along the specified axis.
 * 
 */
  __pyx_tuple__345 = PyTuple_Pack(5, __pyx_n_s_a, __pyx_n_s_q, __pyx_n_s_axis, __pyx_n_s_out, __pyx_n_s_overwrite_input); if (unlikely(!__pyx_tuple__345)) __PYX_ERR(0, 8500, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__345);
  __Pyx_GIVEREF(__pyx_tuple__345);
  __pyx_codeobj__346 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__345, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_percentile, 8500, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__346)) __PYX_ERR(0, 8500, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8580
 * 
 * 
 * def piecewise(x, condlist, funclist):             # <<<<<<<<<<<<<<
 *     """Evaluate a piecewise-defined function.
 * 
 */
  __pyx_tuple__347 = PyTuple_Pack(3, __pyx_n_s_x, __pyx_n_s_condlist, __pyx_n_s_funclist); if (unlikely(!__pyx_tuple__347)) __PYX_ERR(0, 8580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__347);
  __Pyx_GIVEREF(__pyx_tuple__347);
  __pyx_codeobj__348 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__347, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_piecewise, 8580, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__348)) __PYX_ERR(0, 8580, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8663
 * 
 * 
 * def pkgload():             # <<<<<<<<<<<<<<
 *     """Load one or more packages into parent package top-level namespace.
 * 
 */
  __pyx_codeobj__349 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_pkgload, 8663, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__349)) __PYX_ERR(0, 8663, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8702
 * 
 * 
 * def place(arr, mask, vals):             # <<<<<<<<<<<<<<
 *     """Change elements of an array based on conditional and input values.
 * 
 */
  __pyx_tuple__350 = PyTuple_Pack(3, __pyx_n_s_arr, __pyx_n_s_mask, __pyx_n_s_vals); if (unlikely(!__pyx_tuple__350)) __PYX_ERR(0, 8702, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__350);
  __Pyx_GIVEREF(__pyx_tuple__350);
  __pyx_codeobj__351 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__350, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_place, 8702, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__351)) __PYX_ERR(0, 8702, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8738
 * 
 * 
 * def pmt(rate, nper, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the payment against loan principal plus interest.
 * 
 */
  __pyx_tuple__352 = PyTuple_Pack(5, __pyx_n_s_rate, __pyx_n_s_nper, __pyx_n_s_pv, __pyx_n_s_fv, __pyx_n_s_when); if (unlikely(!__pyx_tuple__352)) __PYX_ERR(0, 8738, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__352);
  __Pyx_GIVEREF(__pyx_tuple__352);
  __pyx_codeobj__353 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__352, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_pmt, 8738, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__353)) __PYX_ERR(0, 8738, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8823
 * 
 * 
 * def poly(seq_of_zeros):             # <<<<<<<<<<<<<<
 *     """Find the coefficients of a polynomial with the given sequence of roots.
 * 
 */
  __pyx_tuple__354 = PyTuple_Pack(1, __pyx_n_s_seq_of_zeros); if (unlikely(!__pyx_tuple__354)) __PYX_ERR(0, 8823, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__354);
  __Pyx_GIVEREF(__pyx_tuple__354);
  __pyx_codeobj__355 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__354, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_poly, 8823, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__355)) __PYX_ERR(0, 8823, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8917
 * 
 * 
 * def polyadd(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the sum of two polynomials.
 * 
 */
  __pyx_tuple__356 = PyTuple_Pack(2, __pyx_n_s_a1, __pyx_n_s_a2); if (unlikely(!__pyx_tuple__356)) __PYX_ERR(0, 8917, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__356);
  __Pyx_GIVEREF(__pyx_tuple__356);
  __pyx_codeobj__357 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__356, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polyadd, 8917, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__357)) __PYX_ERR(0, 8917, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":8963
 * 
 * 
 * def polyder(p, m=1):             # <<<<<<<<<<<<<<
 *     """Return the derivative of the specified order of a polynomial.
 * 
 */
  __pyx_tuple__358 = PyTuple_Pack(2, __pyx_n_s_p, __pyx_n_s_m); if (unlikely(!__pyx_tuple__358)) __PYX_ERR(0, 8963, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__358);
  __Pyx_GIVEREF(__pyx_tuple__358);
  __pyx_codeobj__359 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__358, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polyder, 8963, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__359)) __PYX_ERR(0, 8963, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9017
 * 
 * 
 * def polydiv(u, v):             # <<<<<<<<<<<<<<
 *     """Returns the quotient and remainder of polynomial division.
 * 
 */
  __pyx_tuple__360 = PyTuple_Pack(2, __pyx_n_s_u, __pyx_n_s_v); if (unlikely(!__pyx_tuple__360)) __PYX_ERR(0, 9017, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__360);
  __Pyx_GIVEREF(__pyx_tuple__360);
  __pyx_codeobj__361 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__360, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polydiv, 9017, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__361)) __PYX_ERR(0, 9017, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9064
 * 
 * 
 * def polyfit(x, y, deg, rcond=None, full=False):             # <<<<<<<<<<<<<<
 *     """Least squares polynomial fit.
 * 
 */
  __pyx_tuple__362 = PyTuple_Pack(5, __pyx_n_s_x, __pyx_n_s_y, __pyx_n_s_deg, __pyx_n_s_rcond, __pyx_n_s_full); if (unlikely(!__pyx_tuple__362)) __PYX_ERR(0, 9064, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__362);
  __Pyx_GIVEREF(__pyx_tuple__362);
  __pyx_codeobj__363 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__362, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polyfit, 9064, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__363)) __PYX_ERR(0, 9064, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9200
 * 
 * 
 * def polyint(p, m=1, k=None):             # <<<<<<<<<<<<<<
 *     """Return an antiderivative (indefinite integral) of a polynomial.
 * 
 */
  __pyx_tuple__364 = PyTuple_Pack(3, __pyx_n_s_p, __pyx_n_s_m, __pyx_n_s_k); if (unlikely(!__pyx_tuple__364)) __PYX_ERR(0, 9200, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__364);
  __Pyx_GIVEREF(__pyx_tuple__364);
  __pyx_codeobj__365 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__364, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polyint, 9200, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__365)) __PYX_ERR(0, 9200, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9269
 * 
 * 
 * def polymul(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the product of two polynomials.
 * 
 */
  __pyx_tuple__366 = PyTuple_Pack(2, __pyx_n_s_a1, __pyx_n_s_a2); if (unlikely(!__pyx_tuple__366)) __PYX_ERR(0, 9269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__366);
  __Pyx_GIVEREF(__pyx_tuple__366);
  __pyx_codeobj__367 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__366, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polymul, 9269, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__367)) __PYX_ERR(0, 9269, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9318
 * 
 * 
 * def polysub(a1, a2):             # <<<<<<<<<<<<<<
 *     """Difference (subtraction) of two polynomials.
 * 
 */
  __pyx_tuple__368 = PyTuple_Pack(2, __pyx_n_s_a1, __pyx_n_s_a2); if (unlikely(!__pyx_tuple__368)) __PYX_ERR(0, 9318, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__368);
  __Pyx_GIVEREF(__pyx_tuple__368);
  __pyx_codeobj__369 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__368, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polysub, 9318, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__369)) __PYX_ERR(0, 9318, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9350
 * 
 * 
 * def polyval(p, x):             # <<<<<<<<<<<<<<
 *     """Evaluate a polynomial at specific values.
 * 
 */
  __pyx_tuple__370 = PyTuple_Pack(2, __pyx_n_s_p, __pyx_n_s_x); if (unlikely(!__pyx_tuple__370)) __PYX_ERR(0, 9350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__370);
  __Pyx_GIVEREF(__pyx_tuple__370);
  __pyx_codeobj__371 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__370, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_polyval, 9350, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__371)) __PYX_ERR(0, 9350, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9411
 * 
 * 
 * def ppmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment against loan principal.
 * 
 */
  __pyx_tuple__372 = PyTuple_Pack(6, __pyx_n_s_rate, __pyx_n_s_per, __pyx_n_s_nper, __pyx_n_s_pv, __pyx_n_s_fv, __pyx_n_s_when); if (unlikely(!__pyx_tuple__372)) __PYX_ERR(0, 9411, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__372);
  __Pyx_GIVEREF(__pyx_tuple__372);
  __pyx_codeobj__373 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__372, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ppmt, 9411, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__373)) __PYX_ERR(0, 9411, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9438
 * 
 * 
 * def prod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_tuple__374 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__374)) __PYX_ERR(0, 9438, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__374);
  __Pyx_GIVEREF(__pyx_tuple__374);
  __pyx_codeobj__375 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__374, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_prod, 9438, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__375)) __PYX_ERR(0, 9438, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9514
 * 
 * 
 * def product(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_tuple__376 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__376)) __PYX_ERR(0, 9514, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__376);
  __Pyx_GIVEREF(__pyx_tuple__376);
  __pyx_codeobj__377 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__376, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_product, 9514, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__377)) __PYX_ERR(0, 9514, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9525
 * 
 * 
 * def promote_types(type1, type2):             # <<<<<<<<<<<<<<
 *     """promote_types(type1, type2)
 * 
 */
  __pyx_tuple__378 = PyTuple_Pack(2, __pyx_n_s_type1, __pyx_n_s_type2); if (unlikely(!__pyx_tuple__378)) __PYX_ERR(0, 9525, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__378);
  __Pyx_GIVEREF(__pyx_tuple__378);
  __pyx_codeobj__379 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__378, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_promote_types, 9525, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__379)) __PYX_ERR(0, 9525, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9575
 * 
 * 
 * def ptp(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Range of values (maximum - minimum) along an axis.
 * 
 */
  __pyx_tuple__380 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__380)) __PYX_ERR(0, 9575, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__380);
  __Pyx_GIVEREF(__pyx_tuple__380);
  __pyx_codeobj__381 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__380, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ptp, 9575, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__381)) __PYX_ERR(0, 9575, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9615
 * 
 * 
 * def put(a, ind, v, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Replaces specified elements of an array with given values.
 * 
 */
  __pyx_tuple__382 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_ind, __pyx_n_s_v, __pyx_n_s_mode); if (unlikely(!__pyx_tuple__382)) __PYX_ERR(0, 9615, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__382);
  __Pyx_GIVEREF(__pyx_tuple__382);
  __pyx_codeobj__383 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__382, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_put, 9615, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__383)) __PYX_ERR(0, 9615, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9665
 * 
 * 
 * def putmask(a, mask, values):             # <<<<<<<<<<<<<<
 *     """putmask(a, mask, values)
 * 
 */
  __pyx_tuple__384 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_mask, __pyx_n_s_values); if (unlikely(!__pyx_tuple__384)) __PYX_ERR(0, 9665, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__384);
  __Pyx_GIVEREF(__pyx_tuple__384);
  __pyx_codeobj__385 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__384, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_putmask, 9665, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__385)) __PYX_ERR(0, 9665, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9709
 * 
 * 
 * def pv(rate, nper, pmt, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the present value.
 * 
 */
  __pyx_tuple__386 = PyTuple_Pack(5, __pyx_n_s_rate, __pyx_n_s_nper, __pyx_n_s_pmt, __pyx_n_s_fv, __pyx_n_s_when); if (unlikely(!__pyx_tuple__386)) __PYX_ERR(0, 9709, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__386);
  __Pyx_GIVEREF(__pyx_tuple__386);
  __pyx_codeobj__387 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__386, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_pv, 9709, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__387)) __PYX_ERR(0, 9709, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9797
 * 
 * 
 * def rank(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_tuple__388 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__388)) __PYX_ERR(0, 9797, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__388);
  __Pyx_GIVEREF(__pyx_tuple__388);
  __pyx_codeobj__389 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__388, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_rank, 9797, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__389)) __PYX_ERR(0, 9797, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9839
 * 
 * 
 * def rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100):             # <<<<<<<<<<<<<<
 *     """Compute the rate of interest per period.
 * 
 */
  __pyx_tuple__390 = PyTuple_Pack(8, __pyx_n_s_nper, __pyx_n_s_pmt, __pyx_n_s_pv, __pyx_n_s_fv, __pyx_n_s_when, __pyx_n_s_guess, __pyx_n_s_tol, __pyx_n_s_maxiter); if (unlikely(!__pyx_tuple__390)) __PYX_ERR(0, 9839, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__390);
  __Pyx_GIVEREF(__pyx_tuple__390);
  __pyx_codeobj__391 = (PyObject*)__Pyx_PyCode_New(8, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__390, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_rate, 9839, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__391)) __PYX_ERR(0, 9839, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9884
 * 
 * 
 * def ravel(a, order='C'):             # <<<<<<<<<<<<<<
 *     """Return a flattened array.
 * 
 */
  __pyx_tuple__392 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_order); if (unlikely(!__pyx_tuple__392)) __PYX_ERR(0, 9884, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__392);
  __Pyx_GIVEREF(__pyx_tuple__392);
  __pyx_codeobj__393 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__392, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ravel, 9884, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__393)) __PYX_ERR(0, 9884, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":9968
 * 
 * 
 * def ravel_multi_index(multi_index, dims, mode='raise', order='C'):             # <<<<<<<<<<<<<<
 *     """ravel_multi_index(multi_index, dims, mode='raise', order='C')
 * 
 */
  __pyx_tuple__394 = PyTuple_Pack(4, __pyx_n_s_multi_index, __pyx_n_s_dims, __pyx_n_s_mode, __pyx_n_s_order); if (unlikely(!__pyx_tuple__394)) __PYX_ERR(0, 9968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__394);
  __Pyx_GIVEREF(__pyx_tuple__394);
  __pyx_codeobj__395 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__394, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_ravel_multi_index, 9968, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__395)) __PYX_ERR(0, 9968, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10028
 * 
 * 
 * def real(val):             # <<<<<<<<<<<<<<
 *     """Return the real part of the elements of the array.
 * 
 */
  __pyx_tuple__396 = PyTuple_Pack(1, __pyx_n_s_val); if (unlikely(!__pyx_tuple__396)) __PYX_ERR(0, 10028, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__396);
  __Pyx_GIVEREF(__pyx_tuple__396);
  __pyx_codeobj__397 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__396, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_real, 10028, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__397)) __PYX_ERR(0, 10028, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10062
 * 
 * 
 * def real_if_close(a, tol=100):             # <<<<<<<<<<<<<<
 *     """If complex input returns a real array if complex parts are close to zero.
 * 
 */
  __pyx_tuple__398 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_tol); if (unlikely(!__pyx_tuple__398)) __PYX_ERR(0, 10062, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__398);
  __Pyx_GIVEREF(__pyx_tuple__398);
  __pyx_codeobj__399 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__398, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_real_if_close, 10062, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__399)) __PYX_ERR(0, 10062, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10107
 * 
 * 
 * def recfromcsv(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a comma-separated file.
 * 
 */
  __pyx_tuple__400 = PyTuple_Pack(1, __pyx_n_s_fname); if (unlikely(!__pyx_tuple__400)) __PYX_ERR(0, 10107, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__400);
  __Pyx_GIVEREF(__pyx_tuple__400);
  __pyx_codeobj__401 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__400, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_recfromcsv, 10107, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__401)) __PYX_ERR(0, 10107, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10124
 * 
 * 
 * def recfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data from a file and return it in a record array.
 * 
 */
  __pyx_tuple__402 = PyTuple_Pack(1, __pyx_n_s_fname); if (unlikely(!__pyx_tuple__402)) __PYX_ERR(0, 10124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__402);
  __Pyx_GIVEREF(__pyx_tuple__402);
  __pyx_codeobj__403 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__402, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_recfromtxt, 10124, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__403)) __PYX_ERR(0, 10124, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10146
 * 
 * 
 * def repeat(a, repeats, axis=None):             # <<<<<<<<<<<<<<
 *     """Repeat elements of an array.
 * 
 */
  __pyx_tuple__404 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_repeats, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__404)) __PYX_ERR(0, 10146, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__404);
  __Pyx_GIVEREF(__pyx_tuple__404);
  __pyx_codeobj__405 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__404, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_repeat, 10146, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__405)) __PYX_ERR(0, 10146, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10187
 * 
 * 
 * def require(a, dtype=None, requirements=None):             # <<<<<<<<<<<<<<
 *     """Return an ndarray of the provided type that satisfies requirements.
 * 
 */
  __pyx_tuple__406 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_dtype, __pyx_n_s_requirements); if (unlikely(!__pyx_tuple__406)) __PYX_ERR(0, 10187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__406);
  __Pyx_GIVEREF(__pyx_tuple__406);
  __pyx_codeobj__407 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__406, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_require, 10187, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__407)) __PYX_ERR(0, 10187, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10246
 * 
 * 
 * def reshape(a, newshape, order='C'):             # <<<<<<<<<<<<<<
 *     """Gives a new shape to an array without changing its data.
 * 
 */
  __pyx_tuple__408 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_newshape, __pyx_n_s_order); if (unlikely(!__pyx_tuple__408)) __PYX_ERR(0, 10246, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__408);
  __Pyx_GIVEREF(__pyx_tuple__408);
  __pyx_codeobj__409 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__408, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_reshape, 10246, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__409)) __PYX_ERR(0, 10246, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10308
 * 
 * 
 * def resize(a, new_shape):             # <<<<<<<<<<<<<<
 *     """Return a new array with the specified shape.
 * 
 */
  __pyx_tuple__410 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_new_shape); if (unlikely(!__pyx_tuple__410)) __PYX_ERR(0, 10308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__410);
  __Pyx_GIVEREF(__pyx_tuple__410);
  __pyx_codeobj__411 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__410, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_resize, 10308, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__411)) __PYX_ERR(0, 10308, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10348
 * 
 * 
 * def restoredot():             # <<<<<<<<<<<<<<
 *     """Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
 *     implementations.
 */
  __pyx_codeobj__412 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_restoredot, 10348, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__412)) __PYX_ERR(0, 10348, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10366
 * 
 * 
 * def result_type(*arrays_and_dtypes):             # <<<<<<<<<<<<<<
 *     """result_type(*arrays_and_dtypes)
 * 
 */
  __pyx_tuple__413 = PyTuple_Pack(1, __pyx_n_s_arrays_and_dtypes); if (unlikely(!__pyx_tuple__413)) __PYX_ERR(0, 10366, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__413);
  __Pyx_GIVEREF(__pyx_tuple__413);
  __pyx_codeobj__414 = (PyObject*)__Pyx_PyCode_New(0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__413, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_result_type, 10366, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__414)) __PYX_ERR(0, 10366, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10437
 * 
 * 
 * def roll(a, shift, axis=None):             # <<<<<<<<<<<<<<
 *     """Roll array elements along a given axis.
 * 
 */
  __pyx_tuple__415 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_shift, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__415)) __PYX_ERR(0, 10437, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__415);
  __Pyx_GIVEREF(__pyx_tuple__415);
  __pyx_codeobj__416 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__415, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_roll, 10437, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__416)) __PYX_ERR(0, 10437, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10488
 * 
 * 
 * def rollaxis(a, axis, start=0):             # <<<<<<<<<<<<<<
 *     """Roll the specified axis backwards, until it lies in a given position.
 * 
 */
  __pyx_tuple__417 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_start); if (unlikely(!__pyx_tuple__417)) __PYX_ERR(0, 10488, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__417);
  __Pyx_GIVEREF(__pyx_tuple__417);
  __pyx_codeobj__418 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__417, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_rollaxis, 10488, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__418)) __PYX_ERR(0, 10488, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10526
 * 
 * 
 * def roots(p):             # <<<<<<<<<<<<<<
 *     """Return the roots of a polynomial with coefficients given in p.
 * 
 */
  __pyx_tuple__419 = PyTuple_Pack(1, __pyx_n_s_p); if (unlikely(!__pyx_tuple__419)) __PYX_ERR(0, 10526, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__419);
  __Pyx_GIVEREF(__pyx_tuple__419);
  __pyx_codeobj__420 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__419, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_roots, 10526, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__420)) __PYX_ERR(0, 10526, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10577
 * 
 * 
 * def rot90(m, k=1):             # <<<<<<<<<<<<<<
 *     """Rotate an array by 90 degrees in the counter-clockwise direction.
 * 
 */
  __pyx_tuple__421 = PyTuple_Pack(2, __pyx_n_s_m, __pyx_n_s_k); if (unlikely(!__pyx_tuple__421)) __PYX_ERR(0, 10577, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__421);
  __Pyx_GIVEREF(__pyx_tuple__421);
  __pyx_codeobj__422 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__421, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_rot90, 10577, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__422)) __PYX_ERR(0, 10577, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10617
 * 
 * 
 * def round(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_tuple__423 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_decimals, __pyx_n_s_out); if (unlikely(!__pyx_tuple__423)) __PYX_ERR(0, 10617, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__423);
  __Pyx_GIVEREF(__pyx_tuple__423);
  __pyx_codeobj__424 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__423, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_round, 10617, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__424)) __PYX_ERR(0, 10617, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10630
 * 
 * 
 * def round_(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_tuple__425 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_decimals, __pyx_n_s_out); if (unlikely(!__pyx_tuple__425)) __PYX_ERR(0, 10630, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__425);
  __Pyx_GIVEREF(__pyx_tuple__425);
  __pyx_codeobj__426 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__425, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_round_2, 10630, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__426)) __PYX_ERR(0, 10630, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10643
 * 
 * 
 * def row_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_tuple__427 = PyTuple_Pack(1, __pyx_n_s_tup); if (unlikely(!__pyx_tuple__427)) __PYX_ERR(0, 10643, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__427);
  __Pyx_GIVEREF(__pyx_tuple__427);
  __pyx_codeobj__428 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__427, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_row_stack, 10643, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__428)) __PYX_ERR(0, 10643, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10694
 * 
 * 
 * def safe_eval(source):             # <<<<<<<<<<<<<<
 *     """Protected string evaluation.
 * 
 */
  __pyx_tuple__429 = PyTuple_Pack(1, __pyx_n_s_source); if (unlikely(!__pyx_tuple__429)) __PYX_ERR(0, 10694, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__429);
  __Pyx_GIVEREF(__pyx_tuple__429);
  __pyx_codeobj__430 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__429, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_safe_eval, 10694, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__430)) __PYX_ERR(0, 10694, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10739
 * 
 * 
 * def save(file, arr):             # <<<<<<<<<<<<<<
 *     """Save an array to a binary file in NumPy ``.npy`` format.
 * 
 */
  __pyx_tuple__431 = PyTuple_Pack(2, __pyx_n_s_file, __pyx_n_s_arr); if (unlikely(!__pyx_tuple__431)) __PYX_ERR(0, 10739, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__431);
  __Pyx_GIVEREF(__pyx_tuple__431);
  __pyx_codeobj__432 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__431, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_save, 10739, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__432)) __PYX_ERR(0, 10739, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10777
 * 
 * 
 * def savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n'):             # <<<<<<<<<<<<<<
 *     """Save an array to a text file.
 * 
 */
  __pyx_tuple__433 = PyTuple_Pack(5, __pyx_n_s_fname, __pyx_n_s_X, __pyx_n_s_fmt, __pyx_n_s_delimiter, __pyx_n_s_newline); if (unlikely(!__pyx_tuple__433)) __PYX_ERR(0, 10777, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__433);
  __Pyx_GIVEREF(__pyx_tuple__433);
  __pyx_codeobj__434 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__433, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_savetxt, 10777, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__434)) __PYX_ERR(0, 10777, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10868
 * 
 * 
 * def savez(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in uncompressed ``.npz`` format.
 * 
 */
  __pyx_tuple__435 = PyTuple_Pack(1, __pyx_n_s_file); if (unlikely(!__pyx_tuple__435)) __PYX_ERR(0, 10868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__435);
  __Pyx_GIVEREF(__pyx_tuple__435);
  __pyx_codeobj__436 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__435, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_savez, 10868, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__436)) __PYX_ERR(0, 10868, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10948
 * 
 * 
 * def savez_compressed(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in compressed ``.npz`` format.
 * 
 */
  __pyx_tuple__437 = PyTuple_Pack(1, __pyx_n_s_file); if (unlikely(!__pyx_tuple__437)) __PYX_ERR(0, 10948, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__437);
  __Pyx_GIVEREF(__pyx_tuple__437);
  __pyx_codeobj__438 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__437, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_savez_compressed, 10948, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__438)) __PYX_ERR(0, 10948, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":10972
 * 
 * 
 * def sctype2char(sctype):             # <<<<<<<<<<<<<<
 *     """Return the string representation of a scalar dtype.
 * 
 */
  __pyx_tuple__439 = PyTuple_Pack(1, __pyx_n_s_sctype); if (unlikely(!__pyx_tuple__439)) __PYX_ERR(0, 10972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__439);
  __Pyx_GIVEREF(__pyx_tuple__439);
  __pyx_codeobj__440 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__439, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_sctype2char, 10972, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__440)) __PYX_ERR(0, 10972, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11016
 * 
 * 
 * def searchsorted(a, v, side='left'):             # <<<<<<<<<<<<<<
 *     """Find indices where elements should be inserted to maintain order.
 * 
 */
  __pyx_tuple__441 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_v, __pyx_n_s_side); if (unlikely(!__pyx_tuple__441)) __PYX_ERR(0, 11016, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__441);
  __Pyx_GIVEREF(__pyx_tuple__441);
  __pyx_codeobj__442 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__441, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_searchsorted, 11016, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__442)) __PYX_ERR(0, 11016, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11064
 * 
 * 
 * def select(condlist, choicelist, default=0):             # <<<<<<<<<<<<<<
 *     """Return an array drawn from elements in choicelist, depending on conditions.
 * 
 */
  __pyx_tuple__443 = PyTuple_Pack(3, __pyx_n_s_condlist, __pyx_n_s_choicelist, __pyx_n_s_default); if (unlikely(!__pyx_tuple__443)) __PYX_ERR(0, 11064, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__443);
  __Pyx_GIVEREF(__pyx_tuple__443);
  __pyx_codeobj__444 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__443, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_select, 11064, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__444)) __PYX_ERR(0, 11064, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11103
 * 
 * 
 * def set_numeric_ops():             # <<<<<<<<<<<<<<
 *     """set_numeric_ops(op1=func1, op2=func2, ...)
 * 
 */
  __pyx_codeobj__445 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_set_numeric_ops, 11103, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__445)) __PYX_ERR(0, 11103, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11149
 * 
 * 
 * def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None):             # <<<<<<<<<<<<<<
 *     """Set printing options.
 * 
 */
  __pyx_tuple__446 = PyTuple_Pack(7, __pyx_n_s_precision, __pyx_n_s_threshold, __pyx_n_s_edgeitems, __pyx_n_s_linewidth, __pyx_n_s_suppress, __pyx_n_s_nanstr, __pyx_n_s_infstr); if (unlikely(!__pyx_tuple__446)) __PYX_ERR(0, 11149, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__446);
  __Pyx_GIVEREF(__pyx_tuple__446);
  __pyx_codeobj__447 = (PyObject*)__Pyx_PyCode_New(7, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__446, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_set_printoptions, 11149, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__447)) __PYX_ERR(0, 11149, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11214
 * 
 * 
 * def set_string_function(f, repr=True):             # <<<<<<<<<<<<<<
 *     """Set a Python function to be used when pretty printing arrays.
 * 
 */
  __pyx_tuple__448 = PyTuple_Pack(2, __pyx_n_s_f, __pyx_n_s_repr); if (unlikely(!__pyx_tuple__448)) __PYX_ERR(0, 11214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__448);
  __Pyx_GIVEREF(__pyx_tuple__448);
  __pyx_codeobj__449 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__448, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_set_string_function, 11214, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__449)) __PYX_ERR(0, 11214, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11267
 * 
 * 
 * def setbufsize(size):             # <<<<<<<<<<<<<<
 *     """Set the size of the buffer used in ufuncs.
 * 
 */
  __pyx_tuple__450 = PyTuple_Pack(1, __pyx_n_s_size); if (unlikely(!__pyx_tuple__450)) __PYX_ERR(0, 11267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__450);
  __Pyx_GIVEREF(__pyx_tuple__450);
  __pyx_codeobj__451 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__450, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_setbufsize, 11267, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__451)) __PYX_ERR(0, 11267, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11279
 * 
 * 
 * def setdiff1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set difference of two arrays.
 * 
 */
  __pyx_tuple__452 = PyTuple_Pack(3, __pyx_n_s_ar1, __pyx_n_s_ar2, __pyx_n_s_assume_unique); if (unlikely(!__pyx_tuple__452)) __PYX_ERR(0, 11279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__452);
  __Pyx_GIVEREF(__pyx_tuple__452);
  __pyx_codeobj__453 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__452, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_setdiff1d, 11279, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__453)) __PYX_ERR(0, 11279, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11315
 * 
 * 
 * def seterr(all=None, divide=None, over=None, under=None, invalid=None):             # <<<<<<<<<<<<<<
 *     """Set how floating-point errors are handled.
 * 
 */
  __pyx_tuple__454 = PyTuple_Pack(5, __pyx_n_s_all, __pyx_n_s_divide, __pyx_n_s_over, __pyx_n_s_under, __pyx_n_s_invalid); if (unlikely(!__pyx_tuple__454)) __PYX_ERR(0, 11315, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__454);
  __Pyx_GIVEREF(__pyx_tuple__454);
  __pyx_codeobj__455 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__454, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_seterr, 11315, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__455)) __PYX_ERR(0, 11315, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11394
 * 
 * 
 * def seterrcall(func):             # <<<<<<<<<<<<<<
 *     """Set the floating-point error callback function or log object.
 * 
 */
  __pyx_tuple__456 = PyTuple_Pack(1, __pyx_n_s_func); if (unlikely(!__pyx_tuple__456)) __PYX_ERR(0, 11394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__456);
  __Pyx_GIVEREF(__pyx_tuple__456);
  __pyx_codeobj__457 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__456, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_seterrcall, 11394, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__457)) __PYX_ERR(0, 11394, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11477
 * 
 * 
 * def seterrobj(errobj):             # <<<<<<<<<<<<<<
 *     """seterrobj(errobj)
 * 
 */
  __pyx_tuple__458 = PyTuple_Pack(1, __pyx_n_s_errobj); if (unlikely(!__pyx_tuple__458)) __PYX_ERR(0, 11477, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__458);
  __Pyx_GIVEREF(__pyx_tuple__458);
  __pyx_codeobj__459 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__458, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_seterrobj, 11477, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__459)) __PYX_ERR(0, 11477, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11538
 * 
 * 
 * def setxor1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set exclusive-or of two arrays.
 * 
 */
  __pyx_tuple__460 = PyTuple_Pack(3, __pyx_n_s_ar1, __pyx_n_s_ar2, __pyx_n_s_assume_unique); if (unlikely(!__pyx_tuple__460)) __PYX_ERR(0, 11538, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__460);
  __Pyx_GIVEREF(__pyx_tuple__460);
  __pyx_codeobj__461 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__460, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_setxor1d, 11538, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__461)) __PYX_ERR(0, 11538, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11569
 * 
 * 
 * def show_config():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_codeobj__462 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_show_config, 11569, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__462)) __PYX_ERR(0, 11569, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11576
 * 
 * 
 * def sinc(x):             # <<<<<<<<<<<<<<
 *     """Return the sinc function.
 * 
 */
  __pyx_tuple__463 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__463)) __PYX_ERR(0, 11576, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__463);
  __Pyx_GIVEREF(__pyx_tuple__463);
  __pyx_codeobj__464 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__463, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_sinc, 11576, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__464)) __PYX_ERR(0, 11576, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11653
 * 
 * 
 * def size(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the number of elements along a given axis.
 * 
 */
  __pyx_tuple__465 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__465)) __PYX_ERR(0, 11653, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__465);
  __Pyx_GIVEREF(__pyx_tuple__465);
  __pyx_codeobj__466 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__465, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_size, 11653, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__466)) __PYX_ERR(0, 11653, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11689
 * 
 * 
 * def sometrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check whether some values are true.
 * 
 */
  __pyx_tuple__467 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_out); if (unlikely(!__pyx_tuple__467)) __PYX_ERR(0, 11689, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__467);
  __Pyx_GIVEREF(__pyx_tuple__467);
  __pyx_codeobj__468 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__467, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_sometrue, 11689, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__468)) __PYX_ERR(0, 11689, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11702
 * 
 * 
 * def sort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Return a sorted copy of an array.
 * 
 */
  __pyx_tuple__469 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_kind, __pyx_n_s_order); if (unlikely(!__pyx_tuple__469)) __PYX_ERR(0, 11702, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__469);
  __Pyx_GIVEREF(__pyx_tuple__469);
  __pyx_codeobj__470 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__469, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_sort, 11702, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__470)) __PYX_ERR(0, 11702, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11803
 * 
 * 
 * def sort_complex(a):             # <<<<<<<<<<<<<<
 *     """Sort a complex array using the real part first, then the imaginary part.
 * 
 */
  __pyx_tuple__471 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__471)) __PYX_ERR(0, 11803, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__471);
  __Pyx_GIVEREF(__pyx_tuple__471);
  __pyx_codeobj__472 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__471, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_sort_complex, 11803, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__472)) __PYX_ERR(0, 11803, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11828
 * 
 * 
 * def source(object, output=sys.stdout):             # <<<<<<<<<<<<<<
 *     """Print or write to a file the source code for a Numpy object.
 * 
 */
  __pyx_tuple__473 = PyTuple_Pack(2, __pyx_n_s_object, __pyx_n_s_output); if (unlikely(!__pyx_tuple__473)) __PYX_ERR(0, 11828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__473);
  __Pyx_GIVEREF(__pyx_tuple__473);
  __pyx_codeobj__474 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__473, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_source, 11828, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__474)) __PYX_ERR(0, 11828, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11868
 * 
 * 
 * def split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal size.
 * 
 */
  __pyx_tuple__475 = PyTuple_Pack(3, __pyx_n_s_ary, __pyx_n_s_indices_or_sections, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__475)) __PYX_ERR(0, 11868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__475);
  __Pyx_GIVEREF(__pyx_tuple__475);
  __pyx_codeobj__476 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__475, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_split, 11868, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__476)) __PYX_ERR(0, 11868, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11935
 * 
 * 
 * def squeeze(a):             # <<<<<<<<<<<<<<
 *     """Remove single-dimensional entries from the shape of an array.
 * 
 */
  __pyx_tuple__477 = PyTuple_Pack(1, __pyx_n_s_a); if (unlikely(!__pyx_tuple__477)) __PYX_ERR(0, 11935, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__477);
  __Pyx_GIVEREF(__pyx_tuple__477);
  __pyx_codeobj__478 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__477, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_squeeze, 11935, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__478)) __PYX_ERR(0, 11935, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":11961
 * 
 * 
 * def std(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the standard deviation along the specified axis.
 * 
 */
  __pyx_tuple__479 = PyTuple_Pack(5, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out, __pyx_n_s_ddof); if (unlikely(!__pyx_tuple__479)) __PYX_ERR(0, 11961, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__479);
  __Pyx_GIVEREF(__pyx_tuple__479);
  __pyx_codeobj__480 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__479, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_std, 11961, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__480)) __PYX_ERR(0, 11961, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12049
 * 
 * 
 * def sum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Sum of array elements over a given axis.
 * 
 */
  __pyx_tuple__481 = PyTuple_Pack(4, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__481)) __PYX_ERR(0, 12049, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__481);
  __Pyx_GIVEREF(__pyx_tuple__481);
  __pyx_codeobj__482 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__481, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_sum, 12049, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__482)) __PYX_ERR(0, 12049, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12117
 * 
 * 
 * def swapaxes(a, axis1, axis2):             # <<<<<<<<<<<<<<
 *     """Interchange two axes of an array.
 * 
 */
  __pyx_tuple__483 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_axis1, __pyx_n_s_axis2); if (unlikely(!__pyx_tuple__483)) __PYX_ERR(0, 12117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__483);
  __Pyx_GIVEREF(__pyx_tuple__483);
  __pyx_codeobj__484 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__483, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_swapaxes, 12117, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__484)) __PYX_ERR(0, 12117, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12160
 * 
 * 
 * def take(a, indices, axis=None, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Take elements from an array along an axis.
 * 
 */
  __pyx_tuple__485 = PyTuple_Pack(5, __pyx_n_s_a, __pyx_n_s_indices, __pyx_n_s_axis, __pyx_n_s_out, __pyx_n_s_mode); if (unlikely(!__pyx_tuple__485)) __PYX_ERR(0, 12160, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__485);
  __Pyx_GIVEREF(__pyx_tuple__485);
  __pyx_codeobj__486 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__485, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_take, 12160, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__486)) __PYX_ERR(0, 12160, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12216
 * 
 * 
 * def tensordot(a, b, axes=2):             # <<<<<<<<<<<<<<
 *     """Compute tensor dot product along specified axes for arrays >= 1-D.
 * 
 */
  __pyx_tuple__487 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_axes); if (unlikely(!__pyx_tuple__487)) __PYX_ERR(0, 12216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__487);
  __Pyx_GIVEREF(__pyx_tuple__487);
  __pyx_codeobj__488 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__487, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_tensordot, 12216, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__488)) __PYX_ERR(0, 12216, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12332
 * 
 * 
 * def tile(A, reps):             # <<<<<<<<<<<<<<
 *     """Construct an array by repeating A the number of times given by reps.
 * 
 */
  __pyx_tuple__489 = PyTuple_Pack(2, __pyx_n_s_A, __pyx_n_s_reps); if (unlikely(!__pyx_tuple__489)) __PYX_ERR(0, 12332, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__489);
  __Pyx_GIVEREF(__pyx_tuple__489);
  __pyx_codeobj__490 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__489, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_tile, 12332, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__490)) __PYX_ERR(0, 12332, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12390
 * 
 * 
 * def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the sum along diagonals of the array.
 * 
 */
  __pyx_tuple__491 = PyTuple_Pack(6, __pyx_n_s_a, __pyx_n_s_offset, __pyx_n_s_axis1, __pyx_n_s_axis2, __pyx_n_s_dtype, __pyx_n_s_out); if (unlikely(!__pyx_tuple__491)) __PYX_ERR(0, 12390, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__491);
  __Pyx_GIVEREF(__pyx_tuple__491);
  __pyx_codeobj__492 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__491, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_trace, 12390, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__492)) __PYX_ERR(0, 12390, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12448
 * 
 * 
 * def transpose(a, axes=None):             # <<<<<<<<<<<<<<
 *     """Permute the dimensions of an array.
 * 
 */
  __pyx_tuple__493 = PyTuple_Pack(2, __pyx_n_s_a, __pyx_n_s_axes); if (unlikely(!__pyx_tuple__493)) __PYX_ERR(0, 12448, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__493);
  __Pyx_GIVEREF(__pyx_tuple__493);
  __pyx_codeobj__494 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__493, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_transpose, 12448, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__494)) __PYX_ERR(0, 12448, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12488
 * 
 * 
 * def trapz(y, x=None, dx=1.0, axis=-1):             # <<<<<<<<<<<<<<
 *     """Integrate along the given axis using the composite trapezoidal rule.
 * 
 */
  __pyx_tuple__495 = PyTuple_Pack(4, __pyx_n_s_y, __pyx_n_s_x, __pyx_n_s_dx, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__495)) __PYX_ERR(0, 12488, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__495);
  __Pyx_GIVEREF(__pyx_tuple__495);
  __pyx_codeobj__496 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__495, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_trapz, 12488, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__496)) __PYX_ERR(0, 12488, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12549
 * 
 * 
 * def tri(N, M=None, k=0, dtype=float):             # <<<<<<<<<<<<<<
 *     """An array with ones at and below the given diagonal and zeros elsewhere.
 * 
 */
  __pyx_tuple__497 = PyTuple_Pack(4, __pyx_n_s_N, __pyx_n_s_M, __pyx_n_s_k, __pyx_n_s_dtype); if (unlikely(!__pyx_tuple__497)) __PYX_ERR(0, 12549, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__497);
  __Pyx_GIVEREF(__pyx_tuple__497);
  __pyx_codeobj__498 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__497, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_tri, 12549, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__498)) __PYX_ERR(0, 12549, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12588
 * 
 * 
 * def tril(m, k=0):             # <<<<<<<<<<<<<<
 *     """Lower triangle of an array.
 * 
 */
  __pyx_tuple__499 = PyTuple_Pack(2, __pyx_n_s_m, __pyx_n_s_k); if (unlikely(!__pyx_tuple__499)) __PYX_ERR(0, 12588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__499);
  __Pyx_GIVEREF(__pyx_tuple__499);
  __pyx_codeobj__500 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__499, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_tril, 12588, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__500)) __PYX_ERR(0, 12588, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12622
 * 
 * 
 * def tril_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of an (n, n) array.
 * 
 */
  __pyx_tuple__501 = PyTuple_Pack(2, __pyx_n_s_n, __pyx_n_s_k); if (unlikely(!__pyx_tuple__501)) __PYX_ERR(0, 12622, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__501);
  __Pyx_GIVEREF(__pyx_tuple__501);
  __pyx_codeobj__502 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__501, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_tril_indices, 12622, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__502)) __PYX_ERR(0, 12622, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12694
 * 
 * 
 * def tril_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of arr.
 * 
 */
  __pyx_tuple__503 = PyTuple_Pack(2, __pyx_n_s_arr, __pyx_n_s_k); if (unlikely(!__pyx_tuple__503)) __PYX_ERR(0, 12694, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__503);
  __Pyx_GIVEREF(__pyx_tuple__503);
  __pyx_codeobj__504 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__503, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_tril_indices_from, 12694, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__504)) __PYX_ERR(0, 12694, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12719
 * 
 * 
 * def trim_zeros(filt, trim='fb'):             # <<<<<<<<<<<<<<
 *     """Trim the leading and/or trailing zeros from a 1-D array or sequence.
 * 
 */
  __pyx_tuple__505 = PyTuple_Pack(2, __pyx_n_s_filt, __pyx_n_s_trim); if (unlikely(!__pyx_tuple__505)) __PYX_ERR(0, 12719, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__505);
  __Pyx_GIVEREF(__pyx_tuple__505);
  __pyx_codeobj__506 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__505, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_trim_zeros, 12719, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__506)) __PYX_ERR(0, 12719, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12754
 * 
 * 
 * def triu(m, k=0):             # <<<<<<<<<<<<<<
 *     """Upper triangle of an array.
 * 
 */
  __pyx_tuple__507 = PyTuple_Pack(2, __pyx_n_s_m, __pyx_n_s_k); if (unlikely(!__pyx_tuple__507)) __PYX_ERR(0, 12754, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__507);
  __Pyx_GIVEREF(__pyx_tuple__507);
  __pyx_codeobj__508 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__507, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_triu, 12754, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__508)) __PYX_ERR(0, 12754, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12778
 * 
 * 
 * def triu_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_tuple__509 = PyTuple_Pack(2, __pyx_n_s_n, __pyx_n_s_k); if (unlikely(!__pyx_tuple__509)) __PYX_ERR(0, 12778, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__509);
  __Pyx_GIVEREF(__pyx_tuple__509);
  __pyx_codeobj__510 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__509, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_triu_indices, 12778, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__510)) __PYX_ERR(0, 12778, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12851
 * 
 * 
 * def triu_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_tuple__511 = PyTuple_Pack(2, __pyx_n_s_arr, __pyx_n_s_k); if (unlikely(!__pyx_tuple__511)) __PYX_ERR(0, 12851, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__511);
  __Pyx_GIVEREF(__pyx_tuple__511);
  __pyx_codeobj__512 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__511, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_triu_indices_from, 12851, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__512)) __PYX_ERR(0, 12851, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12876
 * 
 * 
 * def typename(char_):             # <<<<<<<<<<<<<<
 *     """Return a description for the given data type code.
 * 
 */
  __pyx_tuple__513 = PyTuple_Pack(1, __pyx_n_s_char); if (unlikely(!__pyx_tuple__513)) __PYX_ERR(0, 12876, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__513);
  __Pyx_GIVEREF(__pyx_tuple__513);
  __pyx_codeobj__514 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__513, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_typename, 12876, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__514)) __PYX_ERR(0, 12876, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12927
 * 
 * 
 * def union1d(ar1, ar2):             # <<<<<<<<<<<<<<
 *     """Find the union of two arrays.
 * 
 */
  __pyx_tuple__515 = PyTuple_Pack(2, __pyx_n_s_ar1, __pyx_n_s_ar2); if (unlikely(!__pyx_tuple__515)) __PYX_ERR(0, 12927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__515);
  __Pyx_GIVEREF(__pyx_tuple__515);
  __pyx_codeobj__516 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__515, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_union1d, 12927, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__516)) __PYX_ERR(0, 12927, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":12957
 * 
 * 
 * def unique(ar, return_index=False, return_inverse=False):             # <<<<<<<<<<<<<<
 *     """Find the unique elements of an array.
 * 
 */
  __pyx_tuple__517 = PyTuple_Pack(3, __pyx_n_s_ar, __pyx_n_s_return_index, __pyx_n_s_return_inverse); if (unlikely(!__pyx_tuple__517)) __PYX_ERR(0, 12957, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__517);
  __Pyx_GIVEREF(__pyx_tuple__517);
  __pyx_codeobj__518 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__517, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_unique, 12957, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__518)) __PYX_ERR(0, 12957, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13028
 * 
 * 
 * def unpackbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """unpackbits(myarray, axis=None)
 * 
 */
  __pyx_tuple__519 = PyTuple_Pack(2, __pyx_n_s_myarray, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__519)) __PYX_ERR(0, 13028, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__519);
  __Pyx_GIVEREF(__pyx_tuple__519);
  __pyx_codeobj__520 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__519, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_unpackbits, 13028, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__520)) __PYX_ERR(0, 13028, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13073
 * 
 * 
 * def unravel_index(indices, dims, order='C'):             # <<<<<<<<<<<<<<
 *     """unravel_index(indices, dims, order='C')
 * 
 */
  __pyx_tuple__521 = PyTuple_Pack(3, __pyx_n_s_indices, __pyx_n_s_dims, __pyx_n_s_order); if (unlikely(!__pyx_tuple__521)) __PYX_ERR(0, 13073, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__521);
  __Pyx_GIVEREF(__pyx_tuple__521);
  __pyx_codeobj__522 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__521, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_unravel_index, 13073, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__522)) __PYX_ERR(0, 13073, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13118
 * 
 * 
 * def unwrap(p, discont=3.14159265359, axis=-1):             # <<<<<<<<<<<<<<
 *     """Unwrap by changing deltas between values to 2*pi complement.
 * 
 */
  __pyx_tuple__523 = PyTuple_Pack(3, __pyx_n_s_p, __pyx_n_s_discont, __pyx_n_s_axis); if (unlikely(!__pyx_tuple__523)) __PYX_ERR(0, 13118, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__523);
  __Pyx_GIVEREF(__pyx_tuple__523);
  __pyx_codeobj__524 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__523, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_unwrap, 13118, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__524)) __PYX_ERR(0, 13118, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13161
 * 
 * 
 * def vander(x, N=None):             # <<<<<<<<<<<<<<
 *     """Generate a Van der Monde matrix.
 * 
 */
  __pyx_tuple__525 = PyTuple_Pack(2, __pyx_n_s_x, __pyx_n_s_N); if (unlikely(!__pyx_tuple__525)) __PYX_ERR(0, 13161, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__525);
  __Pyx_GIVEREF(__pyx_tuple__525);
  __pyx_codeobj__526 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__525, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_vander, 13161, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__526)) __PYX_ERR(0, 13161, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13219
 * 
 * 
 * def var(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the variance along the specified axis.
 * 
 */
  __pyx_tuple__527 = PyTuple_Pack(5, __pyx_n_s_a, __pyx_n_s_axis, __pyx_n_s_dtype, __pyx_n_s_out, __pyx_n_s_ddof); if (unlikely(!__pyx_tuple__527)) __PYX_ERR(0, 13219, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__527);
  __Pyx_GIVEREF(__pyx_tuple__527);
  __pyx_codeobj__528 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__527, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_var, 13219, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__528)) __PYX_ERR(0, 13219, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13309
 * 
 * 
 * def vdot():             # <<<<<<<<<<<<<<
 *     """Return the dot product of two vectors.
 * 
 */
  __pyx_codeobj__529 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_vdot, 13309, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__529)) __PYX_ERR(0, 13309, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13364
 * 
 * 
 * def vsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays vertically (row-wise).
 * 
 */
  __pyx_tuple__530 = PyTuple_Pack(2, __pyx_n_s_ary, __pyx_n_s_indices_or_sections); if (unlikely(!__pyx_tuple__530)) __PYX_ERR(0, 13364, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__530);
  __Pyx_GIVEREF(__pyx_tuple__530);
  __pyx_codeobj__531 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__530, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_vsplit, 13364, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__531)) __PYX_ERR(0, 13364, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13413
 * 
 * 
 * def vstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_tuple__532 = PyTuple_Pack(1, __pyx_n_s_tup); if (unlikely(!__pyx_tuple__532)) __PYX_ERR(0, 13413, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__532);
  __Pyx_GIVEREF(__pyx_tuple__532);
  __pyx_codeobj__533 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__532, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_vstack, 13413, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__533)) __PYX_ERR(0, 13413, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13464
 * 
 * 
 * def where():             # <<<<<<<<<<<<<<
 *     """where(condition, [x, y])
 * 
 */
  __pyx_codeobj__534 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_where, 13464, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__534)) __PYX_ERR(0, 13464, __pyx_L1_error)

  /* "ga4py/gain/notimplemented.pyx":13526
 * 
 * 
 * def who(vardict=None):             # <<<<<<<<<<<<<<
 *     """Print the Numpy arrays in the given dictionary.
 * 
 */
  __pyx_tuple__535 = PyTuple_Pack(1, __pyx_n_s_vardict); if (unlikely(!__pyx_tuple__535)) __PYX_ERR(0, 13526, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__535);
  __Pyx_GIVEREF(__pyx_tuple__535);
  __pyx_codeobj__536 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__535, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_ga4py_gain_notimplemented_pyx, __pyx_n_s_who, 13526, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__536)) __PYX_ERR(0, 13526, __pyx_L1_error)
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 2, __pyx_L1_error);
  __pyx_float_0_0 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_float_0_0)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_float_0_1 = PyFloat_FromDouble(0.1); if (unlikely(!__pyx_float_0_1)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_float_1_0 = PyFloat_FromDouble(1.0); if (unlikely(!__pyx_float_1_0)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_float_1eneg_05 = PyFloat_FromDouble(1e-05); if (unlikely(!__pyx_float_1eneg_05)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_float_1eneg_06 = PyFloat_FromDouble(1e-06); if (unlikely(!__pyx_float_1eneg_06)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_float_1eneg_08 = PyFloat_FromDouble(1e-08); if (unlikely(!__pyx_float_1eneg_08)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_float_3_14159265359 = PyFloat_FromDouble(3.14159265359); if (unlikely(!__pyx_float_3_14159265359)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_int_10 = PyInt_FromLong(10); if (unlikely(!__pyx_int_10)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_int_76 = PyInt_FromLong(76); if (unlikely(!__pyx_int_76)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_int_100 = PyInt_FromLong(100); if (unlikely(!__pyx_int_100)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 2, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/

static int __Pyx_modinit_global_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
  /*--- Global init code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
  /*--- Variable export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
  /*--- Function export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
  /*--- Type init code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_import_code(void) {
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
  /*--- Type import code ---*/
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
  sizeof(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject),
  #endif
  __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_5numpy_dtype = __Pyx_ImportType(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __Pyx_ImportType_CheckSize_Ignore);
   if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 206, __pyx_L1_error)
  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 229, __pyx_L1_error)
  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 233, __pyx_L1_error)
  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __Pyx_ImportType_CheckSize_Ignore);
   if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 242, __pyx_L1_error)
  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 918, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_variable_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
  /*--- Variable import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
  /*--- Function import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}


#if PY_MAJOR_VERSION < 3
#ifdef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC void
#else
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#endif
#else
#ifdef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC PyObject *
#else
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#endif
#endif


#if PY_MAJOR_VERSION < 3
__Pyx_PyMODINIT_FUNC initnotimplemented(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC initnotimplemented(void)
#else
__Pyx_PyMODINIT_FUNC PyInit_notimplemented(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC PyInit_notimplemented(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
  return PyModuleDef_Init(&__pyx_moduledef);
}
static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
    #if PY_VERSION_HEX >= 0x030700A1
    static PY_INT64_T main_interpreter_id = -1;
    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
    if (main_interpreter_id == -1) {
        main_interpreter_id = current_id;
        return (unlikely(current_id == -1)) ? -1 : 0;
    } else if (unlikely(main_interpreter_id != current_id))
    #else
    static PyInterpreterState *main_interpreter = NULL;
    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
    if (!main_interpreter) {
        main_interpreter = current_interpreter;
    } else if (unlikely(main_interpreter != current_interpreter))
    #endif
    {
        PyErr_SetString(
            PyExc_ImportError,
            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
        return -1;
    }
    return 0;
}
static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
    PyObject *value = PyObject_GetAttrString(spec, from_name);
    int result = 0;
    if (likely(value)) {
        if (allow_none || value != Py_None) {
            result = PyDict_SetItemString(moddict, to_name, value);
        }
        Py_DECREF(value);
    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Clear();
    } else {
        result = -1;
    }
    return result;
}
static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
    PyObject *module = NULL, *moddict, *modname;
    if (__Pyx_check_single_interpreter())
        return NULL;
    if (__pyx_m)
        return __Pyx_NewRef(__pyx_m);
    modname = PyObject_GetAttrString(spec, "name");
    if (unlikely(!modname)) goto bad;
    module = PyModule_NewObject(modname);
    Py_DECREF(modname);
    if (unlikely(!module)) goto bad;
    moddict = PyModule_GetDict(module);
    if (unlikely(!moddict)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
    return module;
bad:
    Py_XDECREF(module);
    return NULL;
}


static CYTHON_SMALL_CODE int __pyx_pymod_exec_notimplemented(PyObject *__pyx_pyinit_module)
#endif
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannyDeclarations
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  if (__pyx_m) {
    if (__pyx_m == __pyx_pyinit_module) return 0;
    PyErr_SetString(PyExc_RuntimeError, "Module 'notimplemented' has already been imported. Re-initialisation is not supported.");
    return -1;
  }
  #elif PY_MAJOR_VERSION >= 3
  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
  #endif
  #if CYTHON_REFNANNY
__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
if (!__Pyx_RefNanny) {
  PyErr_Clear();
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
  if (!__Pyx_RefNanny)
      Py_FatalError("failed to import 'refnanny' module");
}
#endif
  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_notimplemented(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #ifdef __Pxy_PyFrame_Initialize_Offsets
  __Pxy_PyFrame_Initialize_Offsets();
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 2, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 2, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  #ifdef __Pyx_AsyncGen_USED
  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  __pyx_m = __pyx_pyinit_module;
  Py_INCREF(__pyx_m);
  #else
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("notimplemented", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 2, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 2, __pyx_L1_error)
  Py_INCREF(__pyx_b);
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 2, __pyx_L1_error)
  Py_INCREF(__pyx_cython_runtime);
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 2, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_ga4py__gain__notimplemented) {
    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 2, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "ga4py.gain.notimplemented")) {
      if (unlikely(PyDict_SetItemString(modules, "ga4py.gain.notimplemented", __pyx_m) < 0)) __PYX_ERR(0, 2, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  /*--- Global type/function init code ---*/
  (void)__Pyx_modinit_global_init_code();
  (void)__Pyx_modinit_variable_export_code();
  (void)__Pyx_modinit_function_export_code();
  (void)__Pyx_modinit_type_init_code();
  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;
  (void)__Pyx_modinit_variable_import_code();
  (void)__Pyx_modinit_function_import_code();
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  #endif

  /* "ga4py/gain/notimplemented.pyx":2
 * 
 * import sys             # <<<<<<<<<<<<<<
 * 
 * import numpy as np
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_sys, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_1) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":4
 * import sys
 * 
 * import numpy as np             # <<<<<<<<<<<<<<
 * cimport numpy as np
 * 
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8
 * 
 * 
 * def docstring(obj, docstring):             # <<<<<<<<<<<<<<
 *     """docstring(obj, docstring)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_1docstring, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_docstring, __pyx_t_1) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":21
 * 
 * 
 * def add_newdoc(place, obj, doc):             # <<<<<<<<<<<<<<
 *     """Adds documentation to obj which is in module place.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_3add_newdoc, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_add_newdoc, __pyx_t_1) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":40
 * 
 * 
 * def all(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether all array elements along a given axis evaluate to True.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_5all, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_all, __pyx_t_1) < 0) __PYX_ERR(0, 40, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":99
 * 
 * 
 * def allclose(a, b, rtol=1e-05, atol=1e-08):             # <<<<<<<<<<<<<<
 *     """Returns True if two arrays are element-wise equal within a tolerance.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_7allclose, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_allclose, __pyx_t_1) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":153
 * 
 * 
 * def alltrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check if all elements of input array are true.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_9alltrue, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 153, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_alltrue, __pyx_t_1) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":164
 * 
 * 
 * def alterdot():             # <<<<<<<<<<<<<<
 *     """Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_11alterdot, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_alterdot, __pyx_t_1) < 0) __PYX_ERR(0, 164, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":187
 * 
 * 
 * def amax(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_13amax, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_amax, __pyx_t_1) < 0) __PYX_ERR(0, 187, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":244
 * 
 * 
 * def amin(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_15amin, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_amin, __pyx_t_1) < 0) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":301
 * 
 * 
 * def angle(z, deg=0):             # <<<<<<<<<<<<<<
 *     """Return the angle of the complex argument.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_17angle, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_angle, __pyx_t_1) < 0) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":335
 * 
 * 
 * def any(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Test whether any array element along a given axis evaluates to True.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_19any, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 335, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_any, __pyx_t_1) < 0) __PYX_ERR(0, 335, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":401
 * 
 * 
 * def append(arr, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Append values to the end of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_21append, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 401, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_append, __pyx_t_1) < 0) __PYX_ERR(0, 401, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":449
 * 
 * 
 * def apply_along_axis(func1d, axis, arr):             # <<<<<<<<<<<<<<
 *     """Apply a function to 1-D slices along the given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_23apply_along_axis, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 449, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_apply_along_axis, __pyx_t_1) < 0) __PYX_ERR(0, 449, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":506
 * 
 * 
 * def apply_over_axes(func, a, axes):             # <<<<<<<<<<<<<<
 *     """Apply a function repeatedly over multiple axes.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_25apply_over_axes, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 506, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_apply_over_axes, __pyx_t_1) < 0) __PYX_ERR(0, 506, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":560
 * 
 * 
 * def argmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Indices of the maximum values along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_27argmax, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 560, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_argmax, __pyx_t_1) < 0) __PYX_ERR(0, 560, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":612
 * 
 * 
 * def argmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the indices of the minimum values along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_29argmin, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 612, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_argmin, __pyx_t_1) < 0) __PYX_ERR(0, 612, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":624
 * 
 * 
 * def argsort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Returns the indices that would sort an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_31argsort, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_argsort, __pyx_t_1) < 0) __PYX_ERR(0, 624, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":704
 * 
 * 
 * def argwhere(a):             # <<<<<<<<<<<<<<
 *     """Find the indices of array elements that are non-zero, grouped by element.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_33argwhere, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_argwhere, __pyx_t_1) < 0) __PYX_ERR(0, 704, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":744
 * 
 * 
 * def around(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Evenly round to the given number of decimals.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_35around, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 744, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_around, __pyx_t_1) < 0) __PYX_ERR(0, 744, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":812
 * 
 * 
 * def array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_37array, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array, __pyx_t_1) < 0) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":906
 * 
 * 
 * def array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=repr):             # <<<<<<<<<<<<<<
 *     """Return a string representation of an array.
 * 
 */
  __pyx_t_1 = __Pyx_GetBuiltinName(__pyx_n_s_repr); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k__3 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_39array2string, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array2string, __pyx_t_1) < 0) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":955
 * 
 * 
 * def array_equal(a1, a2):             # <<<<<<<<<<<<<<
 *     """True if two arrays have the same shape and elements, False otherwise.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_41array_equal, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 955, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array_equal, __pyx_t_1) < 0) __PYX_ERR(0, 955, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":990
 * 
 * 
 * def array_equiv(a1, a2):             # <<<<<<<<<<<<<<
 *     """Returns True if input arrays are shape consistent and all elements equal.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_43array_equiv, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 990, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array_equiv, __pyx_t_1) < 0) __PYX_ERR(0, 990, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1027
 * 
 * 
 * def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return the string representation of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_45array_repr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1027, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array_repr, __pyx_t_1) < 0) __PYX_ERR(0, 1027, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1071
 * 
 * 
 * def array_split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal or near-equal size.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_47array_split, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1071, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array_split, __pyx_t_1) < 0) __PYX_ERR(0, 1071, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1093
 * 
 * 
 * def array_str(a, max_line_width=None, precision=None, suppress_small=None):             # <<<<<<<<<<<<<<
 *     """Return a string representation of the data in an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_49array_str, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array_str, __pyx_t_1) < 0) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1129
 * 
 * 
 * def asanyarray(a, dtype=None, order=None):             # <<<<<<<<<<<<<<
 *     """Convert the input to an ndarray, but pass ndarray subclasses through.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_51asanyarray, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1129, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_asanyarray, __pyx_t_1) < 0) __PYX_ERR(0, 1129, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1181
 * 
 * 
 * def asarray_chkfinite(a):             # <<<<<<<<<<<<<<
 *     """Convert the input to an array, checking for NaNs or Infs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_53asarray_chkfinite, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_asarray_chkfinite, __pyx_t_1) < 0) __PYX_ERR(0, 1181, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1243
 * 
 * 
 * def ascontiguousarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return a contiguous array in memory (C order).
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_55ascontiguousarray, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ascontiguousarray, __pyx_t_1) < 0) __PYX_ERR(0, 1243, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":1279
 * 
 * 
 * def asfarray(a, dtype=np.float64):             # <<<<<<<<<<<<<<
 *     """Return an array converted to a float type.
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_k__4 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_57asfarray, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_asfarray, __pyx_t_2) < 0) __PYX_ERR(0, 1279, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1308
 * 
 * 
 * def asfortranarray(a, dtype=None):             # <<<<<<<<<<<<<<
 *     """Return an array laid out in Fortran order in memory.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_59asfortranarray, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_asfortranarray, __pyx_t_2) < 0) __PYX_ERR(0, 1308, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1344
 * 
 * 
 * def asmatrix(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_61asmatrix, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1344, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_asmatrix, __pyx_t_2) < 0) __PYX_ERR(0, 1344, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1376
 * 
 * 
 * def asscalar(a):             # <<<<<<<<<<<<<<
 *     """Convert an array of size 1 to its scalar equivalent.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_63asscalar, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1376, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_asscalar, __pyx_t_2) < 0) __PYX_ERR(0, 1376, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1398
 * 
 * 
 * def atleast_1d():             # <<<<<<<<<<<<<<
 *     """Convert inputs to arrays with at least one dimension.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_65atleast_1d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1398, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_atleast_1d, __pyx_t_2) < 0) __PYX_ERR(0, 1398, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1439
 * 
 * 
 * def atleast_2d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least two dimensions.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_67atleast_2d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1439, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_atleast_2d, __pyx_t_2) < 0) __PYX_ERR(0, 1439, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1478
 * 
 * 
 * def atleast_3d():             # <<<<<<<<<<<<<<
 *     """View inputs as arrays with at least three dimensions.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_69atleast_3d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1478, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_atleast_3d, __pyx_t_2) < 0) __PYX_ERR(0, 1478, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1529
 * 
 * 
 * def average(a, axis=None, weights=None, returned=False):             # <<<<<<<<<<<<<<
 *     """Compute the weighted average along the specified axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_71average, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1529, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_average, __pyx_t_2) < 0) __PYX_ERR(0, 1529, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1604
 * 
 * 
 * def bartlett(M):             # <<<<<<<<<<<<<<
 *     """Return the Bartlett window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_73bartlett, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1604, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_bartlett, __pyx_t_2) < 0) __PYX_ERR(0, 1604, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1708
 * 
 * 
 * def base_repr(number, base=2, padding=0):             # <<<<<<<<<<<<<<
 *     """Return a string representation of a number in the given base system.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_75base_repr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1708, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_base_repr, __pyx_t_2) < 0) __PYX_ERR(0, 1708, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1748
 * 
 * 
 * def binary_repr(num, width=None):             # <<<<<<<<<<<<<<
 *     """Return the binary representation of the input number as a string.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_77binary_repr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1748, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_binary_repr, __pyx_t_2) < 0) __PYX_ERR(0, 1748, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1808
 * 
 * 
 * def bincount(x, weights=None, minlength=None):             # <<<<<<<<<<<<<<
 *     """bincount(x, weights=None, minlength=None)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_79bincount, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1808, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_bincount, __pyx_t_2) < 0) __PYX_ERR(0, 1808, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1883
 * 
 * 
 * def blackman(M):             # <<<<<<<<<<<<<<
 *     """Return the Blackman window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_81blackman, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1883, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_blackman, __pyx_t_2) < 0) __PYX_ERR(0, 1883, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":1979
 * 
 * 
 * def bmat(obj, ldict=None, gdict=None):             # <<<<<<<<<<<<<<
 *     """Build a matrix object from a string, nested sequence, or array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_83bmat, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1979, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_bmat, __pyx_t_2) < 0) __PYX_ERR(0, 1979, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2026
 * 
 * 
 * def broadcast_arrays():             # <<<<<<<<<<<<<<
 *     """Broadcast any number of arrays against each other.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_85broadcast_arrays, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2026, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_broadcast_arrays, __pyx_t_2) < 0) __PYX_ERR(0, 2026, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2067
 * 
 * 
 * def byte_bounds(a):             # <<<<<<<<<<<<<<
 *     """Returns pointers to the end-points of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_87byte_bounds, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2067, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_byte_bounds, __pyx_t_2) < 0) __PYX_ERR(0, 2067, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2099
 * 
 * 
 * def can_cast():             # <<<<<<<<<<<<<<
 *     """can_cast(from, totype, casting = 'safe')
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_89can_cast, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2099, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_can_cast, __pyx_t_2) < 0) __PYX_ERR(0, 2099, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2202
 * 
 * 
 * def choose(a, choices, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Construct an array from an index array and a set of arrays to choose from.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_91choose, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2202, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_choose, __pyx_t_2) < 0) __PYX_ERR(0, 2202, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2323
 * 
 * 
 * def column_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack 1-D arrays as columns into a 2-D array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_93column_stack, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2323, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_column_stack, __pyx_t_2) < 0) __PYX_ERR(0, 2323, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2362
 * 
 * 
 * def common_type():             # <<<<<<<<<<<<<<
 *     """Return a scalar type which is common to the input arrays.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_95common_type, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2362, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_common_type, __pyx_t_2) < 0) __PYX_ERR(0, 2362, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2400
 * 
 * 
 * def compare_chararrays():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_97compare_chararrays, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2400, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_compare_chararrays, __pyx_t_2) < 0) __PYX_ERR(0, 2400, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2408
 * 
 * 
 * def compress(condition, a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return selected slices of an array along given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_99compress, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2408, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_compress, __pyx_t_2) < 0) __PYX_ERR(0, 2408, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2469
 * 
 * 
 * def concatenate():             # <<<<<<<<<<<<<<
 *     """concatenate((a1, a2, ...), axis=0)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_101concatenate, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2469, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_concatenate, __pyx_t_2) < 0) __PYX_ERR(0, 2469, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2545
 * 
 * 
 * def convolve(a, v, mode='full'):             # <<<<<<<<<<<<<<
 *     """Returns the discrete, linear convolution of two one-dimensional sequences.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_103convolve, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2545, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convolve, __pyx_t_2) < 0) __PYX_ERR(0, 2545, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2630
 * 
 * 
 * def copy(a):             # <<<<<<<<<<<<<<
 *     """Return an array copy of the given object.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_105copy, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2630, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_copy, __pyx_t_2) < 0) __PYX_ERR(0, 2630, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2669
 * 
 * 
 * def corrcoef(x, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Return correlation coefficients.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_107corrcoef, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2669, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_corrcoef, __pyx_t_2) < 0) __PYX_ERR(0, 2669, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2718
 * 
 * 
 * def correlate(a, v, mode='valid', old_behavior=False):             # <<<<<<<<<<<<<<
 *     """Cross-correlation of two 1-dimensional sequences.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_109correlate, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2718, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_correlate, __pyx_t_2) < 0) __PYX_ERR(0, 2718, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2758
 * 
 * 
 * def count_nonzero(a):             # <<<<<<<<<<<<<<
 *     """count_nonzero(a)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_111count_nonzero, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2758, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_count_nonzero, __pyx_t_2) < 0) __PYX_ERR(0, 2758, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2790
 * 
 * 
 * def cov(m, y=None, rowvar=1, bias=0, ddof=None):             # <<<<<<<<<<<<<<
 *     """Estimate a covariance matrix, given data.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_113cov, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2790, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_cov, __pyx_t_2) < 0) __PYX_ERR(0, 2790, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2871
 * 
 * 
 * def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the cross product of two (arrays of) vectors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_115cross, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2871, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_cross, __pyx_t_2) < 0) __PYX_ERR(0, 2871, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2979
 * 
 * 
 * def cumprod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product of elements along a given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_117cumprod, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2979, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_cumprod, __pyx_t_2) < 0) __PYX_ERR(0, 2979, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3041
 * 
 * 
 * def cumproduct(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative product over the given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_119cumproduct, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3041, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_cumproduct, __pyx_t_2) < 0) __PYX_ERR(0, 3041, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3053
 * 
 * 
 * def cumsum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the cumulative sum of the elements along a given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_121cumsum, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3053, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_cumsum, __pyx_t_2) < 0) __PYX_ERR(0, 3053, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3117
 * 
 * 
 * def datetime_data(dtype):             # <<<<<<<<<<<<<<
 *     """Return (unit, numerator, denominator, events) from a datetime dtype
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_123datetime_data, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_datetime_data, __pyx_t_2) < 0) __PYX_ERR(0, 3117, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3124
 * 
 * 
 * def delete(arr, obj, axis=None):             # <<<<<<<<<<<<<<
 *     """Return a new array with sub-arrays along an axis deleted.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_125delete, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_delete, __pyx_t_2) < 0) __PYX_ERR(0, 3124, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3171
 * 
 * 
 * def deprecate():             # <<<<<<<<<<<<<<
 *     """Issues a DeprecationWarning, adds warning to `old_name`'s
 *     docstring, rebinds ``old_name.__name__`` and returns the new
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_127deprecate, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_deprecate, __pyx_t_2) < 0) __PYX_ERR(0, 3171, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3214
 * 
 * 
 * def deprecate_with_doc(msg):             # <<<<<<<<<<<<<<
 *     """message
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_129deprecate_with_doc, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_deprecate_with_doc, __pyx_t_2) < 0) __PYX_ERR(0, 3214, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3221
 * 
 * 
 * def diag_indices(n, ndim=2):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_131diag_indices, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3221, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_diag_indices, __pyx_t_2) < 0) __PYX_ERR(0, 3221, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3287
 * 
 * 
 * def diag_indices_from(arr):             # <<<<<<<<<<<<<<
 *     """Return the indices to access the main diagonal of an n-dimensional array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_133diag_indices_from, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3287, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_diag_indices_from, __pyx_t_2) < 0) __PYX_ERR(0, 3287, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3308
 * 
 * 
 * def diagflat(v, k=0):             # <<<<<<<<<<<<<<
 *     """Create a two-dimensional array with the flattened input as a diagonal.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_135diagflat, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_diagflat, __pyx_t_2) < 0) __PYX_ERR(0, 3308, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3349
 * 
 * 
 * def diff(a, n=1, axis=-1):             # <<<<<<<<<<<<<<
 *     """Calculate the n-th order discrete difference along given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_137diff, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3349, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_diff, __pyx_t_2) < 0) __PYX_ERR(0, 3349, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3394
 * 
 * 
 * def digitize(x, bins):             # <<<<<<<<<<<<<<
 *     """digitize(x, bins)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_139digitize, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_digitize, __pyx_t_2) < 0) __PYX_ERR(0, 3394, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3453
 * 
 * 
 * def disp(mesg, device=None, linefeed=True):             # <<<<<<<<<<<<<<
 *     """Display a message on a device.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_141disp, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3453, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_disp, __pyx_t_2) < 0) __PYX_ERR(0, 3453, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3487
 * 
 * 
 * def dsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split array into multiple sub-arrays along the 3rd axis (depth).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_143dsplit, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3487, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_dsplit, __pyx_t_2) < 0) __PYX_ERR(0, 3487, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3530
 * 
 * 
 * def dstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence depth wise (along third axis).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_145dstack, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3530, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_dstack, __pyx_t_2) < 0) __PYX_ERR(0, 3530, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3580
 * 
 * 
 * def ediff1d(ary, to_end=None, to_begin=None):             # <<<<<<<<<<<<<<
 *     """The differences between consecutive elements of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_147ediff1d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ediff1d, __pyx_t_2) < 0) __PYX_ERR(0, 3580, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3625
 * 
 * 
 * def einsum():             # <<<<<<<<<<<<<<
 *     """einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe')
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_149einsum, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3625, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_einsum, __pyx_t_2) < 0) __PYX_ERR(0, 3625, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3817
 * 
 * 
 * def expand_dims(a, axis):             # <<<<<<<<<<<<<<
 *     """Expand the shape of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_151expand_dims, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3817, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_expand_dims, __pyx_t_2) < 0) __PYX_ERR(0, 3817, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3870
 * 
 * 
 * def extract(condition, arr):             # <<<<<<<<<<<<<<
 *     """Return the elements of an array that satisfy some condition.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_153extract, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3870, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_extract, __pyx_t_2) < 0) __PYX_ERR(0, 3870, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3913
 * 
 * 
 * def _fastCopyAndTranspose(a):             # <<<<<<<<<<<<<<
 *     """_fastCopyAndTranspose(a)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_155_fastCopyAndTranspose, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3913, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fastCopyAndTranspose, __pyx_t_2) < 0) __PYX_ERR(0, 3913, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3921
 * 
 * 
 * def fill_diagonal(a, val):             # <<<<<<<<<<<<<<
 *     """Fill the main diagonal of the given array of any dimensionality.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_157fill_diagonal, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3921, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fill_diagonal, __pyx_t_2) < 0) __PYX_ERR(0, 3921, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":3982
 * 
 * 
 * def find_common_type(array_types, scalar_types):             # <<<<<<<<<<<<<<
 *     """Determine common type following standard coercion rules.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_159find_common_type, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3982, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_find_common_type, __pyx_t_2) < 0) __PYX_ERR(0, 3982, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4035
 * 
 * 
 * def fix(x, y=None):             # <<<<<<<<<<<<<<
 *     """Round to nearest integer towards zero.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_161fix, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4035, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fix, __pyx_t_2) < 0) __PYX_ERR(0, 4035, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4071
 * 
 * 
 * def flatnonzero(a):             # <<<<<<<<<<<<<<
 *     """Return indices that are non-zero in the flattened version of a.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_163flatnonzero, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4071, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_flatnonzero, __pyx_t_2) < 0) __PYX_ERR(0, 4071, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4110
 * 
 * 
 * def fliplr(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the left/right direction.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_165fliplr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fliplr, __pyx_t_2) < 0) __PYX_ERR(0, 4110, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4157
 * 
 * 
 * def flipud(m):             # <<<<<<<<<<<<<<
 *     """Flip array in the up/down direction.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_167flipud, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4157, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_flipud, __pyx_t_2) < 0) __PYX_ERR(0, 4157, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4207
 * 
 * 
 * def frombuffer(buffer, dtype=float, count=-1, offset=0):             # <<<<<<<<<<<<<<
 *     """frombuffer(buffer, dtype=float, count=-1, offset=0)
 * 
 */
  __Pyx_INCREF(((PyObject *)(&PyFloat_Type)));
  __pyx_k__5 = ((PyObject *)(&PyFloat_Type));
  __Pyx_GIVEREF((&PyFloat_Type));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_169frombuffer, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4207, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_frombuffer, __pyx_t_2) < 0) __PYX_ERR(0, 4207, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4247
 * 
 * 
 * def fromfile(file, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromfile(file, dtype=float, count=-1, sep='')
 * 
 */
  __Pyx_INCREF(((PyObject *)(&PyFloat_Type)));
  __pyx_k__6 = ((PyObject *)(&PyFloat_Type));
  __Pyx_GIVEREF((&PyFloat_Type));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_171fromfile, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fromfile, __pyx_t_2) < 0) __PYX_ERR(0, 4247, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4324
 * 
 * 
 * def fromiter(iterable, dtype, count=-1):             # <<<<<<<<<<<<<<
 *     """fromiter(iterable, dtype, count=-1)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_173fromiter, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4324, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fromiter, __pyx_t_2) < 0) __PYX_ERR(0, 4324, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4360
 * 
 * 
 * def frompyfunc(func, nin, nout):             # <<<<<<<<<<<<<<
 *     """frompyfunc(func, nin, nout)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_175frompyfunc, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_frompyfunc, __pyx_t_2) < 0) __PYX_ERR(0, 4360, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4402
 * 
 * 
 * def fromregex(file, regexp, dtype):             # <<<<<<<<<<<<<<
 *     """Construct an array from a text file, using regular expression parsing.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_177fromregex, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4402, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fromregex, __pyx_t_2) < 0) __PYX_ERR(0, 4402, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4459
 * 
 * 
 * def fromstring(string, dtype=float, count=-1, sep=''):             # <<<<<<<<<<<<<<
 *     """fromstring(string, dtype=float, count=-1, sep='')
 * 
 */
  __Pyx_INCREF(((PyObject *)(&PyFloat_Type)));
  __pyx_k__7 = ((PyObject *)(&PyFloat_Type));
  __Pyx_GIVEREF((&PyFloat_Type));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_179fromstring, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4459, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fromstring, __pyx_t_2) < 0) __PYX_ERR(0, 4459, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4513
 * 
 * 
 * def fv(rate, nper, pmt, pv, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the future value.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_181fv, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4513, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fv, __pyx_t_2) < 0) __PYX_ERR(0, 4513, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4596
 * 
 * 
 * def genfromtxt(fname, dtype=float, comments='#', delimiter=None, skiprows=0, skip_header=0, skip_footer=0, converters=None, missing='', missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True):             # <<<<<<<<<<<<<<
 *     """Load data from a text file, with missing values handled as specified.
 * 
 */
  __Pyx_INCREF(((PyObject *)(&PyFloat_Type)));
  __pyx_k__8 = ((PyObject *)(&PyFloat_Type));
  __Pyx_GIVEREF((&PyFloat_Type));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_183genfromtxt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4596, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_genfromtxt, __pyx_t_2) < 0) __PYX_ERR(0, 4596, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4734
 * 
 * 
 * def get_array_wrap():             # <<<<<<<<<<<<<<
 *     """Find the wrapper for the array with the highest priority.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_185get_array_wrap, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4734, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_array_wrap, __pyx_t_2) < 0) __PYX_ERR(0, 4734, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4743
 * 
 * 
 * def get_include():             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the NumPy \*.h header files.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_187get_include, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4743, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_include, __pyx_t_2) < 0) __PYX_ERR(0, 4743, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4764
 * 
 * 
 * def get_numarray_include(type=None):             # <<<<<<<<<<<<<<
 *     """Return the directory that contains the numarray \*.h header files.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_189get_numarray_include, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4764, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_numarray_include, __pyx_t_2) < 0) __PYX_ERR(0, 4764, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4800
 * 
 * 
 * def get_printoptions():             # <<<<<<<<<<<<<<
 *     """Return the current print options.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_191get_printoptions, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4800, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_printoptions, __pyx_t_2) < 0) __PYX_ERR(0, 4800, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4826
 * 
 * 
 * def getbuffer():             # <<<<<<<<<<<<<<
 *     """getbuffer(obj [,offset[, size]])
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_193getbuffer, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4826, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_getbuffer, __pyx_t_2) < 0) __PYX_ERR(0, 4826, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4862
 * 
 * 
 * def getbufsize():             # <<<<<<<<<<<<<<
 *     """Return the size of the buffer used in ufuncs.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_195getbufsize, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4862, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_getbufsize, __pyx_t_2) < 0) __PYX_ERR(0, 4862, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4869
 * 
 * 
 * def geterr():             # <<<<<<<<<<<<<<
 *     """Get the current way of handling floating-point errors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_197geterr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_geterr, __pyx_t_2) < 0) __PYX_ERR(0, 4869, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4908
 * 
 * 
 * def geterrcall():             # <<<<<<<<<<<<<<
 *     """Return the current callback function used on floating-point errors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_199geterrcall, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4908, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_geterrcall, __pyx_t_2) < 0) __PYX_ERR(0, 4908, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":4952
 * 
 * 
 * def geterrobj():             # <<<<<<<<<<<<<<
 *     """geterrobj()
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_201geterrobj, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4952, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_geterrobj, __pyx_t_2) < 0) __PYX_ERR(0, 4952, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5018
 * 
 * 
 * def gradient(f):             # <<<<<<<<<<<<<<
 *     """Return the gradient of an N-dimensional array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_203gradient, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5018, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_gradient, __pyx_t_2) < 0) __PYX_ERR(0, 5018, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5058
 * 
 * 
 * def hamming(M):             # <<<<<<<<<<<<<<
 *     """Return the Hamming window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_205hamming, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5058, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hamming, __pyx_t_2) < 0) __PYX_ERR(0, 5058, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5152
 * 
 * 
 * def hanning(M):             # <<<<<<<<<<<<<<
 *     """Return the Hanning window.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_207hanning, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hanning, __pyx_t_2) < 0) __PYX_ERR(0, 5152, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5248
 * 
 * 
 * def histogram(a, bins=10, range=None, normed=False, weights=None, density=None):             # <<<<<<<<<<<<<<
 *     """Compute the histogram of a set of data.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_209histogram, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_histogram, __pyx_t_2) < 0) __PYX_ERR(0, 5248, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5333
 * 
 * 
 * def histogram2d(x, y, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the bi-dimensional histogram of two data samples.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_211histogram2d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5333, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_histogram2d, __pyx_t_2) < 0) __PYX_ERR(0, 5333, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5418
 * 
 * 
 * def histogramdd(sample, bins=10, range=None, normed=False, weights=None):             # <<<<<<<<<<<<<<
 *     """Compute the multidimensional histogram of some data.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_213histogramdd, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5418, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_histogramdd, __pyx_t_2) < 0) __PYX_ERR(0, 5418, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5471
 * 
 * 
 * def hsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays horizontally (column-wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_215hsplit, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5471, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hsplit, __pyx_t_2) < 0) __PYX_ERR(0, 5471, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5528
 * 
 * 
 * def hstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence horizontally (column wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_217hstack, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5528, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_hstack, __pyx_t_2) < 0) __PYX_ERR(0, 5528, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5572
 * 
 * 
 * def i0(x):             # <<<<<<<<<<<<<<
 *     """Modified Bessel function of the first kind, order 0.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_219i0, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_i0, __pyx_t_2) < 0) __PYX_ERR(0, 5572, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5628
 * 
 * 
 * def imag(val):             # <<<<<<<<<<<<<<
 *     """Return the imaginary part of the elements of the array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_221imag, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5628, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_imag, __pyx_t_2) < 0) __PYX_ERR(0, 5628, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5659
 * 
 * 
 * def in1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Test whether each element of a 1D array is also present in a second array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_223in1d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5659, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_in1d, __pyx_t_2) < 0) __PYX_ERR(0, 5659, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5707
 * 
 * 
 * def indices(dimensions, dtype=int):             # <<<<<<<<<<<<<<
 *     """Return an array representing the indices of a grid.
 * 
 */
  __Pyx_INCREF(((PyObject *)(&PyInt_Type)));
  __pyx_k__11 = ((PyObject *)(&PyInt_Type));
  __Pyx_GIVEREF((&PyInt_Type));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_225indices, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5707, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_indices, __pyx_t_2) < 0) __PYX_ERR(0, 5707, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":5769
 * 
 * 
 * def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):             # <<<<<<<<<<<<<<
 *     """Get help information for a function, class, or module.
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_sys); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5769, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_stdout); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5769, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_k__12 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_227info, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5769, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_info, __pyx_t_1) < 0) __PYX_ERR(0, 5769, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5819
 * 
 * 
 * def inner(a, b):             # <<<<<<<<<<<<<<
 *     """inner(a, b)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_229inner, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5819, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_inner, __pyx_t_1) < 0) __PYX_ERR(0, 5819, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5895
 * 
 * 
 * def insert(arr, obj, values, axis=None):             # <<<<<<<<<<<<<<
 *     """Insert values along the given axis before the given indices.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_231insert, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5895, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_insert, __pyx_t_1) < 0) __PYX_ERR(0, 5895, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5960
 * 
 * 
 * def int_asbuffer():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_233int_asbuffer, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5960, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_int_asbuffer, __pyx_t_1) < 0) __PYX_ERR(0, 5960, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":5968
 * 
 * 
 * def interp(x, xp, fp, left=None, right=None):             # <<<<<<<<<<<<<<
 *     """One-dimensional linear interpolation.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_235interp, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_interp, __pyx_t_1) < 0) __PYX_ERR(0, 5968, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6039
 * 
 * 
 * def intersect1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the intersection of two arrays.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_237intersect1d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6039, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_intersect1d, __pyx_t_1) < 0) __PYX_ERR(0, 6039, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6071
 * 
 * 
 * def ipmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment portion for loan interest.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_239ipmt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6071, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ipmt, __pyx_t_1) < 0) __PYX_ERR(0, 6071, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6113
 * 
 * 
 * def irr(values):             # <<<<<<<<<<<<<<
 *     """Return the Internal Rate of Return (IRR).
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_241irr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6113, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_irr, __pyx_t_1) < 0) __PYX_ERR(0, 6113, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6168
 * 
 * 
 * def iscomplex(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is complex.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_243iscomplex, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6168, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_iscomplex, __pyx_t_1) < 0) __PYX_ERR(0, 6168, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6199
 * 
 * 
 * def iscomplexobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a complex type or an array of complex numbers.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_245iscomplexobj, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6199, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_iscomplexobj, __pyx_t_1) < 0) __PYX_ERR(0, 6199, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6233
 * 
 * 
 * def isfortran(a):             # <<<<<<<<<<<<<<
 *     """Returns True if array is arranged in Fortran-order in memory
 *     and dimension > 1.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_247isfortran, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isfortran, __pyx_t_1) < 0) __PYX_ERR(0, 6233, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6290
 * 
 * 
 * def isneginf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for negative infinity, return result as bool array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_249isneginf, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isneginf, __pyx_t_1) < 0) __PYX_ERR(0, 6290, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6349
 * 
 * 
 * def isposinf(x, y=None):             # <<<<<<<<<<<<<<
 *     """Test element-wise for positive infinity, return result as bool array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_251isposinf, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6349, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isposinf, __pyx_t_1) < 0) __PYX_ERR(0, 6349, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6407
 * 
 * 
 * def isreal(x):             # <<<<<<<<<<<<<<
 *     """Returns a bool array, where True if input element is real.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_253isreal, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6407, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isreal, __pyx_t_1) < 0) __PYX_ERR(0, 6407, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6437
 * 
 * 
 * def isrealobj(x):             # <<<<<<<<<<<<<<
 *     """Return True if x is a not complex type or an array of complex numbers.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_255isrealobj, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6437, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isrealobj, __pyx_t_1) < 0) __PYX_ERR(0, 6437, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6471
 * 
 * 
 * def isscalar(num):             # <<<<<<<<<<<<<<
 *     """Returns True if the type of `num` is a scalar type.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_257isscalar, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6471, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isscalar, __pyx_t_1) < 0) __PYX_ERR(0, 6471, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6497
 * 
 * 
 * def issctype(rep):             # <<<<<<<<<<<<<<
 *     """Determines whether the given object represents a scalar data-type.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_259issctype, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_issctype, __pyx_t_1) < 0) __PYX_ERR(0, 6497, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6533
 * 
 * 
 * def issubclass_(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if a class is a subclass of a second class.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_261issubclass_, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6533, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_issubclass, __pyx_t_1) < 0) __PYX_ERR(0, 6533, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6568
 * 
 * 
 * def issubdtype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Returns True if first argument is a typecode lower/equal in type hierarchy.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_263issubdtype, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6568, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_issubdtype, __pyx_t_1) < 0) __PYX_ERR(0, 6568, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6596
 * 
 * 
 * def issubsctype(arg1, arg2):             # <<<<<<<<<<<<<<
 *     """Determine if the first argument is a subclass of the second argument.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_265issubsctype, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6596, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_issubsctype, __pyx_t_1) < 0) __PYX_ERR(0, 6596, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6626
 * 
 * 
 * def iterable(y):             # <<<<<<<<<<<<<<
 *     """Check whether or not an object can be iterated over.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_267iterable, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6626, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_iterable, __pyx_t_1) < 0) __PYX_ERR(0, 6626, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6652
 * 
 * 
 * def ix_():             # <<<<<<<<<<<<<<
 *     """Construct an open mesh from multiple sequences.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_269ix_, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6652, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ix, __pyx_t_1) < 0) __PYX_ERR(0, 6652, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6698
 * 
 * 
 * def kaiser(M, beta):             # <<<<<<<<<<<<<<
 *     """Return the Kaiser window.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_271kaiser, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6698, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_kaiser, __pyx_t_1) < 0) __PYX_ERR(0, 6698, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6825
 * 
 * 
 * def kron(a, b):             # <<<<<<<<<<<<<<
 *     """Kronecker product of two arrays.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_273kron, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6825, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_kron, __pyx_t_1) < 0) __PYX_ERR(0, 6825, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6897
 * 
 * 
 * def lexsort(keys, axis=-1):             # <<<<<<<<<<<<<<
 *     """lexsort(keys, axis=-1)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_275lexsort, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6897, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_lexsort, __pyx_t_1) < 0) __PYX_ERR(0, 6897, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":6975
 * 
 * 
 * def load(file, mmap_mode=None):             # <<<<<<<<<<<<<<
 *     """Load a pickled, ``.npy``, or ``.npz`` binary file.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_277load, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 6975, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_load, __pyx_t_1) < 0) __PYX_ERR(0, 6975, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7037
 * 
 * 
 * def loads():             # <<<<<<<<<<<<<<
 *     """loads(string) -- Load a pickle from the given string
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_279loads, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7037, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_loads, __pyx_t_1) < 0) __PYX_ERR(0, 7037, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7045
 * 
 * 
 * def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0):             # <<<<<<<<<<<<<<
 *     """Load data from a text file.
 * 
 */
  __Pyx_INCREF(((PyObject *)(&PyFloat_Type)));
  __pyx_k__13 = ((PyObject *)(&PyFloat_Type));
  __Pyx_GIVEREF((&PyFloat_Type));
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_281loadtxt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7045, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_loadtxt, __pyx_t_1) < 0) __PYX_ERR(0, 7045, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7132
 * 
 * 
 * def lookfor(what, module=None, import_modules=True, regenerate=False, output=None):             # <<<<<<<<<<<<<<
 *     """Do a keyword search on docstrings.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_283lookfor, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7132, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_lookfor, __pyx_t_1) < 0) __PYX_ERR(0, 7132, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7179
 * 
 * 
 * def mafromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a text file and return a masked array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_285mafromtxt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_mafromtxt, __pyx_t_1) < 0) __PYX_ERR(0, 7179, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7192
 * 
 * 
 * def mask_indices(n, mask_func, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices to access (n, n) arrays, given a masking function.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_287mask_indices, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7192, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_mask_indices, __pyx_t_1) < 0) __PYX_ERR(0, 7192, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7259
 * 
 * 
 * def mat(data, dtype=None):             # <<<<<<<<<<<<<<
 *     """Interpret the input as a matrix.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_289mat, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_mat, __pyx_t_1) < 0) __PYX_ERR(0, 7259, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7291
 * 
 * 
 * def max(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_291max, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_max, __pyx_t_1) < 0) __PYX_ERR(0, 7291, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7348
 * 
 * 
 * def maximum_sctype(t):             # <<<<<<<<<<<<<<
 *     """Return the scalar type of highest precision of the same kind as the input.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_293maximum_sctype, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7348, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_maximum_sctype, __pyx_t_1) < 0) __PYX_ERR(0, 7348, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7388
 * 
 * 
 * def may_share_memory(a, b):             # <<<<<<<<<<<<<<
 *     """Determine if two arrays can share memory
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_295may_share_memory, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7388, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_may_share_memory, __pyx_t_1) < 0) __PYX_ERR(0, 7388, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7414
 * 
 * 
 * def mean(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Compute the arithmetic mean along the specified axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_297mean, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7414, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_mean, __pyx_t_1) < 0) __PYX_ERR(0, 7414, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7487
 * 
 * 
 * def median(a, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the median along the specified axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_299median, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7487, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_median, __pyx_t_1) < 0) __PYX_ERR(0, 7487, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7563
 * 
 * 
 * def meshgrid(x, y):             # <<<<<<<<<<<<<<
 *     """Return coordinate matrices from two coordinate vectors.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_301meshgrid, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7563, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_meshgrid, __pyx_t_1) < 0) __PYX_ERR(0, 7563, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7611
 * 
 * 
 * def min(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_303min, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7611, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_min, __pyx_t_1) < 0) __PYX_ERR(0, 7611, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7668
 * 
 * 
 * def min_scalar_type(a):             # <<<<<<<<<<<<<<
 *     """min_scalar_type(a)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_305min_scalar_type, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7668, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_min_scalar_type, __pyx_t_1) < 0) __PYX_ERR(0, 7668, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7718
 * 
 * 
 * def mintypecode(typechars, typeset='GDFgdf', default='d'):             # <<<<<<<<<<<<<<
 *     """Return the character for the minimum-size type to which given types can
 *     be safely cast.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_307mintypecode, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7718, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_mintypecode, __pyx_t_1) < 0) __PYX_ERR(0, 7718, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7763
 * 
 * 
 * def mirr(values, finance_rate, reinvest_rate):             # <<<<<<<<<<<<<<
 *     """Modified internal rate of return.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_309mirr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7763, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_mirr, __pyx_t_1) < 0) __PYX_ERR(0, 7763, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7785
 * 
 * 
 * def msort(a):             # <<<<<<<<<<<<<<
 *     """Return a copy of an array sorted along the first axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_311msort, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7785, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_msort, __pyx_t_1) < 0) __PYX_ERR(0, 7785, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7810
 * 
 * 
 * def nan_to_num(x):             # <<<<<<<<<<<<<<
 *     """Replace nan with zero and inf with finite numbers.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_313nan_to_num, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nan_to_num, __pyx_t_1) < 0) __PYX_ERR(0, 7810, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7857
 * 
 * 
 * def nanargmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the maximum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_315nanargmax, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7857, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nanargmax, __pyx_t_1) < 0) __PYX_ERR(0, 7857, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7892
 * 
 * 
 * def nanargmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return indices of the minimum values over an axis, ignoring NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_317nanargmin, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7892, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nanargmin, __pyx_t_1) < 0) __PYX_ERR(0, 7892, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7927
 * 
 * 
 * def nanmax(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the maximum of an array or maximum along an axis ignoring any NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_319nanmax, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nanmax, __pyx_t_1) < 0) __PYX_ERR(0, 7927, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":7984
 * 
 * 
 * def nanmin(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the minimum of an array or minimum along an axis ignoring any NaNs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_321nanmin, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7984, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nanmin, __pyx_t_1) < 0) __PYX_ERR(0, 7984, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8039
 * 
 * 
 * def nansum(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the sum of array elements over a given axis treating
 *     Not a Numbers (NaNs) as zero.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_323nansum, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8039, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nansum, __pyx_t_1) < 0) __PYX_ERR(0, 8039, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8107
 * 
 * 
 * def ndfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a file and return it as a single array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_325ndfromtxt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8107, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ndfromtxt, __pyx_t_1) < 0) __PYX_ERR(0, 8107, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8121
 * 
 * 
 * def ndim(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_327ndim, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ndim, __pyx_t_1) < 0) __PYX_ERR(0, 8121, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8154
 * 
 * 
 * def nested_iters():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_329nested_iters, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8154, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nested_iters, __pyx_t_1) < 0) __PYX_ERR(0, 8154, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8162
 * 
 * 
 * def newbuffer(size):             # <<<<<<<<<<<<<<
 *     """newbuffer(size)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_331newbuffer, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8162, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_newbuffer, __pyx_t_1) < 0) __PYX_ERR(0, 8162, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8172
 * 
 * 
 * def nonzero(a):             # <<<<<<<<<<<<<<
 *     """Return the indices of the elements that are non-zero.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_333nonzero, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8172, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nonzero, __pyx_t_1) < 0) __PYX_ERR(0, 8172, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8247
 * 
 * 
 * def nper(rate, pmt, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the number of periodic payments.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_335nper, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_nper, __pyx_t_1) < 0) __PYX_ERR(0, 8247, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8298
 * 
 * 
 * def npv(rate, values):             # <<<<<<<<<<<<<<
 *     """Returns the NPV (Net Present Value) of a cash flow series.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_337npv, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_npv, __pyx_t_1) < 0) __PYX_ERR(0, 8298, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8342
 * 
 * 
 * def obj2sctype(rep, default=None):             # <<<<<<<<<<<<<<
 *     """Return the scalar dtype or NumPy equivalent of Python type of an object.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_339obj2sctype, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8342, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_obj2sctype, __pyx_t_1) < 0) __PYX_ERR(0, 8342, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8383
 * 
 * 
 * def outer(a, b):             # <<<<<<<<<<<<<<
 *     """Compute the outer product of two vectors.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_341outer, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8383, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_outer, __pyx_t_1) < 0) __PYX_ERR(0, 8383, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8454
 * 
 * 
 * def packbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """packbits(myarray, axis=None)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_343packbits, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8454, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_packbits, __pyx_t_1) < 0) __PYX_ERR(0, 8454, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8500
 * 
 * 
 * def percentile(a, q, axis=None, out=None, overwrite_input=False):             # <<<<<<<<<<<<<<
 *     """Compute the qth percentile of the data along the specified axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_345percentile, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8500, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_percentile, __pyx_t_1) < 0) __PYX_ERR(0, 8500, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8580
 * 
 * 
 * def piecewise(x, condlist, funclist):             # <<<<<<<<<<<<<<
 *     """Evaluate a piecewise-defined function.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_347piecewise, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8580, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_piecewise, __pyx_t_1) < 0) __PYX_ERR(0, 8580, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8663
 * 
 * 
 * def pkgload():             # <<<<<<<<<<<<<<
 *     """Load one or more packages into parent package top-level namespace.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_349pkgload, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8663, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pkgload, __pyx_t_1) < 0) __PYX_ERR(0, 8663, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8702
 * 
 * 
 * def place(arr, mask, vals):             # <<<<<<<<<<<<<<
 *     """Change elements of an array based on conditional and input values.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_351place, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8702, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_place, __pyx_t_1) < 0) __PYX_ERR(0, 8702, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8738
 * 
 * 
 * def pmt(rate, nper, pv, fv=0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the payment against loan principal plus interest.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_353pmt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8738, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pmt, __pyx_t_1) < 0) __PYX_ERR(0, 8738, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8823
 * 
 * 
 * def poly(seq_of_zeros):             # <<<<<<<<<<<<<<
 *     """Find the coefficients of a polynomial with the given sequence of roots.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_355poly, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8823, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_poly, __pyx_t_1) < 0) __PYX_ERR(0, 8823, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8917
 * 
 * 
 * def polyadd(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the sum of two polynomials.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_357polyadd, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8917, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polyadd, __pyx_t_1) < 0) __PYX_ERR(0, 8917, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":8963
 * 
 * 
 * def polyder(p, m=1):             # <<<<<<<<<<<<<<
 *     """Return the derivative of the specified order of a polynomial.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_359polyder, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8963, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polyder, __pyx_t_1) < 0) __PYX_ERR(0, 8963, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9017
 * 
 * 
 * def polydiv(u, v):             # <<<<<<<<<<<<<<
 *     """Returns the quotient and remainder of polynomial division.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_361polydiv, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9017, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polydiv, __pyx_t_1) < 0) __PYX_ERR(0, 9017, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9064
 * 
 * 
 * def polyfit(x, y, deg, rcond=None, full=False):             # <<<<<<<<<<<<<<
 *     """Least squares polynomial fit.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_363polyfit, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9064, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polyfit, __pyx_t_1) < 0) __PYX_ERR(0, 9064, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9200
 * 
 * 
 * def polyint(p, m=1, k=None):             # <<<<<<<<<<<<<<
 *     """Return an antiderivative (indefinite integral) of a polynomial.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_365polyint, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9200, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polyint, __pyx_t_1) < 0) __PYX_ERR(0, 9200, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9269
 * 
 * 
 * def polymul(a1, a2):             # <<<<<<<<<<<<<<
 *     """Find the product of two polynomials.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_367polymul, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polymul, __pyx_t_1) < 0) __PYX_ERR(0, 9269, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9318
 * 
 * 
 * def polysub(a1, a2):             # <<<<<<<<<<<<<<
 *     """Difference (subtraction) of two polynomials.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_369polysub, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9318, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polysub, __pyx_t_1) < 0) __PYX_ERR(0, 9318, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9350
 * 
 * 
 * def polyval(p, x):             # <<<<<<<<<<<<<<
 *     """Evaluate a polynomial at specific values.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_371polyval, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_polyval, __pyx_t_1) < 0) __PYX_ERR(0, 9350, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9411
 * 
 * 
 * def ppmt(rate, per, nper, pv, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Not implemented. Compute the payment against loan principal.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_373ppmt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9411, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ppmt, __pyx_t_1) < 0) __PYX_ERR(0, 9411, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9438
 * 
 * 
 * def prod(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_375prod, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9438, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_prod, __pyx_t_1) < 0) __PYX_ERR(0, 9438, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9514
 * 
 * 
 * def product(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the product of array elements over a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_377product, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9514, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_product, __pyx_t_1) < 0) __PYX_ERR(0, 9514, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9525
 * 
 * 
 * def promote_types(type1, type2):             # <<<<<<<<<<<<<<
 *     """promote_types(type1, type2)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_379promote_types, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9525, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_promote_types, __pyx_t_1) < 0) __PYX_ERR(0, 9525, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9575
 * 
 * 
 * def ptp(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Range of values (maximum - minimum) along an axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_381ptp, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9575, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ptp, __pyx_t_1) < 0) __PYX_ERR(0, 9575, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9615
 * 
 * 
 * def put(a, ind, v, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Replaces specified elements of an array with given values.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_383put, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9615, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_put, __pyx_t_1) < 0) __PYX_ERR(0, 9615, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9665
 * 
 * 
 * def putmask(a, mask, values):             # <<<<<<<<<<<<<<
 *     """putmask(a, mask, values)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_385putmask, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9665, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_putmask, __pyx_t_1) < 0) __PYX_ERR(0, 9665, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9709
 * 
 * 
 * def pv(rate, nper, pmt, fv=0.0, when='end'):             # <<<<<<<<<<<<<<
 *     """Compute the present value.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_387pv, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9709, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pv, __pyx_t_1) < 0) __PYX_ERR(0, 9709, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9797
 * 
 * 
 * def rank(a):             # <<<<<<<<<<<<<<
 *     """Return the number of dimensions of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_389rank, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9797, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_rank, __pyx_t_1) < 0) __PYX_ERR(0, 9797, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9839
 * 
 * 
 * def rate(nper, pmt, pv, fv, when='end', guess=0.1, tol=1e-06, maxiter=100):             # <<<<<<<<<<<<<<
 *     """Compute the rate of interest per period.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_391rate, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9839, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_rate, __pyx_t_1) < 0) __PYX_ERR(0, 9839, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9884
 * 
 * 
 * def ravel(a, order='C'):             # <<<<<<<<<<<<<<
 *     """Return a flattened array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_393ravel, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9884, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ravel, __pyx_t_1) < 0) __PYX_ERR(0, 9884, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":9968
 * 
 * 
 * def ravel_multi_index(multi_index, dims, mode='raise', order='C'):             # <<<<<<<<<<<<<<
 *     """ravel_multi_index(multi_index, dims, mode='raise', order='C')
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_395ravel_multi_index, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ravel_multi_index, __pyx_t_1) < 0) __PYX_ERR(0, 9968, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10028
 * 
 * 
 * def real(val):             # <<<<<<<<<<<<<<
 *     """Return the real part of the elements of the array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_397real, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10028, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_real, __pyx_t_1) < 0) __PYX_ERR(0, 10028, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10062
 * 
 * 
 * def real_if_close(a, tol=100):             # <<<<<<<<<<<<<<
 *     """If complex input returns a real array if complex parts are close to zero.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_399real_if_close, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10062, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_real_if_close, __pyx_t_1) < 0) __PYX_ERR(0, 10062, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10107
 * 
 * 
 * def recfromcsv(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data stored in a comma-separated file.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_401recfromcsv, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10107, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_recfromcsv, __pyx_t_1) < 0) __PYX_ERR(0, 10107, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10124
 * 
 * 
 * def recfromtxt(fname):             # <<<<<<<<<<<<<<
 *     """Load ASCII data from a file and return it in a record array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_403recfromtxt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_recfromtxt, __pyx_t_1) < 0) __PYX_ERR(0, 10124, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10146
 * 
 * 
 * def repeat(a, repeats, axis=None):             # <<<<<<<<<<<<<<
 *     """Repeat elements of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_405repeat, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10146, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_repeat, __pyx_t_1) < 0) __PYX_ERR(0, 10146, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10187
 * 
 * 
 * def require(a, dtype=None, requirements=None):             # <<<<<<<<<<<<<<
 *     """Return an ndarray of the provided type that satisfies requirements.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_407require, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_require, __pyx_t_1) < 0) __PYX_ERR(0, 10187, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10246
 * 
 * 
 * def reshape(a, newshape, order='C'):             # <<<<<<<<<<<<<<
 *     """Gives a new shape to an array without changing its data.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_409reshape, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10246, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reshape, __pyx_t_1) < 0) __PYX_ERR(0, 10246, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10308
 * 
 * 
 * def resize(a, new_shape):             # <<<<<<<<<<<<<<
 *     """Return a new array with the specified shape.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_411resize, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10308, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_resize, __pyx_t_1) < 0) __PYX_ERR(0, 10308, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10348
 * 
 * 
 * def restoredot():             # <<<<<<<<<<<<<<
 *     """Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
 *     implementations.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_413restoredot, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10348, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_restoredot, __pyx_t_1) < 0) __PYX_ERR(0, 10348, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10366
 * 
 * 
 * def result_type(*arrays_and_dtypes):             # <<<<<<<<<<<<<<
 *     """result_type(*arrays_and_dtypes)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_415result_type, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10366, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_result_type, __pyx_t_1) < 0) __PYX_ERR(0, 10366, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10437
 * 
 * 
 * def roll(a, shift, axis=None):             # <<<<<<<<<<<<<<
 *     """Roll array elements along a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_417roll, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10437, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_roll, __pyx_t_1) < 0) __PYX_ERR(0, 10437, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10488
 * 
 * 
 * def rollaxis(a, axis, start=0):             # <<<<<<<<<<<<<<
 *     """Roll the specified axis backwards, until it lies in a given position.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_419rollaxis, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10488, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_rollaxis, __pyx_t_1) < 0) __PYX_ERR(0, 10488, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10526
 * 
 * 
 * def roots(p):             # <<<<<<<<<<<<<<
 *     """Return the roots of a polynomial with coefficients given in p.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_421roots, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10526, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_roots, __pyx_t_1) < 0) __PYX_ERR(0, 10526, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10577
 * 
 * 
 * def rot90(m, k=1):             # <<<<<<<<<<<<<<
 *     """Rotate an array by 90 degrees in the counter-clockwise direction.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_423rot90, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10577, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_rot90, __pyx_t_1) < 0) __PYX_ERR(0, 10577, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10617
 * 
 * 
 * def round(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_425round, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10617, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_round, __pyx_t_1) < 0) __PYX_ERR(0, 10617, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10630
 * 
 * 
 * def round_(a, decimals=0, out=None):             # <<<<<<<<<<<<<<
 *     """Round an array to the given number of decimals.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_427round_, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10630, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_round_2, __pyx_t_1) < 0) __PYX_ERR(0, 10630, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10643
 * 
 * 
 * def row_stack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_429row_stack, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10643, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_row_stack, __pyx_t_1) < 0) __PYX_ERR(0, 10643, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10694
 * 
 * 
 * def safe_eval(source):             # <<<<<<<<<<<<<<
 *     """Protected string evaluation.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_431safe_eval, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10694, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_safe_eval, __pyx_t_1) < 0) __PYX_ERR(0, 10694, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10739
 * 
 * 
 * def save(file, arr):             # <<<<<<<<<<<<<<
 *     """Save an array to a binary file in NumPy ``.npy`` format.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_433save, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10739, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_save, __pyx_t_1) < 0) __PYX_ERR(0, 10739, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10777
 * 
 * 
 * def savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n'):             # <<<<<<<<<<<<<<
 *     """Save an array to a text file.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_435savetxt, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10777, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_savetxt, __pyx_t_1) < 0) __PYX_ERR(0, 10777, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10868
 * 
 * 
 * def savez(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in uncompressed ``.npz`` format.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_437savez, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_savez, __pyx_t_1) < 0) __PYX_ERR(0, 10868, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10948
 * 
 * 
 * def savez_compressed(file):             # <<<<<<<<<<<<<<
 *     """Save several arrays into a single file in compressed ``.npz`` format.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_439savez_compressed, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10948, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_savez_compressed, __pyx_t_1) < 0) __PYX_ERR(0, 10948, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":10972
 * 
 * 
 * def sctype2char(sctype):             # <<<<<<<<<<<<<<
 *     """Return the string representation of a scalar dtype.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_441sctype2char, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sctype2char, __pyx_t_1) < 0) __PYX_ERR(0, 10972, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11016
 * 
 * 
 * def searchsorted(a, v, side='left'):             # <<<<<<<<<<<<<<
 *     """Find indices where elements should be inserted to maintain order.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_443searchsorted, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11016, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_searchsorted, __pyx_t_1) < 0) __PYX_ERR(0, 11016, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11064
 * 
 * 
 * def select(condlist, choicelist, default=0):             # <<<<<<<<<<<<<<
 *     """Return an array drawn from elements in choicelist, depending on conditions.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_445select, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11064, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_select, __pyx_t_1) < 0) __PYX_ERR(0, 11064, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11103
 * 
 * 
 * def set_numeric_ops():             # <<<<<<<<<<<<<<
 *     """set_numeric_ops(op1=func1, op2=func2, ...)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_447set_numeric_ops, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11103, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_numeric_ops, __pyx_t_1) < 0) __PYX_ERR(0, 11103, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11149
 * 
 * 
 * def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None):             # <<<<<<<<<<<<<<
 *     """Set printing options.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_449set_printoptions, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11149, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_printoptions, __pyx_t_1) < 0) __PYX_ERR(0, 11149, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11214
 * 
 * 
 * def set_string_function(f, repr=True):             # <<<<<<<<<<<<<<
 *     """Set a Python function to be used when pretty printing arrays.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_451set_string_function, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_string_function, __pyx_t_1) < 0) __PYX_ERR(0, 11214, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11267
 * 
 * 
 * def setbufsize(size):             # <<<<<<<<<<<<<<
 *     """Set the size of the buffer used in ufuncs.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_453setbufsize, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setbufsize, __pyx_t_1) < 0) __PYX_ERR(0, 11267, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11279
 * 
 * 
 * def setdiff1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set difference of two arrays.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_455setdiff1d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setdiff1d, __pyx_t_1) < 0) __PYX_ERR(0, 11279, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11315
 * 
 * 
 * def seterr(all=None, divide=None, over=None, under=None, invalid=None):             # <<<<<<<<<<<<<<
 *     """Set how floating-point errors are handled.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_457seterr, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11315, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_seterr, __pyx_t_1) < 0) __PYX_ERR(0, 11315, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11394
 * 
 * 
 * def seterrcall(func):             # <<<<<<<<<<<<<<
 *     """Set the floating-point error callback function or log object.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_459seterrcall, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_seterrcall, __pyx_t_1) < 0) __PYX_ERR(0, 11394, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11477
 * 
 * 
 * def seterrobj(errobj):             # <<<<<<<<<<<<<<
 *     """seterrobj(errobj)
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_461seterrobj, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11477, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_seterrobj, __pyx_t_1) < 0) __PYX_ERR(0, 11477, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11538
 * 
 * 
 * def setxor1d(ar1, ar2, assume_unique=False):             # <<<<<<<<<<<<<<
 *     """Find the set exclusive-or of two arrays.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_463setxor1d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11538, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setxor1d, __pyx_t_1) < 0) __PYX_ERR(0, 11538, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11569
 * 
 * 
 * def show_config():             # <<<<<<<<<<<<<<
 *     """
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_465show_config, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11569, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_show_config, __pyx_t_1) < 0) __PYX_ERR(0, 11569, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11576
 * 
 * 
 * def sinc(x):             # <<<<<<<<<<<<<<
 *     """Return the sinc function.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_467sinc, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11576, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sinc, __pyx_t_1) < 0) __PYX_ERR(0, 11576, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11653
 * 
 * 
 * def size(a, axis=None):             # <<<<<<<<<<<<<<
 *     """Return the number of elements along a given axis.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_469size, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11653, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_size, __pyx_t_1) < 0) __PYX_ERR(0, 11653, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11689
 * 
 * 
 * def sometrue(a, axis=None, out=None):             # <<<<<<<<<<<<<<
 *     """Check whether some values are true.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_471sometrue, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11689, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sometrue, __pyx_t_1) < 0) __PYX_ERR(0, 11689, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11702
 * 
 * 
 * def sort(a, axis=-1, kind='quicksort', order=None):             # <<<<<<<<<<<<<<
 *     """Return a sorted copy of an array.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_473sort, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11702, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sort, __pyx_t_1) < 0) __PYX_ERR(0, 11702, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11803
 * 
 * 
 * def sort_complex(a):             # <<<<<<<<<<<<<<
 *     """Sort a complex array using the real part first, then the imaginary part.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_475sort_complex, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11803, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sort_complex, __pyx_t_1) < 0) __PYX_ERR(0, 11803, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "ga4py/gain/notimplemented.pyx":11828
 * 
 * 
 * def source(object, output=sys.stdout):             # <<<<<<<<<<<<<<
 *     """Print or write to a file the source code for a Numpy object.
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_sys); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_stdout); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_k__15 = __pyx_t_2;
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_477source, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_source, __pyx_t_2) < 0) __PYX_ERR(0, 11828, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":11868
 * 
 * 
 * def split(ary, indices_or_sections, axis=0):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays of equal size.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_479split, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_split, __pyx_t_2) < 0) __PYX_ERR(0, 11868, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":11935
 * 
 * 
 * def squeeze(a):             # <<<<<<<<<<<<<<
 *     """Remove single-dimensional entries from the shape of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_481squeeze, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11935, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_squeeze, __pyx_t_2) < 0) __PYX_ERR(0, 11935, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":11961
 * 
 * 
 * def std(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the standard deviation along the specified axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_483std, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11961, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_std, __pyx_t_2) < 0) __PYX_ERR(0, 11961, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12049
 * 
 * 
 * def sum(a, axis=None, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Sum of array elements over a given axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_485sum, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12049, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sum, __pyx_t_2) < 0) __PYX_ERR(0, 12049, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12117
 * 
 * 
 * def swapaxes(a, axis1, axis2):             # <<<<<<<<<<<<<<
 *     """Interchange two axes of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_487swapaxes, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_swapaxes, __pyx_t_2) < 0) __PYX_ERR(0, 12117, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12160
 * 
 * 
 * def take(a, indices, axis=None, out=None, mode='raise'):             # <<<<<<<<<<<<<<
 *     """Take elements from an array along an axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_489take, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12160, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_take, __pyx_t_2) < 0) __PYX_ERR(0, 12160, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12216
 * 
 * 
 * def tensordot(a, b, axes=2):             # <<<<<<<<<<<<<<
 *     """Compute tensor dot product along specified axes for arrays >= 1-D.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_491tensordot, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tensordot, __pyx_t_2) < 0) __PYX_ERR(0, 12216, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12332
 * 
 * 
 * def tile(A, reps):             # <<<<<<<<<<<<<<
 *     """Construct an array by repeating A the number of times given by reps.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_493tile, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12332, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tile, __pyx_t_2) < 0) __PYX_ERR(0, 12332, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12390
 * 
 * 
 * def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):             # <<<<<<<<<<<<<<
 *     """Return the sum along diagonals of the array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_495trace, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12390, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_trace, __pyx_t_2) < 0) __PYX_ERR(0, 12390, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12448
 * 
 * 
 * def transpose(a, axes=None):             # <<<<<<<<<<<<<<
 *     """Permute the dimensions of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_497transpose, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12448, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_transpose, __pyx_t_2) < 0) __PYX_ERR(0, 12448, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12488
 * 
 * 
 * def trapz(y, x=None, dx=1.0, axis=-1):             # <<<<<<<<<<<<<<
 *     """Integrate along the given axis using the composite trapezoidal rule.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_499trapz, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12488, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_trapz, __pyx_t_2) < 0) __PYX_ERR(0, 12488, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12549
 * 
 * 
 * def tri(N, M=None, k=0, dtype=float):             # <<<<<<<<<<<<<<
 *     """An array with ones at and below the given diagonal and zeros elsewhere.
 * 
 */
  __Pyx_INCREF(((PyObject *)(&PyFloat_Type)));
  __pyx_k__16 = ((PyObject *)(&PyFloat_Type));
  __Pyx_GIVEREF((&PyFloat_Type));
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_501tri, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12549, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tri, __pyx_t_2) < 0) __PYX_ERR(0, 12549, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12588
 * 
 * 
 * def tril(m, k=0):             # <<<<<<<<<<<<<<
 *     """Lower triangle of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_503tril, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tril, __pyx_t_2) < 0) __PYX_ERR(0, 12588, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12622
 * 
 * 
 * def tril_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of an (n, n) array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_505tril_indices, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12622, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tril_indices, __pyx_t_2) < 0) __PYX_ERR(0, 12622, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12694
 * 
 * 
 * def tril_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the lower-triangle of arr.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_507tril_indices_from, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12694, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_tril_indices_from, __pyx_t_2) < 0) __PYX_ERR(0, 12694, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12719
 * 
 * 
 * def trim_zeros(filt, trim='fb'):             # <<<<<<<<<<<<<<
 *     """Trim the leading and/or trailing zeros from a 1-D array or sequence.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_509trim_zeros, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12719, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_trim_zeros, __pyx_t_2) < 0) __PYX_ERR(0, 12719, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12754
 * 
 * 
 * def triu(m, k=0):             # <<<<<<<<<<<<<<
 *     """Upper triangle of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_511triu, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12754, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_triu, __pyx_t_2) < 0) __PYX_ERR(0, 12754, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12778
 * 
 * 
 * def triu_indices(n, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_513triu_indices, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12778, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_triu_indices, __pyx_t_2) < 0) __PYX_ERR(0, 12778, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12851
 * 
 * 
 * def triu_indices_from(arr, k=0):             # <<<<<<<<<<<<<<
 *     """Return the indices for the upper-triangle of an (n, n) array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_515triu_indices_from, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12851, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_triu_indices_from, __pyx_t_2) < 0) __PYX_ERR(0, 12851, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12876
 * 
 * 
 * def typename(char_):             # <<<<<<<<<<<<<<
 *     """Return a description for the given data type code.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_517typename, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12876, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_typename, __pyx_t_2) < 0) __PYX_ERR(0, 12876, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12927
 * 
 * 
 * def union1d(ar1, ar2):             # <<<<<<<<<<<<<<
 *     """Find the union of two arrays.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_519union1d, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_union1d, __pyx_t_2) < 0) __PYX_ERR(0, 12927, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":12957
 * 
 * 
 * def unique(ar, return_index=False, return_inverse=False):             # <<<<<<<<<<<<<<
 *     """Find the unique elements of an array.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_521unique, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12957, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unique, __pyx_t_2) < 0) __PYX_ERR(0, 12957, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13028
 * 
 * 
 * def unpackbits(myarray, axis=None):             # <<<<<<<<<<<<<<
 *     """unpackbits(myarray, axis=None)
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_523unpackbits, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13028, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unpackbits, __pyx_t_2) < 0) __PYX_ERR(0, 13028, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13073
 * 
 * 
 * def unravel_index(indices, dims, order='C'):             # <<<<<<<<<<<<<<
 *     """unravel_index(indices, dims, order='C')
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_525unravel_index, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13073, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unravel_index, __pyx_t_2) < 0) __PYX_ERR(0, 13073, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13118
 * 
 * 
 * def unwrap(p, discont=3.14159265359, axis=-1):             # <<<<<<<<<<<<<<
 *     """Unwrap by changing deltas between values to 2*pi complement.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_527unwrap, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13118, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_unwrap, __pyx_t_2) < 0) __PYX_ERR(0, 13118, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13161
 * 
 * 
 * def vander(x, N=None):             # <<<<<<<<<<<<<<
 *     """Generate a Van der Monde matrix.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_529vander, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13161, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_vander, __pyx_t_2) < 0) __PYX_ERR(0, 13161, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13219
 * 
 * 
 * def var(a, axis=None, dtype=None, out=None, ddof=0):             # <<<<<<<<<<<<<<
 *     """Compute the variance along the specified axis.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_531var, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13219, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_var, __pyx_t_2) < 0) __PYX_ERR(0, 13219, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13309
 * 
 * 
 * def vdot():             # <<<<<<<<<<<<<<
 *     """Return the dot product of two vectors.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_533vdot, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13309, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_vdot, __pyx_t_2) < 0) __PYX_ERR(0, 13309, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13364
 * 
 * 
 * def vsplit(ary, indices_or_sections):             # <<<<<<<<<<<<<<
 *     """Split an array into multiple sub-arrays vertically (row-wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_535vsplit, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13364, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_vsplit, __pyx_t_2) < 0) __PYX_ERR(0, 13364, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13413
 * 
 * 
 * def vstack(tup):             # <<<<<<<<<<<<<<
 *     """Stack arrays in sequence vertically (row wise).
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_537vstack, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13413, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_vstack, __pyx_t_2) < 0) __PYX_ERR(0, 13413, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13464
 * 
 * 
 * def where():             # <<<<<<<<<<<<<<
 *     """where(condition, [x, y])
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_539where, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13464, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_where, __pyx_t_2) < 0) __PYX_ERR(0, 13464, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":13526
 * 
 * 
 * def who(vardict=None):             # <<<<<<<<<<<<<<
 *     """Print the Numpy arrays in the given dictionary.
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5ga4py_4gain_14notimplemented_541who, NULL, __pyx_n_s_ga4py_gain_notimplemented); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13526, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_who, __pyx_t_2) < 0) __PYX_ERR(0, 13526, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "ga4py/gain/notimplemented.pyx":2
 * 
 * import sys             # <<<<<<<<<<<<<<
 * 
 * import numpy as np
 */
  __pyx_t_2 = __Pyx_PyDict_NewPresized(230); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_all_line_40, __pyx_kp_u_Test_whether_all_array_elements) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_allclose_line_99, __pyx_kp_u_Returns_True_if_two_arrays_are_e) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_amax_line_187, __pyx_kp_u_Return_the_maximum_of_an_array_o) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_amin_line_244, __pyx_kp_u_Return_the_minimum_of_an_array_o) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_angle_line_301, __pyx_kp_u_Return_the_angle_of_the_complex) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_any_line_335, __pyx_kp_u_Test_whether_any_array_element_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_append_line_401, __pyx_kp_u_Append_values_to_the_end_of_an_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_apply_along_axis_line_449, __pyx_kp_u_Apply_a_function_to_1_D_slices_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_apply_over_axes_line_506, __pyx_kp_u_Apply_a_function_repeatedly_over) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_argmax_line_560, __pyx_kp_u_Indices_of_the_maximum_values_al) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_argsort_line_624, __pyx_kp_u_Returns_the_indices_that_would_s) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_argwhere_line_704, __pyx_kp_u_Find_the_indices_of_array_elemen) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_around_line_744, __pyx_kp_u_Evenly_round_to_the_given_number) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_array_line_812, __pyx_kp_u_array_object_dtype_None_copy_Tru) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_array2string_line_906, __pyx_kp_u_Return_a_string_representation_o) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_array_equal_line_955, __pyx_kp_u_True_if_two_arrays_have_the_same) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_array_equiv_line_990, __pyx_kp_u_Returns_True_if_input_arrays_are) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_array_repr_line_1027, __pyx_kp_u_Return_the_string_representation) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_array_split_line_1071, __pyx_kp_u_Split_an_array_into_multiple_sub) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_array_str_line_1093, __pyx_kp_u_Return_a_string_representation_o_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_asanyarray_line_1129, __pyx_kp_u_Convert_the_input_to_an_ndarray) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_asarray_chkfinite_line_1181, __pyx_kp_u_Convert_the_input_to_an_array_ch) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_ascontiguousarray_line_1243, __pyx_kp_u_Return_a_contiguous_array_in_mem) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_asfarray_line_1279, __pyx_kp_u_Return_an_array_converted_to_a_f) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_asfortranarray_line_1308, __pyx_kp_u_Return_an_array_laid_out_in_Fort) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_asmatrix_line_1344, __pyx_kp_u_Interpret_the_input_as_a_matrix) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_asscalar_line_1376, __pyx_kp_u_Convert_an_array_of_size_1_to_it) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_atleast_1d_line_1398, __pyx_kp_u_Convert_inputs_to_arrays_with_at) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_atleast_2d_line_1439, __pyx_kp_u_View_inputs_as_arrays_with_at_le) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_atleast_3d_line_1478, __pyx_kp_u_View_inputs_as_arrays_with_at_le_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_average_line_1529, __pyx_kp_u_Compute_the_weighted_average_alo) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_bartlett_line_1604, __pyx_kp_u_Return_the_Bartlett_window_The_B) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_base_repr_line_1708, __pyx_kp_u_Return_a_string_representation_o_3) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_binary_repr_line_1748, __pyx_kp_u_Return_the_binary_representation) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_bincount_line_1808, __pyx_kp_u_bincount_x_weights_None_minlengt) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_blackman_line_1883, __pyx_kp_u_Return_the_Blackman_window_The_B) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_bmat_line_1979, __pyx_kp_u_Build_a_matrix_object_from_a_str) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_broadcast_arrays_line_2026, __pyx_kp_u_Broadcast_any_number_of_arrays_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_byte_bounds_line_2067, __pyx_kp_u_Returns_pointers_to_the_end_poin) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_can_cast_line_2099, __pyx_kp_u_can_cast_from_totype_casting_saf) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_choose_line_2202, __pyx_kp_u_Construct_an_array_from_an_index) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_column_stack_line_2323, __pyx_kp_u_Stack_1_D_arrays_as_columns_into) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_common_type_line_2362, __pyx_kp_u_Return_a_scalar_type_which_is_co) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_compress_line_2408, __pyx_kp_u_Return_selected_slices_of_an_arr) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_concatenate_line_2469, __pyx_kp_u_concatenate_a1_a2_axis_0_Join_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_convolve_line_2545, __pyx_kp_u_Returns_the_discrete_linear_conv) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_copy_line_2630, __pyx_kp_u_Return_an_array_copy_of_the_give) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_correlate_line_2718, __pyx_kp_u_Cross_correlation_of_two_1_dimen) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_count_nonzero_line_2758, __pyx_kp_u_count_nonzero_a_Counts_the_numbe) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_cov_line_2790, __pyx_kp_u_Estimate_a_covariance_matrix_giv) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_cross_line_2871, __pyx_kp_u_Return_the_cross_product_of_two) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_cumprod_line_2979, __pyx_kp_u_Return_the_cumulative_product_of) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_cumsum_line_3053, __pyx_kp_u_Return_the_cumulative_sum_of_the) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_delete_line_3124, __pyx_kp_u_Return_a_new_array_with_sub_arra) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_deprecate_line_3171, __pyx_kp_u_Issues_a_DeprecationWarning_adds) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_diag_indices_line_3221, __pyx_kp_u_Return_the_indices_to_access_the) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_diagflat_line_3308, __pyx_kp_u_Create_a_two_dimensional_array_w) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_diff_line_3349, __pyx_kp_u_Calculate_the_n_th_order_discret) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_digitize_line_3394, __pyx_kp_u_digitize_x_bins_Return_the_indic) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_disp_line_3453, __pyx_kp_u_Display_a_message_on_a_device_Pa) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_dsplit_line_3487, __pyx_kp_u_Split_array_into_multiple_sub_ar) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_dstack_line_3530, __pyx_kp_u_Stack_arrays_in_sequence_depth_w) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_ediff1d_line_3580, __pyx_kp_u_The_differences_between_consecut) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_einsum_line_3625, __pyx_kp_u_einsum_subscripts_operands_out_N) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_expand_dims_line_3817, __pyx_kp_u_Expand_the_shape_of_an_array_Ins) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_extract_line_3870, __pyx_kp_u_Return_the_elements_of_an_array) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fill_diagonal_line_3921, __pyx_kp_u_Fill_the_main_diagonal_of_the_gi) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_find_common_type_line_3982, __pyx_kp_u_Determine_common_type_following) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fix_line_4035, __pyx_kp_u_Round_to_nearest_integer_towards) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_flatnonzero_line_4071, __pyx_kp_u_Return_indices_that_are_non_zero) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fliplr_line_4110, __pyx_kp_u_Flip_array_in_the_left_right_dir) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_flipud_line_4157, __pyx_kp_u_Flip_array_in_the_up_down_direct) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_frombuffer_line_4207, __pyx_kp_u_frombuffer_buffer_dtype_float_co) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fromfile_line_4247, __pyx_kp_u_fromfile_file_dtype_float_count) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fromiter_line_4324, __pyx_kp_u_fromiter_iterable_dtype_count_1) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_frompyfunc_line_4360, __pyx_kp_u_frompyfunc_func_nin_nout_Takes_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fromregex_line_4402, __pyx_kp_u_Construct_an_array_from_a_text_f) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fromstring_line_4459, __pyx_kp_u_fromstring_string_dtype_float_co) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_fv_line_4513, __pyx_kp_u_Compute_the_future_value_Given_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_genfromtxt_line_4596, __pyx_kp_u_Load_data_from_a_text_file_with) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_getbuffer_line_4826, __pyx_kp_u_getbuffer_obj_offset_size_Create) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_geterr_line_4869, __pyx_kp_u_Get_the_current_way_of_handling) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_geterrcall_line_4908, __pyx_kp_u_Return_the_current_callback_func) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_geterrobj_line_4952, __pyx_kp_u_geterrobj_Return_the_current_obj) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_gradient_line_5018, __pyx_kp_u_Return_the_gradient_of_an_N_dime) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_hamming_line_5058, __pyx_kp_u_Return_the_Hamming_window_The_Ha) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_hanning_line_5152, __pyx_kp_u_Return_the_Hanning_window_The_Ha) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_histogram_line_5248, __pyx_kp_u_Compute_the_histogram_of_a_set_o) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_histogram2d_line_5333, __pyx_kp_u_Compute_the_bi_dimensional_histo) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_histogramdd_line_5418, __pyx_kp_u_Compute_the_multidimensional_his) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_hsplit_line_5471, __pyx_kp_u_Split_an_array_into_multiple_sub_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_hstack_line_5528, __pyx_kp_u_Stack_arrays_in_sequence_horizon) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_i0_line_5572, __pyx_kp_u_Modified_Bessel_function_of_the) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_imag_line_5628, __pyx_kp_u_Return_the_imaginary_part_of_the) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_in1d_line_5659, __pyx_kp_u_Test_whether_each_element_of_a_1) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_indices_line_5707, __pyx_kp_u_Return_an_array_representing_the) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_info_line_5769, __pyx_kp_u_Get_help_information_for_a_funct) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_inner_line_5819, __pyx_kp_u_inner_a_b_Inner_product_of_two_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_insert_line_5895, __pyx_kp_u_Insert_values_along_the_given_ax) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_interp_line_5968, __pyx_kp_u_One_dimensional_linear_interpola) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_intersect1d_line_6039, __pyx_kp_u_Find_the_intersection_of_two_arr) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_irr_line_6113, __pyx_kp_u_Return_the_Internal_Rate_of_Retu) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_iscomplex_line_6168, __pyx_kp_u_Returns_a_bool_array_where_True) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_iscomplexobj_line_6199, __pyx_kp_u_Return_True_if_x_is_a_complex_ty) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_isfortran_line_6233, __pyx_kp_u_Returns_True_if_array_is_arrange) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_isneginf_line_6290, __pyx_kp_u_Test_element_wise_for_negative_i) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_isposinf_line_6349, __pyx_kp_u_Test_element_wise_for_positive_i) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_isreal_line_6407, __pyx_kp_u_Returns_a_bool_array_where_True_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_isrealobj_line_6437, __pyx_kp_u_Return_True_if_x_is_a_not_comple) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_isscalar_line_6471, __pyx_kp_u_Returns_True_if_the_type_of_num) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_issctype_line_6497, __pyx_kp_u_Determines_whether_the_given_obj) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_issubclass__line_6533, __pyx_kp_u_Determine_if_a_class_is_a_subcla) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_issubdtype_line_6568, __pyx_kp_u_Returns_True_if_first_argument_i) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_issubsctype_line_6596, __pyx_kp_u_Determine_if_the_first_argument) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_iterable_line_6626, __pyx_kp_u_Check_whether_or_not_an_object_c) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_ix__line_6652, __pyx_kp_u_Construct_an_open_mesh_from_mult) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_kaiser_line_6698, __pyx_kp_u_Return_the_Kaiser_window_The_Kai) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_kron_line_6825, __pyx_kp_u_Kronecker_product_of_two_arrays) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_lexsort_line_6897, __pyx_kp_u_lexsort_keys_axis_1_Perform_an_i) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_load_line_6975, __pyx_kp_u_Load_a_pickled_npy_or_npz_binary) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_loadtxt_line_7045, __pyx_kp_u_Load_data_from_a_text_file_Each) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_lookfor_line_7132, __pyx_kp_u_Do_a_keyword_search_on_docstring) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_mask_indices_line_7192, __pyx_kp_u_Return_the_indices_to_access_n_n) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_mat_line_7259, __pyx_kp_u_Interpret_the_input_as_a_matrix) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_max_line_7291, __pyx_kp_u_Return_the_maximum_of_an_array_o) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_maximum_sctype_line_7348, __pyx_kp_u_Return_the_scalar_type_of_highes) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_may_share_memory_line_7388, __pyx_kp_u_Determine_if_two_arrays_can_shar) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_mean_line_7414, __pyx_kp_u_Compute_the_arithmetic_mean_alon) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_median_line_7487, __pyx_kp_u_Compute_the_median_along_the_spe) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_meshgrid_line_7563, __pyx_kp_u_Return_coordinate_matrices_from) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_min_line_7611, __pyx_kp_u_Return_the_minimum_of_an_array_o) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_min_scalar_type_line_7668, __pyx_kp_u_min_scalar_type_a_For_scalar_a_r) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_mintypecode_line_7718, __pyx_kp_u_Return_the_character_for_the_min) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nan_to_num_line_7810, __pyx_kp_u_Replace_nan_with_zero_and_inf_wi) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nanargmax_line_7857, __pyx_kp_u_Return_indices_of_the_maximum_va) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nanargmin_line_7892, __pyx_kp_u_Return_indices_of_the_minimum_va) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nanmax_line_7927, __pyx_kp_u_Return_the_maximum_of_an_array_o_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nanmin_line_7984, __pyx_kp_u_Return_the_minimum_of_an_array_o_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nansum_line_8039, __pyx_kp_u_Return_the_sum_of_array_elements) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_ndim_line_8121, __pyx_kp_u_Return_the_number_of_dimensions) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nonzero_line_8172, __pyx_kp_u_Return_the_indices_of_the_elemen) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_nper_line_8247, __pyx_kp_u_Compute_the_number_of_periodic_p) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_npv_line_8298, __pyx_kp_u_Returns_the_NPV_Net_Present_Valu) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_obj2sctype_line_8342, __pyx_kp_u_Return_the_scalar_dtype_or_NumPy) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_outer_line_8383, __pyx_kp_u_Compute_the_outer_product_of_two) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_packbits_line_8454, __pyx_kp_u_packbits_myarray_axis_None_Packs) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_percentile_line_8500, __pyx_kp_u_Compute_the_qth_percentile_of_th) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_piecewise_line_8580, __pyx_kp_u_Evaluate_a_piecewise_defined_fun) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_place_line_8702, __pyx_kp_u_Change_elements_of_an_array_base) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_pmt_line_8738, __pyx_kp_u_Compute_the_payment_against_loan) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_poly_line_8823, __pyx_kp_u_Find_the_coefficients_of_a_polyn) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polyadd_line_8917, __pyx_kp_u_Find_the_sum_of_two_polynomials) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polyder_line_8963, __pyx_kp_u_Return_the_derivative_of_the_spe) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polydiv_line_9017, __pyx_kp_u_Returns_the_quotient_and_remaind) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polyfit_line_9064, __pyx_kp_u_Least_squares_polynomial_fit_Fit) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polyint_line_9200, __pyx_kp_u_Return_an_antiderivative_indefin) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polymul_line_9269, __pyx_kp_u_Find_the_product_of_two_polynomi) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polysub_line_9318, __pyx_kp_u_Difference_subtraction_of_two_po) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_polyval_line_9350, __pyx_kp_u_Evaluate_a_polynomial_at_specifi) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_prod_line_9438, __pyx_kp_u_Return_the_product_of_array_elem) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_promote_types_line_9525, __pyx_kp_u_promote_types_type1_type2_Return) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_ptp_line_9575, __pyx_kp_u_Range_of_values_maximum_minimum) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_put_line_9615, __pyx_kp_u_Replaces_specified_elements_of_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_putmask_line_9665, __pyx_kp_u_putmask_a_mask_values_Changes_el) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_pv_line_9709, __pyx_kp_u_Compute_the_present_value_Given) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_rank_line_9797, __pyx_kp_u_Return_the_number_of_dimensions_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_ravel_line_9884, __pyx_kp_u_Return_a_flattened_array_A_1_D_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_ravel_multi_index_line_9968, __pyx_kp_u_ravel_multi_index_multi_index_di) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_real_line_10028, __pyx_kp_u_Return_the_real_part_of_the_elem) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_real_if_close_line_10062, __pyx_kp_u_If_complex_input_returns_a_real) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_repeat_line_10146, __pyx_kp_u_Repeat_elements_of_an_array_Para) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_require_line_10187, __pyx_kp_u_Return_an_ndarray_of_the_provide) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_reshape_line_10246, __pyx_kp_u_Gives_a_new_shape_to_an_array_wi) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_resize_line_10308, __pyx_kp_u_Return_a_new_array_with_the_spec) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_result_type_line_10366, __pyx_kp_u_result_type_arrays_and_dtypes_Re) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_roll_line_10437, __pyx_kp_u_Roll_array_elements_along_a_give) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_rollaxis_line_10488, __pyx_kp_u_Roll_the_specified_axis_backward) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_roots_line_10526, __pyx_kp_u_Return_the_roots_of_a_polynomial) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_rot90_line_10577, __pyx_kp_u_Rotate_an_array_by_90_degrees_in) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_row_stack_line_10643, __pyx_kp_u_Stack_arrays_in_sequence_vertica) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_safe_eval_line_10694, __pyx_kp_u_Protected_string_evaluation_Eval) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_save_line_10739, __pyx_kp_u_Save_an_array_to_a_binary_file_i) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_savetxt_line_10777, __pyx_kp_u_Save_an_array_to_a_text_file_Par) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_savez_line_10868, __pyx_kp_u_Save_several_arrays_into_a_singl) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_sctype2char_line_10972, __pyx_kp_u_Return_the_string_representation_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_searchsorted_line_11016, __pyx_kp_u_Find_indices_where_elements_shou) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_select_line_11064, __pyx_kp_u_Return_an_array_drawn_from_eleme) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_set_numeric_ops_line_11103, __pyx_kp_u_set_numeric_ops_op1_func1_op2_fu) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_set_printoptions_line_11149, __pyx_kp_u_Set_printing_options_These_optio) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_set_string_function_line_11214, __pyx_kp_u_Set_a_Python_function_to_be_used) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_setdiff1d_line_11279, __pyx_kp_u_Find_the_set_difference_of_two_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_seterr_line_11315, __pyx_kp_u_Set_how_floating_point_errors_ar) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_seterrcall_line_11394, __pyx_kp_u_Set_the_floating_point_error_cal) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_seterrobj_line_11477, __pyx_kp_u_seterrobj_errobj_Set_the_object) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_setxor1d_line_11538, __pyx_kp_u_Find_the_set_exclusive_or_of_two) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_sinc_line_11576, __pyx_kp_u_Return_the_sinc_function_The_sin) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_size_line_11653, __pyx_kp_u_Return_the_number_of_elements_al) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_sort_line_11702, __pyx_kp_u_Return_a_sorted_copy_of_an_array) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_sort_complex_line_11803, __pyx_kp_u_Sort_a_complex_array_using_the_r) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_source_line_11828, __pyx_kp_u_Print_or_write_to_a_file_the_sou) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_split_line_11868, __pyx_kp_u_Split_an_array_into_multiple_sub_3) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_squeeze_line_11935, __pyx_kp_u_Remove_single_dimensional_entrie) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_std_line_11961, __pyx_kp_u_Compute_the_standard_deviation_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_sum_line_12049, __pyx_kp_u_Sum_of_array_elements_over_a_giv) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_swapaxes_line_12117, __pyx_kp_u_Interchange_two_axes_of_an_array) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_take_line_12160, __pyx_kp_u_Take_elements_from_an_array_alon) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_tensordot_line_12216, __pyx_kp_u_Compute_tensor_dot_product_along) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_tile_line_12332, __pyx_kp_u_Construct_an_array_by_repeating) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_trace_line_12390, __pyx_kp_u_Return_the_sum_along_diagonals_o) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_transpose_line_12448, __pyx_kp_u_Permute_the_dimensions_of_an_arr) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_trapz_line_12488, __pyx_kp_u_Integrate_along_the_given_axis_u) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_tri_line_12549, __pyx_kp_u_An_array_with_ones_at_and_below) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_tril_line_12588, __pyx_kp_u_Lower_triangle_of_an_array_Retur) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_tril_indices_line_12622, __pyx_kp_u_Return_the_indices_for_the_lower) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_trim_zeros_line_12719, __pyx_kp_u_Trim_the_leading_and_or_trailing) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_triu_line_12754, __pyx_kp_u_Upper_triangle_of_an_array_Retur) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_triu_indices_line_12778, __pyx_kp_u_Return_the_indices_for_the_upper) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_typename_line_12876, __pyx_kp_u_Return_a_description_for_the_giv) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_union1d_line_12927, __pyx_kp_u_Find_the_union_of_two_arrays_Ret) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_unique_line_12957, __pyx_kp_u_Find_the_unique_elements_of_an_a) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_unpackbits_line_13028, __pyx_kp_u_unpackbits_myarray_axis_None_Unp) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_unravel_index_line_13073, __pyx_kp_u_unravel_index_indices_dims_order) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_unwrap_line_13118, __pyx_kp_u_Unwrap_by_changing_deltas_betwee) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_vander_line_13161, __pyx_kp_u_Generate_a_Van_der_Monde_matrix) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_var_line_13219, __pyx_kp_u_Compute_the_variance_along_the_s) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_vdot_line_13309, __pyx_kp_u_Return_the_dot_product_of_two_ve) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_vsplit_line_13364, __pyx_kp_u_Split_an_array_into_multiple_sub_4) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_vstack_line_13413, __pyx_kp_u_Stack_arrays_in_sequence_vertica) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_where_line_13464, __pyx_kp_u_where_condition_x_y_Return_eleme) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u_who_line_13526, __pyx_kp_u_Print_the_Numpy_arrays_in_the_gi) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "../../../../usr/local/lib/python2.7/dist-packages/Cython/Includes/numpy/__init__.pxd":1046
 *         raise ImportError("numpy.core.umath failed to import")
 * 
 * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
 *     try:
 *         _import_umath()
 */

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init ga4py.gain.notimplemented", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_CLEAR(__pyx_m);
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init ga4py.gain.notimplemented");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  return (__pyx_m != NULL) ? 0 : -1;
  #elif PY_MAJOR_VERSION >= 3
  return __pyx_m;
  #else
  return;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule(modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, "RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* PyObjectGetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* PyErrFetchRestore */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause) {
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = __Pyx_PyThreadState_Current;
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* KeywordStringCheck */
static int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyCFunctionFastCall */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    int flags = PyCFunction_GET_FLAGS(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
    } else {
        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
    }
}
#endif

/* PyFunctionFastCall */
#if CYTHON_FAST_PYCALL
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif
#endif

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
    if (likely(PyCFunction_Check(func))) {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* DictGetItem */
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
    PyObject *value;
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (!PyErr_Occurred()) {
            if (unlikely(PyTuple_Check(key))) {
                PyObject* args = PyTuple_Pack(1, key);
                if (likely(args)) {
                    PyErr_SetObject(PyExc_KeyError, args);
                    Py_DECREF(args);
                }
            } else {
                PyErr_SetObject(PyExc_KeyError, key);
            }
        }
        return NULL;
    }
    Py_INCREF(value);
    return value;
}
#endif

/* RaiseTooManyValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

/* RaiseNeedMoreValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

/* RaiseNoneIterError */
static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
}

/* ExtTypeTest */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(__Pyx_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

/* GetTopmostException */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem *
__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
{
    _PyErr_StackItem *exc_info = tstate->exc_info;
    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
           exc_info->previous_item != NULL)
    {
        exc_info = exc_info->previous_item;
    }
    return exc_info;
}
#endif

/* SaveResetException */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
    *type = exc_info->exc_type;
    *value = exc_info->exc_value;
    *tb = exc_info->exc_traceback;
    #else
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    #endif
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = tstate->exc_info;
    tmp_type = exc_info->exc_type;
    tmp_value = exc_info->exc_value;
    tmp_tb = exc_info->exc_traceback;
    exc_info->exc_type = type;
    exc_info->exc_value = value;
    exc_info->exc_traceback = tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* PyErrExceptionMatches */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    if (unlikely(PyTuple_Check(err)))
        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* GetException */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
#endif
{
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_FAST_THREAD_STATE
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_FAST_THREAD_STATE
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_FAST_THREAD_STATE
    #if CYTHON_USE_EXC_INFO_STACK
    {
        _PyErr_StackItem *exc_info = tstate->exc_info;
        tmp_type = exc_info->exc_type;
        tmp_value = exc_info->exc_value;
        tmp_tb = exc_info->exc_traceback;
        exc_info->exc_type = local_type;
        exc_info->exc_value = local_value;
        exc_info->exc_traceback = local_tb;
    }
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* TypeImport */
#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
    size_t size, enum __Pyx_ImportType_CheckSize check_size)
{
    PyObject *result = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    result = PyObject_GetAttrString(module, class_name);
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%.200s.%.200s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if ((size_t)basicsize < size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(result);
    return NULL;
}
#endif

/* Import */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_MAJOR_VERSION < 3
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* PyDictVersioning */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
    PyObject **dictptr = NULL;
    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
    if (offset) {
#if CYTHON_COMPILING_IN_CPYTHON
        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
#else
        dictptr = _PyObject_GetDictPtr(obj);
#endif
    }
    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
}
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
        return 0;
    return obj_dict_version == __Pyx_get_object_dict_version(obj);
}
#endif

/* GetModuleGlobalName */
#if CYTHON_USE_DICT_VERSIONS
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
#else
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
#endif
{
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    } else if (unlikely(PyErr_Occurred())) {
        return NULL;
    }
#else
    result = PyDict_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
#endif
#else
    result = PyObject_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
    PyErr_Clear();
#endif
    return __Pyx_GetBuiltinName(name);
}

/* CLineInTraceback */
#ifndef CYTHON_CLINE_IN_TRACEBACK
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
    PyObject *use_cline;
    PyObject *ptype, *pvalue, *ptraceback;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict;
#endif
    if (unlikely(!__pyx_cython_runtime)) {
        return c_line;
    }
    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
#if CYTHON_COMPILING_IN_CPYTHON
    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
            use_cline, *cython_runtime_dict,
            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
    } else
#endif
    {
      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        PyErr_Clear();
        use_cline = NULL;
      }
    }
    if (!use_cline) {
        c_line = 0;
        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
        c_line = 0;
    }
    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
    return c_line;
}
#endif

/* CodeObjectCache */
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(tstate, c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        tstate,            /*PyThreadState *tstate,*/
        py_code,           /*PyCodeObject *code,*/
        __pyx_d,    /*PyObject *globals,*/
        0                  /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* Declarations */
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return ::std::complex< float >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return x + y*(__pyx_t_float_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      __pyx_t_float_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

/* Arithmetic */
#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eq_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sum_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_diff_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prod_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    #if 1
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quot_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        if (b.imag == 0) {
            return __pyx_t_float_complex_from_parts(a.real / b.real, a.imag / b.real);
        } else if (fabsf(b.real) >= fabsf(b.imag)) {
            if (b.real == 0 && b.imag == 0) {
                return __pyx_t_float_complex_from_parts(a.real / b.real, a.imag / b.imag);
            } else {
                float r = b.imag / b.real;
                float s = (float)(1.0) / (b.real + b.imag * r);
                return __pyx_t_float_complex_from_parts(
                    (a.real + a.imag * r) * s, (a.imag - a.real * r) * s);
            }
        } else {
            float r = b.real / b.imag;
            float s = (float)(1.0) / (b.imag + b.real * r);
            return __pyx_t_float_complex_from_parts(
                (a.real * r + a.imag) * s, (a.imag * r - a.real) * s);
        }
    }
    #else
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quot_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        if (b.imag == 0) {
            return __pyx_t_float_complex_from_parts(a.real / b.real, a.imag / b.real);
        } else {
            float denom = b.real * b.real + b.imag * b.imag;
            return __pyx_t_float_complex_from_parts(
                (a.real * b.real + a.imag * b.imag) / denom,
                (a.imag * b.real - a.real * b.imag) / denom);
        }
    }
    #endif
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_neg_float(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zero_float(__pyx_t_float_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conj_float(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
    #if 1
        static CYTHON_INLINE float __Pyx_c_abs_float(__pyx_t_float_complex z) {
          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
            return sqrtf(z.real*z.real + z.imag*z.imag);
          #else
            return hypotf(z.real, z.imag);
          #endif
        }
        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_pow_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
            __pyx_t_float_complex z;
            float r, lnr, theta, z_r, z_theta;
            if (b.imag == 0 && b.real == (int)b.real) {
                if (b.real < 0) {
                    float denom = a.real * a.real + a.imag * a.imag;
                    a.real = a.real / denom;
                    a.imag = -a.imag / denom;
                    b.real = -b.real;
                }
                switch ((int)b.real) {
                    case 0:
                        z.real = 1;
                        z.imag = 0;
                        return z;
                    case 1:
                        return a;
                    case 2:
                        z = __Pyx_c_prod_float(a, a);
                        return __Pyx_c_prod_float(a, a);
                    case 3:
                        z = __Pyx_c_prod_float(a, a);
                        return __Pyx_c_prod_float(z, a);
                    case 4:
                        z = __Pyx_c_prod_float(a, a);
                        return __Pyx_c_prod_float(z, z);
                }
            }
            if (a.imag == 0) {
                if (a.real == 0) {
                    return a;
                } else if (b.imag == 0) {
                    z.real = powf(a.real, b.real);
                    z.imag = 0;
                    return z;
                } else if (a.real > 0) {
                    r = a.real;
                    theta = 0;
                } else {
                    r = -a.real;
                    theta = atan2f(0.0, -1.0);
                }
            } else {
                r = __Pyx_c_abs_float(a);
                theta = atan2f(a.imag, a.real);
            }
            lnr = logf(r);
            z_r = expf(lnr * b.real - theta * b.imag);
            z_theta = theta * b.real + lnr * b.imag;
            z.real = z_r * cosf(z_theta);
            z.imag = z_r * sinf(z_theta);
            return z;
        }
    #endif
#endif

/* Declarations */
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return ::std::complex< double >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return x + y*(__pyx_t_double_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      __pyx_t_double_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

/* Arithmetic */
#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eq_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    #if 1
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        if (b.imag == 0) {
            return __pyx_t_double_complex_from_parts(a.real / b.real, a.imag / b.real);
        } else if (fabs(b.real) >= fabs(b.imag)) {
            if (b.real == 0 && b.imag == 0) {
                return __pyx_t_double_complex_from_parts(a.real / b.real, a.imag / b.imag);
            } else {
                double r = b.imag / b.real;
                double s = (double)(1.0) / (b.real + b.imag * r);
                return __pyx_t_double_complex_from_parts(
                    (a.real + a.imag * r) * s, (a.imag - a.real * r) * s);
            }
        } else {
            double r = b.real / b.imag;
            double s = (double)(1.0) / (b.imag + b.real * r);
            return __pyx_t_double_complex_from_parts(
                (a.real * r + a.imag) * s, (a.imag * r - a.real) * s);
        }
    }
    #else
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        if (b.imag == 0) {
            return __pyx_t_double_complex_from_parts(a.real / b.real, a.imag / b.real);
        } else {
            double denom = b.real * b.real + b.imag * b.imag;
            return __pyx_t_double_complex_from_parts(
                (a.real * b.real + a.imag * b.imag) / denom,
                (a.imag * b.real - a.real * b.imag) / denom);
        }
    }
    #endif
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg_double(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zero_double(__pyx_t_double_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj_double(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
    #if 1
        static CYTHON_INLINE double __Pyx_c_abs_double(__pyx_t_double_complex z) {
          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
            return sqrt(z.real*z.real + z.imag*z.imag);
          #else
            return hypot(z.real, z.imag);
          #endif
        }
        static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
            __pyx_t_double_complex z;
            double r, lnr, theta, z_r, z_theta;
            if (b.imag == 0 && b.real == (int)b.real) {
                if (b.real < 0) {
                    double denom = a.real * a.real + a.imag * a.imag;
                    a.real = a.real / denom;
                    a.imag = -a.imag / denom;
                    b.real = -b.real;
                }
                switch ((int)b.real) {
                    case 0:
                        z.real = 1;
                        z.imag = 0;
                        return z;
                    case 1:
                        return a;
                    case 2:
                        z = __Pyx_c_prod_double(a, a);
                        return __Pyx_c_prod_double(a, a);
                    case 3:
                        z = __Pyx_c_prod_double(a, a);
                        return __Pyx_c_prod_double(z, a);
                    case 4:
                        z = __Pyx_c_prod_double(a, a);
                        return __Pyx_c_prod_double(z, z);
                }
            }
            if (a.imag == 0) {
                if (a.real == 0) {
                    return a;
                } else if (b.imag == 0) {
                    z.real = pow(a.real, b.real);
                    z.imag = 0;
                    return z;
                } else if (a.real > 0) {
                    r = a.real;
                    theta = 0;
                } else {
                    r = -a.real;
                    theta = atan2(0.0, -1.0);
                }
            } else {
                r = __Pyx_c_abs_double(a);
                theta = atan2(a.imag, a.real);
            }
            lnr = log(r);
            z_r = exp(lnr * b.real - theta * b.imag);
            z_theta = theta * b.real + lnr * b.imag;
            z.real = z_r * cos(z_theta);
            z.imag = z_r * sin(z_theta);
            return z;
        }
    #endif
#endif

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) ((int) 0 - (int) 1), const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

/* CIntFromPyVerify */
#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__NPY_TYPES(enum NPY_TYPES value) {
    const enum NPY_TYPES neg_one = (enum NPY_TYPES) ((enum NPY_TYPES) 0 - (enum NPY_TYPES) 1), const_zero = (enum NPY_TYPES) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum NPY_TYPES) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum NPY_TYPES) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum NPY_TYPES) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum NPY_TYPES) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum NPY_TYPES) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum NPY_TYPES),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) ((int) 0 - (int) 1), const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* FastTypeChecks */
#if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
    while (a) {
        a = a->tp_base;
        if (a == b)
            return 1;
    }
    return b == &PyBaseObject_Type;
}
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
    PyObject *mro;
    if (a == b) return 1;
    mro = a->tp_mro;
    if (likely(mro)) {
        Py_ssize_t i, n;
        n = PyTuple_GET_SIZE(mro);
        for (i = 0; i < n; i++) {
            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                return 1;
        }
        return 0;
    }
    return __Pyx_InBases(a, b);
}
#if PY_MAJOR_VERSION == 2
static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
    PyObject *exception, *value, *tb;
    int res;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&exception, &value, &tb);
    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
    if (unlikely(res == -1)) {
        PyErr_WriteUnraisable(err);
        res = 0;
    }
    if (!res) {
        res = PyObject_IsSubclass(err, exc_type2);
        if (unlikely(res == -1)) {
            PyErr_WriteUnraisable(err);
            res = 0;
        }
    }
    __Pyx_ErrRestore(exception, value, tb);
    return res;
}
#else
static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
    if (!res) {
        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
    }
    return res;
}
#endif
static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    assert(PyExceptionClass_Check(exc_type));
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        PyObject *t = PyTuple_GET_ITEM(tuple, i);
        #if PY_MAJOR_VERSION < 3
        if (likely(exc_type == t)) return 1;
        #endif
        if (likely(PyExceptionClass_Check(t))) {
            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
        } else {
        }
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
    if (likely(err == exc_type)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        if (likely(PyExceptionClass_Check(exc_type))) {
            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
        } else if (likely(PyTuple_Check(exc_type))) {
            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
        } else {
        }
    }
    return PyErr_GivenExceptionMatches(err, exc_type);
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
    assert(PyExceptionClass_Check(exc_type1));
    assert(PyExceptionClass_Check(exc_type2));
    if (likely(err == exc_type1 || err == exc_type2)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
    }
    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
}
#endif

/* CheckBinaryVersion */
static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
#if !CYTHON_PEP393_ENABLED
static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    char* defenc_c;
    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
    if (!defenc) return NULL;
    defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    {
        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
        char* c;
        for (c = defenc_c; c < end; c++) {
            if ((unsigned char) (*c) >= 128) {
                PyUnicode_AsASCIIString(o);
                return NULL;
            }
        }
    }
#endif
    *length = PyBytes_GET_SIZE(defenc);
    return defenc_c;
}
#else
static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    if (likely(PyUnicode_IS_ASCII(o))) {
        *length = PyUnicode_GET_LENGTH(o);
        return PyUnicode_AsUTF8(o);
    } else {
        PyUnicode_AsASCIIString(o);
        return NULL;
    }
#else
    return PyUnicode_AsUTF8AndSize(o, length);
#endif
}
#endif
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
        return __Pyx_PyUnicode_AsStringAndSize(o, length);
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
    int retval;
    if (unlikely(!x)) return -1;
    retval = __Pyx_PyObject_IsTrue(x);
    Py_DECREF(x);
    return retval;
}
static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
#if PY_MAJOR_VERSION >= 3
    if (PyLong_Check(result)) {
        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                "__int__ returned non-int (type %.200s).  "
                "The ability to return an instance of a strict subclass of int "
                "is deprecated, and may be removed in a future version of Python.",
                Py_TYPE(result)->tp_name)) {
            Py_DECREF(result);
            return NULL;
        }
        return result;
    }
#endif
    PyErr_Format(PyExc_TypeError,
                 "__%.4s__ returned non-%.4s (type %.200s)",
                 type_name, type_name, Py_TYPE(result)->tp_name);
    Py_DECREF(result);
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_Check(x) || PyLong_Check(x)))
#else
  if (likely(PyLong_Check(x)))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = m->nb_int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = m->nb_long(x);
  }
  #else
  if (likely(m && m->nb_int)) {
    name = "int";
    res = m->nb_int(x);
  }
  #endif
#else
  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
    res = PyNumber_Int(x);
  }
#endif
  if (likely(res)) {
#if PY_MAJOR_VERSION < 3
    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
#else
    if (unlikely(!PyLong_CheckExact(res))) {
#endif
        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(b);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
